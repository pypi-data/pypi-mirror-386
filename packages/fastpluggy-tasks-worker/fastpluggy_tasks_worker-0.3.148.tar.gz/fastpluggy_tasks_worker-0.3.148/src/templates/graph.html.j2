<style>
    .container {
        width: 100%;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }

    .toolbar {
        text-align: center;
        padding: 20px 30px;
        background: #f8f9fa;
        border-bottom: 1px solid #e9ecef;
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        align-items: center;
    }

    .graph-container {
        height: 70vh;
        min-height: 400px;
        position: relative;
        background: #ffffff;
        overflow: hidden;
    }

    .graph-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform-origin: 0 0;
    }

    .task-node {
        position: absolute;
        width: 200px;
        min-height: 100px;
        background: white;
        border: 2px solid #ddd;
        border-radius: 12px;
        padding: 15px;
        cursor: move;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
        z-index: 10;
    }

    .task-node:hover {
        transform: scale(1.05);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    .task-node.selected {
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
    }

    .task-node.pending {
        border-color: #ffc107;
        background: linear-gradient(135deg, #fff8e1, #ffffff);
    }

    .task-node.running {
        border-color: #17a2b8;
        background: linear-gradient(135deg, #e0f7ff, #ffffff);
    }

    .task-node.success,
    .task-node.completed {
        border-color: #28a745;
        background: linear-gradient(135deg, #e8f5e8, #ffffff);
    }

    .task-node.failed {
        border-color: #dc3545;
        background: linear-gradient(135deg, #ffeaea, #ffffff);
    }

    .task-title {
        font-weight: bold;
        font-size: 14px;
        margin-bottom: 8px;
        color: #2c3e50;
    }

    .task-status {
        font-size: 12px;
        padding: 4px 8px;
        border-radius: 20px;
        display: inline-block;
        margin-bottom: 8px;
        font-weight: 600;
    }

    .status-pending {
        background: #ffc107;
        color: #000;
    }

    .status-running {
        background: #17a2b8;
        color: white;
    }

    .status-success,
    .status-completed {
        background: #28a745;
        color: white;
    }

    .status-failed {
        background: #dc3545;
        color: white;
    }

    .task-worker {
        font-size: 11px;
        color: #666;
        margin-bottom: 5px;
    }

    .task-duration {
        font-size: 11px;
        color: #666;
    }

    .task-id {
        font-size: 11px;
        color: #666;
        margin-bottom: 5px;
        word-break: break-all;
    }

    .dependency-line {
        position: absolute;
        height: 3px;
        background: linear-gradient(90deg, #667eea, #764ba2);
        z-index: 1;
        border-radius: 2px;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .dependency-line:hover {
        height: 4px;
        background: linear-gradient(90deg, #5a6fd8, #6c42a3);
        filter: drop-shadow(0 2px 8px rgba(102, 126, 234, 0.4));
    }

    .dependency-arrow {
        position: absolute;
        right: -10px;
        top: -6px;
        width: 0;
        height: 0;
        border-left: 12px solid #764ba2;
        border-top: 6px solid transparent;
        border-bottom: 6px solid transparent;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    }

    .dependency-line:hover .dependency-arrow {
        border-left-color: #667eea;
        transform: scale(1.2);
        transition: all 0.2s ease;
    }

    .legend {
        display: flex;
        gap: 20px;
        margin: 10px 30px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
    }

    .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        border: 2px solid;
    }

    .zoom-controls {
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        z-index: 20;
    }

    .zoom-btn {
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 50%;
        background: rgba(102, 126, 234, 0.9);
        color: white;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
    }

    .zoom-btn:hover {
        background: rgba(102, 126, 234, 1);
        transform: scale(1.1);
    }

    @media (max-width: 768px) {
        .toolbar {
            flex-direction: column;
            align-items: stretch;
        }

        .legend {
            justify-content: center;
        }
    }
</style>

<div class="container">
    <div class="toolbar">
        <button class="btn btn-primary" onclick="autoLayout()">Auto Layout</button>
        <button class="btn btn-secondary" onclick="resetZoom()">Reset Zoom</button>
    </div>

    <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomIn()">+</button>
        <button class="zoom-btn" onclick="zoomOut()">âˆ’</button>
    </div>

    <div class="graph-container" id="graphContainer">
        <div class="graph-canvas" id="graphCanvas"></div>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color"
                 style="border-color: #ffc107; background: linear-gradient(135deg, #fff8e1, #ffffff);"></div>
            <span>Pending</span>
        </div>
        <div class="legend-item">
            <div class="legend-color"
                 style="border-color: #17a2b8; background: linear-gradient(135deg, #e0f7ff, #ffffff);"></div>
            <span>Running</span>
        </div>
        <div class="legend-item">
            <div class="legend-color"
                 style="border-color: #28a745; background: linear-gradient(135deg, #e8f5e8, #ffffff);"></div>
            <span>Success/Completed</span>
        </div>
        <div class="legend-item">
            <div class="legend-color"
                 style="border-color: #dc3545; background: linear-gradient(135deg, #ffeaea, #ffffff);"></div>
            <span>Failed</span>
        </div>
    </div>
</div>

<script>
    const nodes = {{ widget.nodes_json|tojson }};
    const edges = {{ widget.edges_json|tojson }};

    let currentZoom = 1;
    let canvasOffset = {x: 0, y: 0};
    let tasks = [], dependencies = [], draggedTask = null, dragOffset = {x: 0, y: 0};

    function initFromInput() {
        tasks = nodes.map(n => ({
            id: n.id,
            name: n.label,
            worker: n.info.worker || 'unknown',
            status: n.info.status,
            duration: n.info.duration || '0s',
            detail_url: n.detail_url,
            x: Math.random() * 400 + 50,
            y: Math.random() * 300 + 50
        }));
        dependencies = [];
        nodes.forEach(n => {
            if (n.info.parents) {
                n.info.parents.forEach(p => dependencies.push({from: p, to: n.id}));
            }
        });
        edges.forEach(e => dependencies.push({from: e.source, to: e.target}));

        // Remove duplicates
        dependencies = dependencies.filter((dep, index, self) =>
            index === self.findIndex(d => d.from === dep.from && d.to === dep.to)
        );

        autoLayout(); // Auto layout on initialization
        renderGraph();
    }

    function renderGraph() {
        const c = document.getElementById('graphCanvas');
        c.innerHTML = '';
        dependencies.forEach(d => {
            const f = tasks.find(t => t.id === d.from), t = tasks.find(t => t.id === d.to);
            if (f && t) createDependencyLine(f, t);
        });
        tasks.forEach(createTaskNode);
    }

    function createTaskNode(task) {
        const c = document.getElementById('graphCanvas');
        const n = document.createElement('div');
        n.className = `task-node ${task.status}`;
        n.style.left = task.x + 'px';
        n.style.top = task.y + 'px';
        n.dataset.taskId = task.id;

        n.innerHTML = `
            <div class="task-title">${task.name}</div>
            <div class="task-status status-${task.status}">${task.status.toUpperCase()}</div>
            <div class="task-id">Task ID: ${task.id.substring(0, 8)}...</div>
            <div class="task-worker">Worker: ${task.worker}</div>
            <div class="task-duration">Duration: ${task.duration}</div>
        `;

        n.addEventListener('mousedown', startDrag);
        n.addEventListener('click', () => handleNodeClick(task));
        if (task.detail_url) {
            n.addEventListener('dblclick', () => window.open(task.detail_url, '_blank'));
            n.title = 'Double-click to view details';
        }

        c.appendChild(n);
    }

    function handleNodeClick(node) {
        console.log('Node clicked:', node);
        if (node.detail_url) {
            console.log('Detail URL:', node.detail_url);
        }
    }

    function resetZoom() {
        currentZoom = 1;
        canvasOffset = {x: 0, y: 0};
        const canvas = document.getElementById('graphCanvas');
        canvas.style.transform = 'scale(1) translate(0, 0)';
    }

    // Enhanced zoom functions that work better with the improved layout
    function zoomIn() {
        currentZoom = Math.min(currentZoom * 1.2, 3);
        applyZoom();
        // Optionally re-layout if zoom changes significantly
        if (currentZoom < 0.5 || currentZoom > 2) {
            setTimeout(autoLayout, 100);
        }
    }

    function zoomOut() {
        currentZoom = Math.max(currentZoom / 1.2, 0.3);
        applyZoom();
        // Optionally re-layout if zoom changes significantly
        if (currentZoom < 0.5 || currentZoom > 2) {
            setTimeout(autoLayout, 100);
        }
    }

    function applyZoom() {
        const canvas = document.getElementById('graphCanvas');
        // Apply translate first, then scale to ensure proper scaling behavior
        canvas.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${currentZoom})`;
        canvas.style.transformOrigin = '0 0';
    }

    function createDependencyLine(f, t) {
        const c = document.getElementById('graphCanvas');
        const fx = f.x + 100, fy = f.y + 50, tx = t.x + 100, ty = t.y + 50;
        const dx = tx - fx, dy = ty - fy, len = Math.sqrt(dx * dx + dy * dy);
        const ang = Math.atan2(dy, dx) * 180 / Math.PI;

        const l = document.createElement('div');
        l.className = 'dependency-line';
        l.style.width = len + 'px';
        l.style.left = fx + 'px';
        l.style.top = fy + 'px';
        l.style.transformOrigin = '0 50%';
        l.style.transform = `rotate(${ang}deg)`;

        const a = document.createElement('div');
        a.className = 'dependency-arrow';
        l.appendChild(a);
        c.appendChild(l);
    }

    function startDrag(e) {
        e.preventDefault();
        draggedTask = tasks.find(t => t.id == e.currentTarget.dataset.taskId);
        const r = e.currentTarget.getBoundingClientRect();
        const cr = document.getElementById('graphContainer').getBoundingClientRect();

        // Account for zoom when calculating offset
        dragOffset.x = (e.clientX - r.left) / currentZoom;
        dragOffset.y = (e.clientY - r.top) / currentZoom;

        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', stopDrag);
    }

    function drag(e) {
        if (!draggedTask) return;
        const cr = document.getElementById('graphContainer').getBoundingClientRect();

        // Calculate position in the unscaled coordinate system
        const nx = (e.clientX - cr.left - canvasOffset.x) / currentZoom - dragOffset.x;
        const ny = (e.clientY - cr.top - canvasOffset.y) / currentZoom - dragOffset.y;

        // Allow larger movement area when zoomed out
        const virtualWidth = Math.max(cr.width / currentZoom, 1000);
        const virtualHeight = Math.max(cr.height / currentZoom, 800);

        draggedTask.x = Math.max(-200, Math.min(virtualWidth - 200, nx));
        draggedTask.y = Math.max(-100, Math.min(virtualHeight - 100, ny));
        renderGraph();
    }

    function stopDrag() {
        draggedTask = null;
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', stopDrag);
    }

    function autoLayout() {
        const containerRect = document.getElementById('graphContainer').getBoundingClientRect();
        const containerWidth = containerRect.width;
        const containerHeight = containerRect.height;

        // Account for zoom level in calculations
        const effectiveWidth = containerWidth / currentZoom;
        const effectiveHeight = containerHeight / currentZoom;

        // Calculate levels (hierarchical positioning)
        const levels = {};
        const visited = new Set();
        const inDegree = {};

        // Initialize in-degree count
        tasks.forEach(task => inDegree[task.id] = 0);
        dependencies.forEach(dep => {
            if (inDegree[dep.to] !== undefined) {
                inDegree[dep.to]++;
            }
        });

        function getLevel(id, path = new Set()) {
            if (path.has(id)) return 0; // Prevent cycles
            if (visited.has(id)) return levels[id] || 0;

            visited.add(id);
            path.add(id);

            const parents = dependencies.filter(d => d.to === id);
            if (parents.length === 0) {
                levels[id] = 0;
                path.delete(id);
                return 0;
            }

            const maxParentLevel = Math.max(...parents.map(d => getLevel(d.from, new Set(path))));
            levels[id] = maxParentLevel + 1;
            path.delete(id);
            return levels[id];
        }

        // Calculate levels for all tasks
        tasks.forEach(t => getLevel(t.id));

        // Group tasks by level
        const byLevel = {};
        let maxLevel = 0;

        tasks.forEach(task => {
            const level = levels[task.id] || 0;
            maxLevel = Math.max(maxLevel, level);
            if (!byLevel[level]) byLevel[level] = [];
            byLevel[level].push(task);
        });

        // Enhanced spacing calculations
        const nodeWidth = 200;
        const nodeHeight = 100;
        const minHorizontalGap = 30;
        const minVerticalGap = 60;

        // Calculate optimal vertical spacing
        const totalLevels = maxLevel + 1;
        const availableVerticalSpace = effectiveHeight - (nodeHeight * 2); // Leave padding
        const optimalVerticalSpacing = Math.max(
            nodeHeight + minVerticalGap,
            availableVerticalSpace / Math.max(totalLevels - 1, 1)
        );

        // Position nodes level by level
        Object.entries(byLevel).forEach(([level, taskArray]) => {
            const levelNum = parseInt(level);

            // Calculate Y position with better vertical distribution
            const y = levelNum === 0 ?
                50 : // Top level padding
                50 + (levelNum * optimalVerticalSpacing);

            // Enhanced horizontal positioning
            const nodesInLevel = taskArray.length;

            if (nodesInLevel === 1) {
                // Center single nodes
                taskArray[0].x = (effectiveWidth - nodeWidth) / 2;
                taskArray[0].y = y;
            } else {
                // Calculate optimal horizontal spacing
                const totalNodeWidth = nodesInLevel * nodeWidth;
                const totalGapSpace = (nodesInLevel - 1) * minHorizontalGap;
                const requiredWidth = totalNodeWidth + totalGapSpace;

                let spacing, startX;

                if (requiredWidth <= effectiveWidth - 100) { // 50px padding on each side
                    // Nodes fit comfortably - distribute evenly
                    const availableSpace = effectiveWidth - totalNodeWidth - 100;
                    spacing = availableSpace / (nodesInLevel - 1);
                    startX = 50;
                } else {
                    // Nodes need to be compressed - use minimum spacing
                    spacing = nodeWidth + minHorizontalGap;
                    const totalUsedWidth = (nodesInLevel - 1) * spacing + nodeWidth;
                    startX = Math.max(10, (effectiveWidth - totalUsedWidth) / 2);
                }

                // Apply horizontal positioning with improved distribution
                taskArray.forEach((task, i) => {
                    task.x = startX + (i * spacing);
                    task.y = y;
                });

                // Optional: Apply force-based adjustment to reduce overlaps
                adjustForOverlaps(taskArray, effectiveWidth);
            }
        });

        // Post-processing: Optimize positions to reduce edge crossings
        optimizeEdgeCrossings(byLevel);

        // Final adjustment: ensure all nodes are within bounds
        ensureWithinBounds(effectiveWidth, effectiveHeight);

        renderGraph();
    }

    // Helper function to adjust overlapping nodes
    function adjustForOverlaps(nodes, containerWidth) {
        const nodeWidth = 200;
        const minGap = 30;

        // Sort by x position
        nodes.sort((a, b) => a.x - b.x);

        // Adjust overlapping nodes
        for (let i = 1; i < nodes.length; i++) {
            const prevNode = nodes[i - 1];
            const currentNode = nodes[i];
            const minRequiredX = prevNode.x + nodeWidth + minGap;

            if (currentNode.x < minRequiredX) {
                currentNode.x = minRequiredX;
            }
        }

        // If nodes extend beyond container, compress proportionally
        const lastNode = nodes[nodes.length - 1];
        if (lastNode.x + nodeWidth > containerWidth - 50) {
            const compressionRatio = (containerWidth - 100 - nodeWidth) / (lastNode.x + nodeWidth - nodes[0].x);
            const baseX = nodes[0].x;

            nodes.forEach(node => {
                node.x = baseX + (node.x - baseX) * compressionRatio;
            });
        }
    }

    // Helper function to minimize edge crossings
    function optimizeEdgeCrossings(byLevel) {
        // Simple heuristic: for each level, try to minimize crossings with the previous level
        const levelKeys = Object.keys(byLevel).map(k => parseInt(k)).sort((a, b) => a - b);

        for (let i = 1; i < levelKeys.length; i++) {
            const currentLevel = levelKeys[i];
            const previousLevel = levelKeys[i - 1];

            const currentNodes = byLevel[currentLevel];
            const previousNodes = byLevel[previousLevel];

            // Calculate connection weights and sort accordingly
            currentNodes.forEach(node => {
                const parentConnections = dependencies
                    .filter(dep => dep.to === node.id)
                    .map(dep => previousNodes.find(n => n.id === dep.from))
                    .filter(n => n);

                if (parentConnections.length > 0) {
                    const avgParentX = parentConnections.reduce((sum, parent) => sum + parent.x, 0) / parentConnections.length;
                    node.idealX = avgParentX;
                }
            });

            // Sort by ideal X position and redistribute
            const nodesWithIdealX = currentNodes.filter(n => n.idealX !== undefined);
            nodesWithIdealX.sort((a, b) => a.idealX - b.idealX);

            // Redistribute based on sorted order while maintaining spacing constraints
            if (nodesWithIdealX.length > 1) {
                const spacing = currentNodes.length > 1 ?
                    Math.abs(currentNodes[1].x - currentNodes[0].x) : 250;

                nodesWithIdealX.forEach((node, index) => {
                    const originalIndex = currentNodes.indexOf(node);
                    currentNodes[originalIndex].x = currentNodes[0].x + (index * spacing);
                });
            }
        }
    }

    // Helper function to ensure all nodes stay within bounds
    function ensureWithinBounds(maxWidth, maxHeight) {
        tasks.forEach(task => {
            task.x = Math.max(10, Math.min(task.x, maxWidth - 210)); // 200px node width + 10px margin
            task.y = Math.max(10, Math.min(task.y, maxHeight - 110)); // 100px node height + 10px margin
        });
    }


    // Add window resize handler for responsive layout
    window.addEventListener('resize', debounce(() => {
        autoLayout();
    }, 300));

    // Debounce utility function
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // API function for external updates
    window.updateGraphData = function (newNodes, newEdges) {
        nodes.length = 0;
        edges.length = 0;
        nodes.push(...newNodes);
        edges.push(...newEdges);
        initFromInput();
    };

    // Initialize
    initFromInput();
</script>