# coding: utf-8

"""
    FINBOURNE Scheduler API

    FINBOURNE Technology  # noqa: E501

    Contact: info@finbourne.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Any, Dict, Optional
from pydantic.v1 import StrictStr, Field, BaseModel, Field, StrictStr 
from lusid_scheduler.models.resource_id import ResourceId

class JobHistory(BaseModel):
    """
    Job run history  # noqa: E501
    """
    run_id:  Optional[StrictStr] = Field(None,alias="runId", description="Unique id of the job run") 
    job_id: Optional[ResourceId] = Field(None, alias="jobId")
    name:  Optional[StrictStr] = Field(None,alias="name", description="Name of the job") 
    initialised_date: Optional[datetime] = Field(None, alias="initialisedDate", description="The date when the job was initialised")
    start_date: Optional[datetime] = Field(None, alias="startDate", description="The date when the job started running in Scheduler")
    end_date: Optional[datetime] = Field(None, alias="endDate", description="End date of the job Defaults to null if the job has not started or not completed yet If value is null and job has not started, status will be `Pending` If value is null and job has not completed, but is running, status will be `Running`")
    arguments: Optional[Dict[str, StrictStr]] = Field(None, description="All arguments used in in this job run")
    environment_variables: Optional[Dict[str, StrictStr]] = Field(None, alias="environmentVariables", description="All environment variables used in this job run")
    job_status:  Optional[StrictStr] = Field(None,alias="jobStatus", description="Current job status") 
    job_result:  Optional[StrictStr] = Field(None,alias="jobResult", description="Description of the job result") 
    description:  Optional[StrictStr] = Field(None,alias="description", description="Description of the job") 
    schedule_id: Optional[ResourceId] = Field(None, alias="scheduleId")
    result_url:  Optional[StrictStr] = Field(None,alias="resultUrl", description="URI to results. Defaults to null if not available") 
    manually_triggered_by:  Optional[StrictStr] = Field(None,alias="manuallyTriggeredBy", description="UserId of the user that triggered the job. Defaults to null if job was ran on a Schedule") 
    message:  Optional[StrictStr] = Field(None,alias="message", description="Output message generated by the job runner Value will be null when the job is in a `Running` or `Pending` status") 
    __properties = ["runId", "jobId", "name", "initialisedDate", "startDate", "endDate", "arguments", "environmentVariables", "jobStatus", "jobResult", "description", "scheduleId", "resultUrl", "manuallyTriggeredBy", "message"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def __str__(self):
        """For `print` and `pprint`"""
        return pprint.pformat(self.dict(by_alias=False))

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> JobHistory:
        """Create an instance of JobHistory from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                            "job_result",
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of job_id
        if self.job_id:
            _dict['jobId'] = self.job_id.to_dict()
        # override the default output from pydantic by calling `to_dict()` of schedule_id
        if self.schedule_id:
            _dict['scheduleId'] = self.schedule_id.to_dict()
        # set to None if run_id (nullable) is None
        # and __fields_set__ contains the field
        if self.run_id is None and "run_id" in self.__fields_set__:
            _dict['runId'] = None

        # set to None if name (nullable) is None
        # and __fields_set__ contains the field
        if self.name is None and "name" in self.__fields_set__:
            _dict['name'] = None

        # set to None if start_date (nullable) is None
        # and __fields_set__ contains the field
        if self.start_date is None and "start_date" in self.__fields_set__:
            _dict['startDate'] = None

        # set to None if end_date (nullable) is None
        # and __fields_set__ contains the field
        if self.end_date is None and "end_date" in self.__fields_set__:
            _dict['endDate'] = None

        # set to None if arguments (nullable) is None
        # and __fields_set__ contains the field
        if self.arguments is None and "arguments" in self.__fields_set__:
            _dict['arguments'] = None

        # set to None if environment_variables (nullable) is None
        # and __fields_set__ contains the field
        if self.environment_variables is None and "environment_variables" in self.__fields_set__:
            _dict['environmentVariables'] = None

        # set to None if job_status (nullable) is None
        # and __fields_set__ contains the field
        if self.job_status is None and "job_status" in self.__fields_set__:
            _dict['jobStatus'] = None

        # set to None if job_result (nullable) is None
        # and __fields_set__ contains the field
        if self.job_result is None and "job_result" in self.__fields_set__:
            _dict['jobResult'] = None

        # set to None if description (nullable) is None
        # and __fields_set__ contains the field
        if self.description is None and "description" in self.__fields_set__:
            _dict['description'] = None

        # set to None if result_url (nullable) is None
        # and __fields_set__ contains the field
        if self.result_url is None and "result_url" in self.__fields_set__:
            _dict['resultUrl'] = None

        # set to None if manually_triggered_by (nullable) is None
        # and __fields_set__ contains the field
        if self.manually_triggered_by is None and "manually_triggered_by" in self.__fields_set__:
            _dict['manuallyTriggeredBy'] = None

        # set to None if message (nullable) is None
        # and __fields_set__ contains the field
        if self.message is None and "message" in self.__fields_set__:
            _dict['message'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> JobHistory:
        """Create an instance of JobHistory from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return JobHistory.parse_obj(obj)

        _obj = JobHistory.parse_obj({
            "run_id": obj.get("runId"),
            "job_id": ResourceId.from_dict(obj.get("jobId")) if obj.get("jobId") is not None else None,
            "name": obj.get("name"),
            "initialised_date": obj.get("initialisedDate"),
            "start_date": obj.get("startDate"),
            "end_date": obj.get("endDate"),
            "arguments": obj.get("arguments"),
            "environment_variables": obj.get("environmentVariables"),
            "job_status": obj.get("jobStatus"),
            "job_result": obj.get("jobResult"),
            "description": obj.get("description"),
            "schedule_id": ResourceId.from_dict(obj.get("scheduleId")) if obj.get("scheduleId") is not None else None,
            "result_url": obj.get("resultUrl"),
            "manually_triggered_by": obj.get("manuallyTriggeredBy"),
            "message": obj.get("message")
        })
        return _obj
