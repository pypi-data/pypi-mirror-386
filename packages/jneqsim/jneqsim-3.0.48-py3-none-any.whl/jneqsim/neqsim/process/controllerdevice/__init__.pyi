
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import jneqsim.neqsim.process.controllerdevice.structure
import jneqsim.neqsim.process.measurementdevice
import jneqsim.neqsim.util
import typing



class ControllerDeviceInterface(java.io.Serializable):
    def addGainSchedulePoint(self, double: float, double2: float, double3: float, double4: float) -> None: ...
    def autoTune(self, double: float, double2: float) -> None: ...
    def autoTuneStepResponse(self, double: float, double2: float, double3: float) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getControllerSetPoint(self) -> float: ...
    def getEventLog(self) -> java.util.List['ControllerEvent']: ...
    def getIntegralAbsoluteError(self) -> float: ...
    @typing.overload
    def getMeasuredValue(self) -> float: ...
    @typing.overload
    def getMeasuredValue(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getResponse(self) -> float: ...
    def getSettlingTime(self) -> float: ...
    def getUnit(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def isActive(self) -> bool: ...
    def isReverseActing(self) -> bool: ...
    def resetEventLog(self) -> None: ...
    def resetPerformanceMetrics(self) -> None: ...
    @typing.overload
    def runTransient(self, double: float, double2: float, uUID: java.util.UUID) -> None: ...
    @typing.overload
    def runTransient(self, double: float, double2: float) -> None: ...
    def setActive(self, boolean: bool) -> None: ...
    def setControllerParameters(self, double: float, double2: float, double3: float) -> None: ...
    @typing.overload
    def setControllerSetPoint(self, double: float) -> None: ...
    @typing.overload
    def setControllerSetPoint(self, double: float, string: typing.Union[java.lang.String, str]) -> None: ...
    def setDerivativeFilterTime(self, double: float) -> None: ...
    def setOutputLimits(self, double: float, double2: float) -> None: ...
    def setReverseActing(self, boolean: bool) -> None: ...
    def setTransmitter(self, measurementDeviceInterface: jneqsim.neqsim.process.measurementdevice.MeasurementDeviceInterface) -> None: ...
    def setUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...

class ControllerEvent(java.io.Serializable):
    def __init__(self, double: float, double2: float, double3: float, double4: float, double5: float): ...
    def getError(self) -> float: ...
    def getMeasuredValue(self) -> float: ...
    def getResponse(self) -> float: ...
    def getSetPoint(self) -> float: ...
    def getTime(self) -> float: ...

class ControllerDeviceBaseClass(jneqsim.neqsim.util.NamedBaseClass, ControllerDeviceInterface):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    def addGainSchedulePoint(self, double: float, double2: float, double3: float, double4: float) -> None: ...
    def autoTune(self, double: float, double2: float) -> None: ...
    def autoTuneStepResponse(self, double: float, double2: float, double3: float) -> None: ...
    def getControllerSetPoint(self) -> float: ...
    def getEventLog(self) -> java.util.List[ControllerEvent]: ...
    def getIntegralAbsoluteError(self) -> float: ...
    def getKp(self) -> float: ...
    @typing.overload
    def getMeasuredValue(self) -> float: ...
    @typing.overload
    def getMeasuredValue(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getResponse(self) -> float: ...
    def getSettlingTime(self) -> float: ...
    def getTd(self) -> float: ...
    def getTi(self) -> float: ...
    def getUnit(self) -> java.lang.String: ...
    def isActive(self) -> bool: ...
    def isReverseActing(self) -> bool: ...
    def resetEventLog(self) -> None: ...
    def resetPerformanceMetrics(self) -> None: ...
    @typing.overload
    def runTransient(self, double: float, double2: float) -> None: ...
    @typing.overload
    def runTransient(self, double: float, double2: float, uUID: java.util.UUID) -> None: ...
    def setActive(self, boolean: bool) -> None: ...
    def setControllerParameters(self, double: float, double2: float, double3: float) -> None: ...
    @typing.overload
    def setControllerSetPoint(self, double: float) -> None: ...
    @typing.overload
    def setControllerSetPoint(self, double: float, string: typing.Union[java.lang.String, str]) -> None: ...
    def setDerivativeFilterTime(self, double: float) -> None: ...
    def setKp(self, double: float) -> None: ...
    def setOutputLimits(self, double: float, double2: float) -> None: ...
    def setReverseActing(self, boolean: bool) -> None: ...
    def setTd(self, double: float) -> None: ...
    def setTi(self, double: float) -> None: ...
    def setTransmitter(self, measurementDeviceInterface: jneqsim.neqsim.process.measurementdevice.MeasurementDeviceInterface) -> None: ...
    def setUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...

class ModelPredictiveController(jneqsim.neqsim.util.NamedBaseClass, ControllerDeviceInterface):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    def addQualityConstraint(self, qualityConstraint: 'ModelPredictiveController.QualityConstraint') -> None: ...
    def clearMovingHorizonHistory(self) -> None: ...
    def clearQualityConstraints(self) -> None: ...
    def configureControls(self, *string: typing.Union[java.lang.String, str]) -> None: ...
    def disableMovingHorizonEstimation(self) -> None: ...
    def enableMovingHorizonEstimation(self, int: int) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getCalcIdentifier(self) -> java.util.UUID: ...
    def getControlNames(self) -> java.util.List[java.lang.String]: ...
    @typing.overload
    def getControlValue(self, int: int) -> float: ...
    @typing.overload
    def getControlValue(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getControlVector(self) -> typing.MutableSequence[float]: ...
    def getControllerSetPoint(self) -> float: ...
    def getLastAppliedControl(self) -> float: ...
    def getLastMovingHorizonEstimate(self) -> 'ModelPredictiveController.MovingHorizonEstimate': ...
    def getLastSampleTime(self) -> float: ...
    def getLastSampledValue(self) -> float: ...
    def getMaxResponse(self) -> float: ...
    @typing.overload
    def getMeasuredValue(self) -> float: ...
    @typing.overload
    def getMeasuredValue(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getMinResponse(self) -> float: ...
    def getMovingHorizonEstimationWindow(self) -> int: ...
    def getPredictedQuality(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getPredictionHorizon(self) -> int: ...
    def getResponse(self) -> float: ...
    def getUnit(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def ingestPlantSample(self, double: float, double2: float) -> None: ...
    @typing.overload
    def ingestPlantSample(self, double: float, double2: float, double3: float) -> None: ...
    def isActive(self) -> bool: ...
    def isMovingHorizonEstimationEnabled(self) -> bool: ...
    def isReverseActing(self) -> bool: ...
    @typing.overload
    def runTransient(self, double: float, double2: float) -> None: ...
    @typing.overload
    def runTransient(self, double: float, double2: float, uUID: java.util.UUID) -> None: ...
    def setActive(self, boolean: bool) -> None: ...
    @typing.overload
    def setControlLimits(self, int: int, double: float, double2: float) -> None: ...
    @typing.overload
    def setControlLimits(self, string: typing.Union[java.lang.String, str], double: float, double2: float) -> None: ...
    def setControlWeights(self, *double: float) -> None: ...
    def setControllerParameters(self, double: float, double2: float, double3: float) -> None: ...
    @typing.overload
    def setControllerSetPoint(self, double: float, string: typing.Union[java.lang.String, str]) -> None: ...
    @typing.overload
    def setControllerSetPoint(self, double: float) -> None: ...
    def setEnergyReference(self, double: float) -> None: ...
    def setEnergyReferenceVector(self, *double: float) -> None: ...
    def setInitialControlValues(self, *double: float) -> None: ...
    def setMoveWeights(self, *double: float) -> None: ...
    def setOutputLimits(self, double: float, double2: float) -> None: ...
    def setPredictionHorizon(self, int: int) -> None: ...
    def setPreferredControlValue(self, double: float) -> None: ...
    def setPreferredControlVector(self, *double: float) -> None: ...
    def setPrimaryControlIndex(self, int: int) -> None: ...
    def setProcessBias(self, double: float) -> None: ...
    @typing.overload
    def setProcessModel(self, double: float, double2: float) -> None: ...
    @typing.overload
    def setProcessModel(self, double: float, double2: float, double3: float) -> None: ...
    def setReverseActing(self, boolean: bool) -> None: ...
    def setTransmitter(self, measurementDeviceInterface: jneqsim.neqsim.process.measurementdevice.MeasurementDeviceInterface) -> None: ...
    def setUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setWeights(self, double: float, double2: float, double3: float) -> None: ...
    def updateFeedConditions(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], double: float) -> None: ...
    def updateQualityMeasurement(self, string: typing.Union[java.lang.String, str], double: float) -> bool: ...
    def updateQualityMeasurements(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]) -> None: ...
    class MovingHorizonEstimate:
        def getMeanSquaredError(self) -> float: ...
        def getProcessBias(self) -> float: ...
        def getProcessGain(self) -> float: ...
        def getSampleCount(self) -> int: ...
        def getTimeConstant(self) -> float: ...
    class QualityConstraint:
        @staticmethod
        def builder(string: typing.Union[java.lang.String, str]) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
        class Builder:
            def build(self) -> 'ModelPredictiveController.QualityConstraint': ...
            def compositionSensitivities(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def compositionSensitivity(self, string: typing.Union[java.lang.String, str], double: float) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def controlSensitivity(self, *double: float) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def limit(self, double: float) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def margin(self, double: float) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def measurement(self, measurementDeviceInterface: jneqsim.neqsim.process.measurementdevice.MeasurementDeviceInterface) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def rateSensitivity(self, double: float) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def unit(self, string: typing.Union[java.lang.String, str]) -> 'ModelPredictiveController.QualityConstraint.Builder': ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.neqsim.process.controllerdevice")``.

    ControllerDeviceBaseClass: typing.Type[ControllerDeviceBaseClass]
    ControllerDeviceInterface: typing.Type[ControllerDeviceInterface]
    ControllerEvent: typing.Type[ControllerEvent]
    ModelPredictiveController: typing.Type[ModelPredictiveController]
    structure: jneqsim.neqsim.process.controllerdevice.structure.__module_protocol__
