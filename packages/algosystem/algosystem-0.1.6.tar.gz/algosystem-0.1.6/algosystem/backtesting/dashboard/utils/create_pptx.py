# file: algosystem/backtesting/dashboard/utils/pptx_generator.py
"""
Backtesting PowerPoint Generator (No blank first slide + footer preserved)
- Uses the template's FIRST slide for summary (no extra blank slide).
- Keeps bottom-right "generated by algosystem" textbox from the template.
- Two centered tables (Metric/Value), zebra rows, spacing.
- 2×2 charts centered with your exact geometry (do not change).
"""

from copy import deepcopy

from pptx import Presentation
from pptx.util import Inches, Pt, Emu
from pptx.enum.text import PP_ALIGN, MSO_ANCHOR
from pptx.dml.color import RGBColor
from pptx.enum.dml import MSO_THEME_COLOR
import pandas as pd
import os
import glob
import re
from datetime import datetime
from typing import Iterable, List, Tuple, Optional

# ===================== CONFIG (edit here) =====================
class CONFIG:
    TABLE_HEADER_COLOR = RGBColor(255, 108, 0)     # your orange
    TABLE_ZEBRA_COLOR  = RGBColor(242, 245, 249)
    FONT_TITLE  = Pt(20)
    FONT_HEADER = Pt(12)
    FONT_CELL   = Pt(11)

    TABLE_WIDTH = Inches(4.2)
    TABLE_GAP   = Inches(0.5)
    TABLE_ROW_HEIGHT = Inches(0.34)

    # Subtle frame around chart PNGs (optional)
    CHART_BORDER_COLOR = RGBColor(200, 200, 200)
    CHART_BORDER_PT    = Pt(1.0)

    # Title box
    TITLE_LEFT   = Inches(0.5)
    TITLE_TOP    = Inches(0.3)
    TITLE_WIDTH  = Inches(9)
    TITLE_HEIGHT = Inches(0.6)

# =============== DO NOT CHANGE (requested) ====================
# Chart sizing (exactly as provided)
CHART_W    = Inches(5.9)
CHART_H    = Inches(2.6)
GAP_X      = Inches(0.2)
GAP_Y      = Inches(0.2)
TOP_OFFSET = Inches(1.1)
# ==============================================================

# ----------------- helpers -----------------

def find_latest_file(pattern: str) -> str | None:
    matches = glob.glob(pattern)
    if not matches:
        return None
    def key_fn(p):
        m = re.search(r'_(\d{8}_\d{6})\.', os.path.basename(p))
        if m:
            try:
                return datetime.strptime(m.group(1), "%Y%m%d_%H%M%S")
            except ValueError:
                pass
        return datetime.fromtimestamp(os.path.getmtime(p))
    return sorted(matches, key=key_fn)[-1]

def _existing(paths: Iterable[str]) -> List[str]:
    return [p for p in paths if p and os.path.exists(p)]

def _emu_frac(length_emu: Emu, numerator: int, denominator: int = 100) -> Emu:
    total = int(length_emu)
    part = (total * numerator) // denominator
    return Emu(part)

def _add_title(slide, text: str) -> None:
    box = slide.shapes.add_textbox(CONFIG.TITLE_LEFT, CONFIG.TITLE_TOP, CONFIG.TITLE_WIDTH, CONFIG.TITLE_HEIGHT)
    tf = box.text_frame
    tf.clear()
    p = tf.paragraphs[0]
    p.text = text
    p.font.size = CONFIG.FONT_TITLE
    p.font.bold = True
    p.font.color.theme_color = MSO_THEME_COLOR.TEXT_1
    p.alignment = PP_ALIGN.LEFT

# ---------- bottom-right textbox handling ----------

def _find_footer_shape(slide, needle: str = "generated by algosystem") -> Optional[object]:
    """Return the textbox shape that contains the footer text (case-insensitive)."""
    needle = needle.lower()
    for shp in slide.shapes:
        try:
            if shp.has_text_frame and needle in shp.text_frame.text.lower():
                return shp
        except Exception:
            continue
    return None

def _clone_shape_to_slide(src_shape, dst_slide):
    """Clone a shape (textbox) to another slide."""
    new_el = deepcopy(src_shape.element)
    dst_slide.shapes._spTree.insert_element_before(new_el, 'p:extLst')

def _ensure_footer_on_slide(template_slide, target_slide) -> None:
    """Copy the textbox from template_slide if target_slide doesn't have it."""
    src = _find_footer_shape(template_slide)
    if not src:
        return
    if _find_footer_shape(target_slide):
        return
    _clone_shape_to_slide(src, target_slide)

# ---------- summary tables ----------

def _make_table(slide, left: Emu, top: Emu, width: Emu, rows: List[Tuple[str, str]]):
    n_rows = len(rows) + 1
    n_cols = 2
    row_h = CONFIG.TABLE_ROW_HEIGHT

    tbl_shape = slide.shapes.add_table(n_rows, n_cols, left, top, width, row_h * n_rows)
    tbl = tbl_shape.table

    col0_w = _emu_frac(width, 48, 100)
    col1_w = Emu(int(width) - int(col0_w))
    tbl.columns[0].width = col0_w
    tbl.columns[1].width = col1_w

    # Header
    tbl.cell(0, 0).text = "Metric"
    tbl.cell(0, 1).text = "Value"
    for j in range(2):
        c = tbl.cell(0, j)
        p = c.text_frame.paragraphs[0]
        p.font.size = CONFIG.FONT_HEADER
        p.font.bold = True
        p.font.color.rgb = RGBColor(255, 255, 255)
        c.fill.solid()
        c.fill.fore_color.rgb = CONFIG.TABLE_HEADER_COLOR
        c.vertical_anchor = MSO_ANCHOR.MIDDLE

    # Body
    for i, (metric, value) in enumerate(rows, start=1):
        c0 = tbl.cell(i, 0); c1 = tbl.cell(i, 1)
        c0.text = str(metric); c1.text = str(value)
        p0 = c0.text_frame.paragraphs[0]; p1 = c1.text_frame.paragraphs[0]
        p0.font.size = CONFIG.FONT_CELL; p0.font.bold = True; p0.font.color.rgb = RGBColor(0,0,0); p0.alignment = PP_ALIGN.LEFT
        p1.font.size = CONFIG.FONT_CELL; p1.font.color.rgb = RGBColor(0,0,0); p1.alignment = PP_ALIGN.RIGHT
        c0.vertical_anchor = MSO_ANCHOR.MIDDLE; c1.vertical_anchor = MSO_ANCHOR.MIDDLE

        if i % 2 == 0:
            for cell in (c0, c1):
                cell.fill.solid()
                cell.fill.fore_color.rgb = CONFIG.TABLE_ZEBRA_COLOR
    return tbl

def _clear_slide_except_footer(slide):
    """Remove all shapes except the bottom-right textbox."""
    footer = _find_footer_shape(slide)
    for shp in list(slide.shapes):
        if footer is not None and shp == footer:
            continue
        try:
            shp.element.getparent().remove(shp.element)
        except Exception:
            pass

def create_summary_on_first_slide(prs: Presentation, summary_df: pd.DataFrame):
    slide0 = prs.slides[0]
    _clear_slide_except_footer(slide0)
    _add_title(slide0, "Backtesting Summary Statistics")

    # --- Standard, conventional order (only include if present) ---
    STANDARD_ORDER = [
        # Timeline
        "Start Date", "End Date",
        # Returns
        "Total Return", "Annualized Return",
        # Risk (level)
        "Volatility", "Max Drawdown", "Var 95",
        # Risk-adjusted
        "Sharpe Ratio", "Sortino Ratio", "Calmar Ratio",
        # Hit stats / distribution
        "Win Rate", "Positive Days", "Negative Days", "Best Month", "Worst Month",
        # Factor / regression
        "Alpha", "Beta", "Correlation",
    ]

    present = set(summary_df["Metric"].astype(str))
    ordered_rows: List[Tuple[str, str]] = []
    for m in STANDARD_ORDER:
        if m in present:
            v = str(summary_df.loc[summary_df["Metric"] == m, "Value"].iloc[0])
            ordered_rows.append((m, v))

    # Fallback: if nothing matched, keep CSV order
    if not ordered_rows:
        ordered_rows = [(str(m), str(v)) for m, v in summary_df[["Metric", "Value"]].itertuples(index=False)]

    # Split into two columns, centered
    mid = (len(ordered_rows) + 1) // 2
    left_rows, right_rows = ordered_rows[:mid], ordered_rows[mid:]

    slide_w = prs.slide_width
    tbl_w = CONFIG.TABLE_WIDTH
    gap = CONFIG.TABLE_GAP
    total_w = Emu(int(tbl_w) * 2 + int(gap))
    left_start = Emu((int(slide_w) - int(total_w)) // 2)
    top = Inches(1.2)

    _make_table(slide0, left_start, top, tbl_w, left_rows)
    _make_table(slide0, Emu(int(left_start) + int(tbl_w) + int(gap)), top, tbl_w, right_rows)

# ---------- charts (2×2 centered with your constants) ----------

def _chart_positions_centered(prs: Presentation) -> List[Tuple[Emu, Emu, Emu, Emu]]:
    slide_w, _ = prs.slide_width, prs.slide_height
    total_w = Emu(int(CHART_W) * 2 + int(GAP_X))
    left_start = Emu((int(slide_w) - int(total_w)) // 2)
    top_start = TOP_OFFSET
    return [
        (left_start, top_start, CHART_W, CHART_H),
        (Emu(int(left_start) + int(CHART_W) + int(GAP_X)), top_start, CHART_W, CHART_H),
        (left_start, Emu(int(top_start) + int(CHART_H) + int(GAP_Y)), CHART_W, CHART_H),
        (Emu(int(left_start) + int(CHART_W) + int(GAP_X)),
         Emu(int(top_start) + int(CHART_H) + int(GAP_Y)), CHART_W, CHART_H),
    ]

def add_four_chart_slide(
    prs: Presentation,
    title: str,
    chart_paths: List[str] | List[Tuple[str, str]],
    template_index: int = 0,
):
    base_layout = prs.slides[template_index].slide_layout if len(prs.slides) > template_index else prs.slide_layouts[6]
    slide = prs.slides.add_slide(base_layout)

    _ensure_footer_on_slide(prs.slides[0], slide)
    _add_title(slide, title)

    paths = []
    for item in chart_paths[:4]:
        paths.append(item[0] if isinstance(item, (list, tuple)) else str(item))
    paths = _existing(paths)[:4]

    positions = _chart_positions_centered(prs)
    for i, path in enumerate(paths):
        left, top, w, h = positions[i]
        pic = slide.shapes.add_picture(path, left, top, width=w, height=h)
        pic.line.color.rgb = CONFIG.CHART_BORDER_COLOR
        pic.line.width = CONFIG.CHART_BORDER_PT

# ---------- main ----------

base_dir = os.path.dirname(os.path.abspath(__file__))
template_path = os.path.join(base_dir, "template.pptx")

def create_backtest_pptx(
    template_path=template_path,
    output_dir="backtest_exports",
    charts_dir="charts",
    output_path="backtest_presentation.pptx",
    prefix="backtest"
):
    prs = Presentation(template_path) if os.path.exists(template_path) else Presentation()
    print(f"Using template: {template_path}" if os.path.exists(template_path) else "Template not found, creating new presentation")

    summary_pattern = os.path.join(output_dir, f"{prefix}_summary_*.csv")
    summary_file = find_latest_file(summary_pattern)
    if not summary_file:
        print(f"Error: No summary file found matching {summary_pattern}")
        return

    print(f"Loading summary: {summary_file}")
    summary_df = pd.read_csv(summary_file)

    print("Creating summary on first slide...")
    create_summary_on_first_slide(prs, summary_df)

    print("Creating slide 2: Performance Comparison...")
    perf_images = [
        os.path.join(charts_dir, "equity_curves.png"),
        os.path.join(charts_dir, "drawdown_combined.png"),
        os.path.join(charts_dir, "relative_relative_performance.png"),
        os.path.join(charts_dir, "portfolio_value.png"),
    ]
    add_four_chart_slide(prs, "Performance Comparison: Strategy vs Benchmark", perf_images, template_index=0)

    print("Creating slide 3: Rolling Risk Metrics I...")
    risk_images_1 = [
        os.path.join(charts_dir, "risk_rolling_sharpe.png"),
        os.path.join(charts_dir, "risk_rolling_sortino.png"),
        os.path.join(charts_dir, "risk_rolling_volatility.png"),
        os.path.join(charts_dir, "risk_rolling_calmar.png"),
    ]
    add_four_chart_slide(prs, "Rolling Risk Metrics I", risk_images_1, template_index=0)

    print("Creating slide 4: Rolling Risk Metrics II...")
    risk_images_2 = [
        os.path.join(charts_dir, "risk_rolling_var.png"),
        os.path.join(charts_dir, "risk_rolling_skew.png"),
        os.path.join(charts_dir, "relative_relative_performance.png"),
    ]
    add_four_chart_slide(prs, "Rolling Risk Metrics II", risk_images_2, template_index=0)

    prs.save(output_path)
    print(f"\nPresentation saved to: {output_path}")
    print(f"Total slides: {len(prs.slides)}")

if __name__ == "__main__":
    base_dir = os.path.dirname(os.path.abspath(__file__))
    template_path = os.path.join(base_dir, "template.pptx")

    create_backtest_pptx(
        template_path=template_path,
        output_dir="backtest_exports",
        charts_dir="charts",
        output_path="backtest_presentation.pptx",
        prefix="backtest"
    )
