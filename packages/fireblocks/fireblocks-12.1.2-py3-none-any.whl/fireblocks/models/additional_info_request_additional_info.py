# coding: utf-8

"""
    Fireblocks API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.6.2
    Contact: support@fireblocks.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import json
import pprint
from pydantic import BaseModel, ConfigDict, Field, StrictStr, ValidationError, field_validator
from typing import Any, List, Optional
from fireblocks.models.aba_payment_info import AbaPaymentInfo
from fireblocks.models.ach_payment_info import AchPaymentInfo
from fireblocks.models.iban_payment_info import IbanPaymentInfo
from fireblocks.models.lbt_payment_info import LbtPaymentInfo
from fireblocks.models.momo_payment_info import MomoPaymentInfo
from fireblocks.models.pix_payment_info import PixPaymentInfo
from fireblocks.models.sepa_payment_info import SepaPaymentInfo
from fireblocks.models.spei_advanced_payment_info import SpeiAdvancedPaymentInfo
from fireblocks.models.spei_basic_payment_info import SpeiBasicPaymentInfo
from fireblocks.models.us_wire_payment_info import UsWirePaymentInfo
from pydantic import StrictStr, Field
from typing import Union, List, Set, Optional, Dict
from typing_extensions import Literal, Self

ADDITIONALINFOREQUESTADDITIONALINFO_ONE_OF_SCHEMAS = ["AbaPaymentInfo", "AchPaymentInfo", "IbanPaymentInfo", "LbtPaymentInfo", "MomoPaymentInfo", "PixPaymentInfo", "SepaPaymentInfo", "SpeiAdvancedPaymentInfo", "SpeiBasicPaymentInfo", "UsWirePaymentInfo"]

class AdditionalInfoRequestAdditionalInfo(BaseModel):
    """
    Additional payment information based on the payment rail type
    """
    # data type: IbanPaymentInfo
    oneof_schema_1_validator: Optional[IbanPaymentInfo] = None
    # data type: AbaPaymentInfo
    oneof_schema_2_validator: Optional[AbaPaymentInfo] = None
    # data type: SpeiBasicPaymentInfo
    oneof_schema_3_validator: Optional[SpeiBasicPaymentInfo] = None
    # data type: SpeiAdvancedPaymentInfo
    oneof_schema_4_validator: Optional[SpeiAdvancedPaymentInfo] = None
    # data type: PixPaymentInfo
    oneof_schema_5_validator: Optional[PixPaymentInfo] = None
    # data type: SepaPaymentInfo
    oneof_schema_6_validator: Optional[SepaPaymentInfo] = None
    # data type: AchPaymentInfo
    oneof_schema_7_validator: Optional[AchPaymentInfo] = None
    # data type: UsWirePaymentInfo
    oneof_schema_8_validator: Optional[UsWirePaymentInfo] = None
    # data type: MomoPaymentInfo
    oneof_schema_9_validator: Optional[MomoPaymentInfo] = None
    # data type: LbtPaymentInfo
    oneof_schema_10_validator: Optional[LbtPaymentInfo] = None
    actual_instance: Optional[Union[AbaPaymentInfo, AchPaymentInfo, IbanPaymentInfo, LbtPaymentInfo, MomoPaymentInfo, PixPaymentInfo, SepaPaymentInfo, SpeiAdvancedPaymentInfo, SpeiBasicPaymentInfo, UsWirePaymentInfo]] = None
    one_of_schemas: Set[str] = { "AbaPaymentInfo", "AchPaymentInfo", "IbanPaymentInfo", "LbtPaymentInfo", "MomoPaymentInfo", "PixPaymentInfo", "SepaPaymentInfo", "SpeiAdvancedPaymentInfo", "SpeiBasicPaymentInfo", "UsWirePaymentInfo" }

    model_config = ConfigDict(
        validate_assignment=True,
        protected_namespaces=(),
    )


    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_oneof(cls, v):
        instance = AdditionalInfoRequestAdditionalInfo.model_construct()
        error_messages = []
        match = 0
        # validate data type: IbanPaymentInfo
        if not isinstance(v, IbanPaymentInfo):
            error_messages.append(f"Error! Input type `{type(v)}` is not `IbanPaymentInfo`")
        else:
            match += 1
        # validate data type: AbaPaymentInfo
        if not isinstance(v, AbaPaymentInfo):
            error_messages.append(f"Error! Input type `{type(v)}` is not `AbaPaymentInfo`")
        else:
            match += 1
        # validate data type: SpeiBasicPaymentInfo
        if not isinstance(v, SpeiBasicPaymentInfo):
            error_messages.append(f"Error! Input type `{type(v)}` is not `SpeiBasicPaymentInfo`")
        else:
            match += 1
        # validate data type: SpeiAdvancedPaymentInfo
        if not isinstance(v, SpeiAdvancedPaymentInfo):
            error_messages.append(f"Error! Input type `{type(v)}` is not `SpeiAdvancedPaymentInfo`")
        else:
            match += 1
        # validate data type: PixPaymentInfo
        if not isinstance(v, PixPaymentInfo):
            error_messages.append(f"Error! Input type `{type(v)}` is not `PixPaymentInfo`")
        else:
            match += 1
        # validate data type: SepaPaymentInfo
        if not isinstance(v, SepaPaymentInfo):
            error_messages.append(f"Error! Input type `{type(v)}` is not `SepaPaymentInfo`")
        else:
            match += 1
        # validate data type: AchPaymentInfo
        if not isinstance(v, AchPaymentInfo):
            error_messages.append(f"Error! Input type `{type(v)}` is not `AchPaymentInfo`")
        else:
            match += 1
        # validate data type: UsWirePaymentInfo
        if not isinstance(v, UsWirePaymentInfo):
            error_messages.append(f"Error! Input type `{type(v)}` is not `UsWirePaymentInfo`")
        else:
            match += 1
        # validate data type: MomoPaymentInfo
        if not isinstance(v, MomoPaymentInfo):
            error_messages.append(f"Error! Input type `{type(v)}` is not `MomoPaymentInfo`")
        else:
            match += 1
        # validate data type: LbtPaymentInfo
        if not isinstance(v, LbtPaymentInfo):
            error_messages.append(f"Error! Input type `{type(v)}` is not `LbtPaymentInfo`")
        else:
            match += 1
        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when setting `actual_instance` in AdditionalInfoRequestAdditionalInfo with oneOf schemas: AbaPaymentInfo, AchPaymentInfo, IbanPaymentInfo, LbtPaymentInfo, MomoPaymentInfo, PixPaymentInfo, SepaPaymentInfo, SpeiAdvancedPaymentInfo, SpeiBasicPaymentInfo, UsWirePaymentInfo. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when setting `actual_instance` in AdditionalInfoRequestAdditionalInfo with oneOf schemas: AbaPaymentInfo, AchPaymentInfo, IbanPaymentInfo, LbtPaymentInfo, MomoPaymentInfo, PixPaymentInfo, SepaPaymentInfo, SpeiAdvancedPaymentInfo, SpeiBasicPaymentInfo, UsWirePaymentInfo. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: Union[str, Dict[str, Any]]) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        match = 0

        # deserialize data into IbanPaymentInfo
        try:
            instance.actual_instance = IbanPaymentInfo.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into AbaPaymentInfo
        try:
            instance.actual_instance = AbaPaymentInfo.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into SpeiBasicPaymentInfo
        try:
            instance.actual_instance = SpeiBasicPaymentInfo.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into SpeiAdvancedPaymentInfo
        try:
            instance.actual_instance = SpeiAdvancedPaymentInfo.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into PixPaymentInfo
        try:
            instance.actual_instance = PixPaymentInfo.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into SepaPaymentInfo
        try:
            instance.actual_instance = SepaPaymentInfo.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into AchPaymentInfo
        try:
            instance.actual_instance = AchPaymentInfo.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into UsWirePaymentInfo
        try:
            instance.actual_instance = UsWirePaymentInfo.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into MomoPaymentInfo
        try:
            instance.actual_instance = MomoPaymentInfo.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into LbtPaymentInfo
        try:
            instance.actual_instance = LbtPaymentInfo.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when deserializing the JSON string into AdditionalInfoRequestAdditionalInfo with oneOf schemas: AbaPaymentInfo, AchPaymentInfo, IbanPaymentInfo, LbtPaymentInfo, MomoPaymentInfo, PixPaymentInfo, SepaPaymentInfo, SpeiAdvancedPaymentInfo, SpeiBasicPaymentInfo, UsWirePaymentInfo. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when deserializing the JSON string into AdditionalInfoRequestAdditionalInfo with oneOf schemas: AbaPaymentInfo, AchPaymentInfo, IbanPaymentInfo, LbtPaymentInfo, MomoPaymentInfo, PixPaymentInfo, SepaPaymentInfo, SpeiAdvancedPaymentInfo, SpeiBasicPaymentInfo, UsWirePaymentInfo. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        if hasattr(self.actual_instance, "to_json") and callable(self.actual_instance.to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Optional[Union[Dict[str, Any], AbaPaymentInfo, AchPaymentInfo, IbanPaymentInfo, LbtPaymentInfo, MomoPaymentInfo, PixPaymentInfo, SepaPaymentInfo, SpeiAdvancedPaymentInfo, SpeiBasicPaymentInfo, UsWirePaymentInfo]]:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        if hasattr(self.actual_instance, "to_dict") and callable(self.actual_instance.to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())


