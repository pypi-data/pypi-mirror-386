# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import typing
from . import mock

class DataType:
    def __repr__(self) -> str:
        ...


class TraceEventFieldMetadata:
    r"""
    Metadata describing a field in a trace event schema.
    
    This class defines the structure of a field within an event schema,
    including its name, data type, and optional unit of measurement.
    
    Args:
        name (str): The field name.
        data_type (DataType): The data type for the field.
        unit (Optional[str]): Optional unit of measurement.
    
    Examples:
        >>> # Define a field for HTTP status code
        >>> status_field = TraceEventFieldMetadata("status_code", DataType.Int32)
        >>>
        >>> # Define a field with a unit of measurement
        >>> duration_field = TraceEventFieldMetadata(
        ...     "duration_ms", DataType.Float64, "milliseconds")
    """
    name: str
    data_type: DataType
    unit: typing.Optional[str]
    def __new__(cls,name,data_type,unit = ...): ...
    def __repr__(self) -> str:
        ...


class TracePublishClient:
    r"""
    Client for publishing trace events to a Zelos Cloud service.
    
    This client manages the connection to a remote trace service and
    provides the communication channel needed by TraceSource objects
    to transmit events. It handles batching, retries, and connection management.
    
    Examples:
        >>> # Create a client with default settings
        >>> client = TracePublishClient()
        >>>
        >>> # Create a client with custom configuration
        >>> config = TracePublishClientConfig(url="grpc://localhost:2300")
        >>> client = TracePublishClient(config)
    """
    def __new__(cls,url = ...,config = ...): ...
    def shutdown(self) -> None:
        r"""
        Shutdown the client and all background tasks.
        
        This will cancel the background tasks and wait for them to complete.
        After calling this method, the client should not be used further.
        """
        ...

    def is_connected(self) -> bool:
        ...

    def __del__(self) -> None:
        r"""
        Python destructor - automatically shutdown background tasks
        """
        ...

    def __repr__(self) -> str:
        r"""
        String representation of the client.
        """
        ...


class TracePublishClientConfig:
    r"""
    Configuration for the PyTracePublishClient.
    
    This class allows customizing the behavior of trace publishing, including:
    - Batch size: Number of events to batch before sending
    - Batch timeout: Maximum time to wait before sending a partial batch
    
    Examples:
        >>> config = TracePublishClientConfig(
        ...     batch_size=500,
        ...     batch_timeout_ms=2000,
        ... )
        >>> client = TracePublishClient(config)
    """
    batch_size: int
    batch_timeout_ms: int
    def __new__(cls,batch_size = ...,batch_timeout_ms = ...): ...
    def __repr__(self) -> str:
        r"""
        String representation of the configuration.
        """
        ...

    def set_batch_size(self, size:int) -> None:
        r"""
        Set the configured batch size.
        """
        ...

    def set_batch_timeout_ms(self, ms:int) -> None:
        r"""
        Set the configured batch timeout in milliseconds.
        """
        ...


class TraceSender:
    r"""
    Communication channel for sending trace events.
    
    This class is typically obtained from a TracePublishClient and passed to
    a TraceSource during creation. It handles the underlying message transport.
    
    Note:
        Users generally don't need to interact with this class directly;
        it's used internally to connect TraceSource to TracePublishClient.
    """
    ...

class TraceSource:
    r"""
    Central source for trace events in an application.
    
    A TraceSource represents a single data source within your application
    (like a service or component) and manages the event schemas and transmission
    of events to the trace collection system.
    
    Examples:
        >>> client = TracePublishClient()
        >>> source = TraceSource("motor_controller")
        >>>
        >>> # Define an event schema
        >>> motor_event = source.add_event("motor_stats", [
        ...     TraceEventFieldMetadata("rpm", DataType.Float64),
        ...     TraceEventFieldMetadata("torque", DataType.Float64, "Nm"),
        ...     TraceEventFieldMetadata("temperature", DataType.Float64, "celsius"),
        ...     TraceEventFieldMetadata("voltage", DataType.Float64, "V"),
        ... ])
        >>>
        >>> # Log an event
        >>> motor_event.log(**{
        ...     "rpm": 3500.0,
        ...     "torque": 42.8,
        ...     "temperature": 75.5,
        ...     "voltage": 48.2
        ... })
    """
    name: str
    __getattr__: TraceSourceEvent
    def __new__(cls,name,sender = ...): ...
    def add_value_table(self, name,field_name,data) -> None:
        r"""
        Add a value table to the trace source.
        
        Args:
            name (str): The name of the value table.
            data (dict): A dictionary of values to add to the value table.
        
        Returns:
            None
        
        Examples:
            >>> source.add_value_table("motor_status", "state", {0: "stopped", 1: "running"})
            >>> source.add_value_table("sensor_data", "sensor_id", {1: "temp_sensor", 2: "pressure_sensor"})
        """
        ...

    def add_event_from_dict(self, name,data) -> TraceSourceEvent:
        ...

    def log_dict_at(self, time_ns:int, name:str, data:dict) -> None:
        ...

    def log_dict(self, name,data) -> None:
        r"""
        Log an event with a name and a dictionary of fields.
        
        Args:
            name (str): The name to log.
            data (dict): A dictionary of fields to log.
            prefix (str): A prefix to add to the event name.
        
        Returns:
            None
        
        Examples:
            >>> source.log_dict("sensor_data", {"temperature": 25.0, "pressure": 101325})
        """
        ...

    def log(self, name,data) -> None:
        r"""
        Log an event with a name and a dictionary of fields.
        
        Args:
            name (str): The name to log.
            data (dict): A dictionary of fields to log.
        
        Returns:
            None
        
        Examples:
            >>> source.log("sensor_data", {"temperature": 25.0, "pressure": 101325})
        """
        ...

    def log_at(self, time_ns:int, name:str, data:dict) -> None:
        r"""
        Log an event with a name and a dictionary of fields.
        
        Args:
            time_ns (int): The time to log the event at.
            name (str): The name to log.
            data (dict): A dictionary of fields to log.
        
        Returns:
            None
        
        Examples:
            >>> source.log_at(time.time_ns(), "sensor_data", {"temperature": 25.0})
        """
        ...

    def get_event(self, name:str) -> TraceSourceEvent:
        r"""
        Get a handle to a previously registered event schema.
        
        Args:
            name (str): The name of the event schema.
        
        Returns:
            TraceSourceEvent: A handle to the event.
        
        Raises:
            KeyError: If no event with the given name is registered.
        
        Examples:
            >>> # After defining an event schema
            >>> event = source.get_event("motor_stats")
        """
        ...

    def add_event(self, name,schema) -> TraceSourceEvent:
        r"""
        Directly registers an event schema defined by a list of TraceEventFieldMetadata.
        Useful if the schema is constructed programmatically.
        
        Args:
            name (str): The name for the event schema.
            schema (list[TraceEventFieldMetadata]): List defining the fields.
        
        Returns:
            TraceSourceEvent: A handle to the newly registered event.
        
        Raises:
            ValueError: If registering the schema fails internally.
        """
        ...

    def __repr__(self) -> str:
        r"""
        String representation of the source.
        """
        ...


class TraceSourceEvent:
    ...

class TraceStdout:
    r"""
    Python wrapper for the stdout trace sink.
    
    This sink outputs trace events to stdout with configurable log levels.
    It subscribes to all trace events from the router and formats them as
    structured log messages.
    
    The sink uses context management and should be used with a `with` statement
    to ensure proper resource cleanup and automatic start/stop of trace capture.
    
    Examples:
        >>> # Basic usage with default settings (info level)
        >>> with TraceStdout() as sink:
        ...     # Trace events will be logged to stdout
        ...     pass
        >>>
        >>> # Custom log level and batch configuration
        >>> with TraceStdout(log_level="debug", batch_size=500, batch_timeout_ms=2000) as sink:
        ...     # Trace events will be logged with custom settings
        ...     pass
    """
    log_level: str
    def __new__(cls,log_level = ...,batch_size = ...,batch_timeout_ms = ...): ...
    def open(self) -> None:
        r"""
        Start the stdout sink and begin capturing events.
        
        This method subscribes to the trace router and starts a background task
        to process and output trace events to stdout. It's automatically called
        when entering the context manager (with statement).
        
        Returns:
            None
        
        Raises:
            RuntimeError: If the sink cannot be initialized.
        """
        ...

    def __enter__(self) -> TraceStdout:
        ...

    def close(self) -> None:
        r"""
        Stop the stdout sink and finalize trace capture.
        
        This method gracefully shuts down the sink and cancels background tasks.
        It's automatically called when exiting the context manager.
        
        Returns:
            None
        """
        ...

    def __exit__(self, _exc_type:typing.Optional[typing.Any], _exc_value:typing.Optional[typing.Any], _traceback:typing.Optional[typing.Any]) -> None:
        ...

    def __repr__(self) -> str:
        r"""
        String representation of the sink.
        """
        ...


class TraceValue:
    ...

class TraceWriter:
    r"""
    Python wrapper for the TraceWriter.
    
    This writer manages writing trace events to a local file, with support for
    batching and buffering. It can be used with a TraceSource to capture events
    for later analysis.
    
    The writer uses context management and should be used with a `with` statement
    to ensure proper resource cleanup and automatic start/stop of trace capture.
    
    Examples:
        >>> # Basic usage with default settings
        >>> with TraceWriter("my_trace.trz") as writer:
        ...     # Trace events will be captured automatically
        ...     pass
        >>>
        >>> # Custom batch configuration
        >>> with TraceWriter("my_trace.trz", batch_size=500, batch_timeout_ms=2000) as writer:
        ...     # Trace events will be captured with custom batch settings
        ...     pass
    """
    path: str
    def __new__(cls,path,batch_size = ...,batch_timeout_ms = ...): ...
    def open(self) -> None:
        r"""
        Start the trace writer and begin capturing events.
        
        This method initializes the writer and starts background tasks for
        batching and writing trace events. It's automatically called when
        entering the context manager (with statement).
        
        Returns:
            None
        
        Raises:
            RuntimeError: If the writer cannot be initialized.
        
        Note:
            This method is called automatically by __enter__ when using
            the context manager pattern.
        """
        ...

    def __enter__(self) -> TraceWriter:
        ...

    def close(self) -> None:
        r"""
        Stop the trace writer and finalize trace capture.
        
        This method gracefully shuts down the writer, cancels background tasks,
        and ensures all buffered events are written to the trace file. It's
        automatically called when exiting the context manager.
        
        Returns:
            None
        
        Note:
            This method is called automatically by __exit__ when using
            the context manager pattern.
        """
        ...

    def __exit__(self, _exc_type:typing.Optional[typing.Any], _exc_value:typing.Optional[typing.Any], _traceback:typing.Optional[typing.Any]) -> None:
        ...

    def __repr__(self) -> str:
        r"""
        String representation of the writer.
        """
        ...


def enable_logging(log_level = ...) -> None:
    r"""
    Enable logging for the Zelos SDK native module.
    
    This function initializes the tracing system with the specified log level.
    If no log level is provided, it defaults to "info".
    
    Args:
        log_level (Optional[str]): The log level to use.
            Valid values: "trace", "debug", "info", "warn", "error".
            Defaults to "info" if not specified.
    
    Returns:
        None
    
    Examples:
        >>> enable_logging("debug")  # Set log level to debug
        >>> enable_logging("info")   # Set log level to info
        >>> enable_logging()         # Set log level to info
    """
    ...

def get_global_router_sender() -> TraceSender:
    r"""
    Get the global default trace router sender
    
    Returns:
        TraceSender: The global router's sender
    
    Examples:
        >>> sender = get_global_router_sender()
    """
    ...

def log(name,data,source = ...) -> None:
    ...

