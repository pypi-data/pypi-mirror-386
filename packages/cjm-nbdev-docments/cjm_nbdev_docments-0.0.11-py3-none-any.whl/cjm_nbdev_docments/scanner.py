"""Scan nbdev notebooks for exported functions and classes"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/scanner.ipynb.

# %% auto 0
__all__ = ['get_export_cells', 'extract_definitions', 'scan_notebook', 'scan_project']

# %% ../nbs/scanner.ipynb 3
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
import ast
import importlib
from execnb.nbio import read_nb
from fastcore.basics import AttrDict
from nbdev.config import get_config
import re

# %% ../nbs/scanner.ipynb 4
def get_export_cells(
    nb_path: Path    # Path to the notebook file
) -> List[Dict[str, Any]]:  # List of cells with export directives
    "Extract all code cells from a notebook that have export directives"
    nb = read_nb(nb_path)
    export_cells = []
    
    for cell in nb.cells:
        if cell.cell_type == 'code' and cell.source:
            lines = cell.source.split('\n')
            for line in lines:
                if line.strip().startswith('#| export'):
                    export_cells.append({
                        'cell_id': cell.get('id', None),
                        'source': cell.source,
                        'idx': cell.idx_ if hasattr(cell, 'idx_') else None
                    })
                    break
    
    return export_cells

# %% ../nbs/scanner.ipynb 5
def extract_definitions(
    source: str  # Python source code
) -> List[Dict[str, Any]]:  # List of function/class definitions with metadata
    "Extract function and class definitions from source code"
    definitions = []
    
    # Remove export directive lines
    lines = source.split('\n')
    clean_lines = [line for line in lines if not line.strip().startswith('#| ')]
    clean_source = '\n'.join(clean_lines)
    
    try:
        tree = ast.parse(clean_source)
        
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
                # Get the source lines for this definition
                start_line = node.lineno - 1
                end_line = node.end_lineno if hasattr(node, 'end_lineno') else start_line + 1
                
                def_lines = clean_lines[start_line:end_line]
                def_source = '\n'.join(def_lines)
                
                definition = {
                    'name': node.name,
                    'type': type(node).__name__,
                    'source': def_source,
                    'lineno': node.lineno,
                    'is_async': isinstance(node, ast.AsyncFunctionDef)
                }
                
                # For functions, extract parameters
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    definition['args'] = []
                    for arg in node.args.args:
                        definition['args'].append({
                            'name': arg.arg,
                            'annotation': ast.unparse(arg.annotation) if arg.annotation else None
                        })
                    
                    # Add return annotation
                    definition['returns'] = ast.unparse(node.returns) if node.returns else None
                
                definitions.append(definition)
                
    except SyntaxError as e:
        print(f"Syntax error parsing source: {e}")
        
    return definitions

# %% ../nbs/scanner.ipynb 6
def scan_notebook(
    nb_path: Path,  # Path to the notebook to scan
    nbs_root: Optional[Path] = None  # Root notebooks directory (for relative paths)
) -> List[Dict[str, Any]]:  # List of exported definitions with metadata
    "Scan a notebook and extract all exported function/class definitions"
    export_cells = get_export_cells(nb_path)
    all_definitions = []
    
    for cell in export_cells:
        definitions = extract_definitions(cell['source'])
        for defn in definitions:
            # If nbs_root is provided, use it; otherwise get from config
            if nbs_root is None:
                cfg = get_config()
                nbs_root = Path(cfg.config_path) / cfg.nbs_path
            
            # Store relative path from nbs directory for nested folders
            relative_path = nb_path.relative_to(nbs_root)
            
            defn['notebook'] = str(relative_path)  # Store full relative path
            defn['cell_id'] = cell['cell_id']
            
            # Try to get the actual function object from exported module
            try:
                # Get the module name from the notebook name
                module_name = nb_path.stem
                if module_name.startswith('0'):
                    # Handle numbered notebooks like core -> core
                    module_name = module_name.split('_', 1)[1] if '_' in module_name else module_name
                
                # Build module path including subdirectories
                module_parts = ['cjm_nbdev_docments']
                
                # Add subdirectory parts if notebook is in a subdirectory
                if relative_path.parent != Path('.'):
                    module_parts.extend(relative_path.parent.parts)
                
                module_parts.append(module_name)
                full_module_name = '.'.join(module_parts)
                
                # Import the module
                module = importlib.import_module(full_module_name)
                
                # Get the function/class object
                if hasattr(module, defn['name']):
                    defn['func_obj'] = getattr(module, defn['name'])
                else:
                    defn['func_obj'] = None
                    
            except Exception:
                defn['func_obj'] = None
            
            all_definitions.append(defn)
    
    return all_definitions

# %% ../nbs/scanner.ipynb 7
def scan_project(
    nbs_path: Optional[Path] = None,  # Path to notebooks directory (defaults to config.nbs_path)
    pattern: str = "*.ipynb"  # Pattern for notebook files to scan
) -> List[Dict[str, Any]]:  # All exported definitions found in the project
    "Scan all notebooks in a project for exported definitions"
    if nbs_path is None:
        cfg = get_config()
        nbs_path = Path(cfg.config_path) / cfg.nbs_path
    
    nbs_path = Path(nbs_path)
    all_definitions = []
    
    # Use rglob to recursively find notebooks in subdirectories
    for nb_path in nbs_path.rglob(pattern):
        # Skip private notebooks and those in .ipynb_checkpoints
        if not nb_path.name.startswith('_') and '.ipynb_checkpoints' not in str(nb_path):
            try:
                # Pass the nbs_path to scan_notebook so it knows the root
                definitions = scan_notebook(nb_path, nbs_root=nbs_path)
                all_definitions.extend(definitions)
            except Exception as e:
                print(f"Error scanning {nb_path}: {e}")
    
    return all_definitions
