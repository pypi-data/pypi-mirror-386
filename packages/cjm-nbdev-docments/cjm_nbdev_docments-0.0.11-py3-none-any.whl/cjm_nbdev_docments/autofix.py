"""Automatically add placeholder documentation to non-compliant functions"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/autofix.ipynb.

# %% auto 0
__all__ = ['find_signature_boundaries', 'split_parameters', 'parse_single_line_signature', 'generate_param_todo_comment',
           'generate_return_todo_comment', 'build_fixed_single_line_function', 'fix_multi_line_signature',
           'fix_class_definition', 'insert_function_docstring', 'fix_single_line_function', 'fix_multi_line_function',
           'generate_fixed_source', 'fix_notebook', 'DocstringInfo', 'detect_docstring_style', 'parse_google_docstring',
           'parse_numpy_docstring', 'parse_sphinx_docstring', 'extract_docstring_info', 'convert_to_docments_format',
           'convert_single_line_to_docments', 'convert_multiline_to_docments', 'replace_docstring_in_body',
           'generate_fixed_source_with_conversion', 'fix_notebook_with_conversion']

# %% ../nbs/autofix.ipynb 3
import ast
from typing import List, Dict, Any, Optional, NamedTuple
import re
from pathlib import Path
from execnb.nbio import read_nb, write_nb
from fastcore.foundation import L
from fastcore.basics import ifnone, patch, compose
from .core import DocmentsCheckResult, check_definition
from .scanner import scan_notebook, get_export_cells

# %% ../nbs/autofix.ipynb 4
@patch
def needs_fixing(
    self: DocmentsCheckResult
) -> bool:  # Whether the definition needs fixing
    "Check if this definition needs any fixing"
    return not self.is_compliant or self.missing_params or self.params_missing_type_hints

# %% ../nbs/autofix.ipynb 5
@patch
def get_param_name(
    self: DocmentsCheckResult,
    param_str: str  # Parameter string (e.g., "x: int" or "y=10")
) -> str:  # Extracted parameter name
    "Extract parameter name from a parameter string"
    return param_str.split(':', 1)[0].split('=', 1)[0].strip()

# %% ../nbs/autofix.ipynb 6
@patch
def needs_param_fix(
    self: DocmentsCheckResult,
    param_name: str  # Name of the parameter to check
) -> bool:  # Whether the parameter needs fixing
    "Check if a parameter needs documentation or type hint fixes"
    needs_doc = param_name in self.missing_params and param_name != 'self'
    needs_type_hint = param_name in self.params_missing_type_hints and param_name != 'self'
    return needs_doc or needs_type_hint

# %% ../nbs/autofix.ipynb 7
def find_signature_boundaries(
    lines: List[str]  # Source code lines
) -> tuple[int, int]:  # (def_line_idx, sig_end_idx) or (-1, -1) if not found
    "Find the start and end lines of a function signature"
    def_line_idx = None
    sig_end_idx = None
    paren_count = 0
    in_signature = False
    
    for i, line in enumerate(lines):
        if line.strip().startswith(('def ', 'async def ')):
            def_line_idx = i
            in_signature = True
            
        if in_signature:
            # Count parentheses to find where signature ends
            paren_count += line.count('(') - line.count(')')
            
            # If we're back to balanced parens and line contains a colon, signature is done
            # (colon might be followed by comments)
            if paren_count == 0 and ':' in line:
                sig_end_idx = i
                break
    
    # Use ifnone for cleaner null handling
    def_line_idx = ifnone(def_line_idx, -1)
    sig_end_idx = ifnone(sig_end_idx, -1)
    
    if def_line_idx == -1 or sig_end_idx == -1:
        return -1, -1
    
    return def_line_idx, sig_end_idx

# %% ../nbs/autofix.ipynb 8
def split_parameters(
    params_str: str  # Parameter string from function signature
) -> List[str]:  # List of individual parameter strings
    "Split a parameter string into individual parameters, handling nested types"
    if not params_str.strip():
        return []
    
    # Use a more robust approach for complex nested types
    params = []
    current_param = ''
    paren_depth = 0
    bracket_depth = 0
    brace_depth = 0
    
    for char in params_str:
        if char == '(':
            paren_depth += 1
        elif char == ')':
            paren_depth -= 1
        elif char == '[':
            bracket_depth += 1
        elif char == ']':
            bracket_depth -= 1
        elif char == '{':
            brace_depth += 1
        elif char == '}':
            brace_depth -= 1
        elif char == ',' and paren_depth == 0 and bracket_depth == 0 and brace_depth == 0:
            params.append(current_param.strip())
            current_param = ''
            continue
        current_param += char
    
    if current_param.strip():
        params.append(current_param.strip())
    
    # Return as L for easier manipulation
    return L(params).filter()

# %% ../nbs/autofix.ipynb 9
def parse_single_line_signature(
    sig_line: str  # Single-line function signature
) -> dict:  # Parsed components of the signature
    "Parse a single-line function signature into its components"
    func_match = re.match(r'^(\s*)(def|async def)\s+(\w+)\s*\((.*?)\)(\s*(?:->\s*[^:]+)?)\s*:\s*(.*)$', sig_line)
    if not func_match:
        return None
    
    return {
        'indent': func_match.group(1),
        'def_keyword': func_match.group(2),
        'func_name': func_match.group(3),
        'params_str': func_match.group(4),
        'return_type': func_match.group(5),
        'existing_comment': func_match.group(6).strip()
    }

# %% ../nbs/autofix.ipynb 10
def generate_param_todo_comment(
    param_name: str,  # Parameter name
    result: DocmentsCheckResult,  # Check result with type hint and doc info
    existing_comment: str = ""  # Existing comment text (without #)
) -> str:  # TODO comment to add
    "Generate appropriate TODO comment for a parameter based on what's missing"
    has_type_hint = result.params_with_type_hints.get(param_name, False)
    has_doc = result.params_documented.get(param_name, False)
    
    if not has_type_hint and not has_doc:
        # Missing both type hint and description
        return "TODO: Add type hint and description"
    elif not has_type_hint and has_doc:
        # Has description but missing type hint
        if existing_comment:
            # Check if TODO for type hint already exists
            if "TODO: Add type hint" in existing_comment or "TODO:Add type hint" in existing_comment:
                return existing_comment  # Don't add duplicate TODO
            else:
                return f"{existing_comment} - TODO: Add type hint"
        else:
            return "TODO: Add type hint"
    elif has_type_hint and not has_doc:
        # Has type hint but missing description
        return "TODO: Add description"
    else:
        # This shouldn't happen if we're being asked to generate a comment
        return existing_comment if existing_comment else "TODO: Verify documentation"

# %% ../nbs/autofix.ipynb 11
def generate_return_todo_comment(
    result: DocmentsCheckResult,  # Check result with type hint and doc info
    existing_comment: str = ""  # Existing comment text (without #)
) -> str:  # TODO comment to add
    "Generate appropriate TODO comment for return value based on what's missing"
    has_type_hint = result.return_has_type_hint
    has_doc = result.return_documented
    
    if not has_type_hint and not has_doc:
        # Missing both type hint and description
        return "TODO: Add type hint and return description"
    elif not has_type_hint and has_doc:
        # Has description but missing type hint
        if existing_comment:
            # Check if TODO for type hint already exists
            if "TODO: Add type hint" in existing_comment or "TODO:Add type hint" in existing_comment:
                return existing_comment  # Don't add duplicate TODO
            else:
                return f"{existing_comment} - TODO: Add type hint"
        else:
            return "TODO: Add type hint"
    elif has_type_hint and not has_doc:
        # Has type hint but missing description
        return "TODO: Add return description"
    else:
        # This shouldn't happen if we're being asked to generate a comment
        return existing_comment if existing_comment else "TODO: Verify description"

# %% ../nbs/autofix.ipynb 12
def build_fixed_single_line_function(
    parsed: dict,  # Parsed signature components
    params: List[str],  # Individual parameter strings
    result: DocmentsCheckResult  # Check result with missing params info
) -> List[str]:  # Lines of fixed function signature
    "Build a fixed single-line function with documentation comments"
    fixed_lines = []
    indent = parsed['indent']
    
    # Start the function definition
    fixed_lines.append(f"{indent}{parsed['def_keyword']} {parsed['func_name']}(")
    
    # Add parameters with comments as needed
    for i, param in enumerate(params):
        # Use patch method to get parameter name
        param_name = result.get_param_name(param)
        
        # Use patch method to check if needs fixing
        if result.needs_param_fix(param_name):
            todo_comment = generate_param_todo_comment(param_name, result)
            if i < len(params) - 1:
                fixed_lines.append(f"{indent}    {param},  # {todo_comment}")
            else:
                fixed_lines.append(f"{indent}    {param}  # {todo_comment}")
        else:
            if i < len(params) - 1:
                fixed_lines.append(f"{indent}    {param},")
            else:
                fixed_lines.append(f"{indent}    {param}")
    
    # Handle return type and existing comment
    return_type = parsed['return_type']
    existing_comment = parsed['existing_comment']
    
    # Check if return type is None (no return value)
    is_none_return = return_type and 'None' in return_type.strip()
    
    # For single-line conversions, check if return needs fixing
    if return_type:
        # Skip adding TODO comments for functions with return type None
        if not is_none_return and ('return' in result.missing_params or 'return' in result.params_missing_type_hints):
            if existing_comment:
                # Parse existing comment
                comment_text = existing_comment[1:].strip() if existing_comment.startswith('#') else existing_comment
                todo_comment = generate_return_todo_comment(result, comment_text)
                fixed_lines.append(f"{indent}){return_type}: # {todo_comment}")
            else:
                # No existing comment
                todo_comment = generate_return_todo_comment(result)
                fixed_lines.append(f"{indent}){return_type}:  # {todo_comment}")
        else:
            # Return doesn't need fixing OR is None type
            if existing_comment:
                if existing_comment.startswith('#'):
                    fixed_lines.append(f"{indent}){return_type}: {existing_comment}")
                else:
                    fixed_lines.append(f"{indent}){return_type}: # {existing_comment}")
            else:
                fixed_lines.append(f"{indent}){return_type}:")
    else:
        # No return type but might need one
        if 'return' in result.params_missing_type_hints:
            if existing_comment:
                comment_text = existing_comment[1:].strip() if existing_comment.startswith('#') else existing_comment
                todo_comment = generate_return_todo_comment(result, comment_text)
                fixed_lines.append(f"{indent}): # {todo_comment}")
            else:
                todo_comment = generate_return_todo_comment(result)
                fixed_lines.append(f"{indent}): # {todo_comment}")
        else:
            # No return type needed
            if existing_comment:
                if existing_comment.startswith('#'):
                    fixed_lines.append(f"{indent}): {existing_comment}")
                else:
                    fixed_lines.append(f"{indent}): # {existing_comment}")
            else:
                fixed_lines.append(f"{indent}):")
    
    return fixed_lines

# %% ../nbs/autofix.ipynb 13
def fix_multi_line_signature(
    lines: List[str],  # All source lines
    def_line_idx: int,  # Start of function definition
    sig_end_idx: int,  # End of function signature
    result: DocmentsCheckResult  # Check result with missing params info
) -> List[str]:  # Fixed lines for the signature portion
    "Fix a multi-line function signature by adding parameter comments"
    fixed_lines = []
    
    for i in range(def_line_idx, sig_end_idx + 1):
        line = lines[i]
        line_stripped = line.strip()
        
        # More flexible parameter matching for multi-line signatures
        # Match: whitespace + word + optional type annotation + optional comma/paren + optional whitespace + optional comment
        param_match = re.match(r'^(\s*)(\w+)(\s*(?::\s*[^,\)#]+)?)\s*([,\)]?)(\s*)(?:#\s*(.*))?$', line)
        if param_match and i > def_line_idx and i < sig_end_idx:
            # This is a parameter line (not the def line, not the return line)
            indent = param_match.group(1)
            param_name = param_match.group(2)
            type_annotation = param_match.group(3) or ''
            trailing_punct = param_match.group(4) or ''
            trailing_space = param_match.group(5) or ''
            existing_comment = param_match.group(6) or ''
            
            # Check if this parameter needs fixing (either missing docs or missing type hints)
            needs_doc_fix = param_name in result.missing_params and param_name != 'self'
            needs_type_hint_fix = param_name in result.params_missing_type_hints and param_name != 'self'
            
            if needs_doc_fix or needs_type_hint_fix:
                todo_comment = generate_param_todo_comment(param_name, result, existing_comment)
                # Only add the fixed line if the comment actually changed
                if todo_comment != existing_comment:
                    fixed_lines.append(f"{indent}{param_name}{type_annotation}{trailing_punct}{trailing_space}  # {todo_comment}")
                else:
                    # Comment didn't change, keep original line
                    fixed_lines.append(line)
            else:
                fixed_lines.append(line)
        else:
            # Check for return type line
            return_match = re.match(r'^(\s*\)\s*->\s*[^:#]+)\s*:\s*(.*)$', line)
            if return_match:
                pre_colon = return_match.group(1)
                after_colon = return_match.group(2).strip()
                
                # Check if return type is None (no return value)
                is_none_return = 'None' in pre_colon
                
                # Skip adding TODO comments for functions with return type None
                if not is_none_return and ('return' in result.missing_params or 'return' in result.params_missing_type_hints):
                    if after_colon:
                        # There's already a comment, generate appropriate TODO
                        comment_text = after_colon[1:].strip() if after_colon.startswith('#') else after_colon
                        todo_comment = generate_return_todo_comment(result, comment_text)
                        # Only change if the comment actually changed
                        if todo_comment != comment_text:
                            fixed_lines.append(f"{pre_colon}: # {todo_comment}")
                        else:
                            fixed_lines.append(line)
                    else:
                        # No comment, add full TODO
                        todo_comment = generate_return_todo_comment(result)
                        fixed_lines.append(f"{pre_colon}:  # {todo_comment}")
                else:
                    fixed_lines.append(line)
            else:
                fixed_lines.append(line)
    
    return fixed_lines

# %% ../nbs/autofix.ipynb 14
def fix_class_definition(
    result: DocmentsCheckResult  # Check result with non-compliant class
) -> str:  # Fixed source code with class docstring
    "Fix a class definition by adding a docstring if missing"
    lines = result.source.split('\n')
    fixed_lines = []
    
    # Find the class definition line
    class_line_idx = -1
    for i, line in enumerate(lines):
        if line.strip().startswith('class '):
            class_line_idx = i
            break
    
    if class_line_idx == -1:
        return result.source
    
    # Add lines up to and including the class definition
    for i in range(class_line_idx + 1):
        fixed_lines.append(lines[i])
    
    # If missing docstring, add it after the class definition
    if not result.has_docstring:
        # Find the indentation of the first line after class definition
        indent = '    '  # Default
        if class_line_idx + 1 < len(lines):
            next_line = lines[class_line_idx + 1]
            # Match leading whitespace
            indent_match = re.match(r'^(\s*)', next_line)
            indent = ifnone(indent_match.group(1) if indent_match else None, '    ')
        
        fixed_lines.append(f'{indent}"""TODO: Add class description"""')
    
    # Add the rest of the class body
    for i in range(class_line_idx + 1, len(lines)):
        fixed_lines.append(lines[i])
    
    return '\n'.join(fixed_lines)

# %% ../nbs/autofix.ipynb 15
def insert_function_docstring(
    lines: List[str],  # Fixed function lines
    def_line_idx: int,  # Index of function definition line
    indent: str  # Base indentation for the function
) -> List[str]:  # Lines with docstring inserted
    "Insert a TODO docstring after the function signature"
    # Find the signature end (last line before function body)
    sig_end_idx = def_line_idx
    for i in range(def_line_idx, len(lines)):
        if lines[i].rstrip().endswith(':'):
            sig_end_idx = i
            break
    
    # Insert docstring after signature
    result_lines = []
    for i in range(sig_end_idx + 1):
        result_lines.append(lines[i])
    
    # Add the docstring
    docstring_indent = indent + '    '
    result_lines.append(f'{docstring_indent}"""TODO: Add function description"""')
    
    # Add the rest of the function body
    for i in range(sig_end_idx + 1, len(lines)):
        result_lines.append(lines[i])
    
    return result_lines

# %% ../nbs/autofix.ipynb 16
def fix_single_line_function(
    lines: List[str],  # All source lines
    def_line_idx: int,  # Index of function definition line
    result: DocmentsCheckResult  # Check result with missing params info
) -> List[str]:  # Fixed lines for the function
    "Fix a single-line function signature by converting to multi-line with parameter comments"
    # Parse the signature
    parsed = parse_single_line_signature(lines[def_line_idx])
    if not parsed:
        return lines
    
    # Split parameters
    params = split_parameters(parsed['params_str'])
    
    # Build the fixed function signature
    fixed_signature_lines = build_fixed_single_line_function(parsed, params, result)
    
    # Combine with rest of function
    fixed_lines = []
    # Add lines before the function
    for i in range(def_line_idx):
        fixed_lines.append(lines[i])
    
    # Add the fixed signature
    fixed_lines.extend(fixed_signature_lines)
    
    # Add docstring if missing
    if not result.has_docstring:
        docstring_indent = parsed['indent'] + '    '
        fixed_lines.append(f'{docstring_indent}"""TODO: Add function description"""')
    
    # Add lines after the function definition
    for i in range(def_line_idx + 1, len(lines)):
        fixed_lines.append(lines[i])
    
    return fixed_lines

# %% ../nbs/autofix.ipynb 17
def fix_multi_line_function(
    lines: List[str],  # All source lines
    def_line_idx: int,  # Start of function definition
    sig_end_idx: int,  # End of function signature
    result: DocmentsCheckResult  # Check result with missing params info
) -> List[str]:  # Fixed lines for the function
    "Fix a multi-line function signature by adding parameter comments"
    fixed_lines = []
    
    # Add lines before the function
    for i in range(def_line_idx):
        fixed_lines.append(lines[i])
    
    # Fix the signature
    signature_lines = fix_multi_line_signature(lines, def_line_idx, sig_end_idx, result)
    fixed_lines.extend(signature_lines)
    
    # Check if the function already has a docstring by looking at the first non-empty line after signature
    has_existing_docstring = False
    if sig_end_idx + 1 < len(lines):
        for i in range(sig_end_idx + 1, len(lines)):
            line_stripped = lines[i].strip()
            if line_stripped:  # First non-empty line
                # Check if it's a docstring
                if line_stripped.startswith(('"""', "'''", '"', "'")):
                    has_existing_docstring = True
                break
    
    # Insert docstring if missing AND not already present
    if not result.has_docstring and not has_existing_docstring:
        # Find the indentation of the function definition
        indent_match = re.match(r'^(\s*)', lines[def_line_idx])
        base_indent = indent_match.group(1) if indent_match else ''
        docstring_indent = base_indent + '    '
        fixed_lines.append(f'{docstring_indent}"""TODO: Add function description"""')
    
    # Add rest of function body
    for i in range(sig_end_idx + 1, len(lines)):
        fixed_lines.append(lines[i])
    
    return fixed_lines

# %% ../nbs/autofix.ipynb 18
def generate_fixed_source(
    result: DocmentsCheckResult  # Check result with non-compliant function
) -> str:  # Fixed source code with placeholder documentation
    "Generate fixed source code for a non-compliant function or class"
    # Handle classes (including dataclasses)
    if result.type == 'ClassDef':
        return fix_class_definition(result)
    
    # Use the patch method to check if fixing is needed
    if not result.needs_fixing():
        return result.source
    
    lines = result.source.split('\n')
    
    # Find the function definition line and signature end
    def_line_idx, sig_end_idx = find_signature_boundaries(lines)
    
    if def_line_idx == -1:
        return result.source
    
    # Choose the appropriate fix method based on signature type
    if def_line_idx == sig_end_idx and (result.missing_params or result.params_missing_type_hints):
        # Single-line signature that needs parameter fixing
        fixed_lines = fix_single_line_function(lines, def_line_idx, result)
    else:
        # Multi-line signature 
        fixed_lines = fix_multi_line_function(lines, def_line_idx, sig_end_idx, result)
    
    return '\n'.join(fixed_lines)

# %% ../nbs/autofix.ipynb 19
def fix_notebook(
    nb_path: Path,  # Path to notebook to fix
    dry_run: bool = False  # If True, show changes without saving
) -> Dict[str, Any]:  # Summary of changes made
    "Fix non-compliant functions in a notebook by adding placeholder documentation"
    nb = read_nb(nb_path)
    definitions = scan_notebook(nb_path)
    
    changes = {
        'notebook': nb_path.name,
        'definitions_fixed': [],
        'cells_modified': []
    }
    
    # Check each definition
    for defn in definitions:
        result = check_definition(defn)
        
        # Fix if non-compliant OR has missing type hints
        needs_fixing = (not result.is_compliant or 
                       result.missing_params or 
                       result.params_missing_type_hints)
        
        if needs_fixing:
            # Generate fixed source
            fixed_source = generate_fixed_source(result)
            
            # Only proceed if the source actually changed
            if fixed_source != result.source:
                # Find and update the cell
                cell_id = defn['cell_id']
                for cell in nb.cells:
                    if cell.get('id') == cell_id:
                        # Replace the definition in the cell source
                        old_source = result.source
                        cell_source = cell.source
                        
                        # Find the definition in the cell and replace it
                        if old_source in cell_source:
                            new_cell_source = cell_source.replace(old_source, fixed_source)
                            
                            if not dry_run:
                                cell.source = new_cell_source
                            
                            changes['definitions_fixed'].append(result.name)
                            if cell_id not in changes['cells_modified']:
                                changes['cells_modified'].append(cell_id)
                            
                            if dry_run:
                                print(f"\nWould fix {result.name}:")
                                print("-" * 40)
                                print(fixed_source)
                                print("-" * 40)
    
    # Save the notebook if not dry run
    if not dry_run and changes['definitions_fixed']:
        write_nb(nb, nb_path)
        # Fix grammar: use singular/plural based on count
        count = len(changes['definitions_fixed'])
        item_word = "definition" if count == 1 else "definitions"
        print(f"âœ… Fixed {count} {item_word} in {nb_path.name}")
        for defn_name in changes['definitions_fixed']:
            print(f"   - {defn_name}")
    elif dry_run and changes['definitions_fixed']:
        count = len(changes['definitions_fixed'])
        item_word = "definition" if count == 1 else "definitions" 
        print(f"\nðŸ” Dry run: Would fix {count} {item_word}")
    else:
        print(f"âœ… All definitions in {nb_path.name} are already compliant")
    
    return changes

# %% ../nbs/autofix.ipynb 20
class DocstringInfo(NamedTuple):
    """Information extracted from a docstring"""
    description: str  # Main function description
    params: Dict[str, str]  # Parameter name -> description
    returns: Optional[str]  # Return description
    docstring_type: str  # Type of docstring (google, numpy, sphinx, etc.)

# %% ../nbs/autofix.ipynb 21
def detect_docstring_style(
    docstring: str  # Docstring text to analyze
) -> str:  # Detected style: 'google', 'numpy', 'sphinx', 'docments', or 'unknown'
    "Detect the style of a docstring"
    if not docstring:
        return 'unknown'
    
    docstring = docstring.strip()
    
    # Check for Google style (Args:, Returns:, etc.)
    if re.search(r'(Args?|Arguments?|Parameters?|Params?|Returns?|Return|Yields?|Yield|Raises?|Raise|Note|Notes|Example|Examples):\s*$', docstring, re.MULTILINE):
        return 'google'
    
    # Check for NumPy style (Parameters\n----------)
    if re.search(r'(Parameters?|Returns?|Yields?|Raises?|See Also|Notes?|References?|Examples?)\s*\n\s*-{3,}', docstring, re.MULTILINE):
        return 'numpy'
    
    # Check for Sphinx style (:param, :type, :returns, etc.)
    if re.search(r':(param|type|returns?|rtype|raises?|note|example)(\s+\w+)?:', docstring, re.MULTILINE):
        return 'sphinx'
    
    # Check if already in docments style (very simple check)
    # This would be harder to detect since docments puts docs inline
    # For now, assume unknown if none of the above patterns match
    return 'unknown'

# %% ../nbs/autofix.ipynb 22
def parse_google_docstring(
    docstring: str  # Google-style docstring text
) -> DocstringInfo:  # Parsed docstring information
    "Parse a Google-style docstring"
    params = {}
    returns = None
    description_lines = []
    
    # Clean the docstring - remove triple quotes and normalize
    cleaned = docstring.strip()
    if cleaned.startswith('"""') or cleaned.startswith("'''"):
        cleaned = cleaned[3:]
    if cleaned.endswith('"""') or cleaned.endswith("'''"):
        cleaned = cleaned[:-3]
    
    lines = cleaned.split('\n')
    current_section = None
    current_param = None
    
    for line in lines:
        line = line.strip()
        
        # Check for section headers
        if re.match(r'^(Args?|Arguments?|Parameters?|Params?):\s*$', line):
            current_section = 'params'
            continue
        elif re.match(r'^(Returns?|Return):\s*$', line):
            current_section = 'returns'
            continue
        elif re.match(r'^(Yields?|Yield|Raises?|Raise|Note|Notes|Example|Examples):\s*$', line):
            current_section = 'other'
            continue
        
        # Process content based on current section
        if current_section == 'params':
            # Look for parameter definitions: "param_name (type): description"
            param_match = re.match(r'^(\w+)\s*(?:\([^)]+\))?\s*:\s*(.+)$', line)
            if param_match:
                param_name = param_match.group(1)
                param_desc = param_match.group(2)
                params[param_name] = param_desc
                current_param = param_name
            elif current_param and line:
                # Continuation of previous parameter description
                params[current_param] += ' ' + line
        elif current_section == 'returns':
            if line:
                if returns is None:
                    returns = line
                else:
                    returns += ' ' + line
        elif current_section is None:
            # This is part of the main description
            if line:
                description_lines.append(line)
    
    description = ' '.join(description_lines)
    return DocstringInfo(description, params, returns, 'google')

# %% ../nbs/autofix.ipynb 23
def parse_numpy_docstring(
    docstring: str  # NumPy-style docstring text
) -> DocstringInfo:  # Parsed docstring information
    "Parse a NumPy-style docstring"
    params = {}
    returns = None
    description_lines = []
    
    # Clean the docstring - remove triple quotes and normalize
    cleaned = docstring.strip()
    if cleaned.startswith('"""') or cleaned.startswith("'''"):
        cleaned = cleaned[3:]
    if cleaned.endswith('"""') or cleaned.endswith("'''"):
        cleaned = cleaned[:-3]
    
    lines = cleaned.split('\n')
    current_section = None
    current_param = None
    
    for i, line in enumerate(lines):
        line_stripped = line.strip()
        
        # Check for section headers (followed by dashes)
        if i + 1 < len(lines) and re.match(r'^-{3,}$', lines[i + 1].strip()):
            if re.match(r'^(Parameters?|Params?)$', line_stripped):
                current_section = 'params'
                continue
            elif re.match(r'^(Returns?|Return)$', line_stripped):
                current_section = 'returns'
                continue
            elif re.match(r'^(Yields?|Raises?|See Also|Notes?|References?|Examples?)$', line_stripped):
                current_section = 'other'
                continue
        
        # Skip the dashes line
        if re.match(r'^-{3,}$', line_stripped):
            continue
        
        # Process content based on current section
        if current_section == 'params':
            # Look for parameter definitions: "param_name : type" followed by description
            param_match = re.match(r'^(\w+)\s*:\s*(.+)$', line_stripped)
            if param_match:
                param_name = param_match.group(1)
                # The type information is on the same line, description usually follows
                current_param = param_name
                params[param_name] = ''
            elif current_param and line_stripped:
                # Description line for the current parameter
                if params[current_param]:
                    params[current_param] += ' ' + line_stripped
                else:
                    params[current_param] = line_stripped
        elif current_section == 'returns':
            if line_stripped:
                if returns is None:
                    returns = line_stripped
                else:
                    returns += ' ' + line_stripped
        elif current_section is None:
            # This is part of the main description
            if line_stripped:
                description_lines.append(line_stripped)
    
    description = ' '.join(description_lines)
    return DocstringInfo(description, params, returns, 'numpy')

# %% ../nbs/autofix.ipynb 24
def parse_sphinx_docstring(
    docstring: str  # Sphinx-style docstring text
) -> DocstringInfo:  # Parsed docstring information
    "Parse a Sphinx-style docstring"
    params = {}
    returns = None
    description_lines = []
    
    lines = docstring.split('\n')
    
    for line in lines:
        line = line.strip()
        
        # Check for parameter definitions: ":param param_name: description"
        param_match = re.match(r'^:param\s+(\w+)\s*:\s*(.+)$', line)
        if param_match:
            param_name = param_match.group(1)
            param_desc = param_match.group(2)
            params[param_name] = param_desc
            continue
        
        # Check for return definitions: ":returns: description" or ":return: description"
        return_match = re.match(r'^:returns?\s*:\s*(.+)$', line)
        if return_match:
            returns = return_match.group(1)
            continue
        
        # Skip other sphinx directives
        if re.match(r'^:\w+(\s+\w+)?:', line):
            continue
        
        # This is part of the main description
        if line:
            description_lines.append(line)
    
    description = ' '.join(description_lines)
    return DocstringInfo(description, params, returns, 'sphinx')

# %% ../nbs/autofix.ipynb 25
def extract_docstring_info(
    source: str,  # Function source code
    name: str  # Function name
) -> Optional[DocstringInfo]:  # Extracted docstring information or None
    "Extract docstring information from function source code"
    try:
        tree = ast.parse(source)
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                if node.name == name and node.body:
                    # Check if first statement is a docstring
                    first_stmt = node.body[0]
                    if (isinstance(first_stmt, ast.Expr) and 
                        isinstance(first_stmt.value, (ast.Str, ast.Constant))):
                        
                        # Extract docstring text
                        if hasattr(first_stmt.value, 's'):
                            docstring = first_stmt.value.s
                        elif hasattr(first_stmt.value, 'value'):
                            docstring = first_stmt.value.value
                        else:
                            return None
                        
                        if not isinstance(docstring, str):
                            return None
                        
                        # Detect and parse the docstring style
                        style = detect_docstring_style(docstring)
                        
                        if style == 'google':
                            return parse_google_docstring(docstring)
                        elif style == 'numpy':
                            return parse_numpy_docstring(docstring)
                        elif style == 'sphinx':
                            return parse_sphinx_docstring(docstring)
                        else:
                            # Unknown style, return basic info
                            return DocstringInfo(docstring.strip(), {}, None, 'unknown')
                    break
    except Exception:
        return None
    
    return None

# %% ../nbs/autofix.ipynb 26
def convert_to_docments_format(
    source: str,  # Original function source code
    docstring_info: DocstringInfo,  # Extracted docstring information
    result: DocmentsCheckResult  # Check result with missing params info
) -> str:  # Converted source code in docments format
    "Convert function source to docments format using extracted docstring info"
    lines = source.split('\n')
    
    # Find the function definition line and signature end
    def_line_idx, sig_end_idx = find_signature_boundaries(lines)
    
    if def_line_idx == -1:
        return source
    
    # Build the new function with docments-style documentation
    fixed_lines = []
    
    # Add lines before the function
    for i in range(def_line_idx):
        fixed_lines.append(lines[i])
    
    # Convert single-line to multi-line if needed or fix existing multi-line
    if def_line_idx == sig_end_idx:
        # Single-line signature - convert to multi-line with docments comments
        fixed_lines.extend(convert_single_line_to_docments(lines[def_line_idx], docstring_info, result))
    else:
        # Multi-line signature - add docments comments to existing structure
        fixed_lines.extend(convert_multiline_to_docments(lines[def_line_idx:sig_end_idx+1], docstring_info, result))
    
    # Replace the original docstring with the description only
    body_start_idx = sig_end_idx + 1
    if body_start_idx < len(lines):
        # Find the docstring in the function body and replace it
        body_lines = lines[body_start_idx:]
        new_body_lines = replace_docstring_in_body(body_lines, docstring_info.description, lines[def_line_idx])
        fixed_lines.extend(new_body_lines)
    
    return '\n'.join(fixed_lines)

# %% ../nbs/autofix.ipynb 27
def convert_single_line_to_docments(
    sig_line: str,  # Single-line function signature
    docstring_info: DocstringInfo,  # Extracted docstring information
    result: DocmentsCheckResult  # Check result with missing params info
) -> List[str]:  # Multi-line signature with docments comments
    "Convert single-line function signature to multi-line docments format"
    
    # Parse the signature
    parsed = parse_single_line_signature(sig_line)
    if not parsed:
        return [sig_line]
    
    # Split parameters
    params = split_parameters(parsed['params_str'])
    
    # Build the new signature
    fixed_lines = []
    indent = parsed['indent']
    
    # Start the function definition
    fixed_lines.append(f"{indent}{parsed['def_keyword']} {parsed['func_name']}(")
    
    # Add parameters with docments comments
    for i, param in enumerate(params):
        param_name = result.get_param_name(param)
        
        # Get documentation from the extracted docstring info
        param_doc = docstring_info.params.get(param_name, '')
        
        if param_doc:
            # Use the extracted documentation
            if i < len(params) - 1:
                fixed_lines.append(f"{indent}    {param},  # {param_doc}")
            else:
                fixed_lines.append(f"{indent}    {param}  # {param_doc}")
        else:
            # No documentation found, add TODO
            if param_name in result.missing_params:
                todo_comment = generate_param_todo_comment(param_name, result)
                if i < len(params) - 1:
                    fixed_lines.append(f"{indent}    {param},  # {todo_comment}")
                else:
                    fixed_lines.append(f"{indent}    {param}  # {todo_comment}")
            else:
                # Keep as is
                if i < len(params) - 1:
                    fixed_lines.append(f"{indent}    {param},")
                else:
                    fixed_lines.append(f"{indent}    {param}")
    
    # Handle return type
    return_type = parsed['return_type']
    
    # Check if return type is None (no return value)
    is_none_return = return_type and 'None' in return_type.strip()
    
    if return_type and docstring_info.returns and not is_none_return:
        fixed_lines.append(f"{indent}){return_type}:  # {docstring_info.returns}")
    elif return_type and 'return' in result.missing_params and not is_none_return:
        todo_comment = generate_return_todo_comment(result)
        fixed_lines.append(f"{indent}){return_type}:  # {todo_comment}")
    elif return_type:
        fixed_lines.append(f"{indent}){return_type}:")
    else:
        fixed_lines.append(f"{indent}):")
    
    return fixed_lines

# %% ../nbs/autofix.ipynb 28
def convert_multiline_to_docments(
    sig_lines: List[str],  # Multi-line function signature
    docstring_info: DocstringInfo,  # Extracted docstring information
    result: DocmentsCheckResult  # Check result with missing params info
) -> List[str]:  # Multi-line signature with docments comments
    "Convert multi-line function signature to docments format"
    
    fixed_lines = []
    
    for i, line in enumerate(sig_lines):
        line_stripped = line.strip()
        
        # Check if this line contains a parameter (including the last one that might end with ))
        # Updated regex to handle parameters that end with )) for the last param before return type
        param_match = re.match(r'^(\s*)(\w+)(\s*(?::\s*[^,\)#]+)?)\s*([,\)]?)(\)?)\s*(?:->\s*[^:#]+)?\s*:?\s*(?:#\s*(.*))?$', line)
        
        # Check if it's a parameter line (not the def line)
        if param_match and i > 0 and param_match.group(2) != 'def':
            param_name = param_match.group(2)
            
            # Skip if this is actually the return type line
            if '->' in line and ')' in line:
                # This is a return type line, handle it separately
                return_match = re.match(r'^(\s*.*\)\s*->\s*[^:#]+)\s*:\s*(.*)$', line)
                if return_match:
                    pre_colon = return_match.group(1)
                    existing_comment = return_match.group(2).strip()
                    
                    # Check if return type is None (no return value)
                    is_none_return = 'None' in pre_colon
                    
                    # Check if the existing comment is a TODO comment
                    is_todo_comment = 'TODO' in existing_comment if existing_comment else False
                    
                    if docstring_info.returns and not is_none_return and (not existing_comment or is_todo_comment):
                        # Replace with extracted return documentation if no comment or it's a TODO
                        fixed_lines.append(f"{pre_colon}:  # {docstring_info.returns}")
                    elif 'return' in result.missing_params and not is_none_return:
                        comment_text = existing_comment[1:].strip() if existing_comment.startswith('#') else existing_comment
                        todo_comment = generate_return_todo_comment(result, comment_text)
                        fixed_lines.append(f"{pre_colon}:  # {todo_comment}")
                    else:
                        fixed_lines.append(line)
                else:
                    fixed_lines.append(line)
            else:
                # Regular parameter line
                indent = param_match.group(1)
                type_annotation = param_match.group(3) or ''
                trailing_punct = param_match.group(4) or ''
                extra_paren = param_match.group(5) or ''
                existing_comment = param_match.group(6) or ''
                
                # Reconstruct the line ending (could be , or ) or ))
                line_ending = trailing_punct + extra_paren
                
                # Get documentation from the extracted docstring info
                param_doc = docstring_info.params.get(param_name, '')
                
                # Check if the existing comment is a TODO comment
                is_todo_comment = 'TODO' in existing_comment
                
                if param_doc and (not existing_comment or is_todo_comment):
                    # Replace with the extracted documentation if there's no comment or it's a TODO
                    fixed_lines.append(f"{indent}{param_name}{type_annotation}{line_ending}  # {param_doc}")
                elif param_doc and existing_comment and not is_todo_comment:
                    # Keep existing non-TODO comment (it might be manually written documentation)
                    fixed_lines.append(line)
                elif param_name in result.missing_params:
                    # No documentation found in docstring, add TODO
                    todo_comment = generate_param_todo_comment(param_name, result, existing_comment)
                    fixed_lines.append(f"{indent}{param_name}{type_annotation}{line_ending}  # {todo_comment}")
                else:
                    # Keep original
                    fixed_lines.append(line)
        else:
            # Not a parameter line, could be def line or other
            fixed_lines.append(line)
    
    return fixed_lines

# %% ../nbs/autofix.ipynb 29
def replace_docstring_in_body(
    body_lines: List[str],  # Function body lines
    description: str,  # New description to use
    def_line: str  # Function definition line for indentation
) -> List[str]:  # Modified body lines
    "Replace the docstring in function body with a simple description"
    
    # Find the indentation of the function definition
    indent_match = re.match(r'^(\s*)', def_line)
    base_indent = indent_match.group(1) if indent_match else ''
    docstring_indent = base_indent + '    '
    
    # Look for the docstring (first string literal after function definition)
    docstring_found = False
    result_lines = []
    in_multiline_docstring = False
    
    for i, line in enumerate(body_lines):
        line_stripped = line.strip()
        
        # If we haven't found the docstring yet and this line is not empty
        if not docstring_found and line_stripped:
            # Check if it starts a docstring
            if line_stripped.startswith(('"""', "'''", '"', "'")):
                docstring_found = True
                
                # Check if it's a single-line docstring
                if ((line_stripped.startswith('"""') and line_stripped.endswith('"""') and len(line_stripped) > 6) or
                    (line_stripped.startswith("'''") and line_stripped.endswith("'''") and len(line_stripped) > 6) or
                    (line_stripped.startswith('"') and line_stripped.endswith('"') and len(line_stripped) > 2 and not line_stripped.startswith('"""')) or
                    (line_stripped.startswith("'") and line_stripped.endswith("'") and len(line_stripped) > 2 and not line_stripped.startswith("'''"))):
                    # Single-line docstring
                    result_lines.append(f'{docstring_indent}"""{description}"""')
                else:
                    # Start of multi-line docstring
                    in_multiline_docstring = True
                    result_lines.append(f'{docstring_indent}"""{description}"""')
            else:
                # Not a docstring, keep the line
                result_lines.append(line)
        elif in_multiline_docstring:
            # We're inside a multi-line docstring, check if this ends it
            if line_stripped.endswith(('"""', "'''")):
                in_multiline_docstring = False
                # Skip this line (end of docstring)
            # Skip all lines inside the multi-line docstring
        else:
            # Either we already processed the docstring or this is a regular line
            result_lines.append(line)
    
    # If no docstring was found, add the description at the beginning
    if not docstring_found:
        result_lines.insert(0, f'{docstring_indent}"""{description}"""')
    
    return result_lines

# %% ../nbs/autofix.ipynb 30
def generate_fixed_source_with_conversion(
    result: DocmentsCheckResult  # Check result with non-compliant function
) -> str:  # Fixed source code with converted documentation
    "Generate fixed source code, converting existing docstrings to docments format if possible"
    
    # First, try to extract docstring information for conversion
    docstring_info = extract_docstring_info(result.source, result.name)
    
    # If we found structured docstring info (not unknown), convert it
    if (docstring_info and 
        docstring_info.docstring_type in ['google', 'numpy', 'sphinx'] and
        (docstring_info.params or docstring_info.returns)):
        try:
            converted_source = convert_to_docments_format(result.source, docstring_info, result)
            return converted_source
        except Exception:
            # Fallback to original fix if conversion fails
            pass
    
    # Fallback to the original generate_fixed_source function
    return generate_fixed_source(result)

# %% ../nbs/autofix.ipynb 31
def fix_notebook_with_conversion(
    nb_path: Path,  # Path to notebook to fix
    dry_run: bool = False,  # If True, show changes without saving
    convert_docstrings: bool = True  # If True, convert existing docstrings to docments format
) -> Dict[str, Any]:  # Summary of changes made
    "Fix non-compliant functions in a notebook, optionally converting docstrings to docments format"
    nb = read_nb(nb_path)
    definitions = scan_notebook(nb_path)
    
    changes = {
        'notebook': nb_path.name,
        'definitions_fixed': [],
        'definitions_converted': [],
        'cells_modified': []
    }
    
    # Check each definition
    for defn in definitions:
        result = check_definition(defn)
        
        # Fix if non-compliant OR has missing type hints
        needs_fixing = (not result.is_compliant or 
                       result.missing_params or 
                       result.params_missing_type_hints)
        
        if needs_fixing:
            # Choose the appropriate fix method
            if convert_docstrings:
                fixed_source = generate_fixed_source_with_conversion(result)
                
                # Check if this was a conversion (has structured docstring info)
                docstring_info = extract_docstring_info(result.source, result.name)
                is_conversion = (docstring_info and 
                               docstring_info.docstring_type in ['google', 'numpy', 'sphinx'])
            else:
                fixed_source = generate_fixed_source(result)
                is_conversion = False
            
            # Only proceed if the source actually changed
            if fixed_source != result.source:
                # Find and update the cell
                cell_id = defn['cell_id']
                for cell in nb.cells:
                    if cell.get('id') == cell_id:
                        # Replace the definition in the cell source
                        old_source = result.source
                        cell_source = cell.source
                        
                        # Find the definition in the cell and replace it
                        if old_source in cell_source:
                            new_cell_source = cell_source.replace(old_source, fixed_source)
                            
                            if not dry_run:
                                cell.source = new_cell_source
                            
                            changes['definitions_fixed'].append(result.name)
                            if is_conversion:
                                changes['definitions_converted'].append(result.name)
                            
                            if cell_id not in changes['cells_modified']:
                                changes['cells_modified'].append(cell_id)
                            
                            if dry_run:
                                action = "convert and fix" if is_conversion else "fix"
                                print(f"\nWould {action} {result.name}:")
                                print("-" * 40)
                                print(fixed_source)
                                print("-" * 40)
    
    # Save the notebook if not dry run
    if not dry_run and changes['definitions_fixed']:
        write_nb(nb, nb_path)
        
        # Report results
        fixed_count = len(changes['definitions_fixed'])
        converted_count = len(changes['definitions_converted'])
        
        if converted_count > 0:
            print(f"âœ… Fixed {fixed_count} definitions in {nb_path.name} ({converted_count} converted from other docstring styles)")
        else:
            print(f"âœ… Fixed {fixed_count} definitions in {nb_path.name}")
        
        for defn_name in changes['definitions_fixed']:
            action = "converted & fixed" if defn_name in changes['definitions_converted'] else "fixed"
            print(f"   - {defn_name} ({action})")
    elif dry_run and changes['definitions_fixed']:
        fixed_count = len(changes['definitions_fixed'])
        converted_count = len(changes['definitions_converted'])
        
        if converted_count > 0:
            print(f"\nðŸ” Dry run: Would fix {fixed_count} definitions ({converted_count} converted from other docstring styles)")
        else:
            print(f"\nðŸ” Dry run: Would fix {fixed_count} definitions")
    else:
        print(f"âœ… All definitions in {nb_path.name} are already compliant")
    
    return changes
