"""Core functionality for checking docments compliance"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/core.ipynb.

# %% auto 0
__all__ = ['DocmentsCheckResult', 'extract_param_docs_from_func', 'extract_param_docs', 'check_return_doc', 'count_todos_in_docs',
           'check_has_docstring_from_func', 'check_has_docstring', 'function_has_return_value', 'check_type_hints',
           'check_params_documentation', 'determine_compliance', 'check_definition', 'check_notebook', 'check_function']

# %% ../nbs/core.ipynb 3
from typing import Dict, List, Any, Optional, Tuple, Callable
import re
import ast
import importlib
from dataclasses import dataclass
from fastcore.docments import docments, docstring

# %% ../nbs/core.ipynb 4
@dataclass
class DocmentsCheckResult:    
    "Result of checking a function/class for docments compliance"
    name: str  # Name of the function/class
    type: str  # Type (FunctionDef, ClassDef, etc.)
    notebook: str  # Source notebook
    has_docstring: bool  # Whether it has a docstring
    params_documented: Dict[str, bool]  # Which params have documentation
    return_documented: bool  # Whether return is documented
    missing_params: List[str]  # Parameters missing documentation
    is_compliant: bool  # Overall compliance status
    source: str  # Source code of the definition
    has_todos: bool = False  # Whether it contains TODO placeholders
    todo_count: int = 0  # Number of TODO placeholders found
    params_with_type_hints: Dict[str, bool] = None  # Which params have type hints
    return_has_type_hint: bool = False  # Whether return has type hint
    params_missing_type_hints: List[str] = None  # Parameters missing type hints
    
    def __post_init__(self):
        "TODO: Add function description"
        if self.params_with_type_hints is None:
            self.params_with_type_hints = {}
        if self.params_missing_type_hints is None:
            self.params_missing_type_hints = []

# %% ../nbs/core.ipynb 5
def extract_param_docs_from_func(
    func: Callable    # Function object to extract docs from
) -> Dict[str, str]:  # Mapping of parameter names to their documentation
    "Extract parameter documentation from function object using fastcore.docments"
    try:
        return docments(func)
    except Exception:
        # Fallback to original implementation if fastcore.docments fails
        import inspect
        source = inspect.getsource(func)
        return extract_param_docs(source)

# %% ../nbs/core.ipynb 6
def extract_param_docs(
    source:str    # Function source code
) -> Dict[str, str]:  # Mapping of parameter names to their documentation
    "Extract parameter documentation from function source using docments style (fallback)"
    param_docs = {}
    lines = source.split('\n')
    in_params = False
    
    for i, line in enumerate(lines):
        stripped = line.strip()
        
        # Start looking after def line
        if stripped.startswith(('def ', 'async def ')):
            in_params = True
            continue
            
        # Stop when we hit the docstring
        if in_params and stripped.startswith(('"', "'", '"""', "'''")):
            break
            
        # Skip if not in parameters section
        if not in_params:
            continue
            
        # Match parameter with inline comment
        # Flexible regex that handles complex type annotations like Dict[str, Any]
        param_match = re.match(r'\s*(\w+)(?:[^#]*?)#\s*(.+)', line)
        if param_match:
            param_name = param_match.group(1)
            param_doc = param_match.group(2).strip()
            param_docs[param_name] = param_doc
    
    return param_docs

# %% ../nbs/core.ipynb 7
def check_return_doc(
    source: str  # Function source code
) -> bool:  # Whether return is documented
    "Check if function has return documentation"
    lines = source.split('\n')
    
    for line in lines:
        # Check for return type annotation with comment
        if re.search(r'->\s*[^:]+\s*:\s*#\s*.+', line):
            return True
        # Check for standalone return comment
        if re.match(r'\s*->\s*[^:]+\s*$', line):
            # Check if next line has a comment
            idx = lines.index(line)
            if idx + 1 < len(lines):
                next_line = lines[idx + 1]
                if re.match(r'\s*#\s*.+', next_line):
                    return True
    
    return False

# %% ../nbs/core.ipynb 8
def count_todos_in_docs(
    source: str,  # Function/class source code
    name: str  # Name of the function/class for AST parsing
) -> Tuple[int, bool]:  # (todo_count, has_todos)
    "Count TODO placeholders only in documentation (docstring, param docs, return docs)"
    todo_count = 0
    
    # Count TODOs in parameter comments
    param_docs = extract_param_docs(source)
    for doc in param_docs.values():
        todo_count += doc.count('TODO:')
    
    # Count TODOs in return type comments
    lines = source.split('\n')
    for line in lines:
        # Check for return type comment - must be return annotation followed by comment
        return_comment_match = re.search(r'\)\s*->\s*[^:#]+\s*:\s*#\s*(.*)', line)
        if return_comment_match:
            comment_text = return_comment_match.group(1)
            todo_count += comment_text.count('TODO:')
    
    # Count TODOs in docstring only
    try:
        tree = ast.parse(source)
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
                if node.name == name and node.body:
                    # Check if first statement is a docstring
                    first_stmt = node.body[0]
                    if (isinstance(first_stmt, ast.Expr) and 
                        isinstance(first_stmt.value, (ast.Str, ast.Constant))):
                        if hasattr(first_stmt.value, 's'):
                            docstring = first_stmt.value.s
                        elif hasattr(first_stmt.value, 'value'):
                            docstring = first_stmt.value.value
                        else:
                            docstring = ""
                        
                        if isinstance(docstring, str):
                            todo_count += docstring.count('TODO:')
                    break
    except:
        pass
    
    has_todos = todo_count > 0
    return todo_count, has_todos

# %% ../nbs/core.ipynb 9
def check_has_docstring_from_func(
    func: Callable  # Function object to check
) -> bool:  # Whether the function has a docstring
    "Check if a function has a docstring using fastcore.docments"
    try:
        return docstring(func) is not None
    except Exception:
        # Fallback to AST parsing
        import inspect
        source = inspect.getsource(func)
        return check_has_docstring(source, func.__name__)

# %% ../nbs/core.ipynb 10
def check_has_docstring(
    source: str,  # Function/class source code
    name: str  # Name of the function/class
) -> bool:  # Whether the definition has a docstring
    "Check if a function/class has a docstring using AST parsing (fallback)"
    has_docstring = False
    try:
        tree = ast.parse(source)
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
                if node.name == name:
                    # Check if first statement in body is a string (docstring)
                    if (node.body and 
                        isinstance(node.body[0], ast.Expr) and 
                        isinstance(node.body[0].value, (ast.Str, ast.Constant))):
                        has_docstring = True
                    break
    except:
        # Fallback to simple string detection
        has_docstring = any(line.strip().startswith(('"', "'")) for line in source.split('\n')[1:5])
    
    return has_docstring

# %% ../nbs/core.ipynb 11
def function_has_return_value(
    source: str,  # Function source code
    name: str  # Function name
) -> bool:  # Whether function has explicit return statements with values
    "Check if a function actually returns a value (not just implicit None)"
    try:
        tree = ast.parse(source)
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                if node.name == name:
                    # Walk through the function body looking for return statements
                    for body_node in ast.walk(node):
                        if isinstance(body_node, ast.Return):
                            # Check if return has a value (not just 'return' or 'return None')
                            if body_node.value is not None:
                                # Check if it's not explicitly returning None
                                if isinstance(body_node.value, ast.Constant):
                                    if body_node.value.value is not None:
                                        return True
                                elif isinstance(body_node.value, ast.NameConstant):
                                    if body_node.value.value is not None:
                                        return True
                                else:
                                    # Any other return value (variable, expression, etc.)
                                    return True
                    break
    except:
        pass
    
    return False

# %% ../nbs/core.ipynb 12
def check_type_hints(
    definition: Dict[str, Any],  # Definition dict from scanner
    source: Optional[str] = None  # Function source code (optional)
) -> Tuple[Dict[str, bool], List[str], bool]:  # (params_with_type_hints, missing_type_hints, return_has_type_hint)
    "Check which parameters and return value have type hints"
    params_with_type_hints = {}
    missing_type_hints = []
    return_has_type_hint = False
    
    # Only check for functions
    if definition['type'] in ['FunctionDef', 'AsyncFunctionDef']:
        # Check each parameter for type hints
        for arg in definition.get('args', []):
            param_name = arg['name']
            if param_name != 'self':  # Skip self parameter
                has_type_hint = arg.get('annotation') is not None
                params_with_type_hints[param_name] = has_type_hint
                if not has_type_hint:
                    missing_type_hints.append(param_name)
        
        # Check return type hint, but skip for special methods that conventionally don't need return annotations
        function_name = definition.get('name', '')
        special_methods = ['__init__', '__post_init__', '__enter__', '__exit__', '__del__', '__setattr__', '__delattr__', '__setitem__', '__delitem__']
        
        if function_name not in special_methods:
            return_has_type_hint = definition.get('returns') is not None
            
            # Only flag missing return type hint if function actually returns a value
            if not return_has_type_hint:
                # Check if function actually returns something
                if source and function_has_return_value(source, function_name):
                    missing_type_hints.append('return')
                # If no source provided, use the definition's source if available
                elif not source and 'source' in definition:
                    if function_has_return_value(definition['source'], function_name):
                        missing_type_hints.append('return')
        else:
            # Special methods are considered to have appropriate return type (None)
            return_has_type_hint = True
    
    return params_with_type_hints, missing_type_hints, return_has_type_hint

# %% ../nbs/core.ipynb 13
def check_params_documentation(
    definition: Dict[str, Any],  # Definition dict from scanner
    source: str  # Function source code
) -> Tuple[Dict[str, bool], List[str], bool]:  # (params_documented, missing_params, return_documented)
    "Check parameter and return documentation for a function"
    params_documented = {}
    missing_params = []
    return_documented = True  # Default for classes
    
    # Only check for functions
    if definition['type'] in ['FunctionDef', 'AsyncFunctionDef']:
        # Try to use function object with fastcore.docments first
        func_obj = definition.get('func_obj')
        if func_obj and callable(func_obj):
            try:
                param_docs = extract_param_docs_from_func(func_obj)
            except Exception:
                # Fallback to source parsing
                param_docs = extract_param_docs(source)
        else:
            # Fallback to source parsing
            param_docs = extract_param_docs(source)
        
        # Check each parameter
        for arg in definition.get('args', []):
            param_name = arg['name']
            if param_name != 'self':  # Skip self parameter
                has_doc = param_name in param_docs
                params_documented[param_name] = has_doc
                if not has_doc:
                    missing_params.append(param_name)
        
        # Check return documentation if function has return annotation
        if definition.get('returns'):
            return_documented = check_return_doc(source)
            if not return_documented:
                missing_params.append('return')
    
    return params_documented, missing_params, return_documented

# %% ../nbs/core.ipynb 14
def determine_compliance(
    has_docstring: bool,  # Whether definition has a docstring
    params_documented: Dict[str, bool],  # Which params have documentation
    return_documented: bool  # Whether return is documented
) -> bool:  # Overall compliance status
    "Determine if a definition is compliant based on documentation checks"
    return (
        has_docstring and 
        all(params_documented.values()) and 
        return_documented
    )

# %% ../nbs/core.ipynb 15
def check_definition(
    definition: Dict[str, Any]  # Definition dict from scanner
) -> DocmentsCheckResult:  # Check result with compliance details
    "Check a function/class definition for docments compliance"
    name = definition['name']
    def_type = definition['type']
    source = definition['source']
    notebook = definition.get('notebook', 'unknown')
    func_obj = definition.get('func_obj')
    
    # Check for TODO placeholders only in documentation
    todo_count, has_todos = count_todos_in_docs(source, name)
    
    # Check for docstring - use function object if available
    if func_obj and callable(func_obj):
        try:
            has_docstring = check_has_docstring_from_func(func_obj)
        except Exception:
            has_docstring = check_has_docstring(source, name)
    else:
        has_docstring = check_has_docstring(source, name)
    
    # Check parameter and return documentation
    params_documented, missing_params, return_documented = check_params_documentation(definition, source)
    
    # Check type hints - pass the source code for return value detection
    params_with_type_hints, missing_type_hints, return_has_type_hint = check_type_hints(definition, source)
    
    # Determine overall compliance
    is_compliant = determine_compliance(has_docstring, params_documented, return_documented)
    
    return DocmentsCheckResult(
        name=name,
        type=def_type,
        notebook=notebook,
        has_docstring=has_docstring,
        params_documented=params_documented,
        return_documented=return_documented,
        missing_params=missing_params,
        is_compliant=is_compliant,
        source=source,
        has_todos=has_todos,
        todo_count=todo_count,
        params_with_type_hints=params_with_type_hints,
        return_has_type_hint=return_has_type_hint,
        params_missing_type_hints=missing_type_hints
    )

# %% ../nbs/core.ipynb 16
def check_notebook(
    nb_path: str  # Path to notebook file  
) -> None:  # Prints compliance report
    "Check a specific notebook for docments compliance"
    from pathlib import Path
    from cjm_nbdev_docments.scanner import scan_notebook
    from cjm_nbdev_docments.report import generate_text_report
    
    nb_path = Path(nb_path)
    # If it's a relative path, resolve it to an absolute path
    if not nb_path.is_absolute():
        nb_path = nb_path.resolve()
    
    definitions = scan_notebook(nb_path)
    results = [check_definition(defn) for defn in definitions]
    
    print(f"Checking {nb_path.name}:")
    print(generate_text_report(results, verbose=True))

# %% ../nbs/core.ipynb 17
def check_function(
    func:Callable          # Function object to check
) -> DocmentsCheckResult:  # Check result for the function
    "Check a single function for docments compliance"
    import inspect
    
    # Get function source
    source = inspect.getsource(func)
    
    # Create a definition dict compatible with check_definition
    definition = {
        'name': func.__name__,
        'type': 'FunctionDef',
        'source': source,
        'notebook': 'runtime',
        'args': []
    }
    
    # Extract arguments
    sig = inspect.signature(func)
    for param_name, param in sig.parameters.items():
        if param_name != 'self':
            definition['args'].append({
                'name': param_name,
                'annotation': str(param.annotation) if param.annotation != param.empty else None
            })
    
    # Check for return annotation
    if sig.return_annotation != sig.empty:
        definition['returns'] = str(sig.return_annotation)
    
    result = check_definition(definition)
    
    # Print a simple report
    if result.is_compliant:
        print(f"✅ {result.name} is compliant")
    else:
        print(f"❌ {result.name} is not compliant")
        if not result.has_docstring:
            print("   - Missing docstring")
        if result.missing_params:
            print(f"   - Missing docs for: {', '.join(result.missing_params)}")
        if result.params_missing_type_hints:
            missing_type_hints = [p for p in result.params_missing_type_hints if p != 'return']
            if missing_type_hints:
                print(f"   - Missing type hints for: {', '.join(missing_type_hints)}")
            if 'return' in result.params_missing_type_hints:
                print("   - Missing return type hint")
    
    return result
