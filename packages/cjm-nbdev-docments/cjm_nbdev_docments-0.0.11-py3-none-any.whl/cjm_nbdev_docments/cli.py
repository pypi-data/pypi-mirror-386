"""Command-line interface for docments compliance checking"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/cli.ipynb.

# %% auto 0
__all__ = ['create_parser', 'handle_autofix', 'generate_report', 'output_report', 'main']

# %% ../nbs/cli.ipynb 3
import argparse
import sys
import json
from pathlib import Path
from typing import Optional
from .report import check_project, generate_text_report, generate_json_report
from nbdev.config import get_config

# %% ../nbs/cli.ipynb 4
def create_parser(
) -> argparse.ArgumentParser:  # Configured argument parser
    "Create and configure the argument parser for docments CLI"
    parser = argparse.ArgumentParser(
        description="Check nbdev project for docments compliance",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Check current project
  nbdev-docments
  
  # Check specific notebooks directory
  nbdev-docments --nbs-path ./notebooks
  
  # Generate JSON report
  nbdev-docments --format json
  
  # Save report to file
  nbdev-docments --output report.txt
  
  # Show all definitions (including compliant ones)
  nbdev-docments --verbose
  
  # Show only functions with TODO placeholders
  nbdev-docments --todos-only
  
  # Auto-fix non-compliant functions
  nbdev-docments --fix
  
  # Auto-fix with docstring conversion
  nbdev-docments --fix --convert-docstrings
  
  # Preview fixes without applying
  nbdev-docments --fix --dry-run
"""
    )
    
    parser.add_argument(
        "--nbs-path",
        type=Path,
        help="Path to notebooks directory (defaults to nbdev config)"
    )
    
    parser.add_argument(
        "--format",
        choices=["text", "json"],
        default="text",
        help="Output format (default: text)"
    )
    
    parser.add_argument(
        "--output", "-o",
        type=Path,
        help="Save report to file instead of printing"
    )
    
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Show compliant definitions in text report"
    )
    
    parser.add_argument(
        "--quiet", "-q",
        action="store_true",
        help="Only show summary (exit code indicates compliance)"
    )
    
    parser.add_argument(
        "--todos-only",
        action="store_true",
        help="Show only functions with TODO placeholders"
    )
    
    parser.add_argument(
        "--fix",
        action="store_true",
        help="Auto-fix non-compliant functions by adding placeholder docs"
    )
    
    parser.add_argument(
        "--convert-docstrings",
        action="store_true",
        help="Convert existing Google/NumPy/Sphinx docstrings to docments format (use with --fix)"
    )
    
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be fixed without making changes"
    )
    
    return parser

# %% ../nbs/cli.ipynb 5
def handle_autofix(
    args: argparse.Namespace  # Parsed command line arguments
) -> int:  # Exit code
    "Handle auto-fix mode for non-compliant functions"
    from cjm_nbdev_docments.autofix import fix_notebook, fix_notebook_with_conversion
    
    if args.nbs_path:
        nbs_path = args.nbs_path
    else:
        cfg = get_config()
        nbs_path = Path(cfg.config_path) / cfg.nbs_path
    
    # Choose the appropriate fix function based on whether conversion is requested
    if args.convert_docstrings:
        fix_function = lambda nb_path, dry_run: fix_notebook_with_conversion(
            nb_path, dry_run=dry_run, convert_docstrings=True
        )
    else:
        fix_function = fix_notebook
    
    # Fix all notebooks (including in subdirectories)
    total_fixed = 0
    for nb_path in nbs_path.rglob("*.ipynb"):
        # Skip private notebooks and those in .ipynb_checkpoints
        if not nb_path.name.startswith('_') and '.ipynb_checkpoints' not in str(nb_path):
            try:
                changes = fix_function(nb_path, args.dry_run)
                total_fixed += len(changes['definitions_fixed'])
            except Exception as e:
                print(f"Error fixing {nb_path}: {e}", file=sys.stderr)
    
    return 0 if not args.dry_run else (1 if total_fixed > 0 else 0)

# %% ../nbs/cli.ipynb 6
def generate_report(
    results: list,  # Check results from check_project
    format: str,  # Output format ("text" or "json")
    verbose: bool = False  # Whether to show compliant definitions
) -> str:  # Generated report as string
    "Generate a report in the specified format"
    if format == "json":
        return json.dumps(generate_json_report(results), indent=2)
    else:
        return generate_text_report(results, verbose=verbose)

# %% ../nbs/cli.ipynb 7
def output_report(
    report: str,  # Report content to output
    output_path: Optional[Path] = None,  # File path to save report to
    quiet: bool = False  # Whether to suppress output
) -> None:
    "Output the report to console or file"
    if not quiet:
        if output_path:
            output_path.write_text(report)
            print(f"Report saved to {output_path}")
        else:
            print(report)

# %% ../nbs/cli.ipynb 8
def main(
    args: Optional[list] = None  # Command line arguments (for testing)
) -> int:  # Exit code (0 for success, 1 for non-compliance)
    "Main CLI entry point for docments checker"
    parser = create_parser()
    parsed_args = parser.parse_args(args)
    
    # Handle auto-fix mode
    if parsed_args.fix:
        return handle_autofix(parsed_args)
    
    # Normal check mode
    try:
        results = check_project(parsed_args.nbs_path)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1
    
    # Filter for TODOs only if requested
    if parsed_args.todos_only:
        results = [r for r in results if r.has_todos]
        if not results:
            print("âœ… No functions with TODO placeholders found!")
            return 0
    
    # Generate and output report
    report = generate_report(results, parsed_args.format, parsed_args.verbose)
    output_report(report, parsed_args.output, parsed_args.quiet)
    
    # Return exit code based on compliance
    non_compliant = sum(1 for r in results if not r.is_compliant)
    return 0 if non_compliant == 0 else 1
