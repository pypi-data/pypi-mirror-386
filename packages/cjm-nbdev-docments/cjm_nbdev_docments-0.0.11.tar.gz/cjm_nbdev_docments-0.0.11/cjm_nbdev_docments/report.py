"""Generate compliance reports for docments validation"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/report.ipynb.

# %% auto 0
__all__ = ['check_project', 'generate_text_report', 'generate_json_report']

# %% ../nbs/report.ipynb 3
from typing import List, Dict, Any, Optional
from pathlib import Path
import json
from .core import DocmentsCheckResult, check_definition
from .scanner import scan_project, scan_notebook
from collections import defaultdict

# %% ../nbs/report.ipynb 4
def check_project(
    nbs_path: Optional[Path] = None  # Path to notebooks directory
) -> List[DocmentsCheckResult]:  # List of check results for all definitions
    "Check all exported definitions in a project for docments compliance"
    definitions = scan_project(nbs_path)
    results = []
    
    for defn in definitions:
        result = check_definition(defn)
        results.append(result)
    
    return results

# %% ../nbs/report.ipynb 5
def _generate_summary_stats(
    results: List[DocmentsCheckResult]  # Check results to summarize
) -> List[str]:  # Lines of summary statistics
    "Generate summary statistics section of the report"
    compliant = [r for r in results if r.is_compliant]
    non_compliant = [r for r in results if not r.is_compliant]
    with_todos = [r for r in results if r.has_todos]
    
    lines = []
    lines.append("📚 Docments Compliance Report")
    lines.append("=" * 50)
    lines.append(f"Total definitions: {len(results)}")
    lines.append(f"✅ Compliant: {len(compliant)}")
    lines.append(f"❌ Non-compliant: {len(non_compliant)}")
    if with_todos:
        lines.append(f"⚠️  With TODO placeholders: {len(with_todos)}")
    lines.append("")
    
    return lines

# %% ../nbs/report.ipynb 6
def _generate_non_compliant_section(
    results: List[DocmentsCheckResult],  # Check results
    by_notebook: Dict[str, List[DocmentsCheckResult]]  # Results grouped by notebook
) -> List[str]:  # Lines of non-compliant section
    "Generate non-compliant definitions section of the report"
    non_compliant = [r for r in results if not r.is_compliant]
    lines = []
    
    if non_compliant:
        lines.append("❌ Non-compliant definitions:")
        lines.append("-" * 30)
        
        for nb in sorted(by_notebook.keys()):
            nb_results = by_notebook[nb]
            nb_non_compliant = [r for r in nb_results if not r.is_compliant]
            
            if nb_non_compliant:
                lines.append(f"\n📓 {nb}:")
                for r in nb_non_compliant:
                    lines.append(f"  ❌ {r.name}")
                    if not r.has_docstring:
                        lines.append("     - Missing docstring")
                    if r.missing_params:
                        lines.append(f"     - Missing docs for: {', '.join(r.missing_params)}")
                    if r.params_missing_type_hints:
                        missing_type_hints = [p for p in r.params_missing_type_hints if p != 'return']
                        if missing_type_hints:
                            lines.append(f"     - Missing type hints for: {', '.join(missing_type_hints)}")
                        if 'return' in r.params_missing_type_hints:
                            lines.append("     - Missing return type hint")
    
    return lines

# %% ../nbs/report.ipynb 7
def _generate_todos_section(
    results: List[DocmentsCheckResult],  # Check results
    by_notebook: Dict[str, List[DocmentsCheckResult]]  # Results grouped by notebook
) -> List[str]:  # Lines of TODOs section
    "Generate TODO placeholders section of the report"
    with_todos = [r for r in results if r.has_todos]
    lines = []
    
    if with_todos:
        lines.append("\n⚠️  Definitions with TODO placeholders:")
        lines.append("-" * 30)
        
        for nb in sorted(by_notebook.keys()):
            nb_results = by_notebook[nb]
            nb_todos = [r for r in nb_results if r.has_todos]
            
            if nb_todos:
                lines.append(f"\n📓 {nb}:")
                for r in nb_todos:
                    lines.append(f"  ⚠️  {r.name} ({r.todo_count} TODOs)")
    
    return lines

# %% ../nbs/report.ipynb 8
def _generate_compliant_section(
    results: List[DocmentsCheckResult],  # Check results
    by_notebook: Dict[str, List[DocmentsCheckResult]]  # Results grouped by notebook
) -> List[str]:  # Lines of compliant section
    "Generate compliant definitions section of the report"
    compliant = [r for r in results if r.is_compliant]
    lines = []
    
    if compliant:
        lines.append("\n✅ Compliant definitions:")
        lines.append("-" * 30)
        for nb in sorted(by_notebook.keys()):
            nb_results = by_notebook[nb]
            nb_compliant = [r for r in nb_results if r.is_compliant and not r.has_todos]
            
            if nb_compliant:
                lines.append(f"\n📓 {nb}:")
                for r in nb_compliant:
                    lines.append(f"  ✅ {r.name}")
    
    return lines

# %% ../nbs/report.ipynb 9
def generate_text_report(
    results: List[DocmentsCheckResult],  # Check results from check_project
    verbose: bool = False  # Include detailed information
) -> str:  # Formatted text report
    "Generate a human-readable text report of compliance results"
    # Group by notebook
    by_notebook = defaultdict(list)
    for r in results:
        by_notebook[r.notebook].append(r)
    
    lines = []
    
    # Add summary statistics
    lines.extend(_generate_summary_stats(results))
    
    # Add non-compliant section
    lines.extend(_generate_non_compliant_section(results, by_notebook))
    
    # Add TODOs section
    lines.extend(_generate_todos_section(results, by_notebook))
    
    # Add compliant section (if verbose)
    if verbose:
        lines.extend(_generate_compliant_section(results, by_notebook))
    
    return "\n".join(lines)

# %% ../nbs/report.ipynb 10
def generate_json_report(
    results: List[DocmentsCheckResult]  # Check results from check_project
) -> Dict[str, Any]:  # JSON-serializable report data
    "Generate a JSON report of compliance results"
    report = {
        "summary": {
            "total": len(results),
            "compliant": len([r for r in results if r.is_compliant]),
            "non_compliant": len([r for r in results if not r.is_compliant]),
            "with_todos": len([r for r in results if r.has_todos]),
            "total_todos": sum(r.todo_count for r in results)
        },
        "by_notebook": defaultdict(lambda: {"compliant": [], "non_compliant": [], "with_todos": []})
    }
    
    for r in results:
        entry = {
            "name": r.name,
            "type": r.type,
            "has_docstring": r.has_docstring,
            "missing_params": r.missing_params,
            "params_documented": r.params_documented,
            "return_documented": r.return_documented,
            "has_todos": r.has_todos,
            "todo_count": r.todo_count,
            "params_with_type_hints": r.params_with_type_hints,
            "return_has_type_hint": r.return_has_type_hint,
            "params_missing_type_hints": r.params_missing_type_hints
        }
        
        if r.is_compliant:
            report["by_notebook"][r.notebook]["compliant"].append(entry)
        else:
            report["by_notebook"][r.notebook]["non_compliant"].append(entry)
            
        if r.has_todos:
            report["by_notebook"][r.notebook]["with_todos"].append(entry)
    
    # Convert defaultdict to regular dict for JSON serialization
    report["by_notebook"] = dict(report["by_notebook"])
    
    return report
