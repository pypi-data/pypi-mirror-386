"""
Cross viscosity model for rheological analysis.

This module implements the Cross model for shear-thinning fluids with
zero-shear and infinite-shear plateaus using Bayesian inference.
"""

from typing import Any

import jax.numpy as jnp
import numpy as np
import numpyro
import numpyro.distributions as dist

from quantiq.backend.operations import jit
from quantiq.bayesian.base import BayesianModel


class CrossModel(BayesianModel):
    """
    Cross viscosity model for shear-thinning fluids.

    The Cross model describes the transition from zero-shear viscosity to
    infinite-shear viscosity:

        η(γ̇) = η∞ + (η₀ - η∞) / (1 + (λγ̇)^m)

    where:
        - η is the viscosity (Pa·s)
        - γ̇ is the shear rate (s⁻¹)
        - η₀ is the zero-shear viscosity (Pa·s)
        - η∞ is the infinite-shear viscosity (Pa·s)
        - λ is the time constant (s)
        - m is the power-law exponent (dimensionless)

    At low shear rates (when λγ̇ << 1): η → η₀ (zero-shear plateau)
    At high shear rates (when λγ̇ >> 1): η → η∞ (infinite-shear plateau)

    Parameters
    ----------
    n_samples : int, optional
        Number of MCMC samples to draw (default: 1000)
    n_warmup : int, optional
        Number of warmup samples for MCMC (default: 500)
    n_chains : int, optional
        Number of MCMC chains to run (default: 2)
    random_seed : int, optional
        Random seed for reproducibility (default: 0)

    Attributes
    ----------
    samples : dict[str, array] | None
        Posterior samples from MCMC containing:
        - 'eta0': Zero-shear viscosity samples
        - 'eta_inf': Infinite-shear viscosity samples
        - ``'lambda_'``: Time constant samples
        - 'm': Power-law exponent samples
        - 'sigma': Observation noise samples

    Examples
    --------
    >>> import numpy as np
    >>> from quantiq.bayesian.models import CrossModel
    >>>
    >>> # Shear-thinning data with plateaus
    >>> shear_rate = np.logspace(-2, 3, 50)  # 0.01 to 1000 s^-1
    >>> # Simulate Cross model: eta0=100, eta_inf=1, lambda_=1, m=0.7
    >>> viscosity = 1 + (100 - 1) / (1 + (1.0 * shear_rate)**0.7)
    >>>
    >>> # Fit Cross model
    >>> model = CrossModel(n_samples=1000, n_warmup=500)
    >>> model.fit(shear_rate, viscosity)
    >>>
    >>> # Get parameter estimates
    >>> summary = model.summary()
    >>> print(f"Zero-shear viscosity: {summary['eta0']['mean']:.1f} Pa·s")
    >>> print(f"Infinite-shear viscosity: {summary['eta_inf']['mean']:.2f} Pa·s")
    >>>
    >>> # Predict with uncertainty
    >>> shear_rate_new = np.array([0.1, 1.0, 10.0, 100.0])
    >>> predictions = model.predict(shear_rate_new)

    Notes
    -----
    The model uses the following priors:
        - eta0 ~ LogNormal(4, 2): Zero-shear viscosity (centered around e^4 ≈ 55)
        - eta_inf ~ LogNormal(0, 2): Infinite-shear viscosity (centered around 1)
        - ``lambda_`` ~ LogNormal(0, 2): Time constant (centered around 1)
        - m ~ Normal(0.7, 0.3): Power-law exponent (typical range 0.3-1.0)
        - sigma ~ HalfNormal(scale): Observation noise

    The Cross model advantages:
        - Captures both low and high shear rate plateaus
        - More physically realistic than simple power-law
        - Four parameters provide flexibility

    The model assumes:
        - Single relaxation time
        - No yield stress
        - Monotonic shear-thinning behavior

    References
    ----------
    .. [1] Cross, M. M. (1965). "Rheology of non-Newtonian fluids: A new flow
           equation for pseudoplastic systems." Journal of Colloid Science,
           20(5), 417-437.
    .. [2] Morrison, F. A. (2001). "Understanding Rheology." Oxford University Press.
    """

    def model(self, x: Any, y: Any = None, **kwargs: Any) -> None:
        """
        Define the NumPyro probabilistic model for Cross viscosity.

        Parameters
        ----------
        x : array_like
            Shear rate data (γ̇) in s⁻¹
        y : array_like | None, optional
            Viscosity observations (η) in Pa·s. If None, generates prior samples.
        **kwargs : dict
            Additional model parameters (unused)

        Notes
        -----
        This method is called internally by fit() and should not be called directly.
        """
        # Convert to JAX arrays
        x = jnp.asarray(x)
        if y is not None:
            y = jnp.asarray(y)

        # Priors
        # eta0: Zero-shear viscosity (should be > eta_inf)
        eta0 = numpyro.sample("eta0", dist.LogNormal(4.0, 2.0))

        # eta_inf: Infinite-shear viscosity (typically much smaller than eta0)
        eta_inf = numpyro.sample("eta_inf", dist.LogNormal(0.0, 2.0))

        # lambda_: Time constant (relaxation time)
        lambda_ = numpyro.sample("lambda_", dist.LogNormal(0.0, 2.0))

        # m: Power-law exponent (typically 0.3 to 1.0)
        m = numpyro.sample("m", dist.Normal(0.7, 0.3))

        # sigma: Observation noise
        if y is not None:
            sigma_scale = jnp.maximum(jnp.std(y) * 0.1, 0.01)
        else:
            sigma_scale = jnp.array(1.0)
        sigma = numpyro.sample("sigma", dist.HalfNormal(sigma_scale))

        # Model: η(γ̇) = η∞ + (η₀ - η∞) / (1 + (λγ̇)^m)
        eta_pred = eta_inf + (eta0 - eta_inf) / (1 + (lambda_ * x) ** m)

        # Likelihood
        with numpyro.plate("data", x.shape[0]):
            numpyro.sample("obs", dist.Normal(eta_pred, sigma), obs=y)

    @staticmethod
    @jit
    def _compute_predictions(eta0_samples, eta_inf_samples, lambda_samples, m_samples, shear_rate):  # type: ignore[no-untyped-def]
        """
        JIT-compiled prediction computation for 5-10x speedup.

        Parameters
        ----------
        eta0_samples : array
            Posterior samples for zero-shear viscosity η₀
        eta_inf_samples : array
            Posterior samples for infinite-shear viscosity η∞
        lambda_samples : array
            Posterior samples for time constant λ
        m_samples : array
            Posterior samples for power-law exponent m
        shear_rate : array
            Shear rate values to predict at

        Returns
        -------
        array
            Predicted viscosity samples (n_samples × n_points)

        Notes
        -----
        This function is JIT-compiled with JAX for optimal performance.
        First call will be slower due to compilation, but subsequent calls
        will be 5-10x faster on CPU and up to 100x faster on GPU.

        Model: η(γ̇) = η∞ + (η₀ - η∞) / (1 + (λγ̇)^m)
        """
        return eta_inf_samples[:, None] + (eta0_samples[:, None] - eta_inf_samples[:, None]) / (
            1 + (lambda_samples[:, None] * shear_rate[None, :]) ** m_samples[:, None]
        )

    def predict(self, shear_rate: Any, credible_interval: float = 0.95) -> dict[str, np.ndarray]:
        """
        Predict viscosity with uncertainty at given shear rates.

        Uses posterior samples from MCMC to generate predictions with
        credible intervals.

        Parameters
        ----------
        shear_rate : array_like
            Shear rate values (γ̇) in s⁻¹ at which to predict viscosity
        credible_interval : float, optional
            Credible interval level between 0 and 1 (default: 0.95)

        Returns
        -------
        dict
            Dictionary containing:
            - 'mean': Mean predicted viscosity (array)
            - 'lower': Lower credible bound (array)
            - 'upper': Upper credible bound (array)
            - 'samples': Full posterior predictive samples (2D array)

        Raises
        ------
        RuntimeError
            If model has not been fit yet

        Examples
        --------
        >>> model = CrossModel()
        >>> model.fit(shear_rate_data, viscosity_data)
        >>> predictions = model.predict(np.array([0.01, 0.1, 1.0, 10.0]))
        >>> print(predictions['mean'])
        [98.5 85.3 45.2 12.1]
        """
        if self._samples is None:
            raise RuntimeError("Model must be fit before prediction")

        # Convert to JAX arrays for JIT compilation
        shear_rate = jnp.asarray(shear_rate)
        eta0_samples = jnp.asarray(self._samples["eta0"])
        eta_inf_samples = jnp.asarray(self._samples["eta_inf"])
        lambda_samples = jnp.asarray(self._samples["lambda_"])
        m_samples = jnp.asarray(self._samples["m"])

        # Use JIT-compiled prediction: 5-10x faster on CPU, up to 100x on GPU
        eta_samples = self._compute_predictions(
            eta0_samples, eta_inf_samples, lambda_samples, m_samples, shear_rate
        )

        # Compute statistics
        mean = jnp.mean(eta_samples, axis=0)
        alpha = 1 - credible_interval
        lower = jnp.percentile(eta_samples, 100 * alpha / 2, axis=0)
        upper = jnp.percentile(eta_samples, 100 * (1 - alpha / 2), axis=0)

        return {
            "mean": np.array(mean),
            "lower": np.array(lower),
            "upper": np.array(upper),
            "samples": np.array(eta_samples),
        }
