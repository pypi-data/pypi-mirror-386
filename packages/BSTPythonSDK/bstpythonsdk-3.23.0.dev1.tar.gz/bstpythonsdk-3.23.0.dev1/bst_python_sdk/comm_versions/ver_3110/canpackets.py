#*=+--+=#=+--         SwiftCore Flight Management Software        --+=#=+--+=#*#
#               Copyright (C) 2020 Black Swift Technologies LLC.               #
#                             All Rights Reserved.                             #
#                                                                              #
#    NOTICE:  All information contained herein is, and remains the property    #
#    of Black Swift Technologies.                                              #
#                                                                              #
#    The intellectual and technical concepts contained herein are              #
#    proprietary to Black Swift Technologies LLC and may be covered by U.S.    #
#    and foreign patents, patents in process, and are protected by trade       #
#    secret or copyright law.                                                  #
#                                                                              #
#    Dissemination of this information or reproduction of this material is     #
#    strictly forbidden unless prior written permission is obtained from       #
#    Black Swift Technologies LLC.                                             #
#                                                                              #
#*=+--+=#=+--                 --+=#=+--+=#=+--                    --+=#=+--+=#*#

from enum import Enum
import struct
import sys

from .comm_packets import *

#                      THIS FILE IS AUTOGENERATED BY                           #
#                                 msg-gen.py                                   #
#                                DO NOT EDIT                                   #

#---------[ Actuators ]---------#

CAN_NUM_ACTUATORS = 16

#---------[ Comms ]---------#

class CAN_PacketTypes (Enum):
	# SENSORS

	CAN_PKT_PRESSURE=16
	CAN_PKT_IMU=32
	CAN_PKT_ACCEL=33
	CAN_PKT_GYRO=34
	CAN_PKT_MAG=35
	CAN_PKT_GNSS=48
	CAN_PKT_GNSS_UTC=49
	CAN_PKT_GNSS_LLA=50
	CAN_PKT_GNSS_VEL=51
	CAN_PKT_GNSS_HEALTH=52
	CAN_PKT_AGL=96
	CAN_PKT_PROXIMITY=112

	# STATE


	# CONTROL


	# ACTUATORS

	CAN_PKT_ACTUATOR=2047

	# INPUT

	CAN_PKT_RECEIVER=1

	# SYSTEM

	CAN_PKT_SUPPLY=64

	# TELEMETRY


	# HWIL


	# FLIGHT PLAN


	# VEHICLE CONFIGURATION


	# MISSION


	# PAYLOAD

	CAN_PKT_NDVI=80
	CAN_PKT_NDVI_DOWN=81
	CAN_PKT_NDVI_UP=82

	# ERRORS

#---------[ PAYLOAD ]---------#

class CAN_NDVI:
	PACKET_TYPES = ['CAN_PKT_NDVI']
	SIZE = 20

	def __init__ (self, startByte = 0, id = 0, red = 0.0, near_ir = 0.0,
	ir_ambient = 0.0, ir_object = 0.0, chk = 0):
		self.startByte = startByte
		self.id = id
		self.red = red
		self.near_ir = near_ir
		self.ir_ambient = ir_ambient
		self.ir_object = ir_object
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_NDVI]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.id = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.red = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.near_ir = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.ir_ambient = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.ir_object = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<B', self.id))
		buf.extend(struct.pack('<f', self.red))
		buf.extend(struct.pack('<f', self.near_ir))
		buf.extend(struct.pack('<f', self.ir_ambient))
		buf.extend(struct.pack('<f', self.ir_object))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

#---------[ SENSORS ]---------#

class CAN_AGL:
	PACKET_TYPES = ['CAN_PKT_AGL:']
	SIZE = 15

	def __init__ (self, startByte = 0, timestamp = 0.0, distance = 0.0,
	velocity = 0.0, chk = 0):
		self.startByte = startByte
		self.timestamp = timestamp
		self.distance = distance
		self.velocity = velocity
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_AGL]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.timestamp = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.distance = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.velocity = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<f', self.timestamp))
		buf.extend(struct.pack('<f', self.distance))
		buf.extend(struct.pack('<f', self.velocity))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

class CAN_Accelerometer:
	PACKET_TYPES = ['CAN_PKT_ACCEL']
	SIZE = 19

	def __init__ (self, startByte = 0, ax = 0.0, ay = 0.0, az = 0.0,
	temp = 0.0, chk = 0):
		self.startByte = startByte
		self.ax = ax
		self.ay = ay
		self.az = az
		self.temp = temp
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_Accelerometer]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.ax = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.ay = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.az = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.temp = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<f', self.ax))
		buf.extend(struct.pack('<f', self.ay))
		buf.extend(struct.pack('<f', self.az))
		buf.extend(struct.pack('<f', self.temp))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

class CAN_GNSS:
	PACKET_TYPES = ['CAN_PKT_GNSS']
	SIZE = 54

	def __init__ (self, startByte = 0, hours = 0, minutes = 0, seconds = 0.0,
	latitude = 0.0, longitude = 0.0, altitude = 0.0, heading = 0.0, speed = 0.0,
	pdop = 0.0, satellites = 0, vx = 0.0, vy = 0.0, vz = 0.0, chk = 0):
		self.startByte = startByte
		self.hours = hours
		self.minutes = minutes
		self.seconds = seconds
		self.latitude = latitude
		self.longitude = longitude
		self.altitude = altitude
		self.heading = heading
		self.speed = speed
		self.pdop = pdop
		self.satellites = satellites
		self.vx = vx
		self.vy = vy
		self.vz = vz
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_GNSS]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.hours = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.minutes = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.seconds = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.latitude = struct.unpack_from('<d',buf,offset)[0]
		offset = offset + struct.calcsize('<d')

		self.longitude = struct.unpack_from('<d',buf,offset)[0]
		offset = offset + struct.calcsize('<d')

		self.altitude = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.heading = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.speed = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.pdop = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.satellites = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.vx = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.vy = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.vz = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<B', self.hours))
		buf.extend(struct.pack('<B', self.minutes))
		buf.extend(struct.pack('<f', self.seconds))
		buf.extend(struct.pack('<d', self.latitude))
		buf.extend(struct.pack('<d', self.longitude))
		buf.extend(struct.pack('<f', self.altitude))
		buf.extend(struct.pack('<f', self.heading))
		buf.extend(struct.pack('<f', self.speed))
		buf.extend(struct.pack('<f', self.pdop))
		buf.extend(struct.pack('<B', self.satellites))
		buf.extend(struct.pack('<f', self.vx))
		buf.extend(struct.pack('<f', self.vy))
		buf.extend(struct.pack('<f', self.vz))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

class CAN_GNSS_HEALTH:
	PACKET_TYPES = ['CAN_PKT_GNSS']
	SIZE = 8

	def __init__ (self, startByte = 0, pdop = 0.0, satellites = 0, chk = 0):
		self.startByte = startByte
		self.pdop = pdop
		self.satellites = satellites
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_GNSS_HEALTH]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.pdop = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.satellites = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<f', self.pdop))
		buf.extend(struct.pack('<B', self.satellites))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

class CAN_GNSS_VEL:
	PACKET_TYPES = ['CAN_PKT_GNSS']
	SIZE = 23

	def __init__ (self, startByte = 0, heading = 0.0, speed = 0.0, vx = 0.0,
	vy = 0.0, vz = 0.0, chk = 0):
		self.startByte = startByte
		self.heading = heading
		self.speed = speed
		self.vx = vx
		self.vy = vy
		self.vz = vz
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_GNSS_VEL]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.heading = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.speed = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.vx = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.vy = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.vz = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<f', self.heading))
		buf.extend(struct.pack('<f', self.speed))
		buf.extend(struct.pack('<f', self.vx))
		buf.extend(struct.pack('<f', self.vy))
		buf.extend(struct.pack('<f', self.vz))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

class CAN_Gyroscope:
	PACKET_TYPES = ['CAN_PKT_GYRO']
	SIZE = 19

	def __init__ (self, startByte = 0, gx = 0.0, gy = 0.0, gz = 0.0,
	temp = 0.0, chk = 0):
		self.startByte = startByte
		self.gx = gx
		self.gy = gy
		self.gz = gz
		self.temp = temp
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_Gyroscope]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.gx = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.gy = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.gz = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.temp = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<f', self.gx))
		buf.extend(struct.pack('<f', self.gy))
		buf.extend(struct.pack('<f', self.gz))
		buf.extend(struct.pack('<f', self.temp))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

class CAN_IMU:
	PACKET_TYPES = ['CAN_PKT_IMU']
	SIZE = 43

	def __init__ (self, startByte = 0, ax = 0.0, ay = 0.0, az = 0.0, gx = 0.0,
	gy = 0.0, gz = 0.0, mx = 0.0, my = 0.0, mz = 0.0, temp = 0.0, chk = 0):
		self.startByte = startByte
		self.ax = ax
		self.ay = ay
		self.az = az
		self.gx = gx
		self.gy = gy
		self.gz = gz
		self.mx = mx
		self.my = my
		self.mz = mz
		self.temp = temp
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_IMU]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.ax = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.ay = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.az = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.gx = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.gy = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.gz = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.mx = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.my = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.mz = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.temp = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<f', self.ax))
		buf.extend(struct.pack('<f', self.ay))
		buf.extend(struct.pack('<f', self.az))
		buf.extend(struct.pack('<f', self.gx))
		buf.extend(struct.pack('<f', self.gy))
		buf.extend(struct.pack('<f', self.gz))
		buf.extend(struct.pack('<f', self.mx))
		buf.extend(struct.pack('<f', self.my))
		buf.extend(struct.pack('<f', self.mz))
		buf.extend(struct.pack('<f', self.temp))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

class CAN_Magnetometer:
	PACKET_TYPES = ['CAN_PKT_MAG']
	SIZE = 15

	def __init__ (self, startByte = 0, mx = 0.0, my = 0.0, mz = 0.0,
	chk = 0):
		self.startByte = startByte
		self.mx = mx
		self.my = my
		self.mz = mz
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_Magnetometer]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.mx = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.my = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.mz = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<f', self.mx))
		buf.extend(struct.pack('<f', self.my))
		buf.extend(struct.pack('<f', self.mz))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

class CAN_Pressure:
	PACKET_TYPES = ['CAN_PKT_PRESSURE']
	SIZE = 15

	def __init__ (self, startByte = 0, pressureSta = 0.0, pressureDyn = 0.0,
	temp = 0.0, chk = 0):
		self.startByte = startByte
		self.pressureSta = pressureSta
		self.pressureDyn = pressureDyn
		self.temp = temp
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_Pressure]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.pressureSta = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.pressureDyn = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.temp = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<f', self.pressureSta))
		buf.extend(struct.pack('<f', self.pressureDyn))
		buf.extend(struct.pack('<f', self.temp))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

class CAN_Proximity:
	PACKET_TYPES = ['CAN_PKT_PROXIMITY:']
	SIZE = 15

	def __init__ (self, startByte = 0, timestamp = 0.0, distance = 0.0,
	velocity = 0.0, chk = 0):
		self.startByte = startByte
		self.timestamp = timestamp
		self.distance = distance
		self.velocity = velocity
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_Proximity]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.timestamp = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.distance = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.velocity = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<f', self.timestamp))
		buf.extend(struct.pack('<f', self.distance))
		buf.extend(struct.pack('<f', self.velocity))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

#---------[ SYSTEM ]---------#

class CAN_Supply:
	PACKET_TYPES = ['CAN_PKT_SUPPLY']
	SIZE = 19

	def __init__ (self, startByte = 0, voltage = 0.0, current = 0.0,
	coulomb_count = 0.0, temperature = 0.0, chk = 0):
		self.startByte = startByte
		self.voltage = voltage
		self.current = current
		self.coulomb_count = coulomb_count
		self.temperature = temperature
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_Supply]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.voltage = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.current = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.coulomb_count = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.temperature = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<f', self.voltage))
		buf.extend(struct.pack('<f', self.current))
		buf.extend(struct.pack('<f', self.coulomb_count))
		buf.extend(struct.pack('<f', self.temperature))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

class CAN_GNSS_LLA:
	PACKET_TYPES = ['CAN_PKT_GNSS']
	SIZE = 23

	def __init__ (self, startByte = 0, latitude = 0.0, longitude = 0.0,
	altitude = 0.0, chk = 0):
		self.startByte = startByte
		self.latitude = latitude
		self.longitude = longitude
		self.altitude = altitude
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_GNSS_LLA]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.latitude = struct.unpack_from('<d',buf,offset)[0]
		offset = offset + struct.calcsize('<d')

		self.longitude = struct.unpack_from('<d',buf,offset)[0]
		offset = offset + struct.calcsize('<d')

		self.altitude = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<d', self.latitude))
		buf.extend(struct.pack('<d', self.longitude))
		buf.extend(struct.pack('<f', self.altitude))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

class CAN_GNSS_UTC:
	PACKET_TYPES = ['CAN_PKT_GNSS']
	SIZE = 9

	def __init__ (self, startByte = 0, hours = 0, minutes = 0, seconds = 0.0,
	chk = 0):
		self.startByte = startByte
		self.hours = hours
		self.minutes = minutes
		self.seconds = seconds
		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_GNSS_UTC]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.hours = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.minutes = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.seconds = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))
		buf.extend(struct.pack('<B', self.hours))
		buf.extend(struct.pack('<B', self.minutes))
		buf.extend(struct.pack('<f', self.seconds))
		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

#---------[ ACTUATORS ]---------#

class CAN_Actuator:
	PACKET_TYPES = ['CAN_PKT_ACTUATOR']
	SIZE = 35

	def __init__ (self, startByte = 0, usec = [None] * 16, chk = 0):
		self.startByte = startByte

		if (len(usec) != 16):
			raise ValueError('array usec expecting length '+str(16)+' got '+str(len(usec)))

		self.usec = list(usec)

		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_Actuator]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.usec = [];

		for i in range(0,16):
			self.usec.append(struct.unpack_from('<H',buf,offset)[0])
			offset = offset+struct.calcsize('<H')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))

		for val in self.usec:
		    buf.extend(struct.pack('<H', val))

		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)

#---------[ INPUT ]---------#

class CAN_Receiver:
	PACKET_TYPES = ['CAN_PKT_RECEIVER']
	SIZE = 35

	def __init__ (self, startByte = 0, usec = [None] * 16, chk = 0):
		self.startByte = startByte

		if (len(usec) != 16):
			raise ValueError('array usec expecting length '+str(16)+' got '+str(len(usec)))

		self.usec = list(usec)

		self.chk = chk

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CAN_Receiver]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.startByte = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.usec = [];

		for i in range(0,16):
			self.usec.append(struct.unpack_from('<H',buf,offset)[0])
			offset = offset+struct.calcsize('<H')

		self.chk = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.startByte))

		for val in self.usec:
		    buf.extend(struct.pack('<H', val))

		buf.extend(struct.pack('<H', self.chk))
		return bytearray(buf)
