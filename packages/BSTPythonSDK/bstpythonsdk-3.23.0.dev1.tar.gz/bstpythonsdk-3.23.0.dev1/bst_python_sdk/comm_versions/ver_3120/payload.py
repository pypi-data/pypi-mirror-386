#*=+--+=#=+--         SwiftCore Flight Management Software        --+=#=+--+=#*#
#               Copyright (C) 2020 Black Swift Technologies LLC.               #
#                             All Rights Reserved.                             #
#                                                                              #
#    NOTICE:  All information contained herein is, and remains the property    #
#    of Black Swift Technologies.                                              #
#                                                                              #
#    The intellectual and technical concepts contained herein are              #
#    proprietary to Black Swift Technologies LLC and may be covered by U.S.    #
#    and foreign patents, patents in process, and are protected by trade       #
#    secret or copyright law.                                                  #
#                                                                              #
#    Dissemination of this information or reproduction of this material is     #
#    strictly forbidden unless prior written permission is obtained from       #
#    Black Swift Technologies LLC.                                             #
#                                                                              #
#*=+--+=#=+--                 --+=#=+--+=#=+--                    --+=#=+--+=#*#

from enum import Enum
import struct
import sys

from .comm_packets import *

#                      THIS FILE IS AUTOGENERATED BY                           #
#                                 msg-gen.py                                   #
#                                DO NOT EDIT                                   #

#---------[ Controller ]---------#

class CommandID (Enum):
	# NOTE - you must check the numbers in the CommandID values

	# contained in the parent folder

	#


	# Command Interface

	CMD_PAYLOAD_CONTROL=35

#---------[ PAYLOAD ]---------#

class PayloadControl (Enum):
	PAYLOAD_CTRL_OFF=0
	PAYLOAD_CTRL_CONNECTED=1
	PAYLOAD_CTRL_READY=2
	PAYLOAD_CTRL_ACTIVE=3
	PAYLOAD_CTRL_SHUTDOWN=4
	PAYLOAD_CTRL_ERROR=5
	PAYLOAD_CTRL_INVALID=6

#---------[ Communication ]---------#

class TelemetryPayload:
	PACKET_TYPES = ['TELEMETRY_PAYLOAD']
	SIZE = 7

	def __init__ (self, node_status = PayloadControl(0), num_triggers = 0,
	percent_complete = 0.0):
		self.node_status = PayloadControl(node_status)

		self.num_triggers = num_triggers
		self.percent_complete = percent_complete

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [TelemetryPayload]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.node_status = PayloadControl(struct.unpack_from('<B',buf,offset)[0])
		offset = offset+struct.calcsize('<B')

		self.num_triggers = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

		self.percent_complete = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.put(PayloadControl.encode(self.node_status));

		buf.extend(struct.pack('<H', self.num_triggers))
		buf.extend(struct.pack('<f', self.percent_complete))
		return bytearray(buf)

#---------[ Payload ]---------#

class PayloadID (Enum):
	PAYLOAD_UNKNOWN=0
	PAYLOAD_QX1=1
	PAYLOAD_A6000=2
	PAYLOAD_FLIR_TAU2=3
	PAYLOAD_TETRACAM_ADC_LITE=4

class LDCR:
	PACKET_TYPES = ['PAYLOAD_LDCR']
	SIZE = 64

	def __init__ (self, week = 0, hour = 0, minute = 0, seconds = 0.0, latitude = 0.0,
	longitude = 0.0, altitude = 0.0, agl = 0.0, roll = 0.0, pitch = 0.0,
	ir_meas_down = 0.0, near_ir_meas_down = 0.0, r_meas_down = 0.0,
	ir_meas_up = 0.0, near_ir_meas_up = 0.0, r_meas_up = 0.0):
		self.week = week
		self.hour = hour
		self.minute = minute
		self.seconds = seconds
		self.latitude = latitude
		self.longitude = longitude
		self.altitude = altitude
		self.agl = agl
		self.roll = roll
		self.pitch = pitch
		self.ir_meas_down = ir_meas_down
		self.near_ir_meas_down = near_ir_meas_down
		self.r_meas_down = r_meas_down
		self.ir_meas_up = ir_meas_up
		self.near_ir_meas_up = near_ir_meas_up
		self.r_meas_up = r_meas_up

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [LDCR]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.week = struct.unpack_from('<h',buf,offset)[0]
		offset = offset + struct.calcsize('<h')

		self.hour = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.minute = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.seconds = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.latitude = struct.unpack_from('<d',buf,offset)[0]
		offset = offset + struct.calcsize('<d')

		self.longitude = struct.unpack_from('<d',buf,offset)[0]
		offset = offset + struct.calcsize('<d')

		self.altitude = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.agl = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.roll = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.pitch = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.ir_meas_down = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.near_ir_meas_down = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.r_meas_down = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.ir_meas_up = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.near_ir_meas_up = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.r_meas_up = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<h', self.week))
		buf.extend(struct.pack('<B', self.hour))
		buf.extend(struct.pack('<B', self.minute))
		buf.extend(struct.pack('<f', self.seconds))
		buf.extend(struct.pack('<d', self.latitude))
		buf.extend(struct.pack('<d', self.longitude))
		buf.extend(struct.pack('<f', self.altitude))
		buf.extend(struct.pack('<f', self.agl))
		buf.extend(struct.pack('<f', self.roll))
		buf.extend(struct.pack('<f', self.pitch))
		buf.extend(struct.pack('<f', self.ir_meas_down))
		buf.extend(struct.pack('<f', self.near_ir_meas_down))
		buf.extend(struct.pack('<f', self.r_meas_down))
		buf.extend(struct.pack('<f', self.ir_meas_up))
		buf.extend(struct.pack('<f', self.near_ir_meas_up))
		buf.extend(struct.pack('<f', self.r_meas_up))
		return bytearray(buf)

class NDVI:
	PACKET_TYPES = ['PAYLOAD_NDVI']
	SIZE = 21

	def __init__ (self, system_time = 0.0, id = 0, red = 0.0, near_ir = 0.0,
	ir_ambient = 0.0, ir_object = 0.0):
		self.system_time = system_time
		self.id = id
		self.red = red
		self.near_ir = near_ir
		self.ir_ambient = ir_ambient
		self.ir_object = ir_object

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [NDVI]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.system_time = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.id = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.red = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.near_ir = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.ir_ambient = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.ir_object = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<f', self.system_time))
		buf.extend(struct.pack('<B', self.id))
		buf.extend(struct.pack('<f', self.red))
		buf.extend(struct.pack('<f', self.near_ir))
		buf.extend(struct.pack('<f', self.ir_ambient))
		buf.extend(struct.pack('<f', self.ir_object))
		return bytearray(buf)

class PayloadParam:
	PACKET_TYPES = ['PAYLOAD_PARAMS']
	SIZE = 17

	def __init__ (self, channel = 0, deltaD = 0.0, deltaT = 0.0, pulse = 0.0,
	cruise_speed = 0.0):
		self.channel = channel
		self.deltaD = deltaD
		self.deltaT = deltaT
		self.pulse = pulse
		self.cruise_speed = cruise_speed

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [PayloadParam]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.channel = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.deltaD = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.deltaT = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.pulse = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.cruise_speed = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.channel))
		buf.extend(struct.pack('<f', self.deltaD))
		buf.extend(struct.pack('<f', self.deltaT))
		buf.extend(struct.pack('<f', self.pulse))
		buf.extend(struct.pack('<f', self.cruise_speed))
		return bytearray(buf)

class PayloadTrigger:
	PACKET_TYPES = ['PAYLOAD_TRIGGER']
	SIZE = 39

	def __init__ (self, latitude = 0.0, longitude = 0.0, altitude = 0.0,
	q = [None] * 4, percent = 0, id = 0):
		self.latitude = latitude
		self.longitude = longitude
		self.altitude = altitude

		if (len(q) != 4):
			raise ValueError('array q expecting length '+str(4)+' got '+str(len(q)))

		self.q = list(q)

		self.percent = percent
		self.id = id

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [PayloadTrigger]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.latitude = struct.unpack_from('<d',buf,offset)[0]
		offset = offset + struct.calcsize('<d')

		self.longitude = struct.unpack_from('<d',buf,offset)[0]
		offset = offset + struct.calcsize('<d')

		self.altitude = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.q = [];

		for i in range(0,4):
			self.q.append(struct.unpack_from('<f',buf,offset)[0])
			offset = offset+struct.calcsize('<f')

		self.percent = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.id = struct.unpack_from('<H',buf,offset)[0]
		offset = offset + struct.calcsize('<H')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<d', self.latitude))
		buf.extend(struct.pack('<d', self.longitude))
		buf.extend(struct.pack('<f', self.altitude))

		for val in self.q:
		    buf.extend(struct.pack('<f', val))

		buf.extend(struct.pack('<B', self.percent))
		buf.extend(struct.pack('<H', self.id))
		return bytearray(buf)

class UserPayload:
	PACKET_TYPES = ['USER_PAYLOAD']
	SIZE = 66

	def __init__ (self, system_id = 0, sub_system_id = 0, buffer = [None] * 64):
		self.system_id = system_id
		self.sub_system_id = sub_system_id

		if (len(buffer) != 64):
			raise ValueError('array buffer expecting length '+str(64)+' got '+str(len(buffer)))

		self.buffer = list(buffer)

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [UserPayload]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.system_id = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.sub_system_id = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.buffer = [];

		for i in range(0,64):
			self.buffer.append(struct.unpack_from('<B',buf,offset)[0])
			offset = offset+struct.calcsize('<B')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(struct.pack('<B', self.system_id))
		buf.extend(struct.pack('<B', self.sub_system_id))

		for val in self.buffer:
		    buf.extend(struct.pack('<B', val))
		return bytearray(buf)

class CameraTag:
	PACKET_TYPES = ['PAYLOAD_CAMERA_TAG']
	SIZE = 79

	def __init__ (self, trigger_info = 0, week = 0, hour = 0, minute = 0,
	seconds = 0.0, filename = [None] * 32):
		self.trigger_info = PayloadTrigger(trigger_info)

		self.week = week
		self.hour = hour
		self.minute = minute
		self.seconds = seconds

		if (len(filename) != 32):
			raise ValueError('array filename expecting length '+str(32)+' got '+str(len(filename)))

		self.filename = list(filename)

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [CameraTag]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.trigger_info = PayloadTrigger()
		self.trigger_info.parse(buf[offset:offset+PayloadTrigger.SIZE])
		offset = offset+PayloadTrigger.SIZE

		self.week = struct.unpack_from('<h',buf,offset)[0]
		offset = offset + struct.calcsize('<h')

		self.hour = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.minute = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.seconds = struct.unpack_from('<f',buf,offset)[0]
		offset = offset + struct.calcsize('<f')

		self.filename = [];

		for i in range(0,32):
			self.filename.append(struct.unpack_from('<B',buf,offset)[0])
			offset = offset+struct.calcsize('<B')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.extend(self.trigger_info.serialize())
		buf.extend(struct.pack('<h', self.week))
		buf.extend(struct.pack('<B', self.hour))
		buf.extend(struct.pack('<B', self.minute))
		buf.extend(struct.pack('<f', self.seconds))

		for val in self.filename:
		    buf.extend(struct.pack('<B', val))
		return bytearray(buf)

class PayloadStatus:
	PACKET_TYPES = ['PAYLOAD_STATUS']
	SIZE = 4

	def __init__ (self, identifier = PayloadID.PAYLOAD_UNKNOWN, power_on = 0,
	initialized = 0, state = PayloadControl(0)):
		self.identifier = PayloadID(identifier)

		self.power_on = power_on
		self.initialized = initialized

		self.state = PayloadControl(state)

	def parse(self,buf):
		if (len(buf) != self.SIZE):
			raise BufferError('INVALID PACKET SIZE [PayloadStatus]: Expected=' + str(self.SIZE) + ' Received='+ str(len(buf)))

		offset = 0

		self.identifier = PayloadID(struct.unpack_from('<B',buf,offset)[0])
		offset = offset+struct.calcsize('<B')

		self.power_on = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.initialized = struct.unpack_from('<B',buf,offset)[0]
		offset = offset + struct.calcsize('<B')

		self.state = PayloadControl(struct.unpack_from('<B',buf,offset)[0])
		offset = offset+struct.calcsize('<B')

	def getSize(self):
		return self.SIZE

	def set_system_time(self, sys_time):
		self.system_time = sys_time

	def get_packet_types(self):
		types = getattr(sys.modules[__name__], "PacketTypes")
		return [getattr(types, pkt, types.INVALID_PACKET) for pkt in self.PACKET_TYPES]

	def serialize(self):
		buf = []

		buf.put(PayloadID.encode(self.identifier));

		buf.extend(struct.pack('<B', self.power_on))
		buf.extend(struct.pack('<B', self.initialized))

		buf.put(PayloadControl.encode(self.state));
		return bytearray(buf)
