

// This file is automatically generated by the coding assistants. Don't edit it manually.
// The declarations are generated from the class declarations in the C++ source.

#include "bindings.h"
#include "pybind11/pybind11.h"
#include "pybind11/stl.h"

namespace py = pybind11;

PYBIND11_MODULE(PyGestaltPlanner, m) {

	py::class_<Pose>(m, "Pose")
		.def(py::init<PoseUpdate>())
		.def(
			py::init<
				double,
				double,
				double,
				double,
				double,
				double,
				double
			>(),
			py::kw_only(),
			py::arg("x") = 0.0,
			py::arg("y") = 0.0,
			py::arg("z") = 0.0,
			py::arg("qx") = 0.0,
			py::arg("qy") = 0.0,
			py::arg("qz") = 0.0,
			py::arg("qw") = 1.0
		)
		.def_readwrite("x", &Pose::x)
		.def_readwrite("y", &Pose::y)
		.def_readwrite("z", &Pose::z)
		.def_readwrite("qx", &Pose::qx)
		.def_readwrite("qy", &Pose::qy)
		.def_readwrite("qz", &Pose::qz)
		.def_readwrite("qw", &Pose::qw);

	py::class_<PoseUpdate>(m, "PoseUpdate")
		.def(
			py::init<
				double,
				double,
				double,
				double,
				double,
				double,
				double
			>(),
			py::kw_only(),
			py::arg("x") = unchangedNaN,
			py::arg("y") = unchangedNaN,
			py::arg("z") = unchangedNaN,
			py::arg("qx") = unchangedNaN,
			py::arg("qy") = unchangedNaN,
			py::arg("qz") = unchangedNaN,
			py::arg("qw") = unchangedNaN
		)
		.def_readwrite("x", &PoseUpdate::x)
		.def_readwrite("y", &PoseUpdate::y)
		.def_readwrite("z", &PoseUpdate::z)
		.def_readwrite("qx", &PoseUpdate::qx)
		.def_readwrite("qy", &PoseUpdate::qy)
		.def_readwrite("qz", &PoseUpdate::qz)
		.def_readwrite("qw", &PoseUpdate::qw);

	py::class_<Collision>(m, "Collision")
		.def(
			py::init<
				int,
				std::string,
				std::string
			>(),
			py::kw_only(),
			py::arg("step") = -1,
			py::arg("link1_id") = "",
			py::arg("link2_id") = ""
		)
		.def_readwrite("step", &Collision::step)
		.def_readwrite("link1_id", &Collision::link1_id)
		.def_readwrite("link2_id", &Collision::link2_id);

	py::class_<PlannerParamInfo>(m, "PlannerParamInfo")
		.def(
			py::init<
				string,
				string
			>(),
			py::kw_only(),
			py::arg("defaultValue"),
			py::arg("rangeSuggestion")
		)
		.def_readwrite("defaultValue", &PlannerParamInfo::defaultValue)
		.def_readwrite("rangeSuggestion", &PlannerParamInfo::rangeSuggestion);

	py::class_<PlannerInfo>(m, "PlannerInfo")
		.def(
			py::init<
				bool,
				bool,
				std::map<string, PlannerParamInfo>
			>(),
			py::kw_only(),
			py::arg("multithreaded"),
			py::arg("directed"),
			py::arg("params")
		)
		.def_readwrite("multithreaded", &PlannerInfo::multithreaded)
		.def_readwrite("directed", &PlannerInfo::directed)
		.def_readwrite("params", &PlannerInfo::params);

	py::class_<GestaltPlanner>(m, "GestaltPlanner")
		.def(
			py::init<
				const string &,
				bool
			>(),
			py::kw_only(),
			py::arg("command_log_file") = "last_run.log.cpp",
			py::arg("show_logo") = true
		)
		.def("cache_file",
			&GestaltPlanner::cache_file,
			py::kw_only(),
			py::arg("file_name"),
			py::arg("raw_content"),
			py::arg("is_base64") = false
		)
		.def("check_clearance",
			&GestaltPlanner::check_clearance,
			py::kw_only(),
			py::arg("object_id") = "__world__",
			py::arg("trajectory") = valarray<valarray<double>>{}
		)
		.def("check_kinematic_feasibility",
			&GestaltPlanner::check_kinematic_feasibility,
			py::kw_only(),
			py::arg("trajectory"),
			py::arg("dt"),
			py::arg("max_velocity"),
			py::arg("max_acceleration"),
			py::arg("max_jerk")
		)
		.def("command_log_comment",
			&GestaltPlanner::command_log_comment,
			py::kw_only(),
			py::arg("comment")
		)
		.def("create_collision_ignore_group",
			&GestaltPlanner::create_collision_ignore_group,
			py::kw_only(),
			py::arg("name"),
			py::arg("members")
		)
		.def("delete_collision_ignore_group",
			&GestaltPlanner::delete_collision_ignore_group,
			py::kw_only(),
			py::arg("name")
		)
		.def("export_state",
			&GestaltPlanner::export_state,
			py::kw_only(),
			py::arg("object_id") = "",
			py::arg("indent") = true
		)
		.def("find_collisions",
			&GestaltPlanner::find_collisions,
			py::kw_only(),
			py::arg("object_id") = "__world__",
			py::arg("trajectory") = valarray<valarray<double>>{}
		)
		.def("get_collision_ignore_groups",
			&GestaltPlanner::get_collision_ignore_groups,
			py::kw_only(),
			py::arg("active_object") = ""
		)
		.def("get_joint_selection",
			&GestaltPlanner::get_joint_selection,
			py::kw_only(),
			py::arg("object_id")
		)
		.def("get_planner_info",
			&GestaltPlanner::get_planner_info
		)
		.def("get_version",
			&GestaltPlanner::get_version
		)
		.def("interpolate",
			&GestaltPlanner::interpolate,
			py::kw_only(),
			py::arg("waypoints"),
			py::arg("dt"),
			py::arg("max_velocity"),
			py::arg("max_acceleration") = valarray<double>{},
			py::arg("max_jerk") = valarray<double>{},
			py::arg("safety_factor") = 1.0
		)
		.def("json_call",
			&GestaltPlanner::json_call,
			py::kw_only(),
			py::arg("data")
		)
		.def("plan_multistep_path",
			&GestaltPlanner::plan_multistep_path,
			py::kw_only(),
			py::arg("object_id"),
			py::arg("sets_of_target_joint_positions") = valarray<valarray<valarray<double>>>{},
			py::arg("start_joint_positions") = valarray<double>{},
			py::arg("max_sampling_step_size") = valarray<double>{},
			py::arg("waypoint_suggestions") = valarray<valarray<double>>{},
			py::arg("jiggle") = 1e-6,
			py::arg("constraints") = valarray<valarray<double>>{},
			py::arg("constraint_tolerance") = 1e-6,
			py::arg("planner") = "RRTConnect",
			py::arg("planner_params") = std::map<string, string>{},
			py::arg("max_checks_per_step") = 5000,
			py::arg("timeout_per_step") = -1.0,
			py::arg("random_seed") = 0,
			py::arg("tighten") = true
		)
		.def("plan_path",
			&GestaltPlanner::plan_path,
			py::kw_only(),
			py::arg("object_id"),
			py::arg("target_joint_positions") = valarray<valarray<double>>{},
			py::arg("start_joint_positions") = valarray<double>{},
			py::arg("max_sampling_step_size") = valarray<double>{},
			py::arg("waypoint_suggestions") = valarray<valarray<double>>{},
			py::arg("jiggle") = 1e-6,
			py::arg("constraints") = valarray<valarray<double>>{},
			py::arg("constraint_tolerance") = 1e-6,
			py::arg("planner") = "RRTConnect",
			py::arg("planner_params") = std::map<string, string>{},
			py::arg("maxChecks") = 5000,
			py::arg("timeout") = -1.0,
			py::arg("random_seed") = 0,
			py::arg("simplify") = true,
			py::arg("tighten") = true
		)
		.def("remove",
			&GestaltPlanner::remove,
			py::kw_only(),
			py::arg("object_id")
		)
		.def("render_animation",
			&GestaltPlanner::render_animation,
			py::kw_only(),
			py::arg("title") = "debug",
			py::arg("active_object") = "__world__",
			py::arg("trajectory") = valarray<valarray<double>>{},
			py::arg("dt") = 1.0,
			py::arg("format") = "json",
			py::arg("output_file") = ""
		)
		.def("render_scene",
			&GestaltPlanner::render_scene,
			py::kw_only(),
			py::arg("title") = "debug",
			py::arg("active_object") = "__world__",
			py::arg("format") = "json",
			py::arg("output_file") = "",
			py::arg("probe_margins") = false
		)
		.def("reset",
			&GestaltPlanner::reset
		)
		.def("select_joints",
			&GestaltPlanner::select_joints,
			py::kw_only(),
			py::arg("object_id"),
			py::arg("joints") = vector<string>{}
		)
		.def("set_base_pose",
			&GestaltPlanner::set_base_pose,
			py::kw_only(),
			py::arg("object_id"),
			py::arg("pose") = PoseUpdate{},
			py::arg("parent_object_id") = "",
			py::arg("parent_link") = "__root__"
		)
		.def("set_joint_positions",
			&GestaltPlanner::set_joint_positions,
			py::kw_only(),
			py::arg("object_id"),
			py::arg("joint_positions") = valarray<double>{}
		)
		.def("set_safety_margin",
			&GestaltPlanner::set_safety_margin,
			py::kw_only(),
			py::arg("object_id") = "*",
			py::arg("margin") = 0.0
		)
		.def("simplify_path",
			&GestaltPlanner::simplify_path,
			py::kw_only(),
			py::arg("object_id"),
			py::arg("waypoints"),
			py::arg("constraints") = valarray<valarray<double>>{}
		)
		.def("smoothen_path",
			&GestaltPlanner::smoothen_path,
			py::kw_only(),
			py::arg("object_id"),
			py::arg("waypoints"),
			py::arg("dt"),
			py::arg("max_velocity"),
			py::arg("max_acceleration"),
			py::arg("max_jerk"),
			py::arg("constraints") = valarray<valarray<double>>{},
			py::arg("quick") = true
		)
		.def("spawn",
			&GestaltPlanner::spawn,
			py::kw_only(),
			py::arg("object_id"),
			py::arg("description_file"),
			py::arg("config_file") = "",
			py::arg("pose") = Pose(),
			py::arg("pose_type") = "static",
			py::arg("joint_positions") = valarray<double>{},
			py::arg("parent_object_id") = "__world__",
			py::arg("parent_link") = "__root__",
			py::arg("encapsulate_meshes") = false
		)
		.def("tighten_path",
			&GestaltPlanner::tighten_path,
			py::kw_only(),
			py::arg("object_id"),
			py::arg("waypoints"),
			py::arg("constraints") = valarray<valarray<double>>{},
			py::arg("iterations") = 3
		)
		.def("time_parameterize_path",
			&GestaltPlanner::time_parameterize_path,
			py::kw_only(),
			py::arg("trajectory"),
			py::arg("dt"),
			py::arg("max_velocity"),
			py::arg("max_acceleration"),
			py::arg("max_jerk")
		);

	py::implicitly_convertible<PoseUpdate, Pose>();
	
}
