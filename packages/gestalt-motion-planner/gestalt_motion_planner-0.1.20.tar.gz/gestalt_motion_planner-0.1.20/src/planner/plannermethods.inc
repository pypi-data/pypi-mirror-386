
// This file is automatically generated by the coding assistants. Don't edit it manually.
// The member declarations are generated from the definitions in the cpp files.

private: string render_impl(
	bool  isAnimation,
	const string& title,
	const string& object_id,
	const valarray<valarray<double>>& trajectory,
	double  dt,
	const string& format,
	const string& output_file,
	bool  probe_margins);

private: void spawn_world();

private: void update_collision_bitmasks();

public: GestaltPlanner(
	const string& command_log_file = "last_run.log.cpp",
	bool  show_logo = true);

public: void cache_file(
	const string& file_name,
	const string& raw_content,
	bool  is_base64 = false);

#ifndef PYBIND
public: struct cache_file_params{
	const string& file_name;
	const string& raw_content;
	bool  is_base64 = false; };

public: void cache_file(cache_file_params param_object){
	return cache_file(
		param_object.file_name,
		param_object.raw_content,
		param_object.is_base64);
}
#endif


// much faster than find_collisions()
// only reports true if there were no collisions
// randomizes waypoint checking order
// stops on first collision encounter
public: bool check_clearance(
	const string& object_id = "__world__",
	valarray<valarray<double>>  trajectory = {});

#ifndef PYBIND
public: struct check_clearance_params{
	const string& object_id = "__world__";
	valarray<valarray<double>>  trajectory = {}; };

// much faster than find_collisions()
// only reports true if there were no collisions
// randomizes waypoint checking order
// stops on first collision encounter
public: bool check_clearance(check_clearance_params param_object){
	return check_clearance(
		param_object.object_id,
		param_object.trajectory);
}
#endif


public: bool check_kinematic_feasibility(
	const valarray<valarray<double>>& trajectory,
	double  dt,
	const valarray<double>& max_velocity,
	const valarray<double>& max_acceleration,
	const valarray<double>& max_jerk);

#ifndef PYBIND
public: struct check_kinematic_feasibility_params{
	const valarray<valarray<double>>& trajectory;
	double  dt;
	const valarray<double>& max_velocity;
	const valarray<double>& max_acceleration;
	const valarray<double>& max_jerk; };

public: bool check_kinematic_feasibility(check_kinematic_feasibility_params param_object){
	return check_kinematic_feasibility(
		param_object.trajectory,
		param_object.dt,
		param_object.max_velocity,
		param_object.max_acceleration,
		param_object.max_jerk);
}
#endif


public: void command_log_comment(
	const string& comment);

#ifndef PYBIND
public: struct command_log_comment_params{
	const string& comment; };

public: void command_log_comment(command_log_comment_params param_object){
	return command_log_comment(
		param_object.comment);
}
#endif


public: void create_collision_ignore_group(
	const string& name,
	const vector<string>& members);

#ifndef PYBIND
public: struct create_collision_ignore_group_params{
	const string& name;
	const vector<string>& members; };

public: void create_collision_ignore_group(create_collision_ignore_group_params param_object){
	return create_collision_ignore_group(
		param_object.name,
		param_object.members);
}
#endif


public: void delete_collision_ignore_group(
	const string& name);

#ifndef PYBIND
public: struct delete_collision_ignore_group_params{
	const string& name; };

public: void delete_collision_ignore_group(delete_collision_ignore_group_params param_object){
	return delete_collision_ignore_group(
		param_object.name);
}
#endif


// leave object_ids empty to export entire scene
public: string export_state(
	string  object_id = "",
	bool  indent = true);

#ifndef PYBIND
public: struct export_state_params{
	string  object_id = "";
	bool  indent = true; };

// leave object_ids empty to export entire scene
public: string export_state(export_state_params param_object){
	return export_state(
		param_object.object_id,
		param_object.indent);
}
#endif


public: vector<Collision> find_collisions(
	const string& object_id = "__world__",
	const valarray<valarray<double>>& trajectory = {});

#ifndef PYBIND
public: struct find_collisions_params{
	const string& object_id = "__world__";
	const valarray<valarray<double>>& trajectory = {}; };

public: vector<Collision> find_collisions(find_collisions_params param_object){
	return find_collisions(
		param_object.object_id,
		param_object.trajectory);
}
#endif


public: std::unordered_map<string, std::unordered_set<string>>
get_collision_ignore_groups(
	const string& active_object = "");

#ifndef PYBIND
public: struct get_collision_ignore_groups_params{
	const string& active_object = ""; };

public: std::unordered_map<string, std::unordered_set<string>>
get_collision_ignore_groups(get_collision_ignore_groups_params param_object){
	return get_collision_ignore_groups(
		param_object.active_object);
}
#endif


public: vector<string> get_joint_selection(
	const string& object_id);

#ifndef PYBIND
public: struct get_joint_selection_params{
	const string& object_id; };

public: vector<string> get_joint_selection(get_joint_selection_params param_object){
	return get_joint_selection(
		param_object.object_id);
}
#endif


public: std::map<string, PlannerInfo> get_planner_info();

/*
version.inc is generated by a pre-commit hook:

change the shebang to #!/bin/bash
and insert:

printf "updating src/version.inc\n"
printf "" > src/version.inc
printf "commit_timestamp = \"%(%Y-%m-%d %H:%M:%S)T\"\n" >> src/version.inc
printf "commit_tag = \"" >> src/version.inc
git describe --all --long | tr "\n" "\""  >> src/version.inc
printf "\n" >> src/version.inc
git add "src/version.inc"
*/

public: string get_version();

public: valarray<valarray<double>> interpolate(
	const valarray<valarray<double>>& waypoints,
	double  dt,
	const valarray<double>& max_velocity,
	const valarray<double>& max_acceleration = {},
	const valarray<double>& max_jerk = {},
	double  safety_factor = 1.0);

#ifndef PYBIND
public: struct interpolate_params{
	const valarray<valarray<double>>& waypoints;
	double  dt;
	const valarray<double>& max_velocity;
	const valarray<double>& max_acceleration = {};
	const valarray<double>& max_jerk = {};
	double  safety_factor = 1.0; };

public: valarray<valarray<double>> interpolate(interpolate_params param_object){
	return interpolate(
		param_object.waypoints,
		param_object.dt,
		param_object.max_velocity,
		param_object.max_acceleration,
		param_object.max_jerk,
		param_object.safety_factor);
}
#endif


public: string json_call(
	const string& data);

#ifndef PYBIND
public: struct json_call_params{
	const string& data; };

public: string json_call(json_call_params param_object){
	return json_call(
		param_object.data);
}
#endif


public: valarray<valarray<valarray<double>>> plan_multistep_path(
	const string& object_id,
	const valarray<valarray<valarray<double>>>& sets_of_target_joint_positions = {},
	valarray<double>  start_joint_positions = {},
	valarray<double>  max_sampling_step_size = {},
	const valarray<valarray<double>>& waypoint_suggestions = {},
	double  jiggle = 1e-6,
	const valarray<valarray<double>>& constraints = {},
	double  constraint_tolerance = 1e-6,
	const string& planner = "RRTConnect",
	const std::map<string, string>& planner_params = {},
	size_t  max_checks_per_step = 5000,
	double  timeout_per_step = -1.0,
	size_t  random_seed = 0,
	bool  tighten = true);

#ifndef PYBIND
public: struct plan_multistep_path_params{
	const string& object_id;
	const valarray<valarray<valarray<double>>>& sets_of_target_joint_positions = {};
	valarray<double>  start_joint_positions = {};
	valarray<double>  max_sampling_step_size = {};
	const valarray<valarray<double>>& waypoint_suggestions = {};
	double  jiggle = 1e-6;
	const valarray<valarray<double>>& constraints = {};
	double  constraint_tolerance = 1e-6;
	const string& planner = "RRTConnect";
	const std::map<string, string>& planner_params = {};
	size_t  max_checks_per_step = 5000;
	double  timeout_per_step = -1.0;
	size_t  random_seed = 0;
	bool  tighten = true; };

public: valarray<valarray<valarray<double>>> plan_multistep_path(plan_multistep_path_params param_object){
	return plan_multistep_path(
		param_object.object_id,
		param_object.sets_of_target_joint_positions,
		param_object.start_joint_positions,
		param_object.max_sampling_step_size,
		param_object.waypoint_suggestions,
		param_object.jiggle,
		param_object.constraints,
		param_object.constraint_tolerance,
		param_object.planner,
		param_object.planner_params,
		param_object.max_checks_per_step,
		param_object.timeout_per_step,
		param_object.random_seed,
		param_object.tighten);
}
#endif


public: valarray<valarray<double>> plan_path(
	const string& object_id,
	const valarray<valarray<double>>& target_joint_positions = {},
	valarray<double>  start_joint_positions = {},
	valarray<double>  max_sampling_step_size = {},
	const valarray<valarray<double>>& waypoint_suggestions = {},
	double  jiggle = 1e-6,
	const valarray<valarray<double>>& constraints = {},
	double  constraint_tolerance = 1e-6,
	const string& planner = "RRTConnect",
	const std::map<string, string>& planner_params = {},
	size_t  maxChecks = 5000,
	double  timeout = -1.0,
	size_t  random_seed = 0,
	bool  simplify = true,
	bool  tighten = true);

#ifndef PYBIND
public: struct plan_path_params{
	const string& object_id;
	const valarray<valarray<double>>& target_joint_positions = {};
	valarray<double>  start_joint_positions = {};
	valarray<double>  max_sampling_step_size = {};
	const valarray<valarray<double>>& waypoint_suggestions = {};
	double  jiggle = 1e-6;
	const valarray<valarray<double>>& constraints = {};
	double  constraint_tolerance = 1e-6;
	const string& planner = "RRTConnect";
	const std::map<string, string>& planner_params = {};
	size_t  maxChecks = 5000;
	double  timeout = -1.0;
	size_t  random_seed = 0;
	bool  simplify = true;
	bool  tighten = true; };

public: valarray<valarray<double>> plan_path(plan_path_params param_object){
	return plan_path(
		param_object.object_id,
		param_object.target_joint_positions,
		param_object.start_joint_positions,
		param_object.max_sampling_step_size,
		param_object.waypoint_suggestions,
		param_object.jiggle,
		param_object.constraints,
		param_object.constraint_tolerance,
		param_object.planner,
		param_object.planner_params,
		param_object.maxChecks,
		param_object.timeout,
		param_object.random_seed,
		param_object.simplify,
		param_object.tighten);
}
#endif


public: void remove(
	const string& object_id);

#ifndef PYBIND
public: struct remove_params{
	const string& object_id; };

public: void remove(remove_params param_object){
	return remove(
		param_object.object_id);
}
#endif


public: string render_animation(
	const string& title = "debug",
	const string& active_object = "__world__",
	const valarray<valarray<double>>& trajectory = {},
	double  dt = 1.0,
	const string& format = "json",
	const string& output_file = "");

#ifndef PYBIND
public: struct render_animation_params{
	const string& title = "debug";
	const string& active_object = "__world__";
	const valarray<valarray<double>>& trajectory = {};
	double  dt = 1.0;
	const string& format = "json";
	const string& output_file = ""; };

public: string render_animation(render_animation_params param_object){
	return render_animation(
		param_object.title,
		param_object.active_object,
		param_object.trajectory,
		param_object.dt,
		param_object.format,
		param_object.output_file);
}
#endif


public: string render_scene(
	const string& title = "debug",
	const string& active_object = "__world__",
	const string& format = "json",
	const string& output_file = "",
	bool  probe_margins = false);

#ifndef PYBIND
public: struct render_scene_params{
	const string& title = "debug";
	const string& active_object = "__world__";
	const string& format = "json";
	const string& output_file = "";
	bool  probe_margins = false; };

public: string render_scene(render_scene_params param_object){
	return render_scene(
		param_object.title,
		param_object.active_object,
		param_object.format,
		param_object.output_file,
		param_object.probe_margins);
}
#endif


public: void reset();

// leave joints empty to use all joints from robot.urdf or selected joints from config.yaml
public: void select_joints(
	const string& object_id,
	const vector<string>& joints = {});

#ifndef PYBIND
public: struct select_joints_params{
	const string& object_id;
	const vector<string>& joints = {}; };

// leave joints empty to use all joints from robot.urdf or selected joints from config.yaml
public: void select_joints(select_joints_params param_object){
	return select_joints(
		param_object.object_id,
		param_object.joints);
}
#endif


public: void set_base_pose(
	const string& object_id,
	const Pose& pose = PoseUpdate{},
	const string& parent_object_id = "",
	const string  parent_link = "__root__");

#ifndef PYBIND
public: struct set_base_pose_params{
	const string& object_id;
	const Pose& pose = PoseUpdate{};
	const string& parent_object_id = "";
	const string  parent_link = "__root__"; };

public: void set_base_pose(set_base_pose_params param_object){
	return set_base_pose(
		param_object.object_id,
		param_object.pose,
		param_object.parent_object_id,
		param_object.parent_link);
}
#endif


public: void set_joint_positions(
	const string& object_id,
	const valarray<double>& joint_positions = {});

#ifndef PYBIND
public: struct set_joint_positions_params{
	const string& object_id;
	const valarray<double>& joint_positions = {}; };

public: void set_joint_positions(set_joint_positions_params param_object){
	return set_joint_positions(
		param_object.object_id,
		param_object.joint_positions);
}
#endif


public: void set_safety_margin(
	const string& object_id = "*",
	double  margin = 0.0);

#ifndef PYBIND
public: struct set_safety_margin_params{
	const string& object_id = "*";
	double  margin = 0.0; };

public: void set_safety_margin(set_safety_margin_params param_object){
	return set_safety_margin(
		param_object.object_id,
		param_object.margin);
}
#endif


public: valarray<valarray<double>> simplify_path(
	const string& object_id,
	const valarray<valarray<double>>& waypoints,
	const valarray<valarray<double>>& constraints = {});

#ifndef PYBIND
public: struct simplify_path_params{
	const string& object_id;
	const valarray<valarray<double>>& waypoints;
	const valarray<valarray<double>>& constraints = {}; };

public: valarray<valarray<double>> simplify_path(simplify_path_params param_object){
	return simplify_path(
		param_object.object_id,
		param_object.waypoints,
		param_object.constraints);
}
#endif


// generate velocity vectors in waypoints using heuristics similar to akima spline
// then sample to find a good scaling for each of those vectors

public: valarray<valarray<double>> smoothen_path(
	const string& object_id,
	valarray<valarray<double>>  waypoints,
	double  dt,
	const valarray<double>& max_velocity,
	const valarray<double>& max_acceleration,
	const valarray<double>& max_jerk,
	const valarray<valarray<double>>& constraints = {},
	bool  quick = true);

#ifndef PYBIND
public: struct smoothen_path_params{
	const string& object_id;
	valarray<valarray<double>>  waypoints;
	double  dt;
	const valarray<double>& max_velocity;
	const valarray<double>& max_acceleration;
	const valarray<double>& max_jerk;
	const valarray<valarray<double>>& constraints = {};
	bool  quick = true; };

// generate velocity vectors in waypoints using heuristics similar to akima spline
// then sample to find a good scaling for each of those vectors

public: valarray<valarray<double>> smoothen_path(smoothen_path_params param_object){
	return smoothen_path(
		param_object.object_id,
		param_object.waypoints,
		param_object.dt,
		param_object.max_velocity,
		param_object.max_acceleration,
		param_object.max_jerk,
		param_object.constraints,
		param_object.quick);
}
#endif


public: void spawn(
	const string& object_id,
	const string& description_file,
	const string& config_file = "",
	const Pose& pose = Pose(),
	const string& pose_type = "static",
	const valarray<double>& joint_positions = {},
	const string& parent_object_id = "__world__",
	const string& parent_link = "__root__",
	bool  encapsulate_meshes = false);

#ifndef PYBIND
public: struct spawn_params{
	const string& object_id;
	const string& description_file;
	const string& config_file = "";
	const Pose& pose = Pose();
	const string& pose_type = "static";
	const valarray<double>& joint_positions = {};
	const string& parent_object_id = "__world__";
	const string& parent_link = "__root__";
	bool  encapsulate_meshes = false; };

public: void spawn(spawn_params param_object){
	return spawn(
		param_object.object_id,
		param_object.description_file,
		param_object.config_file,
		param_object.pose,
		param_object.pose_type,
		param_object.joint_positions,
		param_object.parent_object_id,
		param_object.parent_link,
		param_object.encapsulate_meshes);
}
#endif


public: valarray<valarray<double>> tighten_path(
	const string& object_id,
	const valarray<valarray<double>>& waypoints,
	const valarray<valarray<double>>& constraints = {},
	size_t  iterations = 3);

#ifndef PYBIND
public: struct tighten_path_params{
	const string& object_id;
	const valarray<valarray<double>>& waypoints;
	const valarray<valarray<double>>& constraints = {};
	size_t  iterations = 3; };

public: valarray<valarray<double>> tighten_path(tighten_path_params param_object){
	return tighten_path(
		param_object.object_id,
		param_object.waypoints,
		param_object.constraints,
		param_object.iterations);
}
#endif


public: valarray<valarray<double>> time_parameterize_path(
	const valarray<valarray<double>>  trajectory,
	double  dt,
	valarray<double>  max_velocity,
	valarray<double>  max_acceleration,
	valarray<double>  max_jerk);

#ifndef PYBIND
public: struct time_parameterize_path_params{
	const valarray<valarray<double>>  trajectory;
	double  dt;
	valarray<double>  max_velocity;
	valarray<double>  max_acceleration;
	valarray<double>  max_jerk; };

public: valarray<valarray<double>> time_parameterize_path(time_parameterize_path_params param_object){
	return time_parameterize_path(
		param_object.trajectory,
		param_object.dt,
		param_object.max_velocity,
		param_object.max_acceleration,
		param_object.max_jerk);
}
#endif


public: ~GestaltPlanner();

