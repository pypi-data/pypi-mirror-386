
// This file is automatically generated by the coding assistants. Don't edit it manually.
// The dispatch branches are extracted from the definitions in the cpp files.

if (method == "cache_file") {
	self.cache_file(
		params.at("file_name").get<const string>(),
		params.at("raw_content").get<const string>(),
		params.value("is_base64", false));
}

else if (method == "check_clearance") {
	result = self.check_clearance(
		params.value("object_id", "__world__"),
		params.value("trajectory", valarray<valarray<double>> {}));
}

else if (method == "check_kinematic_feasibility") {
	result = self.check_kinematic_feasibility(
		params.at("trajectory").get<const valarray<valarray<double>>>(),
		params.at("dt").get<double >(),
		params.at("max_velocity").get<const valarray<double>>(),
		params.at("max_acceleration").get<const valarray<double>>(),
		params.at("max_jerk").get<const valarray<double>>());
}

else if (method == "command_log_comment") {
	self.command_log_comment(
		params.at("comment").get<const string>());
}

else if (method == "create_collision_ignore_group") {
	self.create_collision_ignore_group(
		params.at("name").get<const string>(),
		params.at("members").get<const vector<string>>());
}

else if (method == "delete_collision_ignore_group") {
	self.delete_collision_ignore_group(
		params.at("name").get<const string>());
}

else if (method == "export_state") {
	result = self.export_state(
		params.value("object_id", ""),
		params.value("indent", true));
}

else if (method == "find_collisions") {
	result = self.find_collisions(
		params.value("object_id", "__world__"),
		params.value("trajectory", valarray<valarray<double>>{}));
}

else if (method == "get_collision_ignore_groups") {
	result = self.get_collision_ignore_groups(
		params.value("active_object", ""));
}

else if (method == "get_joint_selection") {
	result = self.get_joint_selection(
		params.at("object_id").get<const string>());
}

else if (method == "get_planner_info") {
	result = self.get_planner_info();
}

else if (method == "get_version") {
	result = self.get_version();
}

else if (method == "interpolate") {
	result = self.interpolate(
		params.at("waypoints").get<const valarray<valarray<double>>>(),
		params.at("dt").get<double >(),
		params.at("max_velocity").get<const valarray<double>>(),
		params.value("max_acceleration", valarray<double>{}),
		params.value("max_jerk", valarray<double>{}),
		params.value("safety_factor", 1.0));
}

else if (method == "json_call") {
	result = self.json_call(
		params.at("data").get<const string>());
}

else if (method == "plan_multistep_path") {
	result = self.plan_multistep_path(
		params.at("object_id").get<const string>(),
		params.value("sets_of_target_joint_positions", valarray<valarray<valarray<double>>>{}),
		params.value("start_joint_positions", valarray<double> {}),
		params.value("max_sampling_step_size", valarray<double> {}),
		params.value("waypoint_suggestions", valarray<valarray<double>>{}),
		params.value("jiggle", 1e-6),
		params.value("constraints", valarray<valarray<double>>{}),
		params.value("constraint_tolerance", 1e-6),
		params.value("planner", "RRTConnect"),
		params.value("planner_params", std::map<string, string>{}),
		params.value("max_checks_per_step", 5000),
		params.value("timeout_per_step", -1.0),
		params.value("random_seed", 0),
		params.value("tighten", true));
}

else if (method == "plan_path") {
	result = self.plan_path(
		params.at("object_id").get<const string>(),
		params.value("target_joint_positions", valarray<valarray<double>>{}),
		params.value("start_joint_positions", valarray<double> {}),
		params.value("max_sampling_step_size", valarray<double> {}),
		params.value("waypoint_suggestions", valarray<valarray<double>>{}),
		params.value("jiggle", 1e-6),
		params.value("constraints", valarray<valarray<double>>{}),
		params.value("constraint_tolerance", 1e-6),
		params.value("planner", "RRTConnect"),
		params.value("planner_params", std::map<string, string>{}),
		params.value("maxChecks", 5000),
		params.value("timeout", -1.0),
		params.value("random_seed", 0),
		params.value("simplify", true),
		params.value("tighten", true));
}

else if (method == "remove") {
	self.remove(
		params.at("object_id").get<const string>());
}

else if (method == "render_animation") {
	result = self.render_animation(
		params.value("title", "debug"),
		params.value("active_object", "__world__"),
		params.value("trajectory", valarray<valarray<double>>{}),
		params.value("dt", 1.0),
		params.value("format", "json"),
		params.value("output_file", ""));
}

else if (method == "render_scene") {
	result = self.render_scene(
		params.value("title", "debug"),
		params.value("active_object", "__world__"),
		params.value("format", "json"),
		params.value("output_file", ""),
		params.value("probe_margins", false));
}

else if (method == "reset") {
	self.reset();
}

else if (method == "select_joints") {
	self.select_joints(
		params.at("object_id").get<const string>(),
		params.value("joints", vector<string>{}));
}

else if (method == "set_base_pose") {
	self.set_base_pose(
		params.at("object_id").get<const string>(),
		params.value("pose", PoseUpdate{}),
		params.value("parent_object_id", ""),
		params.value("parent_link", "__root__"));
}

else if (method == "set_joint_positions") {
	self.set_joint_positions(
		params.at("object_id").get<const string>(),
		params.value("joint_positions", valarray<double>{}));
}

else if (method == "set_safety_margin") {
	self.set_safety_margin(
		params.value("object_id", "*"),
		params.value("margin", 0.0));
}

else if (method == "simplify_path") {
	result = self.simplify_path(
		params.at("object_id").get<const string>(),
		params.at("waypoints").get<const valarray<valarray<double>>>(),
		params.value("constraints", valarray<valarray<double>>{}));
}

else if (method == "smoothen_path") {
	result = self.smoothen_path(
		params.at("object_id").get<const string>(),
		params.at("waypoints").get<valarray<valarray<double>> >(),
		params.at("dt").get<double >(),
		params.at("max_velocity").get<const valarray<double>>(),
		params.at("max_acceleration").get<const valarray<double>>(),
		params.at("max_jerk").get<const valarray<double>>(),
		params.value("constraints", valarray<valarray<double>>{}),
		params.value("quick", true));
}

else if (method == "spawn") {
	self.spawn(
		params.at("object_id").get<const string>(),
		params.at("description_file").get<const string>(),
		params.value("config_file", ""),
		params.value("pose", Pose()),
		params.value("pose_type", "static"),
		params.value("joint_positions", valarray<double>{}),
		params.value("parent_object_id", "__world__"),
		params.value("parent_link", "__root__"),
		params.value("encapsulate_meshes", false));
}

else if (method == "tighten_path") {
	result = self.tighten_path(
		params.at("object_id").get<const string>(),
		params.at("waypoints").get<const valarray<valarray<double>>>(),
		params.value("constraints", valarray<valarray<double>>{}),
		params.value("iterations", 3));
}

else if (method == "time_parameterize_path") {
	result = self.time_parameterize_path(
		params.at("trajectory").get<const valarray<valarray<double>> >(),
		params.at("dt").get<double >(),
		params.at("max_velocity").get<valarray<double> >(),
		params.at("max_acceleration").get<valarray<double> >(),
		params.at("max_jerk").get<valarray<double> >());
}