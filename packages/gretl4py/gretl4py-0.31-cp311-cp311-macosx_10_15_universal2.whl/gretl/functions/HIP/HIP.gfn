<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="HIP" minver="2025c" lives-in-subdir="true">
<author email="r.lucchetti@univpm.it">Riccardo &quot;Jack&quot; Lucchetti and Claudia Pigini</author>
<version>2025c-git</version>
<date>2023-09-14</date>
<description>Heteroskedastic IV Probit</description>
<tags>C25 C26</tags>
<label>IV/Heteroskedastic</label>
<help>
pdfdoc:HIP.pdf
</help>
<data-files count="1">
examples </data-files>
<gretl-function name="HIP_setup" type="bundle">
 <params count="5">
  <param name="y" type="series"/>
  <param name="EXOG" type="list"/>
  <param name="ENDOG" type="list" optional="true"/>
  <param name="ADDIN" type="list" optional="true"/>
  <param name="HETVAR" type="list" optional="true"/>
 </params>
<code>bundle ret = null

# first, perform a few sanity checks

scalar id = nelem(ENDOG) - nelem(ADDIN)

if (nelem(ADDIN)!=0 &amp;&amp; nelem(ENDOG)==0)
  printf &quot;No endogenous variables specified. Are you sure this is what you want?\n&quot;
  return ret
elif (nelem(ADDIN)==0 &amp;&amp; nelem(ENDOG)!=0)
  scalar w = nelem(ENDOG)
  printf &quot;At least %g additional instruments need to be specified.\n&quot;, w
  return ret
elif (id&gt;0)
  printf &quot;At least %g more instruments are needed. \n&quot;, id
  return ret
endif

# check that there is no constant in HETVAR
list dropped = deflist()
loop while nelem(HETVAR) &gt; 0 --quiet
  ols const HETVAR --quiet
  if $ess &lt; 1.0e-12
    scalar i = imaxc(abs($coeff))
    dropped += HETVAR[i]
    HETVAR = HETVAR[-i]
  else
    break
  endif
endloop
if nelem(dropped)
  printf &quot;%s dropped from HETVAR\n&quot;, flatten(varnames(dropped), &quot;, &quot;)
endif

# then, check that y is a dummy variable
check = isdummy(y) &gt; 0

if check == 0
  printf &quot;%s is not a dummy variable; aborting\n&quot;, argname(y)
  ret[&quot;err&quot;] = 48
  return ret
else
  ret[&quot;err&quot;] = 0
endif

# next, check if HIP is really needed at all

ret[&quot;simple_probit&quot;] = nelem(ENDOG || HETVAR || ADDIN) == 0

ret[&quot;het&quot;] = (nelem(HETVAR)!=0)
ret[&quot;iv&quot;] = (nelem(ADDIN)!=0 &amp;&amp; nelem(ENDOG)!=0)
ret[&quot;vcvmeth&quot;] = 0
ret[&quot;verbose&quot;] = 1
ret[&quot;ntot&quot;] = $nobs
ret[&quot;neff&quot;] = sum(ok(y || EXOG || ENDOG || HETVAR || ADDIN))
ret[&quot;depvar&quot;] = y
ret[&quot;depvarname&quot;] = argname(y)

# Exogenous variables: X_1i
ret[&quot;mk1&quot;] = nelem(EXOG)
ret[&quot;mEXOG&quot;] = { EXOG }
ret[&quot;mEXOGnames&quot;] = varname(EXOG)

# Endogenous variables: Y_i
ret[&quot;mp&quot;] = nelem(ENDOG)
ret[&quot;mENDOG&quot;] = { ENDOG }
ret[&quot;mENDOGnames&quot;] = varname(ENDOG)

# Additional instruments: X_2i
ret[&quot;mk2&quot;] = nelem(ADDIN)
ret[&quot;mADDIN&quot;] = { ADDIN }
ret[&quot;mADDINnames&quot;] = varname(ADDIN)

# Heteros. variables: W_i
ret[&quot;mq&quot;] = nelem(HETVAR)
ret[&quot;mHETVAR&quot;] = { HETVAR }
ret[&quot;mHETVARnames&quot;] = varname(HETVAR)

# Total regressors in main equation
list Z = EXOG ENDOG
ret[&quot;mh&quot;] = ret[&quot;mk1&quot;] + ret[&quot;mp&quot;]
ret[&quot;mZ&quot;] = { Z }
ret[&quot;mZnames&quot;] = varname(Z)

# Total instruments
list X = EXOG || ADDIN
ret[&quot;mk&quot;] = ret[&quot;mk1&quot;] + ret[&quot;mk2&quot;]
ret[&quot;mX&quot;] = { X }
ret[&quot;mXnames&quot;] = varname(X)

matrix Q = InitParm(&amp;ret)
ret[&quot;theta&quot;] = Q[,1]

return ret
</code>
</gretl-function>
<gretl-function name="HIP_estimate" type="scalar">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>series y = b[&quot;depvar&quot;]
matrix EXOG   = b[&quot;mEXOG&quot;]
matrix ENDOG  = b[&quot;mENDOG&quot;]
matrix ADDIN  = b[&quot;mADDIN&quot;]
matrix HETVAR = b[&quot;mHETVAR&quot;]
scalar iv = b[&quot;iv&quot;]

scalar k1 = b[&quot;mk1&quot;]
scalar k2 = b[&quot;mk2&quot;]
scalar p =  b[&quot;mp&quot;]
scalar q =  b[&quot;mq&quot;]

scalar s = b[&quot;vcvmeth&quot;]
scalar verbose = b[&quot;verbose&quot;]

# handle options for MLE

if (verbose==3)
  setopt mle --verbose
else
  setopt mle --quiet
endif

if (s==1)
  setopt mle --hessian
elif (s==2)
  setopt mle --robust
endif

matrix theta = b[&quot;theta&quot;]
set warnings off

matrix beta = {}
matrix alpha = {}
matrix Pi = {}
matrix psi = {}
matrix C = {}

series llik = NA
series sigma = NA
matrix omega = {}
matrix SCORE = {}

# guard against weird initialisation in the conditional

start_ok = 0
iters = 0
loop while (start_ok == 0) &amp;&amp; (iters&lt;10) --quiet
  iters++
  scalar err = HIP_params_shape(&amp;theta, &amp;beta, &amp;alpha, &amp;Pi, &amp;psi, &amp;C, k1, k2, p, q)

  scalar err = HIP_loglik(y, &amp;EXOG, &amp;ENDOG, &amp;ADDIN, &amp;HETVAR, &amp;beta, &amp;alpha, &amp;Pi, &amp;psi, &amp;C, &amp;llik, &amp;omega, &amp;sigma)

  if err == 4
    theta[1:(k1+k2)] = theta[1:(k1+k2)] ./ 2
    printf &quot;Brrr! Halving params\n&quot;
  else
    start_ok = 1
  endif
endloop

if iters==10
  printf &quot;Man, these data are weird! Giving up.\n&quot;
  return 101
endif

SCORE = {}

catch mle ll = llik
  scalar err = HIP_params_shape(&amp;theta, &amp;beta, &amp;alpha, &amp;Pi, &amp;psi, &amp;C, k1, k2, p, q)
  scalar err = HIP_loglik(y, &amp;EXOG, &amp;ENDOG, &amp;ADDIN, &amp;HETVAR, &amp;beta, &amp;alpha, &amp;Pi, &amp;psi, &amp;C, &amp;llik, &amp;omega, &amp;sigma)
  SCORE = err ? zeros(1,rows(theta)) : HIP_Score(y, &amp;EXOG, &amp;ENDOG, &amp;ADDIN, &amp;HETVAR, &amp;beta, &amp;alpha, &amp;Pi, &amp;psi, &amp;C, &amp;omega, &amp;sigma)

  deriv theta = SCORE
end mle

errcode = $error
b[&quot;errcode&quot;] = $error

if errcode == 0
  matrix V = $vcv
  b[&quot;theta&quot;] = theta
  b[&quot;VCVtheta&quot;] = V

  if s==1
    b[&quot;vcvmeth&quot;] = &quot;Hessian&quot;
  elif s==2
    b[&quot;vcvmeth&quot;] = &quot;Sandwich&quot;
  else
    b[&quot;vcvmeth&quot;] = &quot;OPG&quot;
  endif

  if iv
    matrix X = EXOG ~ ADDIN
    scalar J = rescale_results(&amp;b, &amp;theta, &amp;V, &amp;SCORE)
    scalar ll_m  = sum(loglik_m(&amp;ENDOG, &amp;X, &amp;Pi, &amp;C, &amp;omega))
    b[&quot;lnl1m&quot;] = ll_m  - J
    b[&quot;theta&quot;] = theta
    b[&quot;VCVtheta&quot;] = V
  else
    scalar J = 0
    ll_m = 0
  endif

  b[&quot;T&quot;] = $T
  b[&quot;t1&quot;] = $t1
  b[&quot;t2&quot;] = $t2

  b[&quot;llt&quot;] = llik - J
  J = J*b[&quot;T&quot;]
  b[&quot;lnl1&quot;] = $lnl - J

  b[&quot;lnl1c&quot;] = $lnl - ll_m
  b[&quot;infocrit&quot;] = ($aic ~ $bic ~ $hqc) + 2*J

  b[&quot;SCORE&quot;] = SCORE

  HIP_diagnostics(&amp;b)
else
  printf &quot;errcode = %d\n&quot;, errcode
endif

return errcode
</code>
</gretl-function>
<gretl-function name="HIP_printout" type="void" pkg-role="bundle-print">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>scalar k1 = b[&quot;mk1&quot;]
scalar k2 = b[&quot;mk2&quot;]
scalar p =  b[&quot;mp&quot;]
scalar q =  b[&quot;mq&quot;]
scalar v =  b[&quot;verbose&quot;]

theta = b[&quot;theta&quot;]
matrix beta = {}
matrix alpha = {}
matrix Pi = {}
matrix psi = {}
matrix C = {}
err = HIP_params_shape(&amp;theta, &amp;beta, &amp;alpha, &amp;Pi, &amp;psi, &amp;C, k1, k2, p, q)

stderr = sqrt(diag(b[&quot;VCVtheta&quot;]))

matrix sd_beta = {}
matrix sd_alpha = {}
matrix sd_Pi = {}
matrix sd_psi = {}
matrix sd_C = {}
err = HIP_params_shape(&amp;stderr, &amp;sd_beta, &amp;sd_alpha, &amp;sd_Pi, &amp;sd_psi, &amp;sd_C, k1, k2, p, q)

scalar iv = b[&quot;iv&quot;]
scalar het = b[&quot;het&quot;]
s = b[&quot;vcvmeth&quot;]

matrix V = alpha ~ sd_alpha

if (het==1 &amp;&amp; iv==1)
  printf &quot;Heteroskedastic probit model with endogenous regressors\n&quot;
elif (het==0 &amp;&amp; iv==1)
  printf &quot;Probit model with endogenous regressors\n&quot;
elif (het==1 &amp;&amp; iv==0)
  printf &quot;Heteroskedastic probit model \n&quot;
else
  printf &quot;Probit model \n&quot;
endif

printf &quot;ML, using observations %d-%d\n&quot;, b[&quot;t1&quot;], b[&quot;t2&quot;]

string depvar = b[&quot;depvarname&quot;]
printf &quot;Dependent Variable: @depvar \n&quot;
if iv
  string endog = b[&quot;mENDOGnames&quot;]
  string inst_names = b[&quot;mXnames&quot;]
  printf &quot;Instrumented: %s\n&quot;, strsub(endog, &quot;,&quot;, &quot;, &quot;)
  printf &quot;Instruments: %s \n&quot;, strsub(inst_names, &quot;,&quot;, &quot;, &quot;)
endif

printf &quot;Parameter covariance matrix: %s\n&quot;, b[&quot;vcvmeth&quot;]

mnames = b[&quot;mZnames&quot;]
matrix M = beta ~ sd_beta
modprint M mnames

if het
  printf &quot;Variance \n&quot;
  mnames = b[&quot;mHETVARnames&quot;]
  modprint V mnames
endif

if v&gt;1 &amp;&amp;  iv
  p = b[&quot;mp&quot;]
  printf &quot;\&quot;First-stage\&quot; regressions\n&quot;
  loop i=1..p -q
    matrix K = Pi[,$i] ~ sd_Pi[,$i]
    modprint K inst_names
  endloop
endif
infocrit = b[&quot;infocrit&quot;]
printf &quot;Log-likelihood   %14.4f  Akaike criterion %12.4f\n&quot;, b[&quot;lnl1&quot;], infocrit[1]
printf &quot;Schwarz criterion  %12.4f  Hannan-Quinn   %14.4f\n&quot;, infocrit[2], infocrit[3]
if iv
  printf &quot;Conditional ll     %12.6f  Cragg-Donald stat. %10.3f\n\n&quot;, b[&quot;lnl1c&quot;], b[&quot;CraggDonald&quot;]
else
  printf &quot;\n&quot;
endif

WT = b[&quot;WaldAll&quot;]
printf &quot;Overall test (Wald) = %g (%d df, p-value = %6.4f)\n&quot;, WT[1], WT[2], WT[3]

if !(iv || het) # ordinary probit
  CI = b[&quot;normtest&quot;]
  printf &quot;Chesher and Irish normality test = %g (%d df, p-value = %6.4f)\n&quot;, CI[1], CI[2], CI[3]
endif

if iv
  WT = b[&quot;WaldEnd&quot;]
  printf &quot;Endogeneity test (Wald) = %g (%d df, p-value = %6.4f)\n&quot;, WT[1], WT[2], WT[3]
  if (k2&gt;p)
    LM = b[&quot;LMOverid&quot;]
    printf &quot;Test for overidentifying restrictions (LM) = %g (%d df, p-value = %6.4f)\n&quot;, LM[1], LM[2], LM[3]
  endif
endif

if het
  T = b[&quot;HETtest&quot;]
  if iv
    printf &quot;Heteroskedasticity test (Wald) = %g (%d df, p-value = %6.4f)\n&quot;, T[1], T[2], T[3]
  else
    printf &quot;Heteroskedasticity test (LR) = %g (%d df, p-value = %6.4f)\n&quot;, T[1], T[2], T[3]

    CI = b[&quot;normtest&quot;]
    printf &quot;Chesher and Irish normality test = %g (%d df, p-value = %6.4f)\n&quot;, CI[1], CI[2], CI[3]
  endif

endif
</code>
</gretl-function>
<gretl-function name="HIP_setoption" type="scalar">
 <params count="3">
  <param name="b" type="bundleref"/>
  <param name="opt" type="string"/>
  <param name="value" type="scalar"/>
 </params>
<code>err = 0

if opt==&quot;verbose&quot;
  if (value &lt; 0) || (value &gt; 3)
    err = 1
  else
    b[&quot;verbose&quot;] = value
  endif
elif opt==&quot;vcvmeth&quot;
  if (value &lt; 0) || (value &gt; 2)
    err = 2
  else
    b[&quot;vcvmeth&quot;] = value
  endif
else
  err = 3
endif

if err&gt;0
  printf &quot;Warning in HIP_setoption\n&quot;
  if err &lt; 3
    printf &quot;Illegal value %s = %d\n&quot;, opt, value
  else
    printf &quot;%s unrecognised option\n&quot;, opt
  endif
endif

return err
</code>
</gretl-function>
<gretl-function name="HIP" type="bundle" pkg-role="gui-main">
 <params count="7">
  <param name="y" type="series">
<description>Dependent variable</description>
  </param>
  <param name="EXOG" type="list">
<description>Exogenous variables</description>
  </param>
  <param name="ENDOG" type="list" optional="true">
<description>Endogenous variables</description>
  </param>
  <param name="ADDIN" type="list" optional="true">
<description>Instruments</description>
  </param>
  <param name="HETVAR" type="list" optional="true">
<description>Variance regressors</description>
  </param>
  <param name="v" type="int" min="0" max="3" default="1">
<description>Verbosity level</description>
  </param>
  <param name="s" type="int" min="0" max="2" default="0">
<description>Covariance matrix estimation</description>
<labels count="3">
"OPG" "Hessian" "Sandwich" </labels>
  </param>
 </params>
<code># first thing, drop all obs with missing values anywhere
list EVERYTHING = y || EXOG || ENDOG || ADDIN || HETVAR
smpl EVERYTHING --no-missing

# first, force the constant to be the first exogenous variable
EXOG = EXOG - const
EXOG = const EXOG

# let the dance begin
set warnings off

bundle b = HIP_setup(y, EXOG, ENDOG, ADDIN, HETVAR)

if exists(b)
  if v != 1
    HIP_setoption(&amp;b, &quot;verbose&quot;, v)
  endif

  if s != 0
    HIP_setoption(&amp;b, &quot;vcvmeth&quot;, s)
  endif

  b[&quot;depvarname&quot;] = argname(y)
  err = b[&quot;err&quot;]
  if ! err
    err = HIP_estimate(&amp;b)
  endif

  if !err
    if v &gt; 0
      HIP_printout(&amp;b)
    else
      printf &quot;Done.\n&quot;
    endif
  else
    printf &quot;Error = %s\n&quot;, errmsg(err)
  endif
endif

return b
</code>
</gretl-function>
<gretl-function name="HIP_params_shape" type="scalar" private="1">
 <params count="10">
  <param name="theta" type="matrixref"/>
  <param name="beta" type="matrixref"/>
  <param name="alpha" type="matrixref"/>
  <param name="Pi" type="matrixref"/>
  <param name="psi" type="matrixref"/>
  <param name="C" type="matrixref"/>
  <param name="k1" type="scalar"/>
  <param name="k2" type="scalar"/>
  <param name="p" type="scalar"/>
  <param name="q" type="scalar"/>
 </params>
<code>scalar h = k1 + p + q
matrix beta = theta[1: k1+p]

if q &gt; 0
  matrix alpha = theta[k1+p+1:h]
endif

if (p!=0)
  scalar k = k1+k2
  Pi = mshape(theta[h+1 : h+p*k],k,p)
  matrix psi = theta[h+p*k+1:h + p*(k+1),]
  matrix C = lower(unvech(theta[h+p*(k+1)+1:,]))
else
  Pi = {}
  psi = {}
  C = {}
endif

return 0
</code>
</gretl-function>
<gretl-function name="EndoVarNormalize" type="matrix" private="1">
 <params count="1">
  <param name="E" type="matrix" const="true"/>
 </params>
<code>matrix s = diag(mcov(E))
scalar h = 0.5
s = s .^ h
return s
</code>
</gretl-function>
<gretl-function name="ExoVarNormalize" type="matrix" private="1">
 <params count="1">
  <param name="X" type="matrix" const="true"/>
 </params>
<code># we exclude from the treatment the constant
# and the dummy variables

k = cols(X)
s = ones(k,1)
matrix chk = minc((X .= 0) + (X .= 1))
matrix   s = chk + (1-chk) .* sdc(X)
return s'
</code>
</gretl-function>
<gretl-function name="CraggDonald" type="scalar" private="1">
 <params count="4">
  <param name="Sigma" type="matrix" const="true"/>
  <param name="Y" type="matrix" const="true"/>
  <param name="X" type="matrix" const="true"/>
  <param name="Z" type="matrix" const="true"/>
 </params>
<code># p = cols(Y)
matrix U = {}
mols(Z, X, &amp;U)
B = mols(Y, U)
matrix l = eigsolve((Y'U) * B, Sigma)
return minc(l)/cols(Z)
</code>
</gretl-function>
<gretl-function name="InitProbit" type="matrix" private="1">
 <params count="3">
  <param name="y" type="series"/>
  <param name="W" type="list"/>
  <param name="err" type="scalarref"/>
 </params>
<code>scalar k = nelem(W)
catch probit y W --quiet	# here we can run into the perfect-prediction problem
err = $error
if err == 0
  list DROPPED = W - $xlist
  # handle some failures
  if nelem(DROPPED) &gt;0
    printf &quot;The variable(s) %s were dropped\n&quot;, varname(DROPPED)
    printf &quot;Initializing to zeros and hoping for the best.\n&quot;
    matrix beta = zeros(k,1)
  else
    matrix beta = $coeff
  endif
  ret = $lnl | beta
else
  printf &quot;Warning: probit returned error %d (%s)\n&quot;, err, errmsg(err)
  printf &quot;This is weird and disturbing.\n&quot;
  ret = {NA} | zeros(k,1)
endif

return ret
</code>
</gretl-function>
<gretl-function name="InitParm" type="matrix" private="1">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>matrix HETVAR = b[&quot;mHETVAR&quot;]
matrix ENDOG = b[&quot;mENDOG&quot;]
matrix Z = b[&quot;mZ&quot;] # total regressors
matrix X = b[&quot;mX&quot;] # total instruments
series y = b[&quot;depvar&quot;]
scalar k1 = b[&quot;mk1&quot;]
scalar k = b[&quot;mk&quot;]
scalar p = b[&quot;mp&quot;]
scalar q = b[&quot;mq&quot;]
scalar h = b[&quot;mh&quot;]

scalar het = b[&quot;het&quot;]
scalar iv = b[&quot;iv&quot;]
if $version &lt; 20220
  list W
  loop i=1..h -q
    series z$i = Z[,$i]
    W += z$i
  endloop
else
  list W = mat2list(Z, &quot;z&quot;)
endif

RESCALEX = 0 # Experimental; not for now

if RESCALEX
  matrix rescale = ExoVarNormalize(X[,1:k1])
  b[&quot;rescaleX&quot;] = rescale
  X[,1:k1] = X[,1:k1] ./ rescale'
  b[&quot;mX&quot;] = X
  b[&quot;mEXOG&quot;] = b[&quot;mEXOG&quot;] ./ rescale'
else
  matrix rescale = ones(k1,1)
  b[&quot;rescaleX&quot;] = rescale
endif

matrix E = { }
matrix V_Pi = { }
if iv
  matrix Pi = mols(ENDOG, X, &amp;E, &amp;V_Pi)
  matrix Sigma = mcov(E)

  lambda = CraggDonald(Sigma, ENDOG, b[&quot;mEXOG&quot;], b[&quot;mADDIN&quot;])
  b[&quot;CraggDonald&quot;] = lambda
  if lambda &lt; 1.0e-2
    printf &quot;Weak instruments (lambda = %g); expect trouble.\n&quot;, lambda
  endif

  matrix rescale = EndoVarNormalize(E)
  b[&quot;rescaleY&quot;] = rescale

  if rows(rescale) &gt; 0
    ENDOG = ENDOG ./ rescale'
    b[&quot;mENDOG&quot;] = ENDOG
    Pi = Pi ./ rescale'
    E  = E ./ rescale'
    Sigma = Sigma ./ (rescale .* rescale')
  endif

  b[&quot;uhat&quot;] = E
  loop i=1..p -q
    series e$i = E[,$i]
    W += e$i
  endloop

  matrix C = cholesky(invpd(Sigma))
else
  matrix Pi = {}
  matrix psi = {}
  matrix C = {}
endif

scalar err = 0
##BUG: cambiato il nome da beta a inipar
# (conflitto con il vecchio script)
matrix inipar = InitProbit(y, W, &amp;err)

if err &gt; 0
  print &quot;Initial probit failed (%s). Aborting.&quot;, errmsg(error)
  beta = {}
  scalar b[&quot;lnl0&quot;] = NA
  return beta
else
  scalar b[&quot;lnl0&quot;] = inipar[1]
  matrix beta = inipar[2:h+1]
endif

if het
  series ndx = Z * beta
  series mills = y ? invmills(-ndx) : -invmills(ndx)
  series s2 = -ndx*mills
  alpha = mols(s2 , 1 ~ HETVAR)
  alpha = alpha[2:]
else
  alpha = {}
endif

if iv
  ##BUG
  #gamma = $coeff[h+1: ]
  matrix gamma = inipar[h+2:]
  scalar scale = sqrt(1 + qform(gamma', Sigma))
  matrix beta = beta ./ scale
  matrix psi = inv(C')*gamma ./ scale
endif

theta = beta | alpha | vec(Pi) | psi | vech(C)
return theta
</code>
</gretl-function>
<gretl-function name="rescale_results" type="scalar" private="1">
 <params count="4">
  <param name="mod" type="bundleref"/>
  <param name="theta" type="matrixref"/>
  <param name="vcv" type="matrixref"/>
  <param name="G" type="matrixref"/>
 </params>
<code># used to undo the scaling of the endogenous variables once estimation
# is done; while we're at it, we also compute the Jacobian term to correct
# the loglikelihood by

matrix sY = mod[&quot;rescaleY&quot;]
matrix sX = mod[&quot;rescaleX&quot;]
matrix isY = 1 ./ sY
matrix isX = 1 ./ sX
scalar p = rows(sY)
scalar k1 = mod[&quot;mk1&quot;]
scalar k2 = mod[&quot;mk2&quot;]

if mod[&quot;het&quot;]
  s_a = ones(mod[&quot;mq&quot;],1)
else
  s_a = {}
endif

if mod[&quot;iv&quot;]
  a_Pi = vec( (isX .* sY') | mshape(sY, p, k2)' )
  a_end = ones(p,1) | vech(mshape(isY,p,p)')
else
  a_Pi = {}
  a_end = {}
endif

matrix a = isX | isY | s_a | a_Pi | a_end

theta = theta .* a
vcv   = vcv .* (a .* a')
G     = G ./ a'
#   mod[&quot;mENDOG&quot;] = mod[&quot;mENDOG&quot;] .* sY'

return sumc(ln(sY))
</code>
</gretl-function>
<gretl-function name="loglik_m" type="series" private="1">
 <params count="5">
  <param name="Y" type="matrixref"/>
  <param name="X" type="matrixref"/>
  <param name="Pi" type="matrixref"/>
  <param name="C" type="matrixref"/>
  <param name="ScaledRes" type="matrixref"/>
 </params>
<code># computes the marginal loglikelihood: the argument ScaledRes will
# hold in output the re-scaled residuals (used in the conditional
# loglik)

matrix ScaledRes = (Y - X*Pi) * C
scalar J = sumc(ln(diag(C))) - cols(Y)*.91893853320467274178
return J - 0.5*sumr(ScaledRes .^2)
</code>
</gretl-function>
<gretl-function name="HIP_loglik" type="scalar" private="1">
 <params count="13">
  <param name="y" type="series"/>
  <param name="EXOG" type="matrixref"/>
  <param name="ENDOG" type="matrixref" optional="true"/>
  <param name="ADDIN" type="matrixref" optional="true"/>
  <param name="HETVAR" type="matrixref" optional="true"/>
  <param name="beta" type="matrixref"/>
  <param name="alpha" type="matrixref" optional="true"/>
  <param name="Pi" type="matrixref" optional="true"/>
  <param name="psi" type="matrixref" optional="true"/>
  <param name="C" type="matrixref" optional="true"/>
  <param name="ll" type="seriesref"/>
  <param name="omega" type="matrixref"/>
  <param name="sigma" type="seriesref"/>
 </params>
<code># computes the total loglikelihood: the arguments omega and sigma will
# hold in output the re-scaled residual and the conditional variance
# to avoid re-computing them later (eg for the score matrix); note that
# sigma holds the conditional standard error (NOT the variance)

scalar het = (rows(alpha) &gt; 0)
scalar iv = (rows(Pi) &gt; 0)
series ll = NA
scalar err = 0

# do checks first
if iv
  scalar cVar = 1-psi'psi
  scalar pdCheck = (minc(diag(C)) &gt; 1.0e-8) &amp;&amp; (cVar &gt; 1.0e-20)
  err = pdCheck ? 0 : 1
endif

if het &amp;&amp; !err
  series ndxv = HETVAR * alpha
  scalar cvCheck = (max(ndxv) &lt; 100)
  err = cvCheck ? 0 : 2
endif

if err
  return err
endif

# ok, we should be within 'nice' bounds by now

if iv # compute marginal loglikelihood
  matrix X = EXOG ~ ADDIN
  matrix omega = {}
  series llm = loglik_m(&amp;ENDOG, &amp;X, &amp;Pi, &amp;C, &amp;omega)
  if sum(missing(llm)) &gt; 0
    err = 3
    printf &quot;Problems with marginal loglik!\n&quot;
    return err
  endif
endif

# now compute conditional loglikelihood
# compute 'plain' nu first
series nu = (EXOG ~ ENDOG) * beta

# next, adjust as needed
if het
  series sigma = exp(ndxv)
  series nu = nu / sigma
else
  series sigma = 1
endif

if iv
  series nu = (nu + (omega * psi)) / sqrt(cVar)
endif

# form loglikelihood and add marginal if needed
series ndx = y ? nu : -nu

check = min(ndx)
if check &lt; -35.0
  err = 4
  #	printf &quot;Problems with conditional loglik! min(ndx = %g)\n&quot;, check
  series ll = NA
else
  series ll = ln(cnorm(ndx))
endif

if !err &amp;&amp; iv
  ll += llm
endif

#done
return err
</code>
</gretl-function>
<gretl-function name="HIP_Score" type="matrix" private="1">
 <params count="12">
  <param name="y" type="series"/>
  <param name="EXOG" type="matrixref"/>
  <param name="ENDOG" type="matrixref" optional="true"/>
  <param name="ADDIN" type="matrixref" optional="true"/>
  <param name="HETVAR" type="matrixref" optional="true"/>
  <param name="beta" type="matrixref"/>
  <param name="alpha" type="matrixref" optional="true"/>
  <param name="Pi" type="matrixref" optional="true"/>
  <param name="psi" type="matrixref" optional="true"/>
  <param name="C" type="matrixref" optional="true"/>
  <param name="omega" type="matrixref"/>
  <param name="sigma" type="seriesref"/>
 </params>
<code>scalar het = (rows(alpha) &gt; 0)
scalar p = cols(ENDOG)
scalar iv = (p &gt; 0)
matrix Z = EXOG ~ ENDOG

# build nu first
series ndxm = Z * beta

if het
  series ndxm = ndxm/sigma
endif

if iv
  scalar sigmacond = sqrt(1 - psi'psi)
  series nu = (ndxm + (omega * psi)) / sigmacond
else
  scalar sigmacond = 1
  series nu = ndxm
endif

# the mills ratio
series mills = y ? invmills(-nu) : -invmills(nu)

# now the derivatives wrt nu
series s_beta = mills/(sigmacond * sigma)
matrix S_beta = s_beta .* Z

if het
  series s_alpha = -(ndxm*mills)/sigmacond
  matrix S_alpha =  {s_alpha} .* HETVAR
else
  matrix S_alpha = { }
endif

if iv
  matrix scaledpsi = psi ./ sigmacond
  matrix s_Pi = omega - (mills .* scaledpsi')
  matrix tmp = s_Pi * C'
  matrix X = EXOG ~ ADDIN
  # matrix S_Pi = wkron(&amp;tmp,&amp;X)
  matrix S_Pi = hdprod(tmp, X)

  matrix S_psi = omega + nu .* scaledpsi'
  matrix S_psi = (mills/sigmacond) .* S_psi

  matrix tmp = zeros(p,p)
  tmp[diag] = 1 ./ diag(C)
  tmp = vech(tmp)'
  sel = vech(mshape(seq(1,p*p),p,p)')
  matrix omiC = omega*inv(C)
  # matrix S_dc = wkron(&amp;s_Pi,&amp;omiC)
  matrix S_dc = hdprod(s_Pi, omiC)
  matrix S_dc = tmp .- S_dc[,sel]
else
  matrix S_psi = { }
  matrix S_dc = { }
  matrix S_Pi = { }
endif

ret = (S_beta ~ S_alpha ~ S_Pi ~ S_psi ~ S_dc)
return ret
</code>
</gretl-function>
<gretl-function name="Wald_test" type="matrix" private="1">
 <params count="3">
  <param name="b" type="bundleref"/>
  <param name="ini" type="scalar"/>
  <param name="df" type="scalar"/>
 </params>
<code># it is assumed that the model has already been estimated
# and that the coefficients and the vcv matrix exist

scalar fin = ini + df - 1

theta = b[&quot;theta&quot;]
vtheta = b[&quot;VCVtheta&quot;]

vtheta = vtheta[ini:fin, ini:fin]

matrix WT = qform(theta[ini:fin]', invpd(vtheta))
return (WT  ~ df ~ pvalue(X, df, WT[1]))
</code>
</gretl-function>
<gretl-function name="LM_test" type="matrix" private="1">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>theta = b[&quot;theta&quot;]
k1 = b[&quot;mk1&quot;]
k2 = b[&quot;mk2&quot;]
k = b[&quot;mk&quot;]
p = b[&quot;mp&quot;]
q = b[&quot;mq&quot;]
scalar het = (q&gt;0)

scalar g = k1 + p + q

alpha = theta[1:k1]
delta = theta[k1+1:k1+p]
if het
  gamma = theta[k1+p+1:g]
endif

Pi = mshape(theta[g+1 : g+p*k],k,p)
P1 = Pi[1:k1,]
P2 = Pi[k1+1:k,]
psi = (alpha + P1*delta) | (P2*delta) | delta

X = b[&quot;mX&quot;]
W = b[&quot;mHETVAR&quot;]
V = b[&quot;uhat&quot;]
y = b[&quot;depvar&quot;]

if het
  series ex  = exp(-W*gamma)
  series ndx = {ex} .* ((X ~ V) * psi)
else
  series ndx = (X ~ V) * psi
endif

series mills = y ? invmills(-ndx) : -invmills(ndx)

if het
  matrix S_psi = (mills * ex) .* (X ~ V)
  matrix S_gamma = - mills*ndx .* W
else
  matrix S_psi = mills .* (X ~ V)
  matrix S_gamma = { }
endif

matrix G = S_psi ~ S_gamma

scalar LM = qform(sumc(G),invpd(G'G))
df = k2 - p
return (LM ~ df ~ pvalue(X,df,LM))
</code>
</gretl-function>
<gretl-function name="LR_test" type="matrix" private="1">
 <params count="2">
  <param name="b" type="bundleref"/>
  <param name="df" type="scalar"/>
 </params>
<code>LR = 2*(b[&quot;lnl1&quot;] - b[&quot;lnl0&quot;])
return (LR ~ df ~ pvalue(X,df,LR))
</code>
</gretl-function>
<gretl-function name="CI_test" type="matrix" private="1">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>scalar het = b[&quot;het&quot;]
theta = b[&quot;theta&quot;]
Z = b[&quot;mZ&quot;]
h = b[&quot;mh&quot;]
q = b[&quot;mq&quot;]
W = b[&quot;mHETVAR&quot;]

beta = theta[1:h]
series ndxm = Z * beta
if het
  alpha = theta[h+1:h+q]
  series ndxv = W * alpha
else
  series ndxv = 0
endif

y = b[&quot;depvar&quot;]
series mills = y ? invmills(-ndxm) : -invmills(ndxm)

matrix e3 = exp(3*ndxv)*mills*(2 + ndxm*ndxm)
matrix e4 = -exp(4*ndxv)*mills*ndxm*(3 + ndxm*ndxm)

G = b[&quot;SCORE&quot;]
G = G[,1:h+q] ~ e3 ~ e4
scalar T = qform(sumc(G),invpd(G'G))
return (T ~ 2 ~ pvalue(X,2,T))
</code>
</gretl-function>
<gretl-function name="HIP_diagnostics" type="void" private="1">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>k1 = b[&quot;mk1&quot;]
p = b[&quot;mp&quot;]
h = b[&quot;mh&quot;]
q = b[&quot;mq&quot;]
k = b[&quot;mk&quot;]
het = b[&quot;het&quot;]
iv = b[&quot;iv&quot;]

# Overall test (Wald)
scalar df = k1 + p - 1
scalar ini = 2
WT = Wald_test(&amp;b, ini, df)
b[&quot;WaldAll&quot;] = WT

if iv
  # Endogeneity test (Wald)
  scalar df  = p
  scalar ini = h + q + k*p + 1
  WT = Wald_test(&amp;b, ini, df)
  b[&quot;WaldEnd&quot;] = WT

  if (k&gt;h) # Test of overidentifying restrictions (LM)
    LM = LM_test(&amp;b)
    b[&quot;LMOverid&quot;] = LM
  endif
else
  # Chesher&amp;Irish CM test for normality (unsuitable
  # for IV but ok if HET)
  CI = CI_test(&amp;b)
  b[&quot;normtest&quot;] = CI
endif

# Heteroskedasticity test: Wald if iv, else LR
if het
  if iv
    scalar ini = h + 1
    T = Wald_test(&amp;b, ini, q)
  else
    T = LR_test(&amp;b, q)
  endif
  b[&quot;HETtest&quot;] = T
endif
</code>
</gretl-function>
<sample-script filename="HIP_example.inp">
set verbose off
include HIP.gfn

open mroz87.gdt -q

list EXOG = const WA CIT K618 
list ENDOG = WE
list ADDIN = WMED WFED 
list HETVAR = HW 

Mroz = HIP(LFP, EXOG, ENDOG, ADDIN, HETVAR, 2, 0)
</sample-script>
</gretl-function-package>
</gretl-functions>
