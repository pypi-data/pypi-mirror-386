\item {optimization [{string}]}: selects the type of optimization
\item {name [{string}]}: contains the title of the problem, used for display purposes.
\item {verbose [{boolean}]}: If set to {True} \HYGO displays relevant information on the optimization process.
\item {MaxTries [{integer}]}: Maximum number of operations to create/evolve an individual. Useful when setting the {remove_duplicates} attribute to {True}.
\item {plotter [{function}(HYGO_object)]}: python function that includes as a single input the HYGO object. Custom function that allows to plot anything the user wants. Called upon the termination of the optimization.
\item {batch_evaluation [{boolean}]}: If set to {True}, the cost function will receive the parameters of {batch_size} number of individuals, enabling parallel computing to enhance evaluation times.
\item {batch_size [{integer}]}: number of individuals' parameters sent to the cost function at the same time. The cost function will receive a list with {batch_size} elements, each of which is an individual parameter. It is set to 1 by default.
\item {pop_size [{integer}]}: Individuals per generation. It can be a natural number, setting the same population size for all generations, of a list containing the population size per generation (its size must agree with {n_gen}). 
\item {ngen [{integer}]}: number of generations.
\item {repetitions [{integer}]}: number of times an individual will be evaluated. Introduced to accommodate optimizations where the evaluation of an individual incorporates uncertainty.
\item {uncertainty [{float}]}: value above which the difference between repetitions labels an individual as not valid. Introduced as a floating point percentage: 5\%=0.05.
\item {repeat_indivs_outside_uncertainty [{boolean}]}: if set to {True}, the individuals that have been found not valid will be evaluated one more time to try and get them inside the uncertainty threshold.
\item {badvalue [{float}]}: cost value assigned to invalid individuals, usually taken as $10^36$.
\item {remove_duplicates [{boolean}]}: individuals are re-generated a maximum of {MaxTries} if after an operation, the offspring already exists.
\item {force_individuals [{boolean}]}: if set to {True} the function\\ {individual_forced_generator} will be called when creating the first generation. This function enables the initialization of a desired number of individuals (not necessarily the complete population) with user-defined parameters. If set to {False} the initialization can be: 1. \texttt{random}: the individuals of the first generation will have random parameters. 2. \texttt{LatinHypercube}: Latin Hypercube initializes a predefined number of individuals.
\item {validity [{function}]}: optional attribute. A function used to determine if an individual is valid or not valid. A non-valid individual will be assigned a {badvalue}. It must only return one output, {True} if the individual is valid and {False} if not. It has two inputs: 1. {HYGO_parameters}: object of the Plant {Parameters}, it may be useful for some computations 2. {parameters}: it is a list with the individual's parameters to assess the validity of an individual.
\item {cost_function [{function}]}: cost function of the problem. It must have three inputs: 1. {parameters}: it is a list with the individual's parameters to be evaluated. 2. {HYGO_parameters}: object of the Plant {Parameters}, it may be useful for some computations 3. {path}: path for storing individual-specific information.This function must also have two outputs: 1. {J [{float}]}: a float with the cost value of the individual. It {must} be a single float value 2. {J_values [{list}]}: a list with data that might have been useful for the cost estimation and the user wants to save. User-oriented data not employed by the algorithm.
\item {individual_paths [{boolean}]}: if {True}, each individual will have an assigned folder of the form {output/geni/repj/individualk} where information is saved. It is useful if the cost function requires file loading. If the individual folders do not exist, they will be created. 
\item {security_backup [{boolean}]}: A population object will be saved after each individual is evaluated to make sure that no information is lost.
\item {Nb_bits [{integer}]}: number of bits utilized to represent {each} parameter. If represented by an integer, all parameters will have the same number of bits. If it is a list, it must only include integers and have the same length as the number of parameters since it includes the number of bits representing each parameter (in order). The possible values of each parameter will be a list between the maximum and minimum values selected with length equal to {$2^{Nb_bits}$} due to the properties of binary encoding.
\item {params_range [{list}]}: a list that includes the minimum and maximum values for each parameter which must be introduced in order as a set of 2 element lists.
\item {N_params [{integer}]}: number of optimization parameters.
\item {custom_parameters [{list}]}: This refers to a list of functions that modify the representation of the Chromosome of each parameter set. By default, parameters are represented as equally spaced values within a range, but if a different distribution is required, this can be customized using this parameter. The list must have a length equal to the number of parameters, where each index corresponds to a specific parameter. To customize a parameter's distribution, include a function at its corresponding index. This function should take the parameter value as input and return the modified value. If a parameter does not require modification, set the corresponding index to None. For example, if a parameter must only take integer values between 1 and 6, the default bit-array representation might generate a vector like $[1,1.71,2.43,3.14,3.86,4.57,5.29,6]$, which includes non-integer values. To address this, a function could be introduced to round each value to the nearest integer. This way, multiple chromosomes (e.g., those representing 1.71 and 2.43) would map to the integer value 2, allowing finer control over the parameter's representation and distribution.
\item {check_convergence [{boolean}]}: if set to {True}, convergence is checked after each generation.
\item {check_type [{string}]}: name of the check_convergence method to be used. The implemented methods are: 1. \texttt{interval}: Convergence is reached if an individual is several intervals away from the global minima in {all} parameters. An interval is the distance between two consecutive possible choices for a parameter. It is the separation defined with the minimum and maximum parameter's values, together with the number of bits $interval=(maximum - minimum)/2^{Nbits}-1$. It is checked for all parameters and must be satisfied for all of them to consider Convergence. In other words, a sphere of radius equal to predefined number intervals and centered in the global minima satisfy Convergence. The parameters ninterval and global_minima are used to specify the values. 2. \texttt{Neval}: Comes into play if the user sets a maximum number of evaluations. It might be helpful when Exploitation is permitted since the evaluation number is not a simple addition of the individuals per generation. The parameter {neval} specifies this maximum value. 3. \texttt{Relative_change}: Enables considering Convergence if the cost has not evolved significantly in a selected number of iterations. It utilizes $(J^{max}-J^{min})/J^{min}<threshold$ to check if, in the selected number of individuals, the populations' cost has changed less than a user-defined threshold. Parameters {check_n} and {threshold_convergence} control this methodology. 4. \texttt{Generation_change}: Works similarly as the \texttt{Relative_change} convergence checker method but, instead of comparing the last {check_n} individuals, the best cost of the latest {generations_stuck} generations is checked. If the same value is present in those generations, Convergence is assumed. The parameter {generations_stuck} is used for this method.
\item {ninterval [{integer}]}: number of intervals away from the global minima that are considered for Convergence in the interval convergence type.
\item {global_minima [list]}: global minima of the cost function for Convergence in the interval convergence type.
\item {neval [{integer}]}: maximum number of evaluations for Convergence in the Neval convergence type.
\item {check_n [{integer}]}: number of individuals taken to see if the cost has evolved sufficiently. Employs the last {check_n} individuals added to the {HYGO.table}.
\item {threshold_convergence [{float}]}: relative change between the minimum and maximum values of the cost in the last {check_n} individuals to consider Convergence. It must be introduced in \%.
\item {generations_stuck [{integer}]}: number of generations that will be taken into account to see if the cost has not evolved.
\item {limit_evaluations [{boolean}]}: if set to {True} the number of individuals evaluated will be stopped after {neval} number of individuals. This allows us to limit the number of evaluations and set other convergence criteria.
\item {tournament_size [{integer}]}: number of individuals that form the tournament used when creating the next generation.
\item {p_tour [{float}]}: probability for using an individual in the tournament in a selected operation.
\item {N_elitism [{integer}]}: number of individuals that are carried over to the next generation by the elitism operation.
\item {crossover_points [{integer}]}: number of divisions made in the crossover operation.
\item {crossover_mix [{boolean}]}: if set to {True}, the crossover operation will switch the crossed portions of the Chromosome. If {False}, the individual from which a section of the Chromosome is selected is random, which may lead to an offspring having several sections of the same parent.
\item {mutation_type [{string}]}: mutation type applied to the mutation operatio
\item {mutation_rate [{float}]}: probability of bit mutation expressed between 0 and 1 (5\% = 0.05).
\item {p_replication [{float}]}: the probability of creating an individual by Replication in the next generation. Expressed between 0 and 1 (5\% = 0.05).
\item {p_crossover [{float}]}: probability of creating an individual by Crossover in the next generation. Expressed between 0 and 1 (5\% = 0.05).
\item {p_mutation [{float}]}: probability of creating an individual by mutation in the next generation. Expressed between 0 and 1 (5\% = 0.05).
\item {initialization [{string}]}: if the {force_individuals} parameter is set to {False} this parameter serves to select the initialization type: \texttt{random} or \texttt{LatinHypercube}.
\item {LatinN [{integer}]}: selects the number of individuals that will be created with the Latin hypercube initialization
\item {exploitation [{boolean}]}: if set to {True}, the selected exploitation method will be performed at the end of every generation.
\item {ExploitationType [{string}]}: selects the type of Exploitation.
\item {MaxSimplexCycles [{integer}]}: maximum number of cycles that the Downhill simplex exploitation can perform in a generation.
\item {SimplexSize [{integer}]}: size of the simplex. DSM theory recommends setting it as {N_params+1}.
\item {SimplexPool [{string}]}: selects the individuals considered to build the simplex. It can be {Population} only to consider the individuals of the current generation, or {All} to consider all evaluated individuals.
\item {SimplexOffspring [{integer}]}: number of individuals generated by the Exploitation in each generation.
\item {Simplexinitialisation [{string}]}: selects how the method for building the first Simplex in each generation. It can be: 1. \texttt{BestN}: With the best N (N=simplex size) individuals of the population or all evaluations. 2. \texttt{ClosestN}: closest N individuals (geometrically) to the best individual of thPopulationon or all evaluations.
\item {SimplexCycleChecker [{integer}]}: number of simplex cycles after which the algorithm checks if the Simplex is fixed in a hyperplane of {N_params-1} (or lower) dimensions.
\item {Simplex_R2 [{float}]}: R2 criterion threshold to consider that a selected number of simplexes have been in the same hyperplane.
\item {Simplex_intervals_movement [{integer}]}: number of intervals (defined in the convergence criterion) that a new individual is created away from the centroid. This creation occurs in the perpendicular direction to a found hyperplane.
\item {Simplex_intervals_random_movement [{integer}]}: number of intervals that a new individual is created away from the centroid if the Simplex has not changed in {SimplexCycleChecker} cycles. This movement is performed in a random direction.
\item {reflection_alpha [{float}]}: parameter to compute the reflection operation in the Downhill simplex method. Recommended to be taken as 1.
\item {expansion_gamma [{float}]}: parameter to compute the expansion operation in the Downhill simplex method. Recommended to be taken as 2.
\item {contraction_rho [{float}]}: parameter to compute the contraction operation in the Downhill simplex method. Recommended to be taken as 0.5.
\item {shrinkage_sigma [{float}]}: parameter to compute the shrinkage operation in the Downhill simplex method. Recommended to be taken as 0.5. {Prameters specific to Genetic Programming}
\item {operations [{dictionary}]}: dictionary containing the operations, with the expression format that will be interpreted by Python's {eval} functionality, and the simplification conditions.
\item {precission [{integer}]}: number of decimals the control law will be approximated to.
\item {control_output [{integer}]}: number of control laws each individual will contain.
\item {control_input [{integer}]}: number of input sensors the problem can have.
\item {variable_registers [{integer}]}: number of variable registers apart from the number of output registers.
\item {constant_registers [{integer}]}: number isregisters apart from the number of output registers.
\item {number_operations [{integer}]}: number of operations available for the problem. The maximum number of operations are the ones defined in {operations}. Selecting a lower number of operations will cause only consider the first {number_operations} defined.
\item {Ninstructions_initial_min [{integer}]}: minimum number of instructions an individual can contain after intron elimination for the first generation. If violated, the individual will be re-generated.
\item {Ninstructions_initial_max [{integer}]}: maximum number of instructions an individual can contain after intron elimination for the first generation. If violated, the individual will be re-generated.
\item {Minimum_instructions [{integer}]}: overall minimum number of instructions an individual can have. If not satisfied, the individual is re-generated.
\item {Max_instructions [{integer}]}: overall maximum number of instructions an individual can have. If not satisfied, the individual is re-generated.
\item {Max_eval_time [{float}]}: parameter employed to control the time integration time for the control problem.
\item {N_control_points [{integer}]}: length of the control points employed to compare individuals and re-generate their instruction matrix.
\item {Sensor_range [{list}]}: $N_{sensors}\times 2$ list containing the minimum and maximum values each sensor can have.
\item {Control_range [{list}]}: $N_{laws}\times 2$ list containing the maximum control for each law. Each control law is tested in the {CotrolPoints}. The individual is re-generated if the control output of any of the laws violates this constraint.
\item {SimplexInterpolation [{boolean}]}: If set to {True}, the Subplex methodology is implemented. If not, the DSM methodology employs the {ControlPoints} specific to each individual for the operations.
\item {reconstruction_neval [{integer}]}: number of individuals employed in the secondary optimization to reconstruct the instruction matrix of a Subplex individual.
\item {reconstruction_pop_size [{integer}]}: population size in the secondary optimization to reconstruct the instruction matrix of a Subplex individual.
\item {registers [{list}]}: initial register common to all individuals. The terminology for the sensors and constant registers must be maintained.
\item {register_size [{integer}]}: length of the {registers} parameter.
\item {variable_registers [{integer}]}: total number of variable registers (output, sensors, and memory registers).
\item {ControlPoints [{list}]}: $N_{laws}\times N_control_points$ list containing the {ControlPoints} used to test the individuals.
\item {Scipy_method [{str}]}: optimization method selected from scipy.optimize (Not all methods may be implemented).
\item {Scipy_Initial_Condition [{str}]}: Initial condition for the optimization.
\item {Scipy_options [{dict}]}: Dictionary containing extra options for the optimization.
\item {Scipy_force_evaluate [{bool}]}: Employed to force individuals close to each other to re-evaluate, essential in gradient based solvers.