Metadata-Version: 2.4
Name: dsf-quantum-sdk
Version: 1.0.4
Summary: Lightweight SDK for DSF Quantum Adaptive Scoring with IBM Quantum support
Home-page: https://github.com/jaimeajl/dsf-quantum-sdk
Author: Jaime Alexander Jimenez
Author-email: contacto@softwarefinanzas.com.co
Project-URL: Bug Tracker, https://github.com/jaimeajl/dsf-quantum-sdk/issues
Project-URL: Documentation, https://docs.jaimeajl.com/dsf-quantum-sdk
Project-URL: Source Code, https://github.com/jaimeajl/dsf-quantum-sdk
Project-URL: Examples, https://github.com/jaimeajl/dsf-quantum-sdk/tree/main/examples
Keywords: quantum,quantum computing,ibm quantum,qiskit,adaptive scoring,hierarchical evaluation,quantum amplitude estimation,qae,dsf,decision support,machine learning
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Science/Research
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Scientific/Engineering :: Physics
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Classifier: License :: Other/Proprietary License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Operating System :: OS Independent
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: requests>=2.25.0
Provides-Extra: dev
Requires-Dist: pytest>=7.0; extra == "dev"
Requires-Dist: pytest-cov>=3.0; extra == "dev"
Requires-Dist: black>=22.0; extra == "dev"
Requires-Dist: flake8>=4.0; extra == "dev"
Requires-Dist: mypy>=0.950; extra == "dev"
Requires-Dist: pytest-asyncio>=0.18; extra == "dev"
Dynamic: author
Dynamic: author-email
Dynamic: classifier
Dynamic: description
Dynamic: description-content-type
Dynamic: home-page
Dynamic: keywords
Dynamic: license-file
Dynamic: project-url
Dynamic: provides-extra
Dynamic: requires-dist
Dynamic: requires-python
Dynamic: summary

Ôªø# DSF Quantum SDK

Reduce costos y complejidad en evaluaci√≥n de inferencias cu√°nticas mediante simulaci√≥n adaptativa y compilaci√≥n inteligente.
Ejecuta y valida workloads h√≠bridos 10√ó m√°s r√°pido con m√≠nima sobrecarga.

## üöÄ Why DSF Quantum?

Los entornos cu√°nticos tradicionales requieren acceso costoso a hardware QPU y tiempos de espera prolongados.
DSF Quantum SDK encapsula la l√≥gica de evaluaci√≥n, simulaci√≥n y compilaci√≥n en una capa unificada que permite:

- Simular, evaluar y compilar circuitos cu√°nticos desde c√≥digo Python o remoto.
- Reducir pruebas reales en hardware mediante simuladores inteligentes.
- Optimizar pipelines h√≠bridos con inferencias aceleradas en CPU/GPU.

## üìö Core Concepts

- **Adaptive Simulation** ‚Äì Ejecuta circuitos cu√°nticos de forma incremental con reducci√≥n adaptativa de ruido.
- **Config-as-topology** ‚Äì Define tus qubits, compuertas y prioridades en forma declarativa.
- **Quantum Compilation** ‚Äì Convierte circuitos de alto nivel en representaciones optimizadas (QASM, Tensor, o BinaryGraph).
- **Hybrid Evaluation** ‚Äì Conecta resultados cl√°sicos y cu√°nticos dentro de un mismo pipeline.
- **Enterprise**: incluye soporte para "quantum workers" distribuidos y compilaci√≥n hacia hardware real o simuladores especializados.

## üì¶ Installation

```bash
pip install dsf-quantum-sdk
```

Opcionalmente, apunta el SDK hacia tu backend:

```python
import os
from dsf_quantum_sdk import QuantumSDK

sdk = QuantumSDK(
    base_url=os.getenv("DSF_QUANTUM_BASE_URL"),  # e.g. https://dsf-quantum-api.vercel.app
    tier="community"
)
```

## üéØ Quick Start

### Community

```python
from dsf_quantum_sdk import QuantumSDK

sdk = QuantumSDK()  # tier community por defecto

# Crear un circuito b√°sico
circuit = sdk.create_circuit()
circuit.add_qubit('q0')
circuit.add_gate('H', targets=['q0'])
circuit.add_measure('q0')

# Simular localmente
result = sdk.simulate(circuit)
print("Probabilidades:", result['probabilities'])
```

### Professional

```python
from dsf_quantum_sdk import QuantumSDK

sdk = QuantumSDK(license_key="PRO-2026-12-31-XXXX", tier="professional")

circuit = (sdk.create_circuit()
    .add_qubit('q0')
    .add_qubit('q1')
    .add_gate('H', targets=['q0'])
    .add_gate('CX', targets=['q0','q1'])
    .add_measure('q0')
    .add_measure('q1')
)

# Evaluar en batch (hasta 1000 simulaciones)
experiments = [circuit.to_dict() for _ in range(10)]
scores = sdk.batch_simulate(experiments)
print("Resultados batch:", scores)
```

### Enterprise

```python
from dsf_quantum_sdk import QuantumSDK

sdk = QuantumSDK(license_key="ENT-2026-12-31-XXXX", tier="enterprise")

# Compilaci√≥n + ejecuci√≥n h√≠brida
circuit = (sdk.create_circuit()
    .add_qubit('q0')
    .add_qubit('q1')
    .add_gate('H', targets=['q0'])
    .add_gate('CX', targets=['q0','q1'])
    .add_measure('q0')
    .add_measure('q1')
)

compiled = sdk.compile(circuit, target="qasm")
hybrid_result = sdk.hybrid_run(compiled, classical_inputs={"alpha": 0.7})
print("Resultado h√≠brido:", hybrid_result)
```

## üß† Advanced Pipelines

### Quantum Worker Orchestration (Enterprise)

Permite ejecutar simulaciones o evaluaciones distribuidas en workers configurados en la nube (GCP, AWS, Vercel, etc.):

```python
task = sdk.worker_submit(
    circuit=circuit,
    backend="gcr.io/dsf-quantum-475822/quantum-worker",
    batch_size=50
)
print("Tarea enviada:", task["id"])
```

Puedes monitorear progreso:

```python
status = sdk.worker_status(task["id"])
print(status)
```

## üîß Fine-Tuned Recipes

### A) Community ‚Äî Simple Superposition

```python
circuit = (sdk.create_circuit()
    .add_qubit('q0')
    .add_gate('H', targets=['q0'])
    .add_measure('q0')
)
result = sdk.simulate(circuit)
print(result['probabilities'])
```

### B) Professional ‚Äî Entanglement Test

```python
circuit = (sdk.create_circuit()
    .add_qubit('q0').add_qubit('q1')
    .add_gate('H', targets=['q0'])
    .add_gate('CX', targets=['q0','q1'])
    .add_measure('q0').add_measure('q1')
)
sim = sdk.batch_simulate([circuit.to_dict()]*100)
print("Promedio correlaci√≥n:", sum(x["correlation"] for x in sim)/100)
```

### C) Enterprise ‚Äî Hybrid Workflow

```python
cfg = {"iterations": 3, "noise_level": 0.01}
hybrid = sdk.hybrid_run(circuit, classical_inputs=cfg)
print("Output:", hybrid)
```

## ‚ö° Performance Tips

- Usa `batch_simulate()` en lugar de `simulate()` para grandes vol√∫menes.
- `compile()` puede cachearse para reutilizar topolog√≠as.
- Usa `worker_submit()` para ejecutar tareas en paralelo.
- `hybrid_run()` acepta datos cl√°sicos para reducir overhead cu√°ntico.

## üí° Use Cases

### 1. Quantum Evaluation

Eval√∫a m√∫ltiples variantes de un circuito para analizar estabilidad y fidelidad:

```python
scores = sdk.batch_simulate([circuit.to_dict() for _ in range(500)])
```

### 2. Hybrid Optimization

Integra valores cl√°sicos y cu√°nticos:

```python
result = sdk.hybrid_run(circuit, classical_inputs={"alpha": 0.5, "beta": 0.9})
```

### 3. Distributed Compilation

Despliega compilaciones pesadas a workers remotos:

```python
sdk.worker_submit(circuit, backend="gcr.io/dsf-quantum-475822/quantum-worker")
```

## üìä Rate Limits

|      Tier    | Simulations/Day | Batch Size | Worker Jobs | Compilation |
|--------------|-----------------|------------|-------------|-------------|
| Community    |       500       |      ‚ùå    |     ‚ùå     |     ‚ùå      |
| Professional |     ilimitado   |  ‚úÖ ‚â§1000  |  limitado   |     ‚úÖ      |
| Enterprise   |     ilimitado   |  ‚úÖ ‚â§1000  |     ‚úÖ     | ‚úÖ (QPU)     |

## üÜö Tier Comparison

|       Feature       | Community | Professional | Enterprise |
|---------------------|-----------|--------------|------------|
| Local simulation    |    ‚úÖ     |      ‚úÖ     |     ‚úÖ     |
| Batch simulation    |    ‚ùå     |      ‚úÖ     |     ‚úÖ     |
| Quantum compilation |    ‚ùå     |      ‚úÖ     | ‚úÖ (QPU+)  |
| Hybrid evaluation   |    ‚ùå     |      ‚úÖ     |     ‚úÖ     |
| Distributed workers |    ‚ùå     |      ‚ùå     |     ‚úÖ     |
| Cloud orchestration |    ‚ùå     |      ‚ùå     |     ‚úÖ     |

## üìñ API Reference

### Initialization

```python
QuantumSDK(
    tier='community'|'professional'|'enterprise',
    license_key=None,
    base_url=None,
    timeout=30
)
```

### Core Methods

- `create_circuit()` ‚Üí Crea una nueva topolog√≠a.
- `simulate(circuit)` ‚Üí Simula localmente.
- `batch_simulate(circuits)` ‚Üí Simula m√∫ltiples circuitos.
- `compile(circuit, target="qasm"|"binary"|"tensor")` ‚Üí Compila el circuito.
- `hybrid_run(circuit, classical_inputs)` ‚Üí Eval√∫a circuito con datos cl√°sicos.
- `worker_submit(circuit, backend, batch_size)` ‚Üí Env√≠o distribuido.
- `worker_status(task_id)` ‚Üí Monitorea progreso.

## ‚ö†Ô∏è Common Errors

|         C√≥digo         |           Causa            |            Soluci√≥n          |
|------------------------|----------------------------|------------------------------|
| 422 Invalid Circuit    | Falta topolog√≠a o medida   | A√±ade al menos una medida    |
| 429 Rate Limit         | Excediste el l√≠mite diario | Espera o sube de tier        |
| 500 Worker Unavailable | El worker no responde      | Reintenta o usa otro backend |
