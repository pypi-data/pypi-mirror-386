"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane import utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic.functional_validators import PlainValidator
from typing import Any, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class RunnableJobCollectionJobType(str, Enum, metaclass=utils.OpenEnumMeta):
    COLLECTION = "collection"
    EXECUTOR = "executor"
    SCHEDULED_SEARCH = "scheduledSearch"


class RunnableJobCollectionRunType(str, Enum):
    COLLECTION = "collection"


class RunnableJobCollectionScheduleLogLevel(str, Enum):
    r"""Level at which to set task logging"""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class RunnableJobCollectionScheduleTimeWarningTypedDict(TypedDict):
    pass


class RunnableJobCollectionScheduleTimeWarning(BaseModel):
    pass


class RunnableJobCollectionRunSettingsTypedDict(TypedDict):
    type: NotRequired[RunnableJobCollectionRunType]
    reschedule_dropped_tasks: NotRequired[bool]
    r"""Reschedule tasks that failed with non-fatal errors"""
    max_task_reschedule: NotRequired[float]
    r"""Maximum number of times a task can be rescheduled"""
    log_level: NotRequired[RunnableJobCollectionScheduleLogLevel]
    r"""Level at which to set task logging"""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time."""
    mode: NotRequired[str]
    r"""Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job."""
    time_range_type: NotRequired[str]
    earliest: NotRequired[float]
    r"""Earliest time to collect data for the selected timezone"""
    latest: NotRequired[float]
    r"""Latest time to collect data for the selected timezone"""
    timestamp_timezone: NotRequired[Any]
    time_warning: NotRequired[RunnableJobCollectionScheduleTimeWarningTypedDict]
    expression: NotRequired[str]
    r"""A filter for tokens in the provided collect path and/or the events being collected"""
    min_task_size: NotRequired[str]
    r"""Limits the bundle size for small tasks. For example,










    if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task.
    """
    max_task_size: NotRequired[str]
    r"""Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB,










    you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks.
    """


class RunnableJobCollectionRunSettings(BaseModel):
    type: Optional[RunnableJobCollectionRunType] = None

    reschedule_dropped_tasks: Annotated[
        Optional[bool], pydantic.Field(alias="rescheduleDroppedTasks")
    ] = True
    r"""Reschedule tasks that failed with non-fatal errors"""

    max_task_reschedule: Annotated[
        Optional[float], pydantic.Field(alias="maxTaskReschedule")
    ] = 1
    r"""Maximum number of times a task can be rescheduled"""

    log_level: Annotated[
        Optional[RunnableJobCollectionScheduleLogLevel],
        pydantic.Field(alias="logLevel"),
    ] = RunnableJobCollectionScheduleLogLevel.INFO
    r"""Level at which to set task logging"""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = "0"
    r"""Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time."""

    mode: Optional[str] = "list"
    r"""Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job."""

    time_range_type: Annotated[Optional[str], pydantic.Field(alias="timeRangeType")] = (
        "relative"
    )

    earliest: Optional[float] = None
    r"""Earliest time to collect data for the selected timezone"""

    latest: Optional[float] = None
    r"""Latest time to collect data for the selected timezone"""

    timestamp_timezone: Annotated[
        Optional[Any], pydantic.Field(alias="timestampTimezone")
    ] = None

    time_warning: Annotated[
        Optional[RunnableJobCollectionScheduleTimeWarning],
        pydantic.Field(alias="timeWarning"),
    ] = None

    expression: Optional[str] = "true"
    r"""A filter for tokens in the provided collect path and/or the events being collected"""

    min_task_size: Annotated[Optional[str], pydantic.Field(alias="minTaskSize")] = "1MB"
    r"""Limits the bundle size for small tasks. For example,










    if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task.
    """

    max_task_size: Annotated[Optional[str], pydantic.Field(alias="maxTaskSize")] = (
        "10MB"
    )
    r"""Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB,










    you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks.
    """


class RunnableJobCollectionScheduleTypedDict(TypedDict):
    r"""Configuration for a scheduled job"""

    enabled: NotRequired[bool]
    r"""Enable to configure scheduling for this Collector"""
    cron_schedule: NotRequired[str]
    r"""A cron schedule on which to run this job"""
    max_concurrent_runs: NotRequired[float]
    r"""The maximum number of instances of this scheduled job that may be running at any time"""
    skippable: NotRequired[bool]
    r"""Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits"""
    resume_missed: NotRequired[Any]
    run: NotRequired[RunnableJobCollectionRunSettingsTypedDict]


class RunnableJobCollectionSchedule(BaseModel):
    r"""Configuration for a scheduled job"""

    enabled: Optional[bool] = None
    r"""Enable to configure scheduling for this Collector"""

    cron_schedule: Annotated[Optional[str], pydantic.Field(alias="cronSchedule")] = (
        "*/5 * * * *"
    )
    r"""A cron schedule on which to run this job"""

    max_concurrent_runs: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentRuns")
    ] = 1
    r"""The maximum number of instances of this scheduled job that may be running at any time"""

    skippable: Optional[bool] = True
    r"""Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits"""

    resume_missed: Annotated[Optional[Any], pydantic.Field(alias="resumeMissed")] = None

    run: Optional[RunnableJobCollectionRunSettings] = None


class CollectorSpecificSettingsTypedDict(TypedDict):
    pass


class CollectorSpecificSettings(BaseModel):
    pass


class CollectorTypedDict(TypedDict):
    type: str
    r"""The type of collector to run"""
    conf: CollectorSpecificSettingsTypedDict
    destructive: NotRequired[bool]
    r"""Delete any files collected (where applicable)"""
    encoding: NotRequired[str]
    r"""Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters."""


class Collector(BaseModel):
    type: str
    r"""The type of collector to run"""

    conf: CollectorSpecificSettings

    destructive: Optional[bool] = False
    r"""Delete any files collected (where applicable)"""

    encoding: Optional[str] = None
    r"""Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters."""


class InputType(str, Enum, metaclass=utils.OpenEnumMeta):
    COLLECTION = "collection"


class RunnableJobCollectionPreprocessTypedDict(TypedDict):
    disabled: NotRequired[bool]
    command: NotRequired[str]
    r"""Command to feed the data through (via stdin) and process its output (stdout)"""
    args: NotRequired[List[str]]
    r"""Arguments to be added to the custom command"""


class RunnableJobCollectionPreprocess(BaseModel):
    disabled: Optional[bool] = True

    command: Optional[str] = None
    r"""Command to feed the data through (via stdin) and process its output (stdout)"""

    args: Optional[List[str]] = None
    r"""Arguments to be added to the custom command"""


class RunnableJobCollectionMetadatumTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)"""


class RunnableJobCollectionMetadatum(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)"""


class RunnableJobCollectionInputTypedDict(TypedDict):
    type: NotRequired[InputType]
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    send_to_routes: NotRequired[bool]
    r"""Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination."""
    preprocess: NotRequired[RunnableJobCollectionPreprocessTypedDict]
    throttle_rate_per_sec: NotRequired[str]
    r"""Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling."""
    metadata: NotRequired[List[RunnableJobCollectionMetadatumTypedDict]]
    r"""Fields to add to events from this input"""
    pipeline: NotRequired[str]
    r"""Pipeline to process results"""
    output: NotRequired[str]
    r"""Destination to send results to"""


class RunnableJobCollectionInput(BaseModel):
    type: Annotated[Optional[InputType], PlainValidator(validate_open_enum(False))] = (
        InputType.COLLECTION
    )

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = 10000
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination."""

    preprocess: Optional[RunnableJobCollectionPreprocess] = None

    throttle_rate_per_sec: Annotated[
        Optional[str], pydantic.Field(alias="throttleRatePerSec")
    ] = "0"
    r"""Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling."""

    metadata: Optional[List[RunnableJobCollectionMetadatum]] = None
    r"""Fields to add to events from this input"""

    pipeline: Optional[str] = None
    r"""Pipeline to process results"""

    output: Optional[str] = None
    r"""Destination to send results to"""


class RunnableJobCollectionLogLevel(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Level at which to set task logging"""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class RunnableJobCollectionMode(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job."""

    LIST = "list"
    PREVIEW = "preview"
    RUN = "run"


class TimeRange(str, Enum, metaclass=utils.OpenEnumMeta):
    ABSOLUTE = "absolute"
    RELATIVE = "relative"


class RunnableJobCollectionTimeWarningTypedDict(TypedDict):
    pass


class RunnableJobCollectionTimeWarning(BaseModel):
    pass


class WhereToCapture(int, Enum, metaclass=utils.OpenEnumMeta):
    ZERO = 0
    ONE = 1
    TWO = 2
    THREE = 3


class CaptureSettingsTypedDict(TypedDict):
    duration: NotRequired[float]
    r"""Amount of time to keep capture open, in seconds"""
    max_events: NotRequired[float]
    r"""Maximum number of events to capture"""
    level: NotRequired[WhereToCapture]


class CaptureSettings(BaseModel):
    duration: Optional[float] = 60
    r"""Amount of time to keep capture open, in seconds"""

    max_events: Annotated[Optional[float], pydantic.Field(alias="maxEvents")] = 100
    r"""Maximum number of events to capture"""

    level: Annotated[
        Optional[WhereToCapture], PlainValidator(validate_open_enum(True))
    ] = WhereToCapture.ZERO


class RunnableJobCollectionRunTypedDict(TypedDict):
    reschedule_dropped_tasks: NotRequired[bool]
    r"""Reschedule tasks that failed with non-fatal errors"""
    max_task_reschedule: NotRequired[float]
    r"""Maximum number of times a task can be rescheduled"""
    log_level: NotRequired[RunnableJobCollectionLogLevel]
    r"""Level at which to set task logging"""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time."""
    mode: NotRequired[RunnableJobCollectionMode]
    r"""Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job."""
    time_range_type: NotRequired[TimeRange]
    earliest: NotRequired[float]
    r"""Earliest time to collect data for the selected timezone"""
    latest: NotRequired[float]
    r"""Latest time to collect data for the selected timezone"""
    timestamp_timezone: NotRequired[str]
    r"""Timezone to use for Earliest and Latest times"""
    time_warning: NotRequired[RunnableJobCollectionTimeWarningTypedDict]
    expression: NotRequired[str]
    r"""A filter for tokens in the provided collect path and/or the events being collected"""
    min_task_size: NotRequired[str]
    r"""Limits the bundle size for small tasks. For example,









    if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task.
    """
    max_task_size: NotRequired[str]
    r"""Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB,









    you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks.
    """
    discover_to_routes: NotRequired[bool]
    r"""Send discover results to Routes"""
    capture: NotRequired[CaptureSettingsTypedDict]


class RunnableJobCollectionRun(BaseModel):
    reschedule_dropped_tasks: Annotated[
        Optional[bool], pydantic.Field(alias="rescheduleDroppedTasks")
    ] = True
    r"""Reschedule tasks that failed with non-fatal errors"""

    max_task_reschedule: Annotated[
        Optional[float], pydantic.Field(alias="maxTaskReschedule")
    ] = 1
    r"""Maximum number of times a task can be rescheduled"""

    log_level: Annotated[
        Annotated[
            Optional[RunnableJobCollectionLogLevel],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="logLevel"),
    ] = RunnableJobCollectionLogLevel.INFO
    r"""Level at which to set task logging"""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = "0"
    r"""Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time."""

    mode: Annotated[
        Optional[RunnableJobCollectionMode], PlainValidator(validate_open_enum(False))
    ] = RunnableJobCollectionMode.LIST
    r"""Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job."""

    time_range_type: Annotated[
        Annotated[Optional[TimeRange], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="timeRangeType"),
    ] = TimeRange.RELATIVE

    earliest: Optional[float] = None
    r"""Earliest time to collect data for the selected timezone"""

    latest: Optional[float] = None
    r"""Latest time to collect data for the selected timezone"""

    timestamp_timezone: Annotated[
        Optional[str], pydantic.Field(alias="timestampTimezone")
    ] = "UTC"
    r"""Timezone to use for Earliest and Latest times"""

    time_warning: Annotated[
        Optional[RunnableJobCollectionTimeWarning], pydantic.Field(alias="timeWarning")
    ] = None

    expression: Optional[str] = "true"
    r"""A filter for tokens in the provided collect path and/or the events being collected"""

    min_task_size: Annotated[Optional[str], pydantic.Field(alias="minTaskSize")] = "1MB"
    r"""Limits the bundle size for small tasks. For example,









    if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task.
    """

    max_task_size: Annotated[Optional[str], pydantic.Field(alias="maxTaskSize")] = (
        "10MB"
    )
    r"""Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB,









    you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks.
    """

    discover_to_routes: Annotated[
        Optional[bool], pydantic.Field(alias="discoverToRoutes")
    ] = False
    r"""Send discover results to Routes"""

    capture: Optional[CaptureSettings] = None


class RunnableJobCollectionTypedDict(TypedDict):
    collector: CollectorTypedDict
    run: RunnableJobCollectionRunTypedDict
    id: NotRequired[str]
    r"""Unique ID for this Job"""
    description: NotRequired[str]
    type: NotRequired[RunnableJobCollectionJobType]
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    remove_fields: NotRequired[List[str]]
    r"""List of fields to remove from Discover results. Wildcards (for example, aws*) are allowed. This is useful when discovery returns sensitive fields that should not be exposed in the Jobs user interface."""
    resume_on_boot: NotRequired[bool]
    r"""Resume the ad hoc job if a failure condition causes Stream to restart during job execution"""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    schedule: NotRequired[RunnableJobCollectionScheduleTypedDict]
    r"""Configuration for a scheduled job"""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    worker_affinity: NotRequired[bool]
    r"""If enabled, tasks are created and run by the same Worker Node"""
    input: NotRequired[RunnableJobCollectionInputTypedDict]


class RunnableJobCollection(BaseModel):
    collector: Collector

    run: RunnableJobCollectionRun

    id: Optional[str] = None
    r"""Unique ID for this Job"""

    description: Optional[str] = None

    type: Annotated[
        Optional[RunnableJobCollectionJobType],
        PlainValidator(validate_open_enum(False)),
    ] = None

    ttl: Optional[str] = "4h"
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = False
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    remove_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="removeFields")
    ] = None
    r"""List of fields to remove from Discover results. Wildcards (for example, aws*) are allowed. This is useful when discovery returns sensitive fields that should not be exposed in the Jobs user interface."""

    resume_on_boot: Annotated[Optional[bool], pydantic.Field(alias="resumeOnBoot")] = (
        False
    )
    r"""Resume the ad hoc job if a failure condition causes Stream to restart during job execution"""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    schedule: Optional[RunnableJobCollectionSchedule] = None
    r"""Configuration for a scheduled job"""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    worker_affinity: Annotated[
        Optional[bool], pydantic.Field(alias="workerAffinity")
    ] = False
    r"""If enabled, tasks are created and run by the same Worker Node"""

    input: Optional[RunnableJobCollectionInput] = None
