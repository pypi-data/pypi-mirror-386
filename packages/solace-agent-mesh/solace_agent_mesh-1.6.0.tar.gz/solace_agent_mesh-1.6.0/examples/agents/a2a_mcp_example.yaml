# Solace AI Connector Example: A2A ADK Host Component Configurations
#
# This file demonstrates various ways to configure the A2A_ADK_HostComponent.
# The app-level 'namespace' will be automatically prepended
# to queue names by the custom A2A_ADK_App class.
# The required A2A subscriptions are also automatically generated by A2A_ADK_App.
# Remember to set required environment variables (e.g., SOLACE_*, GOOGLE_API_KEY,
# GOOGLE_CLOUD_PROJECT, GOOGLE_CLOUD_LOCATION, specific LLM keys, NAMESPACE).

log:
  stdout_log_level: INFO
  log_file_level: DEBUG # Changed from INFO to DEBUG to capture ADK INFO logs
  log_file: a2a_mcp_example.log

# Shared SAM config
!include ../shared_config.yaml

apps:
# --- Example 1: Filesystem MCP Agent ---
  - name: filesystem_mcp_agent_app
    app_base_path: .
    app_module: src.solace_agent_mesh.agent.sac.app
    broker:
      <<: *broker_connection

    # --- App Level Config ---
    app_config:
      namespace: ${NAMESPACE}
      supports_streaming: true # Likely false for tool/MCP agents
      agent_name: "FileSystemAgent"
      display_name: "File System"
      model: *planning_model
      instruction: |
        You can interact with the local filesystem.

      # --- Tools Definition (including MCP) ---
      tools:
        - tool_type: mcp
          # tool_name: "specific_tool_name" # Optional: Uncomment and set if you only want one specific tool from the server
          connection_params:
            type: stdio # Correct key is 'type' inside connection_params
            command: "npx"
            args:
              - "-y"
              - "@modelcontextprotocol/server-filesystem"
              - "/tmp/samv2"
            timeout: 300 # Timeout for the MCP server
        - tool_type: builtin-group
          group_name: "artifact_management"

      session_service:
        type: "memory"
        default_behavior: "PERSISTENT" # Or "RUN_BASED"
      artifact_service: { type: "memory" }
      # --- Tool Output Handling ---
      tool_output_save_threshold_bytes: 4000 # Example: If any tool output > 4KB, save it
      tool_output_llm_return_max_bytes: 30000 # Example: Max 30KB of tool output to LLM
      # --- LLM-Powered Artifact Extraction Tool Config (Example) ---
      extract_content_from_artifact_config:
        supported_binary_mime_types: ["image/png", "image/jpeg"] # Process PNGs and JPEGs
        # model: "gemini-1.5-pro-latest" # Optional: Use a specific model for extraction
      # --- Artifact Handling & Embeds ---
      artifact_handling_mode: "reference"
      enable_embed_resolution: true
      enable_artifact_content_instruction: true

      # --- Agent Card Definition ---
      agent_card:
        description: "An agent that interacts with the local filesystem via an MCP server."
        defaultInputModes: ["text"]
        defaultOutputModes: ["text", "file"] # Can potentially output file info/content
        skills: [] # Define skills if specific filesystem operations are exposed as tools later

      # --- Discovery & Communication ---
      agent_card_publishing: { interval_seconds: 10 }
      agent_discovery: { enabled: false }
      inter_agent_communication:
        allow_list: []
        request_timeout_seconds: 30

# --- Example 2: Playwright MCP Agent ---
  - name: playwright_mcp_agent_app
    app_base_path: .
    app_module: solace_agent_mesh.agent.sac.app
    broker:
      <<: *broker_connection

    # --- App Level Config ---
    app_config:
      namespace: ${NAMESPACE}
      supports_streaming: true
      agent_name: "PlaywrightAgent"
      display_name: "Web Browser"
      model: *planning_model
      instruction: |
        Use the Playwright MCP server to answer incoming questions through web browsing. The tools you have will allow
        you to navigate to, click on, and extract information from web pages. You must retrieve information to answer
        the incoming request, which might require visiting multiple pages and interacting with them. During this, you
        must return status_update messages to the user using embeds so it is clear what you are doing. Any files you get that
        might be useful should be saved using create_artifact.

      # --- Tools Definition (including MCP) ---
      tools:
        - tool_type: mcp
          # tool_name: "specific_tool_name" # Optional: Uncomment and set if you only want one specific tool from the server
          connection_params:
            type: stdio # Correct key is 'type' inside connection_params
            command: "npx"
            args:
              - "@playwright/mcp@latest"
              - "--headless"
        - tool_type: builtin-group
          group_name: "artifact_management"

      session_service: { type: "memory" }
      artifact_service:
        type: "filesystem"
        base_path: "/tmp/samv2"
        artifact_scope: namespace # Default scope, shares artifacts within the NAMESPACE
      # Alternative S3 artifact service configuration:
      # artifact_service:
      #   type: "s3"
      #   bucket_name: "my-artifacts-bucket"
      #   endpoint_url: "https://s3.amazonaws.com"  # Optional, leave empty for AWS S3
      #   region: "us-east-1"
      #   artifact_scope: namespace  # Default scope, shares artifacts within the NAMESPACE
      artifact_handling_mode: "reference"
      enable_embed_resolution: true
      enable_artifact_content_instruction: true
      extract_content_from_artifact_config:
          supported_binary_mime_types: ["image/png", "image/jpeg"] # Process PNGs and JPEGs
          model: *general_model 

      # --- Agent Card Definition ---
      agent_card:
        description: "An agent that interacts with the web pages."
        defaultInputModes: ["text"]
        defaultOutputModes: ["text", "file"] # Can potentially output file info/content
        skills: [] # Define skills if specific filesystem operations are exposed as tools later

      # --- Discovery & Communication ---
      agent_card_publishing: { interval_seconds: 10 }
      agent_discovery: { enabled: false }
      inter_agent_communication:
        allow_list: []
        request_timeout_seconds: 30

# --- Example 3: Atlassian (Jira/Confluence) MCP Agent ---
  # - name: atlassian_mcp_agent_app
  #   app_base_path: .
  #   app_module: src.solace_agent_mesh.agent.sac.app
  #   broker:
  #     <<: *broker_connection

  #   # --- App Level Config ---
  #   app_config:
  #     namespace: ${NAMESPACE}
  #     supports_streaming: true # MCP tools generally don't stream responses
  #     agent_name: "AtlassianAgent"
  #     model: *multimodal_model

  #     instruction: |
  #       You can interact with Jira and Confluence using the Atlassian MCP server.
  #     # --- Tools Definition (including MCP) ---
  #     tools:
  #       - tool_type: mcp
  #         connection_params:
  #           type: stdio
  #           command: "uvx" # Command to run
  #           args:
  #             - "mcp-atlassian" # Arguments for the command
  #           # Note: Authentication for Atlassian MCP is typically handled via environment variables
  #           # (ATLASSIAN_URL, ATLASSIAN_USERNAME, ATLASSIAN_API_TOKEN)
  #         environment_variables:
  #           CONFLUENCE_URL: ${CONFLUENCE_URL}
  #           CONFLUENCE_USERNAME: ${CONFLUENCE_USERNAME}
  #           CONfluence_API_TOKEN: ${CONFLUENCE_API_TOKEN}
  #           JIRA_URL: ${JIRA_URL}
  #           JIRA_USERNAME: ${JIRA_USERNAME}
  #           JIRA_API_TOKEN: ${JIRA_API_TOKEN}

  #     session_service: { type: "memory" }
  #     artifact_service: { type: "memory" }
  #     artifact_handling_mode: "reference"
  #     enable_embed_resolution: true
  #     enable_artifact_content_instruction: true
  #     # --- Agent Card Definition ---
  #     agent_card:
  #       description: "An agent that interacts with Jira and Confluence via the Atlassian MCP server."
  #       defaultInputModes: ["text"]
  #       defaultOutputModes: ["text", "file"] # Can output Jira/Confluence data
  #       skills: [] # Skills could be defined based on specific Jira/Confluence actions

  #     # --- Discovery & Communication ---
  #     agent_card_publishing: { interval_seconds: 10 }
  #     agent_discovery: { enabled: false }
  #     inter_agent_communication:
  #       allow_list: []
  #       request_timeout_seconds: 60 # Increase timeout for potentially longer Atlassian API calls

