## Quick Summary
This directory contains SQLAlchemy ORM models and Pydantic schemas for database persistence in the HTTP SSE gateway. It provides models for managing chat sessions, messages, tasks, task events, and user feedback with proper relationships and database schema definitions.

## Files Overview
- `__init__.py` - Package initialization exposing all SQLAlchemy and Pydantic models
- `base.py` - SQLAlchemy declarative base configuration
- `feedback_model.py` - FeedbackModel for storing user feedback on tasks
- `message_model.py` - MessageModel and Pydantic schemas for chat messages with session relationships
- `session_model.py` - SessionModel and Pydantic schemas for managing chat sessions
- `task_event_model.py` - TaskEventModel for storing A2A task events with task relationships
- `task_model.py` - TaskModel for managing tasks with event relationships and token usage tracking

## Developer API Reference

### __init__.py
**Purpose:** Package entry point that exposes all SQLAlchemy models and Pydantic schemas
**Import:** `from solace_agent_mesh.gateway.http_sse.repository.models import Base, MessageModel, SessionModel, CreateMessageModel, UpdateMessageModel, CreateSessionModel, UpdateSessionModel, TaskEventModel, TaskModel, FeedbackModel`

**Constants/Variables:**
- `__all__: List[str]` - Public API exports including all models and schemas

### base.py
**Purpose:** Provides the SQLAlchemy declarative base for all models
**Import:** `from solace_agent_mesh.gateway.http_sse.repository.models.base import Base`

**Constants/Variables:**
- `Base: DeclarativeMeta` - SQLAlchemy declarative base class for all models

**Usage Examples:**
```python
from solace_agent_mesh.gateway.http_sse.repository.models.base import Base
from sqlalchemy import create_engine

# Create all tables
engine = create_engine("sqlite:///example.db")
Base.metadata.create_all(engine)
```

### feedback_model.py
**Purpose:** SQLAlchemy model for storing user feedback on tasks
**Import:** `from solace_agent_mesh.gateway.http_sse.repository.models.feedback_model import FeedbackModel`

**Classes:**
- `FeedbackModel(Base)` - SQLAlchemy model for user feedback
  - `id: Column[String]` - Primary key feedback identifier
  - `session_id: Column[String]` - Session identifier
  - `task_id: Column[String]` - Task identifier (indexed)
  - `user_id: Column[String]` - User identifier (indexed)
  - `rating: Column[String]` - Feedback rating (e.g., 'up', 'down')
  - `comment: Column[Text]` - Optional feedback comment
  - `created_time: Column[BigInteger]` - Creation timestamp in epoch milliseconds

**Usage Examples:**
```python
from solace_agent_mesh.gateway.http_sse.repository.models.feedback_model import FeedbackModel
from sqlalchemy.orm import sessionmaker

# Create feedback
feedback = FeedbackModel(
    id="feedback_123",
    session_id="session_456",
    task_id="task_789",
    user_id="user_123",
    rating="up",
    comment="Great response!",
    created_time=1640995200000
)

# Add to database
Session = sessionmaker(bind=engine)
db_session = Session()
db_session.add(feedback)
db_session.commit()
```

### message_model.py
**Purpose:** SQLAlchemy model and Pydantic schemas for storing chat messages with session relationships
**Import:** `from solace_agent_mesh.gateway.http_sse.repository.models.message_model import MessageModel, CreateMessageModel, UpdateMessageModel`

**Classes:**
- `MessageModel(Base)` - SQLAlchemy model for chat messages
  - `id: Column[String]` - Primary key message identifier
  - `session_id: Column[String]` - Foreign key to sessions table with CASCADE delete
  - `message: Column[Text]` - Message content
  - `created_time: Column[BigInteger]` - Creation timestamp (auto-generated)
  - `sender_type: Column[String]` - Type of message sender (max 50 chars)
  - `sender_name: Column[String]` - Name of message sender (max 255 chars)
  - `session: relationship` - SQLAlchemy relationship to SessionModel

- `CreateMessageModel(BaseModel)` - Pydantic model for creating messages
  - `id: str` - Message identifier
  - `session_id: str` - Session identifier
  - `message: str` - Message content
  - `sender_type: str` - Sender type
  - `sender_name: str` - Sender name
  - `created_time: int` - Creation timestamp

- `UpdateMessageModel(BaseModel)` - Pydantic model for updating messages
  - `message: str` - Updated message content
  - `sender_type: str` - Updated sender type
  - `sender_name: str` - Updated sender name

**Usage Examples:**
```python
from solace_agent_mesh.gateway.http_sse.repository.models.message_model import MessageModel, CreateMessageModel
from sqlalchemy.orm import sessionmaker

# Create using SQLAlchemy model
message = MessageModel(
    id="msg_123",
    session_id="session_456",
    message="Hello, world!",
    sender_type="user",
    sender_name="John Doe"
)

# Create using Pydantic model
create_data = CreateMessageModel(
    id="msg_124",
    session_id="session_456",
    message="How are you?",
    sender_type="user",
    sender_name="John Doe",
    created_time=1640995200000
)
```

### session_model.py
**Purpose:** SQLAlchemy model and Pydantic schemas for managing chat sessions with message relationships
**Import:** `from solace_agent_mesh.gateway.http_sse.repository.models.session_model import SessionModel, CreateSessionModel, UpdateSessionModel`

**Classes:**
- `SessionModel(Base)` - SQLAlchemy model for chat sessions
  - `id: Column[String]` - Primary key session identifier
  - `name: Column[String]` - Optional session name
  - `user_id: Column[String]` - Required user identifier
  - `agent_id: Column[String]` - Optional agent identifier
  - `created_time: Column[BigInteger]` - Creation timestamp (auto-generated)
  - `updated_time: Column[BigInteger]` - Last update timestamp (auto-updated)
  - `messages: relationship` - SQLAlchemy relationship to MessageModel with cascade delete

- `CreateSessionModel(BaseModel)` - Pydantic model for creating sessions
  - `id: str` - Session identifier
  - `name: str | None` - Optional session name
  - `user_id: str` - User identifier
  - `agent_id: str | None` - Optional agent identifier
  - `created_time: int` - Creation timestamp
  - `updated_time: int` - Update timestamp

- `UpdateSessionModel(BaseModel)` - Pydantic model for updating sessions
  - `name: str | None` - Optional updated session name
  - `agent_id: str | None` - Optional updated agent identifier
  - `updated_time: int` - Update timestamp

**Usage Examples:**
```python
from solace_agent_mesh.gateway.http_sse.repository.models.session_model import SessionModel, CreateSessionModel
from sqlalchemy.orm import sessionmaker

# Create using SQLAlchemy model
session = SessionModel(
    id="session_123",
    name="My Chat Session",
    user_id="user_456",
    agent_id="agent_789"
)

# Create using Pydantic model
create_data = CreateSessionModel(
    id="session_124",
    name="Another Session",
    user_id="user_456",
    agent_id="agent_789",
    created_time=1640995200000,
    updated_time=1640995200000
)

# Access related messages
messages = session.messages  # Returns list of MessageModel instances
```

### task_event_model.py
**Purpose:** SQLAlchemy model for storing A2A task events with task relationships
**Import:** `from solace_agent_mesh.gateway.http_sse.repository.models.task_event_model import TaskEventModel`

**Classes:**
- `TaskEventModel(Base)` - SQLAlchemy model for A2A task events
  - `id: Column[String]` - Primary key event identifier
  - `task_id: Column[String]` - Foreign key to tasks table with CASCADE delete (indexed)
  - `user_id: Column[String]` - Optional user identifier (indexed)
  - `created_time: Column[BigInteger]` - Creation timestamp in epoch milliseconds
  - `topic: Column[Text]` - Event topic
  - `direction: Column[String]` - Event direction (max 50 chars)
  - `payload: Column[JSON]` - Event payload as JSON
  - `task: relationship` - SQLAlchemy relationship to TaskModel

**Usage Examples:**
```python
from solace_agent_mesh.gateway.http_sse.repository.models.task_event_model import TaskEventModel
from sqlalchemy.orm import sessionmaker

# Create a task event
event = TaskEventModel(
    id="event_123",
    task_id="task_456",
    user_id="user_789",
    created_time=1640995200000,
    topic="agent/response",
    direction="inbound",
    payload={"message": "Task completed", "status": "success"}
)

# Add to database
Session = sessionmaker(bind=engine)
db_session = Session()
db_session.add(event)
db_session.commit()
```

### task_model.py
**Purpose:** SQLAlchemy model for managing tasks with event relationships and token usage tracking
**Import:** `from solace_agent_mesh.gateway.http_sse.repository.models.task_model import TaskModel`

**Classes:**
- `TaskModel(Base)` - SQLAlchemy model for tasks
  - `id: Column[String]` - Primary key task identifier
  - `user_id: Column[String]` - User identifier (indexed)
  - `start_time: Column[BigInteger]` - Task start timestamp in epoch milliseconds
  - `end_time: Column[BigInteger]` - Optional task end timestamp
  - `status: Column[String]` - Optional task status
  - `initial_request_text: Column[Text]` - Optional initial request text (indexed)
  - `total_input_tokens: Column[Integer]` - Optional total input tokens used
  - `total_output_tokens: Column[Integer]` - Optional total output tokens used
  - `total_cached_input_tokens: Column[Integer]` - Optional total cached input tokens
  - `token_usage_details: Column[JSON]` - Optional detailed token usage information
  - `events: relationship` - SQLAlchemy relationship to TaskEventModel with cascade delete

**Usage Examples:**
```python
from solace_agent_mesh.gateway.http_sse.repository.models.task_model import TaskModel
from sqlalchemy.orm import sessionmaker

# Create a new task with token tracking
task = TaskModel(
    id="task_123",
    user_id="user_456",
    start_time=1640995200000,
    status="in_progress",
    initial_request_text="Please help me with this task",
    total_input_tokens=150,
    total_output_tokens=300,
    total_cached_input_tokens=50,
    token_usage_details={"model": "gpt-4", "breakdown": {"reasoning": 200, "response": 100}}
)

# Add to database
Session = sessionmaker(bind=engine)
db_session = Session()
db_session.add(task)
db_session.commit()

# Access related events
events = task.events  # Returns list of TaskEventModel instances
```

# content_hash: 0583795702abeb023659a686bf3cfa551016bdd0284b01f2448dd9d4d2050f3b
