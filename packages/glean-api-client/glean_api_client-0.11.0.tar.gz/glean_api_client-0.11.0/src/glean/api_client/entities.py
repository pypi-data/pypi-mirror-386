"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from glean.api_client import errors, models, utils
from glean.api_client._hooks import HookContext
from glean.api_client.types import OptionalNullable, UNSET
from glean.api_client.utils import get_security_from_env
from glean.api_client.utils.unmarshal_json_response import unmarshal_json_response
from typing import List, Mapping, Optional, Union


class Entities(BaseSDK):
    def list(
        self,
        *,
        filter_: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        sort: Optional[
            Union[List[models.SortOptions], List[models.SortOptionsTypedDict]]
        ] = None,
        entity_type: Optional[
            models.ListEntitiesRequestEntityType
        ] = models.ListEntitiesRequestEntityType.PEOPLE,
        datasource: Optional[str] = None,
        query: Optional[str] = None,
        include_fields: Optional[List[models.ListEntitiesRequestIncludeField]] = None,
        page_size: Optional[int] = None,
        cursor: Optional[str] = None,
        source: Optional[str] = None,
        request_type: Optional[models.RequestType] = models.RequestType.STANDARD,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListEntitiesResponse:
        r"""List entities

        List some set of details for all entities that fit the given criteria and return in the requested order. Does not support negation in filters, assumes relation type EQUALS. There is a limit of 10000 entities that can be retrieved via this endpoint, except when using FULL_DIRECTORY request type for people entities.

        :param filter_:
        :param sort: Use EntitiesSortOrder enum for SortOptions.sortBy
        :param entity_type:
        :param datasource: The datasource associated with the entity type, most commonly used with CUSTOM_ENTITIES
        :param query: A query string to search for entities that each entity in the response must conform to. An empty query does not filter any entities.
        :param include_fields: List of entity fields to return (that aren't returned by default)
        :param page_size: Hint to the server about how many results to send back. Server may return less.
        :param cursor: Pagination cursor. A previously received opaque token representing the position in the overall results at which to start.
        :param source: A string denoting the search surface from which the endpoint is called.
        :param request_type: The type of request being made.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListEntitiesRequest(
            filter_=utils.get_pydantic_model(
                filter_, Optional[List[models.FacetFilter]]
            ),
            sort=utils.get_pydantic_model(sort, Optional[List[models.SortOptions]]),
            entity_type=entity_type,
            datasource=datasource,
            query=query,
            include_fields=include_fields,
            page_size=page_size,
            cursor=cursor,
            source=source,
            request_type=request_type,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/listentities",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.ListEntitiesRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="listentities",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListEntitiesResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def list_async(
        self,
        *,
        filter_: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        sort: Optional[
            Union[List[models.SortOptions], List[models.SortOptionsTypedDict]]
        ] = None,
        entity_type: Optional[
            models.ListEntitiesRequestEntityType
        ] = models.ListEntitiesRequestEntityType.PEOPLE,
        datasource: Optional[str] = None,
        query: Optional[str] = None,
        include_fields: Optional[List[models.ListEntitiesRequestIncludeField]] = None,
        page_size: Optional[int] = None,
        cursor: Optional[str] = None,
        source: Optional[str] = None,
        request_type: Optional[models.RequestType] = models.RequestType.STANDARD,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListEntitiesResponse:
        r"""List entities

        List some set of details for all entities that fit the given criteria and return in the requested order. Does not support negation in filters, assumes relation type EQUALS. There is a limit of 10000 entities that can be retrieved via this endpoint, except when using FULL_DIRECTORY request type for people entities.

        :param filter_:
        :param sort: Use EntitiesSortOrder enum for SortOptions.sortBy
        :param entity_type:
        :param datasource: The datasource associated with the entity type, most commonly used with CUSTOM_ENTITIES
        :param query: A query string to search for entities that each entity in the response must conform to. An empty query does not filter any entities.
        :param include_fields: List of entity fields to return (that aren't returned by default)
        :param page_size: Hint to the server about how many results to send back. Server may return less.
        :param cursor: Pagination cursor. A previously received opaque token representing the position in the overall results at which to start.
        :param source: A string denoting the search surface from which the endpoint is called.
        :param request_type: The type of request being made.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListEntitiesRequest(
            filter_=utils.get_pydantic_model(
                filter_, Optional[List[models.FacetFilter]]
            ),
            sort=utils.get_pydantic_model(sort, Optional[List[models.SortOptions]]),
            entity_type=entity_type,
            datasource=datasource,
            query=query,
            include_fields=include_fields,
            page_size=page_size,
            cursor=cursor,
            source=source,
            request_type=request_type,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/listentities",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.ListEntitiesRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="listentities",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListEntitiesResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def read_people(
        self,
        *,
        timezone_offset: Optional[int] = None,
        obfuscated_ids: Optional[List[str]] = None,
        email_ids: Optional[List[str]] = None,
        include_fields: Optional[List[models.PeopleRequestIncludeField]] = None,
        include_types: Optional[List[models.IncludeType]] = None,
        source: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PeopleResponse:
        r"""Read people

        Read people details for the given IDs.

        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param obfuscated_ids: The Person IDs to retrieve. If no IDs are requested, the current user's details are returned.
        :param email_ids: The email IDs to retrieve. The result is the deduplicated union of emailIds and obfuscatedIds.
        :param include_fields: List of PersonMetadata fields to return (that aren't returned by default)
        :param include_types: The types of people entities to include in the response in addition to those returned by default.
        :param source: A string denoting the search surface from which the endpoint is called.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PeopleRequest(
            timezone_offset=timezone_offset,
            obfuscated_ids=obfuscated_ids,
            email_ids=email_ids,
            include_fields=include_fields,
            include_types=include_types,
            source=source,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/people",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PeopleRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="people",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PeopleResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def read_people_async(
        self,
        *,
        timezone_offset: Optional[int] = None,
        obfuscated_ids: Optional[List[str]] = None,
        email_ids: Optional[List[str]] = None,
        include_fields: Optional[List[models.PeopleRequestIncludeField]] = None,
        include_types: Optional[List[models.IncludeType]] = None,
        source: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PeopleResponse:
        r"""Read people

        Read people details for the given IDs.

        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param obfuscated_ids: The Person IDs to retrieve. If no IDs are requested, the current user's details are returned.
        :param email_ids: The email IDs to retrieve. The result is the deduplicated union of emailIds and obfuscatedIds.
        :param include_fields: List of PersonMetadata fields to return (that aren't returned by default)
        :param include_types: The types of people entities to include in the response in addition to those returned by default.
        :param source: A string denoting the search surface from which the endpoint is called.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PeopleRequest(
            timezone_offset=timezone_offset,
            obfuscated_ids=obfuscated_ids,
            email_ids=email_ids,
            include_fields=include_fields,
            include_types=include_types,
            source=source,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/people",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PeopleRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="people",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PeopleResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)
