"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from datetime import datetime
from glean.api_client import errors, models, utils
from glean.api_client._hooks import HookContext
from glean.api_client.types import OptionalNullable, UNSET
from glean.api_client.utils import get_security_from_env
from glean.api_client.utils.unmarshal_json_response import unmarshal_json_response
from typing import List, Mapping, Optional, Union


class Announcements(BaseSDK):
    def create(
        self,
        *,
        start_time: datetime,
        end_time: datetime,
        title: str,
        body: Optional[
            Union[models.StructuredText, models.StructuredTextTypedDict]
        ] = None,
        emoji: Optional[str] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        banner: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        source_document_id: Optional[str] = None,
        hide_attribution: Optional[bool] = None,
        channel: Optional[models.CreateAnnouncementRequestChannel] = None,
        post_type: Optional[models.CreateAnnouncementRequestPostType] = None,
        is_prioritized: Optional[bool] = None,
        view_url: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Create Announcement

        Create a textual announcement visible to some set of users based on department and location.

        :param start_time: The date and time at which the announcement becomes active.
        :param end_time: The date and time at which the announcement expires.
        :param title: The headline of the announcement.
        :param body:
        :param emoji: An emoji used to indicate the nature of the announcement.
        :param thumbnail:
        :param banner:
        :param audience_filters: Filters which restrict who should see the announcement. Values are taken from the corresponding filters in people search.
        :param source_document_id: The Glean Document ID of the source document this Announcement was created from (e.g. Slack thread).
        :param hide_attribution: Whether or not to hide an author attribution.
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param post_type: This determines whether this is an external-link post or a regular announcement post. TEXT - Regular announcement that can contain rich text. LINK - Announcement that is linked to an external site.
        :param is_prioritized: Used by the Social Feed to pin posts to the front of the feed.
        :param view_url: URL for viewing the announcement. It will be set to document URL for announcements from other datasources e.g. simpplr. Can only be written when channel=\"SOCIAL_FEED\".
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateAnnouncementRequest(
            start_time=start_time,
            end_time=end_time,
            title=title,
            body=utils.get_pydantic_model(body, Optional[models.StructuredText]),
            emoji=emoji,
            thumbnail=utils.get_pydantic_model(thumbnail, Optional[models.Thumbnail]),
            banner=utils.get_pydantic_model(banner, Optional[models.Thumbnail]),
            audience_filters=utils.get_pydantic_model(
                audience_filters, Optional[List[models.FacetFilter]]
            ),
            source_document_id=source_document_id,
            hide_attribution=hide_attribution,
            channel=channel,
            post_type=post_type,
            is_prioritized=is_prioritized,
            view_url=view_url,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/createannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateAnnouncementRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createannouncement",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Announcement, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def create_async(
        self,
        *,
        start_time: datetime,
        end_time: datetime,
        title: str,
        body: Optional[
            Union[models.StructuredText, models.StructuredTextTypedDict]
        ] = None,
        emoji: Optional[str] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        banner: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        source_document_id: Optional[str] = None,
        hide_attribution: Optional[bool] = None,
        channel: Optional[models.CreateAnnouncementRequestChannel] = None,
        post_type: Optional[models.CreateAnnouncementRequestPostType] = None,
        is_prioritized: Optional[bool] = None,
        view_url: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Create Announcement

        Create a textual announcement visible to some set of users based on department and location.

        :param start_time: The date and time at which the announcement becomes active.
        :param end_time: The date and time at which the announcement expires.
        :param title: The headline of the announcement.
        :param body:
        :param emoji: An emoji used to indicate the nature of the announcement.
        :param thumbnail:
        :param banner:
        :param audience_filters: Filters which restrict who should see the announcement. Values are taken from the corresponding filters in people search.
        :param source_document_id: The Glean Document ID of the source document this Announcement was created from (e.g. Slack thread).
        :param hide_attribution: Whether or not to hide an author attribution.
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param post_type: This determines whether this is an external-link post or a regular announcement post. TEXT - Regular announcement that can contain rich text. LINK - Announcement that is linked to an external site.
        :param is_prioritized: Used by the Social Feed to pin posts to the front of the feed.
        :param view_url: URL for viewing the announcement. It will be set to document URL for announcements from other datasources e.g. simpplr. Can only be written when channel=\"SOCIAL_FEED\".
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateAnnouncementRequest(
            start_time=start_time,
            end_time=end_time,
            title=title,
            body=utils.get_pydantic_model(body, Optional[models.StructuredText]),
            emoji=emoji,
            thumbnail=utils.get_pydantic_model(thumbnail, Optional[models.Thumbnail]),
            banner=utils.get_pydantic_model(banner, Optional[models.Thumbnail]),
            audience_filters=utils.get_pydantic_model(
                audience_filters, Optional[List[models.FacetFilter]]
            ),
            source_document_id=source_document_id,
            hide_attribution=hide_attribution,
            channel=channel,
            post_type=post_type,
            is_prioritized=is_prioritized,
            view_url=view_url,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/createannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateAnnouncementRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createannouncement",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Announcement, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def delete(
        self,
        *,
        id: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete Announcement

        Delete an existing user-generated announcement.

        :param id: The opaque id of the announcement to be deleted.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteAnnouncementRequest(
            id=id,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/deleteannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeleteAnnouncementRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteannouncement",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def delete_async(
        self,
        *,
        id: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete Announcement

        Delete an existing user-generated announcement.

        :param id: The opaque id of the announcement to be deleted.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteAnnouncementRequest(
            id=id,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/deleteannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeleteAnnouncementRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteannouncement",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def update(
        self,
        *,
        start_time: datetime,
        end_time: datetime,
        title: str,
        id: int,
        body: Optional[
            Union[models.StructuredText, models.StructuredTextTypedDict]
        ] = None,
        emoji: Optional[str] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        banner: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        source_document_id: Optional[str] = None,
        hide_attribution: Optional[bool] = None,
        channel: Optional[models.UpdateAnnouncementRequestChannel] = None,
        post_type: Optional[models.UpdateAnnouncementRequestPostType] = None,
        is_prioritized: Optional[bool] = None,
        view_url: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Update Announcement

        Update a textual announcement visible to some set of users based on department and location.

        :param start_time: The date and time at which the announcement becomes active.
        :param end_time: The date and time at which the announcement expires.
        :param title: The headline of the announcement.
        :param id: The opaque id of the announcement.
        :param body:
        :param emoji: An emoji used to indicate the nature of the announcement.
        :param thumbnail:
        :param banner:
        :param audience_filters: Filters which restrict who should see the announcement. Values are taken from the corresponding filters in people search.
        :param source_document_id: The Glean Document ID of the source document this Announcement was created from (e.g. Slack thread).
        :param hide_attribution: Whether or not to hide an author attribution.
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param post_type: This determines whether this is an external-link post or a regular announcement post. TEXT - Regular announcement that can contain rich text. LINK - Announcement that is linked to an external site.
        :param is_prioritized: Used by the Social Feed to pin posts to the front of the feed.
        :param view_url: URL for viewing the announcement. It will be set to document URL for announcements from other datasources e.g. simpplr. Can only be written when channel=\"SOCIAL_FEED\".
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateAnnouncementRequest(
            start_time=start_time,
            end_time=end_time,
            title=title,
            body=utils.get_pydantic_model(body, Optional[models.StructuredText]),
            emoji=emoji,
            thumbnail=utils.get_pydantic_model(thumbnail, Optional[models.Thumbnail]),
            banner=utils.get_pydantic_model(banner, Optional[models.Thumbnail]),
            audience_filters=utils.get_pydantic_model(
                audience_filters, Optional[List[models.FacetFilter]]
            ),
            source_document_id=source_document_id,
            hide_attribution=hide_attribution,
            channel=channel,
            post_type=post_type,
            is_prioritized=is_prioritized,
            view_url=view_url,
            id=id,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/updateannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.UpdateAnnouncementRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateannouncement",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Announcement, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def update_async(
        self,
        *,
        start_time: datetime,
        end_time: datetime,
        title: str,
        id: int,
        body: Optional[
            Union[models.StructuredText, models.StructuredTextTypedDict]
        ] = None,
        emoji: Optional[str] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        banner: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        source_document_id: Optional[str] = None,
        hide_attribution: Optional[bool] = None,
        channel: Optional[models.UpdateAnnouncementRequestChannel] = None,
        post_type: Optional[models.UpdateAnnouncementRequestPostType] = None,
        is_prioritized: Optional[bool] = None,
        view_url: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Update Announcement

        Update a textual announcement visible to some set of users based on department and location.

        :param start_time: The date and time at which the announcement becomes active.
        :param end_time: The date and time at which the announcement expires.
        :param title: The headline of the announcement.
        :param id: The opaque id of the announcement.
        :param body:
        :param emoji: An emoji used to indicate the nature of the announcement.
        :param thumbnail:
        :param banner:
        :param audience_filters: Filters which restrict who should see the announcement. Values are taken from the corresponding filters in people search.
        :param source_document_id: The Glean Document ID of the source document this Announcement was created from (e.g. Slack thread).
        :param hide_attribution: Whether or not to hide an author attribution.
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param post_type: This determines whether this is an external-link post or a regular announcement post. TEXT - Regular announcement that can contain rich text. LINK - Announcement that is linked to an external site.
        :param is_prioritized: Used by the Social Feed to pin posts to the front of the feed.
        :param view_url: URL for viewing the announcement. It will be set to document URL for announcements from other datasources e.g. simpplr. Can only be written when channel=\"SOCIAL_FEED\".
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateAnnouncementRequest(
            start_time=start_time,
            end_time=end_time,
            title=title,
            body=utils.get_pydantic_model(body, Optional[models.StructuredText]),
            emoji=emoji,
            thumbnail=utils.get_pydantic_model(thumbnail, Optional[models.Thumbnail]),
            banner=utils.get_pydantic_model(banner, Optional[models.Thumbnail]),
            audience_filters=utils.get_pydantic_model(
                audience_filters, Optional[List[models.FacetFilter]]
            ),
            source_document_id=source_document_id,
            hide_attribution=hide_attribution,
            channel=channel,
            post_type=post_type,
            is_prioritized=is_prioritized,
            view_url=view_url,
            id=id,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/updateannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.UpdateAnnouncementRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateannouncement",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Announcement, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)
