"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .agentconfig import AgentConfig, AgentConfigTypedDict
from .chatmessagecitation import ChatMessageCitation, ChatMessageCitationTypedDict
from .chatmessagefragment import ChatMessageFragment, ChatMessageFragmentTypedDict
from enum import Enum
from glean.api_client.types import BaseModel
import pydantic
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class Author(str, Enum):
    USER = "USER"
    GLEAN_AI = "GLEAN_AI"


class MessageType(str, Enum):
    r"""Semantically groups content of a certain type. It can be used for purposes such as differential UI treatment. USER authored messages should be of type CONTENT and do not need `messageType` specified."""

    UPDATE = "UPDATE"
    CONTENT = "CONTENT"
    CONTEXT = "CONTEXT"
    DEBUG = "DEBUG"
    DEBUG_EXTERNAL = "DEBUG_EXTERNAL"
    ERROR = "ERROR"
    HEADING = "HEADING"
    WARNING = "WARNING"
    SERVER_TOOL = "SERVER_TOOL"


class ChatMessageTypedDict(TypedDict):
    r"""A message that is rendered as one coherent unit with one given sender."""

    agent_config: NotRequired[AgentConfigTypedDict]
    r"""Describes the agent that executes the request."""
    author: NotRequired[Author]
    citations: NotRequired[List[ChatMessageCitationTypedDict]]
    r"""A list of Citations that were used to generate the response."""
    uploaded_file_ids: NotRequired[List[str]]
    r"""IDs of files uploaded in the message that are referenced to generate the answer."""
    fragments: NotRequired[List[ChatMessageFragmentTypedDict]]
    r"""A list of rich data used to represent the response or formulate a request. These are linearly stitched together to support richer data formats beyond simple text."""
    ts: NotRequired[str]
    r"""Response timestamp of the message."""
    message_id: NotRequired[str]
    r"""A unique server-side generated ID used to identify a message, automatically populated for any USER authored messages."""
    message_tracking_token: NotRequired[str]
    r"""Opaque tracking token generated server-side."""
    message_type: NotRequired[MessageType]
    r"""Semantically groups content of a certain type. It can be used for purposes such as differential UI treatment. USER authored messages should be of type CONTENT and do not need `messageType` specified."""
    has_more_fragments: NotRequired[bool]
    r"""Signals there are additional response fragments incoming."""


class ChatMessage(BaseModel):
    r"""A message that is rendered as one coherent unit with one given sender."""

    agent_config: Annotated[
        Optional[AgentConfig], pydantic.Field(alias="agentConfig")
    ] = None
    r"""Describes the agent that executes the request."""

    author: Optional[Author] = Author.USER

    citations: Optional[List[ChatMessageCitation]] = None
    r"""A list of Citations that were used to generate the response."""

    uploaded_file_ids: Annotated[
        Optional[List[str]], pydantic.Field(alias="uploadedFileIds")
    ] = None
    r"""IDs of files uploaded in the message that are referenced to generate the answer."""

    fragments: Optional[List[ChatMessageFragment]] = None
    r"""A list of rich data used to represent the response or formulate a request. These are linearly stitched together to support richer data formats beyond simple text."""

    ts: Optional[str] = None
    r"""Response timestamp of the message."""

    message_id: Annotated[Optional[str], pydantic.Field(alias="messageId")] = None
    r"""A unique server-side generated ID used to identify a message, automatically populated for any USER authored messages."""

    message_tracking_token: Annotated[
        Optional[str], pydantic.Field(alias="messageTrackingToken")
    ] = None
    r"""Opaque tracking token generated server-side."""

    message_type: Annotated[
        Optional[MessageType], pydantic.Field(alias="messageType")
    ] = MessageType.CONTENT
    r"""Semantically groups content of a certain type. It can be used for purposes such as differential UI treatment. USER authored messages should be of type CONTENT and do not need `messageType` specified."""

    has_more_fragments: Annotated[
        Optional[bool],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible.",
            alias="hasMoreFragments",
        ),
    ] = None
    r"""Signals there are additional response fragments incoming."""
