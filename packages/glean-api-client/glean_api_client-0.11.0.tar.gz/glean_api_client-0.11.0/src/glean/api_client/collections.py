"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from glean.api_client import errors, models, utils
from glean.api_client._hooks import HookContext
from glean.api_client.types import OptionalNullable, UNSET
from glean.api_client.utils import get_security_from_env
from glean.api_client.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, List, Mapping, Optional, Union


class Collections(BaseSDK):
    def add_items(
        self,
        *,
        collection_id: float,
        added_collection_item_descriptors: Optional[
            Union[
                List[models.CollectionItemDescriptor],
                List[models.CollectionItemDescriptorTypedDict],
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AddCollectionItemsResponse:
        r"""Add Collection item

        Add items to a Collection.

        :param collection_id: The ID of the Collection to add items to.
        :param added_collection_item_descriptors: The CollectionItemDescriptors of the items being added.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddCollectionItemsRequest(
            collection_id=collection_id,
            added_collection_item_descriptors=utils.get_pydantic_model(
                added_collection_item_descriptors,
                Optional[List[models.CollectionItemDescriptor]],
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/addcollectionitems",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.AddCollectionItemsRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="addcollectionitems",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AddCollectionItemsResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def add_items_async(
        self,
        *,
        collection_id: float,
        added_collection_item_descriptors: Optional[
            Union[
                List[models.CollectionItemDescriptor],
                List[models.CollectionItemDescriptorTypedDict],
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AddCollectionItemsResponse:
        r"""Add Collection item

        Add items to a Collection.

        :param collection_id: The ID of the Collection to add items to.
        :param added_collection_item_descriptors: The CollectionItemDescriptors of the items being added.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddCollectionItemsRequest(
            collection_id=collection_id,
            added_collection_item_descriptors=utils.get_pydantic_model(
                added_collection_item_descriptors,
                Optional[List[models.CollectionItemDescriptor]],
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/addcollectionitems",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.AddCollectionItemsRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="addcollectionitems",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AddCollectionItemsResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def create(
        self,
        *,
        name: str,
        description: Optional[str] = None,
        added_roles: Optional[
            Union[
                List[models.UserRoleSpecification],
                List[models.UserRoleSpecificationTypedDict],
            ]
        ] = None,
        removed_roles: Optional[
            Union[
                List[models.UserRoleSpecification],
                List[models.UserRoleSpecificationTypedDict],
            ]
        ] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        icon: Optional[str] = None,
        admin_locked: Optional[bool] = None,
        parent_id: Optional[int] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        allowed_datasource: Optional[str] = None,
        new_next_item_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreatecollectionResponse:
        r"""Create Collection

        Create a publicly visible (empty) Collection of documents.

        :param name: The unique name of the Collection.
        :param description: A brief summary of the Collection's contents.
        :param added_roles: A list of added user roles for the Collection.
        :param removed_roles: A list of removed user roles for the Collection.
        :param audience_filters: Filters which restrict who should see this Collection. Values are taken from the corresponding filters in people search.
        :param icon: The emoji icon of this Collection.
        :param admin_locked: Indicates whether edits are allowed for everyone or only admins.
        :param parent_id: The parent of this Collection, or 0 if it's a top-level Collection.
        :param thumbnail:
        :param allowed_datasource: The datasource type this Collection can hold.
        :param new_next_item_id: The (optional) ItemId of the next CollectionItem in sequence. If omitted, will be added to the end of the Collection. Only used if parentId is specified.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateCollectionRequest(
            name=name,
            description=description,
            added_roles=utils.get_pydantic_model(
                added_roles, Optional[List[models.UserRoleSpecification]]
            ),
            removed_roles=utils.get_pydantic_model(
                removed_roles, Optional[List[models.UserRoleSpecification]]
            ),
            audience_filters=utils.get_pydantic_model(
                audience_filters, Optional[List[models.FacetFilter]]
            ),
            icon=icon,
            admin_locked=admin_locked,
            parent_id=parent_id,
            thumbnail=utils.get_pydantic_model(thumbnail, Optional[models.Thumbnail]),
            allowed_datasource=allowed_datasource,
            new_next_item_id=new_next_item_id,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/createcollection",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateCollectionRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createcollection",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "422", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CreatecollectionResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.CollectionErrorData, http_res
            )
            raise errors.CollectionError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def create_async(
        self,
        *,
        name: str,
        description: Optional[str] = None,
        added_roles: Optional[
            Union[
                List[models.UserRoleSpecification],
                List[models.UserRoleSpecificationTypedDict],
            ]
        ] = None,
        removed_roles: Optional[
            Union[
                List[models.UserRoleSpecification],
                List[models.UserRoleSpecificationTypedDict],
            ]
        ] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        icon: Optional[str] = None,
        admin_locked: Optional[bool] = None,
        parent_id: Optional[int] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        allowed_datasource: Optional[str] = None,
        new_next_item_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreatecollectionResponse:
        r"""Create Collection

        Create a publicly visible (empty) Collection of documents.

        :param name: The unique name of the Collection.
        :param description: A brief summary of the Collection's contents.
        :param added_roles: A list of added user roles for the Collection.
        :param removed_roles: A list of removed user roles for the Collection.
        :param audience_filters: Filters which restrict who should see this Collection. Values are taken from the corresponding filters in people search.
        :param icon: The emoji icon of this Collection.
        :param admin_locked: Indicates whether edits are allowed for everyone or only admins.
        :param parent_id: The parent of this Collection, or 0 if it's a top-level Collection.
        :param thumbnail:
        :param allowed_datasource: The datasource type this Collection can hold.
        :param new_next_item_id: The (optional) ItemId of the next CollectionItem in sequence. If omitted, will be added to the end of the Collection. Only used if parentId is specified.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateCollectionRequest(
            name=name,
            description=description,
            added_roles=utils.get_pydantic_model(
                added_roles, Optional[List[models.UserRoleSpecification]]
            ),
            removed_roles=utils.get_pydantic_model(
                removed_roles, Optional[List[models.UserRoleSpecification]]
            ),
            audience_filters=utils.get_pydantic_model(
                audience_filters, Optional[List[models.FacetFilter]]
            ),
            icon=icon,
            admin_locked=admin_locked,
            parent_id=parent_id,
            thumbnail=utils.get_pydantic_model(thumbnail, Optional[models.Thumbnail]),
            allowed_datasource=allowed_datasource,
            new_next_item_id=new_next_item_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/createcollection",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateCollectionRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createcollection",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "422", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CreatecollectionResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.CollectionErrorData, http_res
            )
            raise errors.CollectionError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def delete(
        self,
        *,
        ids: List[int],
        allowed_datasource: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete Collection

        Delete a Collection given the Collection's ID.

        :param ids: The IDs of the Collections to delete.
        :param allowed_datasource: The datasource allowed in the Collection to be deleted.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteCollectionRequest(
            ids=ids,
            allowed_datasource=allowed_datasource,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/deletecollection",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeleteCollectionRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deletecollection",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "422", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.CollectionErrorData, http_res
            )
            raise errors.CollectionError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def delete_async(
        self,
        *,
        ids: List[int],
        allowed_datasource: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete Collection

        Delete a Collection given the Collection's ID.

        :param ids: The IDs of the Collections to delete.
        :param allowed_datasource: The datasource allowed in the Collection to be deleted.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteCollectionRequest(
            ids=ids,
            allowed_datasource=allowed_datasource,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/deletecollection",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeleteCollectionRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deletecollection",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "422", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.CollectionErrorData, http_res
            )
            raise errors.CollectionError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def delete_item(
        self,
        *,
        collection_id: float,
        item_id: str,
        document_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DeleteCollectionItemResponse:
        r"""Delete Collection item

        Delete a single item from a Collection.

        :param collection_id: The ID of the Collection to remove an item in.
        :param item_id: The item ID of the CollectionItem to remove from this Collection.
        :param document_id: The (optional) Glean Document ID of the CollectionItem to remove from this Collection if this is an indexed document.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteCollectionItemRequest(
            collection_id=collection_id,
            item_id=item_id,
            document_id=document_id,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/deletecollectionitem",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeleteCollectionItemRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deletecollectionitem",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "422", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DeleteCollectionItemResponse, http_res
            )
        if utils.match_response(http_res, ["400", "401", "422", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def delete_item_async(
        self,
        *,
        collection_id: float,
        item_id: str,
        document_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DeleteCollectionItemResponse:
        r"""Delete Collection item

        Delete a single item from a Collection.

        :param collection_id: The ID of the Collection to remove an item in.
        :param item_id: The item ID of the CollectionItem to remove from this Collection.
        :param document_id: The (optional) Glean Document ID of the CollectionItem to remove from this Collection if this is an indexed document.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteCollectionItemRequest(
            collection_id=collection_id,
            item_id=item_id,
            document_id=document_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/deletecollectionitem",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeleteCollectionItemRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deletecollectionitem",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "422", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DeleteCollectionItemResponse, http_res
            )
        if utils.match_response(http_res, ["400", "401", "422", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def update(
        self,
        *,
        name: str,
        id: int,
        description: Optional[str] = None,
        added_roles: Optional[
            Union[
                List[models.UserRoleSpecification],
                List[models.UserRoleSpecificationTypedDict],
            ]
        ] = None,
        removed_roles: Optional[
            Union[
                List[models.UserRoleSpecification],
                List[models.UserRoleSpecificationTypedDict],
            ]
        ] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        icon: Optional[str] = None,
        admin_locked: Optional[bool] = None,
        parent_id: Optional[int] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        allowed_datasource: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EditCollectionResponse:
        r"""Update Collection

        Update the properties of an existing Collection.

        :param name: The unique name of the Collection.
        :param id: The ID of the Collection to modify.
        :param description: A brief summary of the Collection's contents.
        :param added_roles: A list of added user roles for the Collection.
        :param removed_roles: A list of removed user roles for the Collection.
        :param audience_filters: Filters which restrict who should see this Collection. Values are taken from the corresponding filters in people search.
        :param icon: The emoji icon of this Collection.
        :param admin_locked: Indicates whether edits are allowed for everyone or only admins.
        :param parent_id: The parent of this Collection, or 0 if it's a top-level Collection.
        :param thumbnail:
        :param allowed_datasource: The datasource type this Collection can hold.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EditCollectionRequest(
            name=name,
            description=description,
            added_roles=utils.get_pydantic_model(
                added_roles, Optional[List[models.UserRoleSpecification]]
            ),
            removed_roles=utils.get_pydantic_model(
                removed_roles, Optional[List[models.UserRoleSpecification]]
            ),
            audience_filters=utils.get_pydantic_model(
                audience_filters, Optional[List[models.FacetFilter]]
            ),
            icon=icon,
            admin_locked=admin_locked,
            parent_id=parent_id,
            thumbnail=utils.get_pydantic_model(thumbnail, Optional[models.Thumbnail]),
            allowed_datasource=allowed_datasource,
            id=id,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/editcollection",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.EditCollectionRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="editcollection",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "422", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EditCollectionResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.CollectionErrorData, http_res
            )
            raise errors.CollectionError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def update_async(
        self,
        *,
        name: str,
        id: int,
        description: Optional[str] = None,
        added_roles: Optional[
            Union[
                List[models.UserRoleSpecification],
                List[models.UserRoleSpecificationTypedDict],
            ]
        ] = None,
        removed_roles: Optional[
            Union[
                List[models.UserRoleSpecification],
                List[models.UserRoleSpecificationTypedDict],
            ]
        ] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        icon: Optional[str] = None,
        admin_locked: Optional[bool] = None,
        parent_id: Optional[int] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        allowed_datasource: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EditCollectionResponse:
        r"""Update Collection

        Update the properties of an existing Collection.

        :param name: The unique name of the Collection.
        :param id: The ID of the Collection to modify.
        :param description: A brief summary of the Collection's contents.
        :param added_roles: A list of added user roles for the Collection.
        :param removed_roles: A list of removed user roles for the Collection.
        :param audience_filters: Filters which restrict who should see this Collection. Values are taken from the corresponding filters in people search.
        :param icon: The emoji icon of this Collection.
        :param admin_locked: Indicates whether edits are allowed for everyone or only admins.
        :param parent_id: The parent of this Collection, or 0 if it's a top-level Collection.
        :param thumbnail:
        :param allowed_datasource: The datasource type this Collection can hold.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EditCollectionRequest(
            name=name,
            description=description,
            added_roles=utils.get_pydantic_model(
                added_roles, Optional[List[models.UserRoleSpecification]]
            ),
            removed_roles=utils.get_pydantic_model(
                removed_roles, Optional[List[models.UserRoleSpecification]]
            ),
            audience_filters=utils.get_pydantic_model(
                audience_filters, Optional[List[models.FacetFilter]]
            ),
            icon=icon,
            admin_locked=admin_locked,
            parent_id=parent_id,
            thumbnail=utils.get_pydantic_model(thumbnail, Optional[models.Thumbnail]),
            allowed_datasource=allowed_datasource,
            id=id,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/editcollection",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.EditCollectionRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="editcollection",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "422", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EditCollectionResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.CollectionErrorData, http_res
            )
            raise errors.CollectionError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def update_item(
        self,
        *,
        collection_id: int,
        item_id: str,
        name: Optional[str] = None,
        description: Optional[str] = None,
        icon: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EditCollectionItemResponse:
        r"""Update Collection item

        Update the URL, Glean Document ID, description of an item within a Collection given its ID.

        :param collection_id: The ID of the Collection to edit CollectionItems in.
        :param item_id: The ID of the CollectionItem to edit.
        :param name: The optional name of the Collection item.
        :param description: A helpful description of why this CollectionItem is in the Collection that it's in.
        :param icon: The emoji icon for this CollectionItem. Only used for Text type items.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EditCollectionItemRequest(
            name=name,
            description=description,
            icon=icon,
            collection_id=collection_id,
            item_id=item_id,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/editcollectionitem",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.EditCollectionItemRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="editcollectionitem",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EditCollectionItemResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def update_item_async(
        self,
        *,
        collection_id: int,
        item_id: str,
        name: Optional[str] = None,
        description: Optional[str] = None,
        icon: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EditCollectionItemResponse:
        r"""Update Collection item

        Update the URL, Glean Document ID, description of an item within a Collection given its ID.

        :param collection_id: The ID of the Collection to edit CollectionItems in.
        :param item_id: The ID of the CollectionItem to edit.
        :param name: The optional name of the Collection item.
        :param description: A helpful description of why this CollectionItem is in the Collection that it's in.
        :param icon: The emoji icon for this CollectionItem. Only used for Text type items.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EditCollectionItemRequest(
            name=name,
            description=description,
            icon=icon,
            collection_id=collection_id,
            item_id=item_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/editcollectionitem",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.EditCollectionItemRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="editcollectionitem",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EditCollectionItemResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def retrieve(
        self,
        *,
        id: int,
        with_items: Optional[bool] = None,
        with_hierarchy: Optional[bool] = None,
        allowed_datasource: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetCollectionResponse:
        r"""Read Collection

        Read the details of a Collection given its ID. Does not fetch items in this Collection.

        :param id: The ID of the Collection to be retrieved.
        :param with_items: Whether or not to include the Collection Items in this Collection. Only request if absolutely required, as this is expensive.
        :param with_hierarchy: Whether or not to include the top level Collection in this Collection's hierarchy.
        :param allowed_datasource: The datasource allowed in the Collection returned.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCollectionRequest(
            id=id,
            with_items=with_items,
            with_hierarchy=with_hierarchy,
            allowed_datasource=allowed_datasource,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/getcollection",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GetCollectionRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getcollection",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetCollectionResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def retrieve_async(
        self,
        *,
        id: int,
        with_items: Optional[bool] = None,
        with_hierarchy: Optional[bool] = None,
        allowed_datasource: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetCollectionResponse:
        r"""Read Collection

        Read the details of a Collection given its ID. Does not fetch items in this Collection.

        :param id: The ID of the Collection to be retrieved.
        :param with_items: Whether or not to include the Collection Items in this Collection. Only request if absolutely required, as this is expensive.
        :param with_hierarchy: Whether or not to include the top level Collection in this Collection's hierarchy.
        :param allowed_datasource: The datasource allowed in the Collection returned.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCollectionRequest(
            id=id,
            with_items=with_items,
            with_hierarchy=with_hierarchy,
            allowed_datasource=allowed_datasource,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/getcollection",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GetCollectionRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getcollection",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetCollectionResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def list(
        self,
        *,
        include_audience: Optional[bool] = None,
        include_roles: Optional[bool] = None,
        allowed_datasource: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListCollectionsResponse:
        r"""List Collections

        List all existing Collections.

        :param include_audience: Whether to include the audience filters with the listed Collections.
        :param include_roles: Whether to include the editor roles with the listed Collections.
        :param allowed_datasource: The datasource type this Collection can hold. ANSWERS - for Collections representing answer boards
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListCollectionsRequest(
            include_audience=include_audience,
            include_roles=include_roles,
            allowed_datasource=allowed_datasource,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/listcollections",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.ListCollectionsRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="listcollections",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListCollectionsResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def list_async(
        self,
        *,
        include_audience: Optional[bool] = None,
        include_roles: Optional[bool] = None,
        allowed_datasource: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListCollectionsResponse:
        r"""List Collections

        List all existing Collections.

        :param include_audience: Whether to include the audience filters with the listed Collections.
        :param include_roles: Whether to include the editor roles with the listed Collections.
        :param allowed_datasource: The datasource type this Collection can hold. ANSWERS - for Collections representing answer boards
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListCollectionsRequest(
            include_audience=include_audience,
            include_roles=include_roles,
            allowed_datasource=allowed_datasource,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/listcollections",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.ListCollectionsRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="listcollections",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListCollectionsResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)
