# Copyright (c) 2025, UChicago Argonne, LLC
# BSD OPEN SOURCE LICENSE. Full license can be found in LICENSE.md
from pathlib import Path
import shutil

import pandas as pd
from polaris.runs import polaris_runner
from polaris.runs.calibrate import activity_generation, destination_choice, mode_choice, timing_choice
from polaris.runs.convergence.config.convergence_config import ConvergenceConfig
from polaris.runs.convergence.convergence_iteration import ConvergenceIteration
from polaris.runs.polaris_inputs import PolarisInputs
from polaris.runs.run_utils import merge_csvs
from polaris.runs.scenario_file import apply_modification
from polaris.utils.cmd_runner import run_cmd
from polaris.utils.logging_utils import polaris_logging

polaris_logging()


def end_of_loop_fn_for_calibration(
    config: ConvergenceConfig, current_iteration: ConvergenceIteration, output_dir: Path
):
    if not config.calibration.enabled:
        return

    if current_iteration.is_abm_init and config.calibration.num_planned_activity_iterations > 0:
        # Then run x iterations of calibration (ASC adjustment) against planned activities generated by act_gen run
        records = [
            step_once(config, current_iteration, i + 1)
            for i in range(0, config.calibration.num_planned_activity_iterations)
        ]

    else:
        # Run 1 calibration against executed activities (from the just run iteration)
        records = [calibrate(config, current_iteration, use_planned=False)]

    pd.DataFrame(records).to_csv(output_dir / "rmse_report.csv", index=False)
    merge_csvs(config, "rmse_report.csv")

    return records


def step_once(config: ConvergenceConfig, current_iteration: ConvergenceIteration, iter_num: int):
    return calibrate(config, run_activity_generation(config, current_iteration, iter_num), use_planned=True)


def calibrate(config: ConvergenceConfig, iteration: ConvergenceIteration, use_planned: bool):
    RMSE_activity, RMSE_destination, RMSE_mode, RMSE_mode_boardings, RMSE_timing = -2, -2, -1, -2, -2
    if config.calibration.calibration_schedule.activity.at_iteration(iteration):
        RMSE_activity = activity_generation.calibrate(config, iteration, use_planned)

    if config.calibration.calibration_schedule.destination.at_iteration(iteration) and not use_planned:
        # destination choice can't be calibrated if we haven't got trips with routed distance
        # TODO: approximate routed distance based on factor * euclidean dist
        RMSE_destination = destination_choice.calibrate(config, iteration)

    if config.calibration.calibration_schedule.mode.at_iteration(iteration):
        RMSE_mode, RMSE_mode_boardings = mode_choice.calibrate(config, iteration, use_planned)

    if config.calibration.calibration_schedule.timing.at_iteration(iteration):
        RMSE_timing = timing_choice.calibrate(config, iteration, use_planned=use_planned)

    # We generate a csv into the iteration folder, then immediately merge it with any other csvs in other iterations
    # into a single merged rmse_report.csv in the root folder
    return {
        "iteration": iteration.output_dir.name,
        "RMSE_activity": RMSE_activity,
        "RMSE_mode": RMSE_mode,
        "RMSE_mode_boardings": RMSE_mode_boardings,
        "RMSE_destination": RMSE_destination,
        "RMSE_timing": RMSE_timing,
    }


def run_activity_generation(config: ConvergenceConfig, current_iteration: ConvergenceIteration, iter_num):
    output_dir = get_output_dir(current_iteration, iter_num)

    mods = {}
    mods["Output controls.output_directory"] = output_dir
    mods["General simulation controls.early_exit"] = "after_activity_gen"

    sc_file = config.data_dir / f"scenario_abm.calibration.json"
    sc_file = apply_modification(current_iteration.scenario_file, mods, sc_file)

    # run executable
    cmd_runner_ignore_errors = lambda *args, **kwargs: run_cmd(*args, ignore_errors=True, **kwargs)
    output_dir, scenario_file_ = polaris_runner.run(
        config.data_dir,
        config.polaris_exe,
        str(sc_file),
        mods,
        config.num_threads,
        num_retries=config.num_retries,
        run_command=cmd_runner_ignore_errors,
    )

    iter = ConvergenceIteration(
        output_dir=output_dir,
        is_abm_init=current_iteration.is_abm_init,  # we need to track this down into each of the sub-iters
        files=PolarisInputs.from_dir(output_dir),
        scenario_file=output_dir / "model_files" / "scenario_abm.calibration.json",
    )
    iter.files.supply_db = current_iteration.files.supply_db
    shutil.copy(sc_file, iter.scenario_file)
    return iter


def get_output_dir(current_iteration, iter_num):
    return f"{current_iteration.output_dir}_calib_{iter_num}"
