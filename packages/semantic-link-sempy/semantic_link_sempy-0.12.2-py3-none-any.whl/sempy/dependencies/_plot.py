import pandas as pd
import numpy as np

from typing import TYPE_CHECKING
from ast import literal_eval

if TYPE_CHECKING:
    import graphviz


def plot_dependency_metadata(metadata_df: pd.DataFrame) -> 'graphviz.Digraph':
    """
    Plot a graph of functional dependencies based on metadata contained in the provided dataframe.

    The input "metadata" dataframe should contain one row per functional dependency.
    Each row names the "determinant" column(s) and the "dependent" column of the actual
    "data" dataframe, where the determinant/dependent relationship is exhibited by
    1:m mapping of the value pairs.

    If the "conditional_entropy" column is present, it will determine the line style: solid line for
    zero entropy that signifies exact mapping, and dashed line for non-zero entropy that signifies
    approximate mapping. The values for the "conditional_entropy" are generated by
    :func:`~sempy.fabric.FabricDataFrame.find_dependencies`.

    Parameters
    ----------
    metadata_df : pandas.DataFrame
        Pandas DataFrame listing functional dependencies. At a minimum, it must contain columns
        "determinant" and "dependent".

    Returns
    -------
    graphviz.Digraph
        Graphviz object.
    """
    groups, dependencies = _to_groups_and_dependencies(metadata_df)
    return _plot_dependency_metadata_internal(groups, dependencies, stats=None, dropna=False)


def _plot_dependency_metadata_internal(groups, dependencies, stats, dropna):
    import graphviz

    g = graphviz.Digraph(node_attr=[('shape', 'plaintext')])

    graph_nodes = set()
    for i, j, conditional_entropy in dependencies:
        if conditional_entropy > 1e-8:
            style = 'dashed'
        else:
            style = 'solid'

        if dropna and (stats[groups[i][0]].null_count > 0 or stats[groups[j][0]].null_count > 0):
            color = 'red'
        else:
            color = 'black'

        g.edge(str(i), str(j), style=style, color=color)
        graph_nodes.update((i, j))

    head = '<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">'
    tail = '</TABLE>>'
    for k in range(len(groups)):
        # Show only multi-member groups or groups that are in dependencies
        if len(groups[k]) > 1 or k in graph_nodes:
            body = ''.join(['<TR><TD>' + member + '</TD></TR>' for member in groups[k]])
            g.node(str(k), head + body + tail)

    return g


def _to_groups_and_dependencies(df):

    def _assign_idx(group):
        if group not in groups:
            groups[group] = _assign_idx.idx
            _assign_idx.idx += 1

    _assign_idx.idx = 0

    groups = {}
    dependencies = []

    for d in df.to_dict(orient="records"):
        determinant = _to_tuple(d["Determinant"])
        _assign_idx(determinant)
        # Dependent value could be a None for groups with no dependencies.
        # It may also be represented by np.nan after deserialization from csv
        if d["Dependent"] not in [None, np.nan]:
            dependent = _to_tuple(d["Dependent"])
            _assign_idx(dependent)
            conditional_entropy = d.get("Conditional Entropy", 0.0)
            dependencies.append((determinant, dependent, conditional_entropy))

    # remap tuples to group idx and add 0.0 entropy to plot exact dependency with a solid line
    remapped_dependencies = [(groups[d[0]], groups[d[1]], d[2]) for d in dependencies]

    return list(groups.keys()), remapped_dependencies


def _to_tuple(value):
    if isinstance(value, str):
        # cell value could be a str() represenation of a list after deserialization from csv
        if value.startswith('[') and value.endswith(']'):
            return tuple(literal_eval(value))
        else:
            return (value,)
    elif isinstance(value, list):
        return tuple(value)
    else:
        raise TypeError(f"Unexpected type {type(value)} in a dataframe cell")
