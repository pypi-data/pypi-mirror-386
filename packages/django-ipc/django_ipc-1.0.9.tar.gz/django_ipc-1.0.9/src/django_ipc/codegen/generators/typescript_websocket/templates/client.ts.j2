/**
 * Generated RPC Client with Environment Detection
 *
 * Auto-generated WebSocket RPC client - DO NOT EDIT
 * Generated by: django_cfg_rpc codegen
 */

import type * as Types from './types';
import { ClientLogger, type ClientLoggerConfig } from './logger';

/**
 * Environment types
 */
type Environment = "development" | "production" | "staging" | "testing";

/**
 * Environment-aware RPC client configuration
 */
class RPCClientConfig {
{% if config %}
  // ðŸ”§ GENERATED CONFIGURATION
  private static readonly ENDPOINTS: Record<Environment, string> = {
    development: "{{ config.development.websocket_url }}",
    production: "{{ config.production.websocket_url }}",
{% if config.staging %}    staging: "{{ config.staging.websocket_url }}",
{% else %}    staging: "ws://localhost:8001/ws",
{% endif %}{% if config.testing %}    testing: "{{ config.testing.websocket_url }}",
{% else %}    testing: "ws://localhost:8001/ws",
{% endif %}  };
{% else %}
  // No configuration provided - using default localhost
  private static readonly ENDPOINTS: Record<Environment, string> = {
    development: "ws://localhost:8001/ws",
    production: "ws://localhost:8001/ws",
    staging: "ws://localhost:8001/ws",
    testing: "ws://localhost:8001/ws",
  };
{% endif %}

  /**
   * Detect current environment from environment variables.
   *
   * Priority:
   * 1. DJANGO_ENV
   * 2. NODE_ENV
   * 3. ENV
   * 4. Default: development
   */
  static detectEnvironment(): Environment {
    // Check NODE_ENV first (standard for Node.js/frontend)
    const nodeEnv = process.env.NODE_ENV?.toLowerCase();
    if (nodeEnv === "production") return "production";
    if (nodeEnv === "development") return "development";
    if (nodeEnv === "test") return "testing";

    // Check DJANGO_ENV (for Django compatibility)
    const djangoEnv = process.env.DJANGO_ENV?.toLowerCase();
    if (djangoEnv) {
      if (["dev", "devel", "develop", "local"].includes(djangoEnv)) return "development";
      if (djangoEnv === "prod") return "production";
      if (djangoEnv === "stage") return "staging";
      if (["development", "production", "staging", "testing"].includes(djangoEnv)) {
        return djangoEnv as Environment;
      }
    }

    // Check ENV fallback
    const env = process.env.ENV?.toLowerCase();
    if (env && ["development", "production", "staging", "testing"].includes(env)) {
      return env as Environment;
    }

    // Default
    return "development";
  }

  /**
   * Get WebSocket URL for environment.
   *
   * @param environment - Environment name (auto-detect if undefined)
   * @returns WebSocket URL
   * @throws Error if environment not configured
   */
  static getUrl(environment?: Environment): string {
    const env = environment || this.detectEnvironment();
    const url = this.ENDPOINTS[env];

    if (!url) {
      const available = Object.keys(this.ENDPOINTS).join(", ");
      throw new Error(
        `No URL configured for environment: ${env}. ` +
        `Available: ${available}`
      );
    }

    return url;
  }
}

/**
 * WebSocket RPC Client with Environment Detection
 *
 * Provides type-safe RPC methods over WebSocket connection.
 * Includes automatic environment detection and URL selection.
 */
export class RPCClient {
  private ws: WebSocket | null = null;
  private url: string;
  private token?: string;
  private correlationId = 0;
  private authReceived = false;
  private pendingRequests = new Map<string, {
    resolve: (value: any) => void;
    reject: (error: Error) => void;
  }>();

  /** RPC call logger - accessible for debugging and log management */
  public readonly logger?: ClientLogger;

  private enableLogging: boolean;

  /**
   * Create RPC client.
   *
   * @param url - WebSocket URL (auto-detect from ENV if undefined)
   * @param token - JWT authentication token (optional)
   * @param loggerConfig - Optional logger configuration
   * @param enableLogging - Whether to enable RPC call logging (default: true)
   *
   * @example
   * // Auto-detect from NODE_ENV or DJANGO_ENV
   * const client = new RPCClient();
   *
   * @example
   * // Explicit URL with token
   * const client = new RPCClient("ws://localhost:8001/ws", "eyJ...");
   *
   * @example
   * // With custom logger
   * const client = new RPCClient(undefined, undefined, { level: 4, logRPCCalls: true });
   *
   * @example
   * // Disable logging
   * const client = new RPCClient(undefined, undefined, undefined, false);
   */
  constructor(url?: string, token?: string, loggerConfig?: ClientLoggerConfig, enableLogging: boolean = true) {
    this.enableLogging = enableLogging;
    this.token = token;

    // Initialize logger first
    if (enableLogging) {
      this.logger = new ClientLogger(loggerConfig);
    }

    if (!url) {
      url = RPCClientConfig.getUrl();
      this.logger?.info(`Auto-detected URL: ${url}`);
    }

    this.url = url;
  }

  /**
   * Create client from environment.
   *
   * @param environment - Environment name (auto-detect if undefined)
   * @returns Configured RPCClient instance
   *
   * @example
   * // Auto-detect from NODE_ENV or DJANGO_ENV
   * const client = RPCClient.fromEnv();
   *
   * @example
   * // Explicit environment
   * const client = RPCClient.fromEnv("production");
   */
  static fromEnv(environment?: Environment): RPCClient {
    const url = RPCClientConfig.getUrl(environment);
    return new RPCClient(url);
  }

  /**
   * Connect to WebSocket server.
   */
  async connect(): Promise<void> {
    // Skip connection during SSR
    if (typeof window === 'undefined') {
      this.logger?.warning('Skipping connection during SSR');
      return Promise.resolve();
    }

    return new Promise((resolve, reject) => {
      this.authReceived = false;
      this.ws = new WebSocket(this.url);

      this.ws.onopen = () => {
        this.logger?.info('Connected');

        // Send auth token if provided
        if (this.token && this.ws) {
          const authMessage = `Bearer ${this.token}`;
          this.logger?.debug('Sending authentication token');
          this.ws.send(authMessage);
        }

        resolve();
      };

      this.ws.onerror = (error) => {
        this.logger?.error('Connection error:', error);
        reject(new Error('WebSocket connection failed'));
      };

      this.ws.onmessage = (event) => {
        this.handleMessage(event.data);
      };

      this.ws.onclose = () => {
        this.logger?.info('Disconnected');
        this.ws = null;
      };
    });
  }

  /**
   * Disconnect from WebSocket server.
   */
  disconnect(): void {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }

  /**
   * Handle incoming WebSocket message.
   */
  private handleMessage(data: string): void {
    // Skip empty messages
    if (!data || data.trim() === '') {
      this.logger?.warning('Received empty message, skipping');
      return;
    }

    try {
      const message = JSON.parse(data);

      // Handle auth message with server version
      if (!this.authReceived && message.type === 'auth' && message.status === 'ok') {
        this.authReceived = true;
        const serverVersion = message.server_version || 'unknown';
        this.logger?.info(`Server version: ${serverVersion}`);
        return;
      }

      if (message.type === 'response' && message.correlation_id) {
        const pending = this.pendingRequests.get(message.correlation_id);
        if (pending) {
          this.pendingRequests.delete(message.correlation_id);
          pending.resolve(message.result);
        }
      } else if (message.type === 'error' && message.correlation_id) {
        const pending = this.pendingRequests.get(message.correlation_id);
        if (pending) {
          this.pendingRequests.delete(message.correlation_id);
          pending.reject(new Error(message.error?.message || 'RPC error'));
        }
      }
    } catch (error) {
      this.logger?.error('Failed to parse message:', error);
    }
  }

  /**
   * Call RPC method.
   *
   * @param method - Method name
   * @param params - Method parameters
   * @returns Promise resolving to method result
   */
  private async call<T>(method: string, params: any): Promise<T> {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      throw new Error('WebSocket not connected');
    }

    const correlationId = `${++this.correlationId}`;

    // Log request
    if (this.logger) {
      this.logger.logRequest(method, params, correlationId);
    }

    const message = {
      type: 'rpc',
      method,
      params,
      correlation_id: correlationId,
    };

    // Track timing
    const startTime = performance.now();

    return new Promise((resolve, reject) => {
      this.pendingRequests.set(correlationId, {
        resolve: (value: any) => {
          const duration = performance.now() - startTime;

          // Log successful call
          if (this.logger) {
            this.logger.logRPCCall(method, params, value, duration, true, correlationId);
          }

          resolve(value);
        },
        reject: (error: Error) => {
          const duration = performance.now() - startTime;

          // Log failed call
          if (this.logger) {
            this.logger.logRPCCall(method, params, error.message, duration, false, correlationId);
          }

          reject(error);
        }
      });

      this.ws!.send(JSON.stringify(message));

      // Timeout after 30 seconds
      setTimeout(() => {
        if (this.pendingRequests.has(correlationId)) {
          this.pendingRequests.delete(correlationId);
          const duration = performance.now() - startTime;

          // Log timeout
          if (this.logger) {
            this.logger.logRPCCall(method, params, 'RPC timeout', duration, false, correlationId);
          }

          reject(new Error('RPC timeout'));
        }
      }, 30000);
    });
  }

  // ========== Generated RPC Methods ==========

{% for method in methods %}
  /**
   * {{ method.docstring | replace('\n', '\n   * ') }}
   *
   * @param params - {{ method.param_type }} parameters
   * @returns Promise<{{ method.return_type }}>
   */
  async {{ method.name_camel }}(params: {% if method.param_type == 'any' %}any{% else %}Types.{{ method.param_type }}{% endif %}): Promise<{% if method.return_type == 'any' %}any{% else %}Types.{{ method.return_type }}{% endif %}> {
    return this.call<{% if method.return_type == 'any' %}any{% else %}Types.{{ method.return_type }}{% endif %}>('{{ method.name }}', params);
  }

{% endfor %}
}
