# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings
from . import query_pb2 as services_dot_query__pb2
from . import response_pb2 as services_dot_response__pb2
from . import transaction_pb2 as services_dot_transaction__pb2
from . import transaction_response_pb2 as services_dot_transaction__response__pb2
GRPC_GENERATED_VERSION = '1.68.1'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in services/file_service_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class FileServiceStub(object):
    """*
    Service gRPC definitions for the Hedera File Service (HFS).

    #### Signature Requirements
    The HFS manages file authorization differently, depending on type of file
    transaction, and this can be surprising.<br/>
    The core element of file authorization is the `keys` field,
    which is a `KeyList`; a list of individual `Key` messages, each of which
    may represent a simple or complex key.<br/>
    The file service transactions treat this list differently.<br/>
    A `fileCreate`, `fileAppend`, or `fileUpdate` MUST have a valid signature
    from _each_ key in the list.<br/>
    A `fileDelete` MUST have a valid signature from _at least one_ key in
    the list. This is different, and allows a file "owned" by many entities
    to be deleted by any one of those entities. A deleted file cannot be
    restored, so it is important to consider this when assigning keys for
    a file.<br/>
    If any of the keys in a `KeyList` are complex, the full requirements of
    each complex key must be met to count as a "valid signature" for that key.
    A complex key structure (i.e. a `ThresholdKey`, or `KeyList`, possibly
    including additional `ThresholdKey` or `KeyList` descendants) may be
    assigned as the sole entry in a file `keys` field to ensure all transactions
    have the same signature requirements.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.createFile = channel.unary_unary(
                '/proto.FileService/createFile',
                request_serializer=services_dot_transaction__pb2.Transaction.SerializeToString,
                response_deserializer=services_dot_transaction__response__pb2.TransactionResponse.FromString,
                _registered_method=True)
        self.updateFile = channel.unary_unary(
                '/proto.FileService/updateFile',
                request_serializer=services_dot_transaction__pb2.Transaction.SerializeToString,
                response_deserializer=services_dot_transaction__response__pb2.TransactionResponse.FromString,
                _registered_method=True)
        self.deleteFile = channel.unary_unary(
                '/proto.FileService/deleteFile',
                request_serializer=services_dot_transaction__pb2.Transaction.SerializeToString,
                response_deserializer=services_dot_transaction__response__pb2.TransactionResponse.FromString,
                _registered_method=True)
        self.appendContent = channel.unary_unary(
                '/proto.FileService/appendContent',
                request_serializer=services_dot_transaction__pb2.Transaction.SerializeToString,
                response_deserializer=services_dot_transaction__response__pb2.TransactionResponse.FromString,
                _registered_method=True)
        self.getFileContent = channel.unary_unary(
                '/proto.FileService/getFileContent',
                request_serializer=services_dot_query__pb2.Query.SerializeToString,
                response_deserializer=services_dot_response__pb2.Response.FromString,
                _registered_method=True)
        self.getFileInfo = channel.unary_unary(
                '/proto.FileService/getFileInfo',
                request_serializer=services_dot_query__pb2.Query.SerializeToString,
                response_deserializer=services_dot_response__pb2.Response.FromString,
                _registered_method=True)
        self.systemDelete = channel.unary_unary(
                '/proto.FileService/systemDelete',
                request_serializer=services_dot_transaction__pb2.Transaction.SerializeToString,
                response_deserializer=services_dot_transaction__response__pb2.TransactionResponse.FromString,
                _registered_method=True)
        self.systemUndelete = channel.unary_unary(
                '/proto.FileService/systemUndelete',
                request_serializer=services_dot_transaction__pb2.Transaction.SerializeToString,
                response_deserializer=services_dot_transaction__response__pb2.TransactionResponse.FromString,
                _registered_method=True)


class FileServiceServicer(object):
    """*
    Service gRPC definitions for the Hedera File Service (HFS).

    #### Signature Requirements
    The HFS manages file authorization differently, depending on type of file
    transaction, and this can be surprising.<br/>
    The core element of file authorization is the `keys` field,
    which is a `KeyList`; a list of individual `Key` messages, each of which
    may represent a simple or complex key.<br/>
    The file service transactions treat this list differently.<br/>
    A `fileCreate`, `fileAppend`, or `fileUpdate` MUST have a valid signature
    from _each_ key in the list.<br/>
    A `fileDelete` MUST have a valid signature from _at least one_ key in
    the list. This is different, and allows a file "owned" by many entities
    to be deleted by any one of those entities. A deleted file cannot be
    restored, so it is important to consider this when assigning keys for
    a file.<br/>
    If any of the keys in a `KeyList` are complex, the full requirements of
    each complex key must be met to count as a "valid signature" for that key.
    A complex key structure (i.e. a `ThresholdKey`, or `KeyList`, possibly
    including additional `ThresholdKey` or `KeyList` descendants) may be
    assigned as the sole entry in a file `keys` field to ensure all transactions
    have the same signature requirements.
    """

    def createFile(self, request, context):
        """*
        Create a file in HFS.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def updateFile(self, request, context):
        """*
        Update a file in HFS.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def deleteFile(self, request, context):
        """*
        Delete a file in HFS.<br/>
        The content of a file deleted in this manner is completely removed
        from network state, but the file metadata remains.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def appendContent(self, request, context):
        """*
        Append content to a file in HFS.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def getFileContent(self, request, context):
        """*
        Retrieve the content of a file in HFS.<br/>
        Note that this query retrieves _only_ the file content, not any of
        the metadata for the file.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def getFileInfo(self, request, context):
        """*
        Retrieve the metadata for a file in HFS.<br/>
        Note that this query does not retrieve the file _content_.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def systemDelete(self, request, context):
        """*
        Delete a "regular" file without "owner" authorization.<br/>
        This transaction _does not_ require signatures for the keys in
        the file `keys` list, but must be signed by a "privileged" account.
        <p>
        This transaction SHALL NOT accept a file identifier for
        a "system" file.<br/>
        This transaction SHALL NOT remove the _content_ of the file from state.
        This permits use of the `systemUndelete` to reverse this action if
        performed in error.
        <p>
        This is a privileged transaction, and only accounts 2-59 are permitted
        to call this function, by default. The actual restriction is in the
        `api-permission.properties` file in the consensus node configuration.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def systemUndelete(self, request, context):
        """*
        Undelete a "regular" file.
        This transaction must be signed by a "privileged" account.<br/>
        <p>
        This transaction SHALL NOT accept a file identifier for
        a "system" file.<br/>
        The file identified SHOULD have been previously deleted.<br/>
        This transaction SHALL NOT recover the _content_ of a file unless that
        file was deleted with a `systemDelete` transaction. The _content_ of a
        file deleted with a `fileDelete` transaction is not retained in state.
        <p>
        This is a privileged transaction, and only accounts 2-60 are permitted
        to call this function, by default. The actual restriction is in the
        `api-permission.properties` file in the consensus node configuration.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_FileServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'createFile': grpc.unary_unary_rpc_method_handler(
                    servicer.createFile,
                    request_deserializer=services_dot_transaction__pb2.Transaction.FromString,
                    response_serializer=services_dot_transaction__response__pb2.TransactionResponse.SerializeToString,
            ),
            'updateFile': grpc.unary_unary_rpc_method_handler(
                    servicer.updateFile,
                    request_deserializer=services_dot_transaction__pb2.Transaction.FromString,
                    response_serializer=services_dot_transaction__response__pb2.TransactionResponse.SerializeToString,
            ),
            'deleteFile': grpc.unary_unary_rpc_method_handler(
                    servicer.deleteFile,
                    request_deserializer=services_dot_transaction__pb2.Transaction.FromString,
                    response_serializer=services_dot_transaction__response__pb2.TransactionResponse.SerializeToString,
            ),
            'appendContent': grpc.unary_unary_rpc_method_handler(
                    servicer.appendContent,
                    request_deserializer=services_dot_transaction__pb2.Transaction.FromString,
                    response_serializer=services_dot_transaction__response__pb2.TransactionResponse.SerializeToString,
            ),
            'getFileContent': grpc.unary_unary_rpc_method_handler(
                    servicer.getFileContent,
                    request_deserializer=services_dot_query__pb2.Query.FromString,
                    response_serializer=services_dot_response__pb2.Response.SerializeToString,
            ),
            'getFileInfo': grpc.unary_unary_rpc_method_handler(
                    servicer.getFileInfo,
                    request_deserializer=services_dot_query__pb2.Query.FromString,
                    response_serializer=services_dot_response__pb2.Response.SerializeToString,
            ),
            'systemDelete': grpc.unary_unary_rpc_method_handler(
                    servicer.systemDelete,
                    request_deserializer=services_dot_transaction__pb2.Transaction.FromString,
                    response_serializer=services_dot_transaction__response__pb2.TransactionResponse.SerializeToString,
            ),
            'systemUndelete': grpc.unary_unary_rpc_method_handler(
                    servicer.systemUndelete,
                    request_deserializer=services_dot_transaction__pb2.Transaction.FromString,
                    response_serializer=services_dot_transaction__response__pb2.TransactionResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'proto.FileService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('proto.FileService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class FileService(object):
    """*
    Service gRPC definitions for the Hedera File Service (HFS).

    #### Signature Requirements
    The HFS manages file authorization differently, depending on type of file
    transaction, and this can be surprising.<br/>
    The core element of file authorization is the `keys` field,
    which is a `KeyList`; a list of individual `Key` messages, each of which
    may represent a simple or complex key.<br/>
    The file service transactions treat this list differently.<br/>
    A `fileCreate`, `fileAppend`, or `fileUpdate` MUST have a valid signature
    from _each_ key in the list.<br/>
    A `fileDelete` MUST have a valid signature from _at least one_ key in
    the list. This is different, and allows a file "owned" by many entities
    to be deleted by any one of those entities. A deleted file cannot be
    restored, so it is important to consider this when assigning keys for
    a file.<br/>
    If any of the keys in a `KeyList` are complex, the full requirements of
    each complex key must be met to count as a "valid signature" for that key.
    A complex key structure (i.e. a `ThresholdKey`, or `KeyList`, possibly
    including additional `ThresholdKey` or `KeyList` descendants) may be
    assigned as the sole entry in a file `keys` field to ensure all transactions
    have the same signature requirements.
    """

    @staticmethod
    def createFile(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/proto.FileService/createFile',
            services_dot_transaction__pb2.Transaction.SerializeToString,
            services_dot_transaction__response__pb2.TransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def updateFile(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/proto.FileService/updateFile',
            services_dot_transaction__pb2.Transaction.SerializeToString,
            services_dot_transaction__response__pb2.TransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def deleteFile(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/proto.FileService/deleteFile',
            services_dot_transaction__pb2.Transaction.SerializeToString,
            services_dot_transaction__response__pb2.TransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def appendContent(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/proto.FileService/appendContent',
            services_dot_transaction__pb2.Transaction.SerializeToString,
            services_dot_transaction__response__pb2.TransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def getFileContent(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/proto.FileService/getFileContent',
            services_dot_query__pb2.Query.SerializeToString,
            services_dot_response__pb2.Response.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def getFileInfo(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/proto.FileService/getFileInfo',
            services_dot_query__pb2.Query.SerializeToString,
            services_dot_response__pb2.Response.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def systemDelete(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/proto.FileService/systemDelete',
            services_dot_transaction__pb2.Transaction.SerializeToString,
            services_dot_transaction__response__pb2.TransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def systemUndelete(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/proto.FileService/systemUndelete',
            services_dot_transaction__pb2.Transaction.SerializeToString,
            services_dot_transaction__response__pb2.TransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
