# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings
from . import query_pb2 as services_dot_query__pb2
from . import response_pb2 as services_dot_response__pb2
from . import transaction_pb2 as services_dot_transaction__pb2
from . import transaction_response_pb2 as services_dot_transaction__response__pb2
GRPC_GENERATED_VERSION = '1.68.1'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in services/schedule_service_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class ScheduleServiceStub(object):
    """*
    Transactions and queries for the Schedule Service.<br/>
    The Schedule Service enables transactions to be submitted without all
    required signatures and offers a `scheduleSign` transaction to provide
    additional signatures independently after the schedule is created. The
    scheduled transaction may be executed immediately when all required
    signatures are present, or at expiration if "long term" schedules
    are enabled in network configuration.

    ### Execution
    Scheduled transactions SHALL be executed under the following conditions.
    1. If "long term" schedules are enabled and `wait_for_expiry` is set for
    that schedule then the transaction SHALL NOT be executed before the
    network consensus time matches or exceeds the `expiration_time` field
    for that schedule.
    1. If "long term" schedules are enabled and `wait_for_expiry` is _not_ set
    for that schedule, then the transaction SHALL be executed when all
    signatures required by the scheduled transaction are active for that
    schedule. This MAY be immediately after the `scheduleCreate` or a
    subsequent `scheduleSign` transaction, or MAY be at expiration if
    the signature requirements are met at that time.
    1. If "long term" schedules are _disabled_, then the scheduled transaction
    SHALL be executed immediately after all signature requirements for the
    scheduled transaction are met during the `scheduleCreate` or a subsequent
    `scheduleSign` transaction. The scheduled transaction SHALL NOT be
    on expiration when "long term" schedules are disabled.

    A schedule SHALL remain in state and MAY be queried with a `getScheduleInfo`
    transaction after execution, until the schedule expires.<br/>
    When network consensus time matches or exceeds the `expiration_time` for
    a schedule, that schedule SHALL be removed from state, whether it has
    executed or not.<br/>
    If "long term" schedules are _disabled_, the maximum expiration time SHALL
    be the consensus time of the `scheduleCreate` transaction extended by
    the network configuration value `ledger.scheduleTxExpiryTimeSecs`.

    ### Block Stream Effects
    When a scheduled transaction is executed, the timestamp in the transaction
    identifier for that transaction SHALL be 1 nanosecond after the consensus
    timestamp for the transaction that resulted in its execution. If execution
    occurred at expiration, that transaction may be almost any transaction,
    including another scheduled transaction that executed at expiration.<br/>
    The transaction identifier for a scheduled transaction that is executed
    SHALL have the `scheduled` flag set and SHALL inherit the `accountID` and
    `transactionValidStart` values from the `scheduleCreate` that created the
    schedule.<br/>
    The `scheduleRef` property of the record for a scheduled transaction SHALL
    be populated with the schedule identifier of the schedule that executed.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.createSchedule = channel.unary_unary(
                '/proto.ScheduleService/createSchedule',
                request_serializer=services_dot_transaction__pb2.Transaction.SerializeToString,
                response_deserializer=services_dot_transaction__response__pb2.TransactionResponse.FromString,
                _registered_method=True)
        self.signSchedule = channel.unary_unary(
                '/proto.ScheduleService/signSchedule',
                request_serializer=services_dot_transaction__pb2.Transaction.SerializeToString,
                response_deserializer=services_dot_transaction__response__pb2.TransactionResponse.FromString,
                _registered_method=True)
        self.deleteSchedule = channel.unary_unary(
                '/proto.ScheduleService/deleteSchedule',
                request_serializer=services_dot_transaction__pb2.Transaction.SerializeToString,
                response_deserializer=services_dot_transaction__response__pb2.TransactionResponse.FromString,
                _registered_method=True)
        self.getScheduleInfo = channel.unary_unary(
                '/proto.ScheduleService/getScheduleInfo',
                request_serializer=services_dot_query__pb2.Query.SerializeToString,
                response_deserializer=services_dot_response__pb2.Response.FromString,
                _registered_method=True)


class ScheduleServiceServicer(object):
    """*
    Transactions and queries for the Schedule Service.<br/>
    The Schedule Service enables transactions to be submitted without all
    required signatures and offers a `scheduleSign` transaction to provide
    additional signatures independently after the schedule is created. The
    scheduled transaction may be executed immediately when all required
    signatures are present, or at expiration if "long term" schedules
    are enabled in network configuration.

    ### Execution
    Scheduled transactions SHALL be executed under the following conditions.
    1. If "long term" schedules are enabled and `wait_for_expiry` is set for
    that schedule then the transaction SHALL NOT be executed before the
    network consensus time matches or exceeds the `expiration_time` field
    for that schedule.
    1. If "long term" schedules are enabled and `wait_for_expiry` is _not_ set
    for that schedule, then the transaction SHALL be executed when all
    signatures required by the scheduled transaction are active for that
    schedule. This MAY be immediately after the `scheduleCreate` or a
    subsequent `scheduleSign` transaction, or MAY be at expiration if
    the signature requirements are met at that time.
    1. If "long term" schedules are _disabled_, then the scheduled transaction
    SHALL be executed immediately after all signature requirements for the
    scheduled transaction are met during the `scheduleCreate` or a subsequent
    `scheduleSign` transaction. The scheduled transaction SHALL NOT be
    on expiration when "long term" schedules are disabled.

    A schedule SHALL remain in state and MAY be queried with a `getScheduleInfo`
    transaction after execution, until the schedule expires.<br/>
    When network consensus time matches or exceeds the `expiration_time` for
    a schedule, that schedule SHALL be removed from state, whether it has
    executed or not.<br/>
    If "long term" schedules are _disabled_, the maximum expiration time SHALL
    be the consensus time of the `scheduleCreate` transaction extended by
    the network configuration value `ledger.scheduleTxExpiryTimeSecs`.

    ### Block Stream Effects
    When a scheduled transaction is executed, the timestamp in the transaction
    identifier for that transaction SHALL be 1 nanosecond after the consensus
    timestamp for the transaction that resulted in its execution. If execution
    occurred at expiration, that transaction may be almost any transaction,
    including another scheduled transaction that executed at expiration.<br/>
    The transaction identifier for a scheduled transaction that is executed
    SHALL have the `scheduled` flag set and SHALL inherit the `accountID` and
    `transactionValidStart` values from the `scheduleCreate` that created the
    schedule.<br/>
    The `scheduleRef` property of the record for a scheduled transaction SHALL
    be populated with the schedule identifier of the schedule that executed.
    """

    def createSchedule(self, request, context):
        """*
        Create a new Schedule.
        <p>
        If all signature requirements are met with this transaction, the
        scheduled transaction MAY execute immediately.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def signSchedule(self, request, context):
        """*
        Add signatures to an existing schedule.
        <p>
        Signatures on this transaction SHALL be added to the set of active
        signatures on the schedule, and MAY result in execution of the
        scheduled transaction if all signature requirements are met.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def deleteSchedule(self, request, context):
        """*
        Mark an existing schedule deleted.
        <p>
        Once deleted a schedule SHALL NOT be executed and any subsequent
        `scheduleSign` transaction SHALL fail.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def getScheduleInfo(self, request, context):
        """*
        Retrieve the metadata for a schedule.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_ScheduleServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'createSchedule': grpc.unary_unary_rpc_method_handler(
                    servicer.createSchedule,
                    request_deserializer=services_dot_transaction__pb2.Transaction.FromString,
                    response_serializer=services_dot_transaction__response__pb2.TransactionResponse.SerializeToString,
            ),
            'signSchedule': grpc.unary_unary_rpc_method_handler(
                    servicer.signSchedule,
                    request_deserializer=services_dot_transaction__pb2.Transaction.FromString,
                    response_serializer=services_dot_transaction__response__pb2.TransactionResponse.SerializeToString,
            ),
            'deleteSchedule': grpc.unary_unary_rpc_method_handler(
                    servicer.deleteSchedule,
                    request_deserializer=services_dot_transaction__pb2.Transaction.FromString,
                    response_serializer=services_dot_transaction__response__pb2.TransactionResponse.SerializeToString,
            ),
            'getScheduleInfo': grpc.unary_unary_rpc_method_handler(
                    servicer.getScheduleInfo,
                    request_deserializer=services_dot_query__pb2.Query.FromString,
                    response_serializer=services_dot_response__pb2.Response.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'proto.ScheduleService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('proto.ScheduleService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class ScheduleService(object):
    """*
    Transactions and queries for the Schedule Service.<br/>
    The Schedule Service enables transactions to be submitted without all
    required signatures and offers a `scheduleSign` transaction to provide
    additional signatures independently after the schedule is created. The
    scheduled transaction may be executed immediately when all required
    signatures are present, or at expiration if "long term" schedules
    are enabled in network configuration.

    ### Execution
    Scheduled transactions SHALL be executed under the following conditions.
    1. If "long term" schedules are enabled and `wait_for_expiry` is set for
    that schedule then the transaction SHALL NOT be executed before the
    network consensus time matches or exceeds the `expiration_time` field
    for that schedule.
    1. If "long term" schedules are enabled and `wait_for_expiry` is _not_ set
    for that schedule, then the transaction SHALL be executed when all
    signatures required by the scheduled transaction are active for that
    schedule. This MAY be immediately after the `scheduleCreate` or a
    subsequent `scheduleSign` transaction, or MAY be at expiration if
    the signature requirements are met at that time.
    1. If "long term" schedules are _disabled_, then the scheduled transaction
    SHALL be executed immediately after all signature requirements for the
    scheduled transaction are met during the `scheduleCreate` or a subsequent
    `scheduleSign` transaction. The scheduled transaction SHALL NOT be
    on expiration when "long term" schedules are disabled.

    A schedule SHALL remain in state and MAY be queried with a `getScheduleInfo`
    transaction after execution, until the schedule expires.<br/>
    When network consensus time matches or exceeds the `expiration_time` for
    a schedule, that schedule SHALL be removed from state, whether it has
    executed or not.<br/>
    If "long term" schedules are _disabled_, the maximum expiration time SHALL
    be the consensus time of the `scheduleCreate` transaction extended by
    the network configuration value `ledger.scheduleTxExpiryTimeSecs`.

    ### Block Stream Effects
    When a scheduled transaction is executed, the timestamp in the transaction
    identifier for that transaction SHALL be 1 nanosecond after the consensus
    timestamp for the transaction that resulted in its execution. If execution
    occurred at expiration, that transaction may be almost any transaction,
    including another scheduled transaction that executed at expiration.<br/>
    The transaction identifier for a scheduled transaction that is executed
    SHALL have the `scheduled` flag set and SHALL inherit the `accountID` and
    `transactionValidStart` values from the `scheduleCreate` that created the
    schedule.<br/>
    The `scheduleRef` property of the record for a scheduled transaction SHALL
    be populated with the schedule identifier of the schedule that executed.
    """

    @staticmethod
    def createSchedule(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/proto.ScheduleService/createSchedule',
            services_dot_transaction__pb2.Transaction.SerializeToString,
            services_dot_transaction__response__pb2.TransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def signSchedule(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/proto.ScheduleService/signSchedule',
            services_dot_transaction__pb2.Transaction.SerializeToString,
            services_dot_transaction__response__pb2.TransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def deleteSchedule(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/proto.ScheduleService/deleteSchedule',
            services_dot_transaction__pb2.Transaction.SerializeToString,
            services_dot_transaction__response__pb2.TransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def getScheduleInfo(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/proto.ScheduleService/getScheduleInfo',
            services_dot_query__pb2.Query.SerializeToString,
            services_dot_response__pb2.Response.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
