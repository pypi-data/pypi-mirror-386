# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

from buildgrid._protos.build.bazel.remote.logstream.v1 import remote_logstream_pb2 as build_dot_bazel_dot_remote_dot_logstream_dot_v1_dot_remote__logstream__pb2

GRPC_GENERATED_VERSION = '1.73.1'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in build/bazel/remote/logstream/v1/remote_logstream_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class LogStreamServiceStub(object):
    """#### Introduction

    The Log Stream API manages LogStream resources which are used to stream
    writes and reads of an ordered sequence of bytes of unknown eventual length.

    Note that this is an API Interface and not an API Service, per the definitons
    at: https://cloud.google.com/apis/design/glossary

    Log Stream API supports the reading of unfinalized LogStreams either by
    seeking or in "tail" mode, for example by end-users browsing to a build
    result UI interested in seeing logs from a build action as soon as they are
    (or as they become) available.

    Reads and Writes of LogStreams are done via the Byte Stream API:
    https://cloud.google.com/dataproc/docs/reference/rpc/google.bytestream
    https://github.com/googleapis/googleapis/blob/master/google/bytestream/bytestream.proto

    #### Writing LogStreams

    LogStreams are written to via the Byte Stream API's `Write` RPC. Bytes
    written to LogStreams are expected to be committed and available for reading
    within a reasonable period of time (implementation-defined). Committed bytes
    to a LogStream cannot be overwritten, and finalized LogStreams - indicated by
    setting `finish_write` field in the final WriteRequest - also cannot be
    appended to.

    When calling the Byte Stream API's `Write` RPC to write LogStreams, writers
    must pass the `write_resource_name` of a LogStream as
    `ByteStream.WriteRequest.resource_name` rather than the LogStream's `name`.
    Separate resource names for reading and writing allows for broadcasting the
    read resource name widely while simultaneously ensuring that only writer(s)
    with knowledge of the write resource name may have written bytes to the
    LogStream.

    #### Reading LogStreams

    Use the Byte Stream API's `Read` RPC to read LogStreams. When reading
    finalized LogStreams the server will stream all contents of the LogStream
    starting at `ByteStream.ReadRequest.read_offset`.

    When reading unfinalized LogStreams the server must keep the streaming
    `ByteStream.Read` RPC open and send `ByteStream.ReadResponse` messages as
    more bytes become available or the LogStream is finalized.

    #### Example Multi-Party Read/Write Flow

    1. LogStream Writer calls `CreateLogStream`
    2. LogStream Writer publishes `LogStream.name`
    3. LogStream Writer calls `ByteStream.Write` with
    `LogStream.write_resource_name` as
    `ByteStream.WriteRequest.resource_name`,
    `ByteStream.WriteRequest.finish_write`=false.
    4. LogStream Reader(s) call `ByteStream.Read` with the published
    `LogStream.name` as `ByteStream.ReadRequest.resource_name`.
    5. LogStream Service streams all committed bytes to LogStream Reader(s),
    leave the stream open.
    6. LogStream Writer calls `ByteStream.Write` with
    `LogStream.write_resource_name` as
    `ByteStream.WriteRequest.resource_name`,
    `ByteStream.WriteRequest.finish_write`=true.
    7. LogStream Service streams all remaining bytes to LogStream Reader(s),
    terminates the stream.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.CreateLogStream = channel.unary_unary(
                '/build.bazel.remote.logstream.v1.LogStreamService/CreateLogStream',
                request_serializer=build_dot_bazel_dot_remote_dot_logstream_dot_v1_dot_remote__logstream__pb2.CreateLogStreamRequest.SerializeToString,
                response_deserializer=build_dot_bazel_dot_remote_dot_logstream_dot_v1_dot_remote__logstream__pb2.LogStream.FromString,
                _registered_method=True)


class LogStreamServiceServicer(object):
    """#### Introduction

    The Log Stream API manages LogStream resources which are used to stream
    writes and reads of an ordered sequence of bytes of unknown eventual length.

    Note that this is an API Interface and not an API Service, per the definitons
    at: https://cloud.google.com/apis/design/glossary

    Log Stream API supports the reading of unfinalized LogStreams either by
    seeking or in "tail" mode, for example by end-users browsing to a build
    result UI interested in seeing logs from a build action as soon as they are
    (or as they become) available.

    Reads and Writes of LogStreams are done via the Byte Stream API:
    https://cloud.google.com/dataproc/docs/reference/rpc/google.bytestream
    https://github.com/googleapis/googleapis/blob/master/google/bytestream/bytestream.proto

    #### Writing LogStreams

    LogStreams are written to via the Byte Stream API's `Write` RPC. Bytes
    written to LogStreams are expected to be committed and available for reading
    within a reasonable period of time (implementation-defined). Committed bytes
    to a LogStream cannot be overwritten, and finalized LogStreams - indicated by
    setting `finish_write` field in the final WriteRequest - also cannot be
    appended to.

    When calling the Byte Stream API's `Write` RPC to write LogStreams, writers
    must pass the `write_resource_name` of a LogStream as
    `ByteStream.WriteRequest.resource_name` rather than the LogStream's `name`.
    Separate resource names for reading and writing allows for broadcasting the
    read resource name widely while simultaneously ensuring that only writer(s)
    with knowledge of the write resource name may have written bytes to the
    LogStream.

    #### Reading LogStreams

    Use the Byte Stream API's `Read` RPC to read LogStreams. When reading
    finalized LogStreams the server will stream all contents of the LogStream
    starting at `ByteStream.ReadRequest.read_offset`.

    When reading unfinalized LogStreams the server must keep the streaming
    `ByteStream.Read` RPC open and send `ByteStream.ReadResponse` messages as
    more bytes become available or the LogStream is finalized.

    #### Example Multi-Party Read/Write Flow

    1. LogStream Writer calls `CreateLogStream`
    2. LogStream Writer publishes `LogStream.name`
    3. LogStream Writer calls `ByteStream.Write` with
    `LogStream.write_resource_name` as
    `ByteStream.WriteRequest.resource_name`,
    `ByteStream.WriteRequest.finish_write`=false.
    4. LogStream Reader(s) call `ByteStream.Read` with the published
    `LogStream.name` as `ByteStream.ReadRequest.resource_name`.
    5. LogStream Service streams all committed bytes to LogStream Reader(s),
    leave the stream open.
    6. LogStream Writer calls `ByteStream.Write` with
    `LogStream.write_resource_name` as
    `ByteStream.WriteRequest.resource_name`,
    `ByteStream.WriteRequest.finish_write`=true.
    7. LogStream Service streams all remaining bytes to LogStream Reader(s),
    terminates the stream.
    """

    def CreateLogStream(self, request, context):
        """Create a LogStream which may be written to.

        The returned LogStream resource name will include a `write_resource_name`
        which is the resource to use when writing to the LogStream.
        Callers of CreateLogStream are expected to NOT publish the
        `write_resource_name`.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_LogStreamServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'CreateLogStream': grpc.unary_unary_rpc_method_handler(
                    servicer.CreateLogStream,
                    request_deserializer=build_dot_bazel_dot_remote_dot_logstream_dot_v1_dot_remote__logstream__pb2.CreateLogStreamRequest.FromString,
                    response_serializer=build_dot_bazel_dot_remote_dot_logstream_dot_v1_dot_remote__logstream__pb2.LogStream.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'build.bazel.remote.logstream.v1.LogStreamService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('build.bazel.remote.logstream.v1.LogStreamService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class LogStreamService(object):
    """#### Introduction

    The Log Stream API manages LogStream resources which are used to stream
    writes and reads of an ordered sequence of bytes of unknown eventual length.

    Note that this is an API Interface and not an API Service, per the definitons
    at: https://cloud.google.com/apis/design/glossary

    Log Stream API supports the reading of unfinalized LogStreams either by
    seeking or in "tail" mode, for example by end-users browsing to a build
    result UI interested in seeing logs from a build action as soon as they are
    (or as they become) available.

    Reads and Writes of LogStreams are done via the Byte Stream API:
    https://cloud.google.com/dataproc/docs/reference/rpc/google.bytestream
    https://github.com/googleapis/googleapis/blob/master/google/bytestream/bytestream.proto

    #### Writing LogStreams

    LogStreams are written to via the Byte Stream API's `Write` RPC. Bytes
    written to LogStreams are expected to be committed and available for reading
    within a reasonable period of time (implementation-defined). Committed bytes
    to a LogStream cannot be overwritten, and finalized LogStreams - indicated by
    setting `finish_write` field in the final WriteRequest - also cannot be
    appended to.

    When calling the Byte Stream API's `Write` RPC to write LogStreams, writers
    must pass the `write_resource_name` of a LogStream as
    `ByteStream.WriteRequest.resource_name` rather than the LogStream's `name`.
    Separate resource names for reading and writing allows for broadcasting the
    read resource name widely while simultaneously ensuring that only writer(s)
    with knowledge of the write resource name may have written bytes to the
    LogStream.

    #### Reading LogStreams

    Use the Byte Stream API's `Read` RPC to read LogStreams. When reading
    finalized LogStreams the server will stream all contents of the LogStream
    starting at `ByteStream.ReadRequest.read_offset`.

    When reading unfinalized LogStreams the server must keep the streaming
    `ByteStream.Read` RPC open and send `ByteStream.ReadResponse` messages as
    more bytes become available or the LogStream is finalized.

    #### Example Multi-Party Read/Write Flow

    1. LogStream Writer calls `CreateLogStream`
    2. LogStream Writer publishes `LogStream.name`
    3. LogStream Writer calls `ByteStream.Write` with
    `LogStream.write_resource_name` as
    `ByteStream.WriteRequest.resource_name`,
    `ByteStream.WriteRequest.finish_write`=false.
    4. LogStream Reader(s) call `ByteStream.Read` with the published
    `LogStream.name` as `ByteStream.ReadRequest.resource_name`.
    5. LogStream Service streams all committed bytes to LogStream Reader(s),
    leave the stream open.
    6. LogStream Writer calls `ByteStream.Write` with
    `LogStream.write_resource_name` as
    `ByteStream.WriteRequest.resource_name`,
    `ByteStream.WriteRequest.finish_write`=true.
    7. LogStream Service streams all remaining bytes to LogStream Reader(s),
    terminates the stream.
    """

    @staticmethod
    def CreateLogStream(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/build.bazel.remote.logstream.v1.LogStreamService/CreateLogStream',
            build_dot_bazel_dot_remote_dot_logstream_dot_v1_dot_remote__logstream__pb2.CreateLogStreamRequest.SerializeToString,
            build_dot_bazel_dot_remote_dot_logstream_dot_v1_dot_remote__logstream__pb2.LogStream.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
