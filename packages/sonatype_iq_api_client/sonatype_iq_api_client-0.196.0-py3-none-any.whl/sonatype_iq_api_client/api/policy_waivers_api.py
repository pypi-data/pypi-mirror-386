# coding: utf-8

"""
    Sonatype Lifecycle Public REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.196.0-01
    Contact: community@sonatype.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from sonatype_iq_api_client.models.api_bulk_waivers_dto import ApiBulkWaiversDTO
from sonatype_iq_api_client.models.api_component_policy_waivers_dto import ApiComponentPolicyWaiversDTO
from sonatype_iq_api_client.models.api_policy_waiver_dto import ApiPolicyWaiverDTO
from sonatype_iq_api_client.models.api_request_policy_waiver_dto import ApiRequestPolicyWaiverDTO
from sonatype_iq_api_client.models.api_waiver_options_dto import ApiWaiverOptionsDTO
from sonatype_iq_api_client.models.component_identifier import ComponentIdentifier

from sonatype_iq_api_client.api_client import ApiClient, RequestSerialized
from sonatype_iq_api_client.api_response import ApiResponse
from sonatype_iq_api_client.rest import RESTResponseType


class PolicyWaiversApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def add_bulk_policy_waivers(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the waiver. Possible values are application, organization, repository, repository_manager, repository_container.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the id for the ownerType provided above. E.g. applicationId if the ownerType is application.")],
        api_bulk_waivers_dto: Annotated[ApiBulkWaiversDTO, Field(description="The request JSON should include:<ol><li>violationIds (required, list of policy violation IDs, maximum 1000)</li><li>apiWaiverOptionsDTO (required) containing:<ul><li>comment (optional, to indicate the reason of the waiver)</li><li>matcherStrategy (enumeration, required) can have values EXACT_COMPONENT or ALL_VERSIONS</li><li>expiryTime (optional) to set the datetime when the waiver expires</li><li>waiverReasonId (optional) waiver reason ID</li><li>expireWhenRemediationAvailable (optional boolean, default false) expire waiver when remediation is available, can only be applied to Exact Components.</li></ul></li></ol>")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """add_bulk_policy_waivers

        Use this method to create policy waivers for multiple policy violations.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the waiver. Possible values are application, organization, repository, repository_manager, repository_container. (required)
        :type owner_type: str
        :param owner_id: Enter the id for the ownerType provided above. E.g. applicationId if the ownerType is application. (required)
        :type owner_id: str
        :param api_bulk_waivers_dto: The request JSON should include:<ol><li>violationIds (required, list of policy violation IDs, maximum 1000)</li><li>apiWaiverOptionsDTO (required) containing:<ul><li>comment (optional, to indicate the reason of the waiver)</li><li>matcherStrategy (enumeration, required) can have values EXACT_COMPONENT or ALL_VERSIONS</li><li>expiryTime (optional) to set the datetime when the waiver expires</li><li>waiverReasonId (optional) waiver reason ID</li><li>expireWhenRemediationAvailable (optional boolean, default false) expire waiver when remediation is available, can only be applied to Exact Components.</li></ul></li></ol> (required)
        :type api_bulk_waivers_dto: ApiBulkWaiversDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_bulk_policy_waivers_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            api_bulk_waivers_dto=api_bulk_waivers_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_bulk_policy_waivers_with_http_info(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the waiver. Possible values are application, organization, repository, repository_manager, repository_container.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the id for the ownerType provided above. E.g. applicationId if the ownerType is application.")],
        api_bulk_waivers_dto: Annotated[ApiBulkWaiversDTO, Field(description="The request JSON should include:<ol><li>violationIds (required, list of policy violation IDs, maximum 1000)</li><li>apiWaiverOptionsDTO (required) containing:<ul><li>comment (optional, to indicate the reason of the waiver)</li><li>matcherStrategy (enumeration, required) can have values EXACT_COMPONENT or ALL_VERSIONS</li><li>expiryTime (optional) to set the datetime when the waiver expires</li><li>waiverReasonId (optional) waiver reason ID</li><li>expireWhenRemediationAvailable (optional boolean, default false) expire waiver when remediation is available, can only be applied to Exact Components.</li></ul></li></ol>")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """add_bulk_policy_waivers

        Use this method to create policy waivers for multiple policy violations.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the waiver. Possible values are application, organization, repository, repository_manager, repository_container. (required)
        :type owner_type: str
        :param owner_id: Enter the id for the ownerType provided above. E.g. applicationId if the ownerType is application. (required)
        :type owner_id: str
        :param api_bulk_waivers_dto: The request JSON should include:<ol><li>violationIds (required, list of policy violation IDs, maximum 1000)</li><li>apiWaiverOptionsDTO (required) containing:<ul><li>comment (optional, to indicate the reason of the waiver)</li><li>matcherStrategy (enumeration, required) can have values EXACT_COMPONENT or ALL_VERSIONS</li><li>expiryTime (optional) to set the datetime when the waiver expires</li><li>waiverReasonId (optional) waiver reason ID</li><li>expireWhenRemediationAvailable (optional boolean, default false) expire waiver when remediation is available, can only be applied to Exact Components.</li></ul></li></ol> (required)
        :type api_bulk_waivers_dto: ApiBulkWaiversDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_bulk_policy_waivers_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            api_bulk_waivers_dto=api_bulk_waivers_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_bulk_policy_waivers_without_preload_content(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the waiver. Possible values are application, organization, repository, repository_manager, repository_container.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the id for the ownerType provided above. E.g. applicationId if the ownerType is application.")],
        api_bulk_waivers_dto: Annotated[ApiBulkWaiversDTO, Field(description="The request JSON should include:<ol><li>violationIds (required, list of policy violation IDs, maximum 1000)</li><li>apiWaiverOptionsDTO (required) containing:<ul><li>comment (optional, to indicate the reason of the waiver)</li><li>matcherStrategy (enumeration, required) can have values EXACT_COMPONENT or ALL_VERSIONS</li><li>expiryTime (optional) to set the datetime when the waiver expires</li><li>waiverReasonId (optional) waiver reason ID</li><li>expireWhenRemediationAvailable (optional boolean, default false) expire waiver when remediation is available, can only be applied to Exact Components.</li></ul></li></ol>")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """add_bulk_policy_waivers

        Use this method to create policy waivers for multiple policy violations.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the waiver. Possible values are application, organization, repository, repository_manager, repository_container. (required)
        :type owner_type: str
        :param owner_id: Enter the id for the ownerType provided above. E.g. applicationId if the ownerType is application. (required)
        :type owner_id: str
        :param api_bulk_waivers_dto: The request JSON should include:<ol><li>violationIds (required, list of policy violation IDs, maximum 1000)</li><li>apiWaiverOptionsDTO (required) containing:<ul><li>comment (optional, to indicate the reason of the waiver)</li><li>matcherStrategy (enumeration, required) can have values EXACT_COMPONENT or ALL_VERSIONS</li><li>expiryTime (optional) to set the datetime when the waiver expires</li><li>waiverReasonId (optional) waiver reason ID</li><li>expireWhenRemediationAvailable (optional boolean, default false) expire waiver when remediation is available, can only be applied to Exact Components.</li></ul></li></ol> (required)
        :type api_bulk_waivers_dto: ApiBulkWaiversDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_bulk_policy_waivers_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            api_bulk_waivers_dto=api_bulk_waivers_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_bulk_policy_waivers_serialize(
        self,
        owner_type,
        owner_id,
        api_bulk_waivers_dto,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if owner_type is not None:
            _path_params['ownerType'] = owner_type
        if owner_id is not None:
            _path_params['ownerId'] = owner_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if api_bulk_waivers_dto is not None:
            _body_params = api_bulk_waivers_dto



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/policyWaivers/{ownerType}/{ownerId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def add_policy_waiver_by_policy_violation_id(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the waiver. Possible values are application, organization, repository, repository_manager, repository_container.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the id for the ownerType provided above. E.g. applicationId if the ownerType is application.")],
        policy_violation_id: Annotated[StrictStr, Field(description="Enter the policyViolationId for the policy on which you want to create a waiver. Use the Policy Violation REST API or Reports REST API to obtain the policyViolationId.")],
        api_waiver_options_dto: Annotated[ApiWaiverOptionsDTO, Field(description="The request JSON can include the fields<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol>")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """add_policy_waiver_by_policy_violation_id

        Use this method to create a policy waiver.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the waiver. Possible values are application, organization, repository, repository_manager, repository_container. (required)
        :type owner_type: str
        :param owner_id: Enter the id for the ownerType provided above. E.g. applicationId if the ownerType is application. (required)
        :type owner_id: str
        :param policy_violation_id: Enter the policyViolationId for the policy on which you want to create a waiver. Use the Policy Violation REST API or Reports REST API to obtain the policyViolationId. (required)
        :type policy_violation_id: str
        :param api_waiver_options_dto: The request JSON can include the fields<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol> (required)
        :type api_waiver_options_dto: ApiWaiverOptionsDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_policy_waiver_by_policy_violation_id_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            policy_violation_id=policy_violation_id,
            api_waiver_options_dto=api_waiver_options_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_policy_waiver_by_policy_violation_id_with_http_info(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the waiver. Possible values are application, organization, repository, repository_manager, repository_container.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the id for the ownerType provided above. E.g. applicationId if the ownerType is application.")],
        policy_violation_id: Annotated[StrictStr, Field(description="Enter the policyViolationId for the policy on which you want to create a waiver. Use the Policy Violation REST API or Reports REST API to obtain the policyViolationId.")],
        api_waiver_options_dto: Annotated[ApiWaiverOptionsDTO, Field(description="The request JSON can include the fields<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol>")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """add_policy_waiver_by_policy_violation_id

        Use this method to create a policy waiver.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the waiver. Possible values are application, organization, repository, repository_manager, repository_container. (required)
        :type owner_type: str
        :param owner_id: Enter the id for the ownerType provided above. E.g. applicationId if the ownerType is application. (required)
        :type owner_id: str
        :param policy_violation_id: Enter the policyViolationId for the policy on which you want to create a waiver. Use the Policy Violation REST API or Reports REST API to obtain the policyViolationId. (required)
        :type policy_violation_id: str
        :param api_waiver_options_dto: The request JSON can include the fields<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol> (required)
        :type api_waiver_options_dto: ApiWaiverOptionsDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_policy_waiver_by_policy_violation_id_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            policy_violation_id=policy_violation_id,
            api_waiver_options_dto=api_waiver_options_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_policy_waiver_by_policy_violation_id_without_preload_content(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the waiver. Possible values are application, organization, repository, repository_manager, repository_container.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the id for the ownerType provided above. E.g. applicationId if the ownerType is application.")],
        policy_violation_id: Annotated[StrictStr, Field(description="Enter the policyViolationId for the policy on which you want to create a waiver. Use the Policy Violation REST API or Reports REST API to obtain the policyViolationId.")],
        api_waiver_options_dto: Annotated[ApiWaiverOptionsDTO, Field(description="The request JSON can include the fields<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol>")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """add_policy_waiver_by_policy_violation_id

        Use this method to create a policy waiver.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the waiver. Possible values are application, organization, repository, repository_manager, repository_container. (required)
        :type owner_type: str
        :param owner_id: Enter the id for the ownerType provided above. E.g. applicationId if the ownerType is application. (required)
        :type owner_id: str
        :param policy_violation_id: Enter the policyViolationId for the policy on which you want to create a waiver. Use the Policy Violation REST API or Reports REST API to obtain the policyViolationId. (required)
        :type policy_violation_id: str
        :param api_waiver_options_dto: The request JSON can include the fields<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol> (required)
        :type api_waiver_options_dto: ApiWaiverOptionsDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_policy_waiver_by_policy_violation_id_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            policy_violation_id=policy_violation_id,
            api_waiver_options_dto=api_waiver_options_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_policy_waiver_by_policy_violation_id_serialize(
        self,
        owner_type,
        owner_id,
        policy_violation_id,
        api_waiver_options_dto,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if owner_type is not None:
            _path_params['ownerType'] = owner_type
        if owner_id is not None:
            _path_params['ownerId'] = owner_id
        if policy_violation_id is not None:
            _path_params['policyViolationId'] = policy_violation_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if api_waiver_options_dto is not None:
            _body_params = api_waiver_options_dto



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/policyWaivers/{ownerType}/{ownerId}/{policyViolationId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def add_waiver_to_transitive_policy_violations_by_app_scan_component(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the waiver that will be created.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        scan_id: Annotated[StrictStr, Field(description="Enter the scanId (reportId) of the evaluation report that shows the transitive component.")],
        component_identifier: Annotated[Optional[ComponentIdentifier], Field(description="Enter the component identifier of the transitive component on which you want to create a policy waiver.")] = None,
        package_url: Annotated[Optional[StrictStr], Field(description="Enter the package URL of the transitive component on which you want to create a policy waiver.")] = None,
        hash: Annotated[Optional[StrictStr], Field(description="Enter the hash of the transitive component on which you want to create a policy waiver.")] = None,
        api_waiver_options_dto: Annotated[Optional[ApiWaiverOptionsDTO], Field(description="The request JSON can include the fields<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol>")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """add_waiver_to_transitive_policy_violations_by_app_scan_component

        Use this method to create a policy waiver on a transitive component detected during the specified scan. NOTE: Any one of the input parameters, i.e. component identifier, packageUrl or hash is required. If more than one is provided, the system will pick them in the order specified here.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the waiver that will be created. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param scan_id: Enter the scanId (reportId) of the evaluation report that shows the transitive component. (required)
        :type scan_id: str
        :param component_identifier: Enter the component identifier of the transitive component on which you want to create a policy waiver.
        :type component_identifier: ComponentIdentifier
        :param package_url: Enter the package URL of the transitive component on which you want to create a policy waiver.
        :type package_url: str
        :param hash: Enter the hash of the transitive component on which you want to create a policy waiver.
        :type hash: str
        :param api_waiver_options_dto: The request JSON can include the fields<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol>
        :type api_waiver_options_dto: ApiWaiverOptionsDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_waiver_to_transitive_policy_violations_by_app_scan_component_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            scan_id=scan_id,
            component_identifier=component_identifier,
            package_url=package_url,
            hash=hash,
            api_waiver_options_dto=api_waiver_options_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_waiver_to_transitive_policy_violations_by_app_scan_component_with_http_info(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the waiver that will be created.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        scan_id: Annotated[StrictStr, Field(description="Enter the scanId (reportId) of the evaluation report that shows the transitive component.")],
        component_identifier: Annotated[Optional[ComponentIdentifier], Field(description="Enter the component identifier of the transitive component on which you want to create a policy waiver.")] = None,
        package_url: Annotated[Optional[StrictStr], Field(description="Enter the package URL of the transitive component on which you want to create a policy waiver.")] = None,
        hash: Annotated[Optional[StrictStr], Field(description="Enter the hash of the transitive component on which you want to create a policy waiver.")] = None,
        api_waiver_options_dto: Annotated[Optional[ApiWaiverOptionsDTO], Field(description="The request JSON can include the fields<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol>")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """add_waiver_to_transitive_policy_violations_by_app_scan_component

        Use this method to create a policy waiver on a transitive component detected during the specified scan. NOTE: Any one of the input parameters, i.e. component identifier, packageUrl or hash is required. If more than one is provided, the system will pick them in the order specified here.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the waiver that will be created. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param scan_id: Enter the scanId (reportId) of the evaluation report that shows the transitive component. (required)
        :type scan_id: str
        :param component_identifier: Enter the component identifier of the transitive component on which you want to create a policy waiver.
        :type component_identifier: ComponentIdentifier
        :param package_url: Enter the package URL of the transitive component on which you want to create a policy waiver.
        :type package_url: str
        :param hash: Enter the hash of the transitive component on which you want to create a policy waiver.
        :type hash: str
        :param api_waiver_options_dto: The request JSON can include the fields<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol>
        :type api_waiver_options_dto: ApiWaiverOptionsDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_waiver_to_transitive_policy_violations_by_app_scan_component_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            scan_id=scan_id,
            component_identifier=component_identifier,
            package_url=package_url,
            hash=hash,
            api_waiver_options_dto=api_waiver_options_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_waiver_to_transitive_policy_violations_by_app_scan_component_without_preload_content(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the waiver that will be created.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        scan_id: Annotated[StrictStr, Field(description="Enter the scanId (reportId) of the evaluation report that shows the transitive component.")],
        component_identifier: Annotated[Optional[ComponentIdentifier], Field(description="Enter the component identifier of the transitive component on which you want to create a policy waiver.")] = None,
        package_url: Annotated[Optional[StrictStr], Field(description="Enter the package URL of the transitive component on which you want to create a policy waiver.")] = None,
        hash: Annotated[Optional[StrictStr], Field(description="Enter the hash of the transitive component on which you want to create a policy waiver.")] = None,
        api_waiver_options_dto: Annotated[Optional[ApiWaiverOptionsDTO], Field(description="The request JSON can include the fields<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol>")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """add_waiver_to_transitive_policy_violations_by_app_scan_component

        Use this method to create a policy waiver on a transitive component detected during the specified scan. NOTE: Any one of the input parameters, i.e. component identifier, packageUrl or hash is required. If more than one is provided, the system will pick them in the order specified here.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the waiver that will be created. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param scan_id: Enter the scanId (reportId) of the evaluation report that shows the transitive component. (required)
        :type scan_id: str
        :param component_identifier: Enter the component identifier of the transitive component on which you want to create a policy waiver.
        :type component_identifier: ComponentIdentifier
        :param package_url: Enter the package URL of the transitive component on which you want to create a policy waiver.
        :type package_url: str
        :param hash: Enter the hash of the transitive component on which you want to create a policy waiver.
        :type hash: str
        :param api_waiver_options_dto: The request JSON can include the fields<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol>
        :type api_waiver_options_dto: ApiWaiverOptionsDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_waiver_to_transitive_policy_violations_by_app_scan_component_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            scan_id=scan_id,
            component_identifier=component_identifier,
            package_url=package_url,
            hash=hash,
            api_waiver_options_dto=api_waiver_options_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_waiver_to_transitive_policy_violations_by_app_scan_component_serialize(
        self,
        owner_type,
        owner_id,
        scan_id,
        component_identifier,
        package_url,
        hash,
        api_waiver_options_dto,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if owner_type is not None:
            _path_params['ownerType'] = owner_type
        if owner_id is not None:
            _path_params['ownerId'] = owner_id
        if scan_id is not None:
            _path_params['scanId'] = scan_id
        # process the query parameters
        if component_identifier is not None:
            
            _query_params.append(('componentIdentifier', component_identifier))
            
        if package_url is not None:
            
            _query_params.append(('packageUrl', package_url))
            
        if hash is not None:
            
            _query_params.append(('hash', hash))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if api_waiver_options_dto is not None:
            _body_params = api_waiver_options_dto



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/policyWaivers/transitive/{ownerType}/{ownerId}/{scanId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def add_waiver_to_transitive_policy_violations_by_owner_stage_component(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the waiver that will be created.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above. E.g. applicationId for ownerType 'application' or organizationId for ownerType 'organization'.")],
        stage_id: Annotated[StrictStr, Field(description="Enter the stageId corresponding to the evaluation stage at which you want to create a waiver. Possible values are 'develop', 'source', 'build', 'stage-release', 'release' and 'operate'.")],
        api_waiver_options_dto: Annotated[ApiWaiverOptionsDTO, Field(description="<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol>")],
        component_identifier: Annotated[Optional[ComponentIdentifier], Field(description="Enter the component identifier and coordinates of the component for which you want to waive the transitive violations.")] = None,
        package_url: Annotated[Optional[StrictStr], Field(description="Enter the package URL of the component for which you want to waive the transitive violations.")] = None,
        hash: Annotated[Optional[StrictStr], Field(description="Enter the hash for the component for which you want to waive the transitive violations ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """add_waiver_to_transitive_policy_violations_by_owner_stage_component

        Use this method to add a waiver for all transitive violations for a given component, detected in the latest scan at the stage specified.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the waiver that will be created. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. E.g. applicationId for ownerType 'application' or organizationId for ownerType 'organization'. (required)
        :type owner_id: str
        :param stage_id: Enter the stageId corresponding to the evaluation stage at which you want to create a waiver. Possible values are 'develop', 'source', 'build', 'stage-release', 'release' and 'operate'. (required)
        :type stage_id: str
        :param api_waiver_options_dto: <ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol> (required)
        :type api_waiver_options_dto: ApiWaiverOptionsDTO
        :param component_identifier: Enter the component identifier and coordinates of the component for which you want to waive the transitive violations.
        :type component_identifier: ComponentIdentifier
        :param package_url: Enter the package URL of the component for which you want to waive the transitive violations.
        :type package_url: str
        :param hash: Enter the hash for the component for which you want to waive the transitive violations 
        :type hash: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_waiver_to_transitive_policy_violations_by_owner_stage_component_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            stage_id=stage_id,
            api_waiver_options_dto=api_waiver_options_dto,
            component_identifier=component_identifier,
            package_url=package_url,
            hash=hash,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_waiver_to_transitive_policy_violations_by_owner_stage_component_with_http_info(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the waiver that will be created.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above. E.g. applicationId for ownerType 'application' or organizationId for ownerType 'organization'.")],
        stage_id: Annotated[StrictStr, Field(description="Enter the stageId corresponding to the evaluation stage at which you want to create a waiver. Possible values are 'develop', 'source', 'build', 'stage-release', 'release' and 'operate'.")],
        api_waiver_options_dto: Annotated[ApiWaiverOptionsDTO, Field(description="<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol>")],
        component_identifier: Annotated[Optional[ComponentIdentifier], Field(description="Enter the component identifier and coordinates of the component for which you want to waive the transitive violations.")] = None,
        package_url: Annotated[Optional[StrictStr], Field(description="Enter the package URL of the component for which you want to waive the transitive violations.")] = None,
        hash: Annotated[Optional[StrictStr], Field(description="Enter the hash for the component for which you want to waive the transitive violations ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """add_waiver_to_transitive_policy_violations_by_owner_stage_component

        Use this method to add a waiver for all transitive violations for a given component, detected in the latest scan at the stage specified.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the waiver that will be created. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. E.g. applicationId for ownerType 'application' or organizationId for ownerType 'organization'. (required)
        :type owner_id: str
        :param stage_id: Enter the stageId corresponding to the evaluation stage at which you want to create a waiver. Possible values are 'develop', 'source', 'build', 'stage-release', 'release' and 'operate'. (required)
        :type stage_id: str
        :param api_waiver_options_dto: <ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol> (required)
        :type api_waiver_options_dto: ApiWaiverOptionsDTO
        :param component_identifier: Enter the component identifier and coordinates of the component for which you want to waive the transitive violations.
        :type component_identifier: ComponentIdentifier
        :param package_url: Enter the package URL of the component for which you want to waive the transitive violations.
        :type package_url: str
        :param hash: Enter the hash for the component for which you want to waive the transitive violations 
        :type hash: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_waiver_to_transitive_policy_violations_by_owner_stage_component_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            stage_id=stage_id,
            api_waiver_options_dto=api_waiver_options_dto,
            component_identifier=component_identifier,
            package_url=package_url,
            hash=hash,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_waiver_to_transitive_policy_violations_by_owner_stage_component_without_preload_content(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the waiver that will be created.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above. E.g. applicationId for ownerType 'application' or organizationId for ownerType 'organization'.")],
        stage_id: Annotated[StrictStr, Field(description="Enter the stageId corresponding to the evaluation stage at which you want to create a waiver. Possible values are 'develop', 'source', 'build', 'stage-release', 'release' and 'operate'.")],
        api_waiver_options_dto: Annotated[ApiWaiverOptionsDTO, Field(description="<ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol>")],
        component_identifier: Annotated[Optional[ComponentIdentifier], Field(description="Enter the component identifier and coordinates of the component for which you want to waive the transitive violations.")] = None,
        package_url: Annotated[Optional[StrictStr], Field(description="Enter the package URL of the component for which you want to waive the transitive violations.")] = None,
        hash: Annotated[Optional[StrictStr], Field(description="Enter the hash for the component for which you want to waive the transitive violations ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """add_waiver_to_transitive_policy_violations_by_owner_stage_component

        Use this method to add a waiver for all transitive violations for a given component, detected in the latest scan at the stage specified.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the waiver that will be created. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. E.g. applicationId for ownerType 'application' or organizationId for ownerType 'organization'. (required)
        :type owner_id: str
        :param stage_id: Enter the stageId corresponding to the evaluation stage at which you want to create a waiver. Possible values are 'develop', 'source', 'build', 'stage-release', 'release' and 'operate'. (required)
        :type stage_id: str
        :param api_waiver_options_dto: <ol><li>comment (optional, to indicate the reason of the waiver) default value is null</li><li>applyToAllComponents (boolean, default 'false'),deprecated in favor of matcherStrategy. If matcherStrategy is not set, 'true' means this will apply the waiver to all components, 'false' means this will apply to a specific component.</li><li>matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.</li><li>expiryTime (default null) to set the datetime when the waiver expires.</li></ol> (required)
        :type api_waiver_options_dto: ApiWaiverOptionsDTO
        :param component_identifier: Enter the component identifier and coordinates of the component for which you want to waive the transitive violations.
        :type component_identifier: ComponentIdentifier
        :param package_url: Enter the package URL of the component for which you want to waive the transitive violations.
        :type package_url: str
        :param hash: Enter the hash for the component for which you want to waive the transitive violations 
        :type hash: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_waiver_to_transitive_policy_violations_by_owner_stage_component_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            stage_id=stage_id,
            api_waiver_options_dto=api_waiver_options_dto,
            component_identifier=component_identifier,
            package_url=package_url,
            hash=hash,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_waiver_to_transitive_policy_violations_by_owner_stage_component_serialize(
        self,
        owner_type,
        owner_id,
        stage_id,
        api_waiver_options_dto,
        component_identifier,
        package_url,
        hash,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if owner_type is not None:
            _path_params['ownerType'] = owner_type
        if owner_id is not None:
            _path_params['ownerId'] = owner_id
        if stage_id is not None:
            _path_params['stageId'] = stage_id
        # process the query parameters
        if component_identifier is not None:
            
            _query_params.append(('componentIdentifier', component_identifier))
            
        if package_url is not None:
            
            _query_params.append(('packageUrl', package_url))
            
        if hash is not None:
            
            _query_params.append(('hash', hash))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if api_waiver_options_dto is not None:
            _body_params = api_waiver_options_dto



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/policyWaivers/transitive/{ownerType}/{ownerId}/stages/{stageId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_policy_waiver(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Enter the ownerType to specify the scope. A waiver corresponding to the policyWaiverId provided and within the scope specified will be deleted.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        policy_waiver_id: Annotated[StrictStr, Field(description="Enter the policyWaiverId to be deleted.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """delete_policy_waiver

        Use this method to delete a waiver, specified by the policyWaiverId.  Permissions required: Waive Policy Violations

        :param owner_type: Enter the ownerType to specify the scope. A waiver corresponding to the policyWaiverId provided and within the scope specified will be deleted. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param policy_waiver_id: Enter the policyWaiverId to be deleted. (required)
        :type policy_waiver_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_policy_waiver_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            policy_waiver_id=policy_waiver_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_policy_waiver_with_http_info(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Enter the ownerType to specify the scope. A waiver corresponding to the policyWaiverId provided and within the scope specified will be deleted.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        policy_waiver_id: Annotated[StrictStr, Field(description="Enter the policyWaiverId to be deleted.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """delete_policy_waiver

        Use this method to delete a waiver, specified by the policyWaiverId.  Permissions required: Waive Policy Violations

        :param owner_type: Enter the ownerType to specify the scope. A waiver corresponding to the policyWaiverId provided and within the scope specified will be deleted. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param policy_waiver_id: Enter the policyWaiverId to be deleted. (required)
        :type policy_waiver_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_policy_waiver_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            policy_waiver_id=policy_waiver_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_policy_waiver_without_preload_content(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Enter the ownerType to specify the scope. A waiver corresponding to the policyWaiverId provided and within the scope specified will be deleted.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        policy_waiver_id: Annotated[StrictStr, Field(description="Enter the policyWaiverId to be deleted.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_policy_waiver

        Use this method to delete a waiver, specified by the policyWaiverId.  Permissions required: Waive Policy Violations

        :param owner_type: Enter the ownerType to specify the scope. A waiver corresponding to the policyWaiverId provided and within the scope specified will be deleted. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param policy_waiver_id: Enter the policyWaiverId to be deleted. (required)
        :type policy_waiver_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_policy_waiver_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            policy_waiver_id=policy_waiver_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_policy_waiver_serialize(
        self,
        owner_type,
        owner_id,
        policy_waiver_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if owner_type is not None:
            _path_params['ownerType'] = owner_type
        if owner_id is not None:
            _path_params['ownerId'] = owner_id
        if policy_waiver_id is not None:
            _path_params['policyWaiverId'] = policy_waiver_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/policyWaivers/{ownerType}/{ownerId}/{policyWaiverId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_policy_waiver(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Enter the ownerType to specify the scope. The response will contain the details for waivers within the scope.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        policy_waiver_id: Annotated[StrictStr, Field(description="Enter the policyWaiverId for which you want to retrieve the waiver details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiPolicyWaiverDTO:
        """get_policy_waiver

        Use this method to retrieve waiver details for the waiverId specified.  Permissions required: View IQ Elements

        :param owner_type: Enter the ownerType to specify the scope. The response will contain the details for waivers within the scope. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param policy_waiver_id: Enter the policyWaiverId for which you want to retrieve the waiver details. (required)
        :type policy_waiver_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_policy_waiver_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            policy_waiver_id=policy_waiver_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiPolicyWaiverDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_policy_waiver_with_http_info(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Enter the ownerType to specify the scope. The response will contain the details for waivers within the scope.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        policy_waiver_id: Annotated[StrictStr, Field(description="Enter the policyWaiverId for which you want to retrieve the waiver details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiPolicyWaiverDTO]:
        """get_policy_waiver

        Use this method to retrieve waiver details for the waiverId specified.  Permissions required: View IQ Elements

        :param owner_type: Enter the ownerType to specify the scope. The response will contain the details for waivers within the scope. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param policy_waiver_id: Enter the policyWaiverId for which you want to retrieve the waiver details. (required)
        :type policy_waiver_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_policy_waiver_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            policy_waiver_id=policy_waiver_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiPolicyWaiverDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_policy_waiver_without_preload_content(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Enter the ownerType to specify the scope. The response will contain the details for waivers within the scope.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        policy_waiver_id: Annotated[StrictStr, Field(description="Enter the policyWaiverId for which you want to retrieve the waiver details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_policy_waiver

        Use this method to retrieve waiver details for the waiverId specified.  Permissions required: View IQ Elements

        :param owner_type: Enter the ownerType to specify the scope. The response will contain the details for waivers within the scope. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param policy_waiver_id: Enter the policyWaiverId for which you want to retrieve the waiver details. (required)
        :type policy_waiver_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_policy_waiver_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            policy_waiver_id=policy_waiver_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiPolicyWaiverDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_policy_waiver_serialize(
        self,
        owner_type,
        owner_id,
        policy_waiver_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if owner_type is not None:
            _path_params['ownerType'] = owner_type
        if owner_id is not None:
            _path_params['ownerId'] = owner_id
        if policy_waiver_id is not None:
            _path_params['policyWaiverId'] = policy_waiver_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/policyWaivers/{ownerType}/{ownerId}/{policyWaiverId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_policy_waivers(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Enter the ownerType to specify the scope. The response will contain waivers that are within the scope specified.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApiPolicyWaiverDTO]:
        """get_policy_waivers

        Use this method to retrieve waiver details for all policy waivers for the scope specified. You can specify the scope by using the parameters ownerType and ownerId.  Permissions required: View IQ Elements

        :param owner_type: Enter the ownerType to specify the scope. The response will contain waivers that are within the scope specified. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_policy_waivers_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiPolicyWaiverDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_policy_waivers_with_http_info(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Enter the ownerType to specify the scope. The response will contain waivers that are within the scope specified.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ApiPolicyWaiverDTO]]:
        """get_policy_waivers

        Use this method to retrieve waiver details for all policy waivers for the scope specified. You can specify the scope by using the parameters ownerType and ownerId.  Permissions required: View IQ Elements

        :param owner_type: Enter the ownerType to specify the scope. The response will contain waivers that are within the scope specified. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_policy_waivers_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiPolicyWaiverDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_policy_waivers_without_preload_content(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Enter the ownerType to specify the scope. The response will contain waivers that are within the scope specified.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_policy_waivers

        Use this method to retrieve waiver details for all policy waivers for the scope specified. You can specify the scope by using the parameters ownerType and ownerId.  Permissions required: View IQ Elements

        :param owner_type: Enter the ownerType to specify the scope. The response will contain waivers that are within the scope specified. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_policy_waivers_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiPolicyWaiverDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_policy_waivers_serialize(
        self,
        owner_type,
        owner_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if owner_type is not None:
            _path_params['ownerType'] = owner_type
        if owner_id is not None:
            _path_params['ownerId'] = owner_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/policyWaivers/{ownerType}/{ownerId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_transitive_policy_waivers_by_app_scan_component(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Enter the ownerType to specify the scope. The response will contain the policy violations that are within the scope specified.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        scan_id: Annotated[StrictStr, Field(description="Enter the scanId (reportId) of the scan for which you want to retrieve the waivers on transitive policy violations occurring due the dependencies of a component.")],
        component_identifier: Annotated[Optional[ComponentIdentifier], Field(description="Enter the component identifier for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.")] = None,
        package_url: Annotated[Optional[StrictStr], Field(description="Enter the package URL for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.")] = None,
        hash: Annotated[Optional[StrictStr], Field(description="Enter the hash for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiComponentPolicyWaiversDTO:
        """get_transitive_policy_waivers_by_app_scan_component

        Use this method to retrieve all waivers on policy violations due to transitive dependencies for a specific component detected in a specific scan. Any one of the input parameters, i.e. componentIdentifier, packageUrl or hash is required. If more than one is provided, the system will pick them in the order specified here.  Permissions required: View IQ Elements

        :param owner_type: Enter the ownerType to specify the scope. The response will contain the policy violations that are within the scope specified. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param scan_id: Enter the scanId (reportId) of the scan for which you want to retrieve the waivers on transitive policy violations occurring due the dependencies of a component. (required)
        :type scan_id: str
        :param component_identifier: Enter the component identifier for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.
        :type component_identifier: ComponentIdentifier
        :param package_url: Enter the package URL for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.
        :type package_url: str
        :param hash: Enter the hash for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.
        :type hash: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_transitive_policy_waivers_by_app_scan_component_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            scan_id=scan_id,
            component_identifier=component_identifier,
            package_url=package_url,
            hash=hash,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiComponentPolicyWaiversDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_transitive_policy_waivers_by_app_scan_component_with_http_info(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Enter the ownerType to specify the scope. The response will contain the policy violations that are within the scope specified.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        scan_id: Annotated[StrictStr, Field(description="Enter the scanId (reportId) of the scan for which you want to retrieve the waivers on transitive policy violations occurring due the dependencies of a component.")],
        component_identifier: Annotated[Optional[ComponentIdentifier], Field(description="Enter the component identifier for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.")] = None,
        package_url: Annotated[Optional[StrictStr], Field(description="Enter the package URL for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.")] = None,
        hash: Annotated[Optional[StrictStr], Field(description="Enter the hash for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiComponentPolicyWaiversDTO]:
        """get_transitive_policy_waivers_by_app_scan_component

        Use this method to retrieve all waivers on policy violations due to transitive dependencies for a specific component detected in a specific scan. Any one of the input parameters, i.e. componentIdentifier, packageUrl or hash is required. If more than one is provided, the system will pick them in the order specified here.  Permissions required: View IQ Elements

        :param owner_type: Enter the ownerType to specify the scope. The response will contain the policy violations that are within the scope specified. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param scan_id: Enter the scanId (reportId) of the scan for which you want to retrieve the waivers on transitive policy violations occurring due the dependencies of a component. (required)
        :type scan_id: str
        :param component_identifier: Enter the component identifier for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.
        :type component_identifier: ComponentIdentifier
        :param package_url: Enter the package URL for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.
        :type package_url: str
        :param hash: Enter the hash for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.
        :type hash: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_transitive_policy_waivers_by_app_scan_component_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            scan_id=scan_id,
            component_identifier=component_identifier,
            package_url=package_url,
            hash=hash,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiComponentPolicyWaiversDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_transitive_policy_waivers_by_app_scan_component_without_preload_content(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Enter the ownerType to specify the scope. The response will contain the policy violations that are within the scope specified.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the corresponding id for the ownerType specified above.")],
        scan_id: Annotated[StrictStr, Field(description="Enter the scanId (reportId) of the scan for which you want to retrieve the waivers on transitive policy violations occurring due the dependencies of a component.")],
        component_identifier: Annotated[Optional[ComponentIdentifier], Field(description="Enter the component identifier for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.")] = None,
        package_url: Annotated[Optional[StrictStr], Field(description="Enter the package URL for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.")] = None,
        hash: Annotated[Optional[StrictStr], Field(description="Enter the hash for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_transitive_policy_waivers_by_app_scan_component

        Use this method to retrieve all waivers on policy violations due to transitive dependencies for a specific component detected in a specific scan. Any one of the input parameters, i.e. componentIdentifier, packageUrl or hash is required. If more than one is provided, the system will pick them in the order specified here.  Permissions required: View IQ Elements

        :param owner_type: Enter the ownerType to specify the scope. The response will contain the policy violations that are within the scope specified. (required)
        :type owner_type: str
        :param owner_id: Enter the corresponding id for the ownerType specified above. (required)
        :type owner_id: str
        :param scan_id: Enter the scanId (reportId) of the scan for which you want to retrieve the waivers on transitive policy violations occurring due the dependencies of a component. (required)
        :type scan_id: str
        :param component_identifier: Enter the component identifier for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.
        :type component_identifier: ComponentIdentifier
        :param package_url: Enter the package URL for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.
        :type package_url: str
        :param hash: Enter the hash for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.
        :type hash: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_transitive_policy_waivers_by_app_scan_component_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            scan_id=scan_id,
            component_identifier=component_identifier,
            package_url=package_url,
            hash=hash,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiComponentPolicyWaiversDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_transitive_policy_waivers_by_app_scan_component_serialize(
        self,
        owner_type,
        owner_id,
        scan_id,
        component_identifier,
        package_url,
        hash,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if owner_type is not None:
            _path_params['ownerType'] = owner_type
        if owner_id is not None:
            _path_params['ownerId'] = owner_id
        if scan_id is not None:
            _path_params['scanId'] = scan_id
        # process the query parameters
        if component_identifier is not None:
            
            _query_params.append(('componentIdentifier', component_identifier))
            
        if package_url is not None:
            
            _query_params.append(('packageUrl', package_url))
            
        if hash is not None:
            
            _query_params.append(('hash', hash))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/policyWaivers/transitive/{ownerType}/{ownerId}/{scanId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def request_policy_waiver(
        self,
        policy_violation_id: Annotated[StrictStr, Field(description="Enter the policyViolationId for which you want to trigger the waiver request event.")],
        api_request_policy_waiver_dto: Annotated[Optional[ApiRequestPolicyWaiverDTO], Field(description="The request JSON should contain<ol><li>comment (optional, default null) to indicate the waiver request reason</li><li>policyViolationLink (link to the policy violation page in the Lifecycle UI)</li><li>addWaiverLink (link to the Add Waiver page in the Lifecycle UI)</li></ol>")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """(Deprecated) request_policy_waiver

        Deprecated since IQ Server 1.192. Triggers a 'Waiver Request' webhook event. Deprecated because the webhook event is now integrated into the policy waiver request process. Please use `api/v2/policyWaiverRequests{ownerType}/policyViolation/{policyViolationId}` instead. Scheduled for removal in December 2025.

        :param policy_violation_id: Enter the policyViolationId for which you want to trigger the waiver request event. (required)
        :type policy_violation_id: str
        :param api_request_policy_waiver_dto: The request JSON should contain<ol><li>comment (optional, default null) to indicate the waiver request reason</li><li>policyViolationLink (link to the policy violation page in the Lifecycle UI)</li><li>addWaiverLink (link to the Add Waiver page in the Lifecycle UI)</li></ol>
        :type api_request_policy_waiver_dto: ApiRequestPolicyWaiverDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /api/v2/policyWaivers/waiverRequests/{policyViolationId} is deprecated.", DeprecationWarning)

        _param = self._request_policy_waiver_serialize(
            policy_violation_id=policy_violation_id,
            api_request_policy_waiver_dto=api_request_policy_waiver_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def request_policy_waiver_with_http_info(
        self,
        policy_violation_id: Annotated[StrictStr, Field(description="Enter the policyViolationId for which you want to trigger the waiver request event.")],
        api_request_policy_waiver_dto: Annotated[Optional[ApiRequestPolicyWaiverDTO], Field(description="The request JSON should contain<ol><li>comment (optional, default null) to indicate the waiver request reason</li><li>policyViolationLink (link to the policy violation page in the Lifecycle UI)</li><li>addWaiverLink (link to the Add Waiver page in the Lifecycle UI)</li></ol>")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """(Deprecated) request_policy_waiver

        Deprecated since IQ Server 1.192. Triggers a 'Waiver Request' webhook event. Deprecated because the webhook event is now integrated into the policy waiver request process. Please use `api/v2/policyWaiverRequests{ownerType}/policyViolation/{policyViolationId}` instead. Scheduled for removal in December 2025.

        :param policy_violation_id: Enter the policyViolationId for which you want to trigger the waiver request event. (required)
        :type policy_violation_id: str
        :param api_request_policy_waiver_dto: The request JSON should contain<ol><li>comment (optional, default null) to indicate the waiver request reason</li><li>policyViolationLink (link to the policy violation page in the Lifecycle UI)</li><li>addWaiverLink (link to the Add Waiver page in the Lifecycle UI)</li></ol>
        :type api_request_policy_waiver_dto: ApiRequestPolicyWaiverDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /api/v2/policyWaivers/waiverRequests/{policyViolationId} is deprecated.", DeprecationWarning)

        _param = self._request_policy_waiver_serialize(
            policy_violation_id=policy_violation_id,
            api_request_policy_waiver_dto=api_request_policy_waiver_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def request_policy_waiver_without_preload_content(
        self,
        policy_violation_id: Annotated[StrictStr, Field(description="Enter the policyViolationId for which you want to trigger the waiver request event.")],
        api_request_policy_waiver_dto: Annotated[Optional[ApiRequestPolicyWaiverDTO], Field(description="The request JSON should contain<ol><li>comment (optional, default null) to indicate the waiver request reason</li><li>policyViolationLink (link to the policy violation page in the Lifecycle UI)</li><li>addWaiverLink (link to the Add Waiver page in the Lifecycle UI)</li></ol>")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) request_policy_waiver

        Deprecated since IQ Server 1.192. Triggers a 'Waiver Request' webhook event. Deprecated because the webhook event is now integrated into the policy waiver request process. Please use `api/v2/policyWaiverRequests{ownerType}/policyViolation/{policyViolationId}` instead. Scheduled for removal in December 2025.

        :param policy_violation_id: Enter the policyViolationId for which you want to trigger the waiver request event. (required)
        :type policy_violation_id: str
        :param api_request_policy_waiver_dto: The request JSON should contain<ol><li>comment (optional, default null) to indicate the waiver request reason</li><li>policyViolationLink (link to the policy violation page in the Lifecycle UI)</li><li>addWaiverLink (link to the Add Waiver page in the Lifecycle UI)</li></ol>
        :type api_request_policy_waiver_dto: ApiRequestPolicyWaiverDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /api/v2/policyWaivers/waiverRequests/{policyViolationId} is deprecated.", DeprecationWarning)

        _param = self._request_policy_waiver_serialize(
            policy_violation_id=policy_violation_id,
            api_request_policy_waiver_dto=api_request_policy_waiver_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _request_policy_waiver_serialize(
        self,
        policy_violation_id,
        api_request_policy_waiver_dto,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if policy_violation_id is not None:
            _path_params['policyViolationId'] = policy_violation_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if api_request_policy_waiver_dto is not None:
            _body_params = api_request_policy_waiver_dto



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/policyWaivers/waiverRequests/{policyViolationId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_policy_waiver(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the policy waiver. Possible values are application, organization, repository, repository_manager, and repository_container.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the id for the `ownerType` provided above. E.g. `applicationId` if the `ownerType` is application.")],
        policy_waiver_id: Annotated[StrictStr, Field(description="Enter the id for the policy waiver.")],
        api_waiver_options_dto: Annotated[ApiWaiverOptionsDTO, Field(description="Enter the policy waiver details to update. Note that updating `matcherStrategy` is currently unsupported.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """update_policy_waiver

        Use this method to update an existing policy waiver.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the policy waiver. Possible values are application, organization, repository, repository_manager, and repository_container. (required)
        :type owner_type: str
        :param owner_id: Enter the id for the `ownerType` provided above. E.g. `applicationId` if the `ownerType` is application. (required)
        :type owner_id: str
        :param policy_waiver_id: Enter the id for the policy waiver. (required)
        :type policy_waiver_id: str
        :param api_waiver_options_dto: Enter the policy waiver details to update. Note that updating `matcherStrategy` is currently unsupported. (required)
        :type api_waiver_options_dto: ApiWaiverOptionsDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_policy_waiver_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            policy_waiver_id=policy_waiver_id,
            api_waiver_options_dto=api_waiver_options_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_policy_waiver_with_http_info(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the policy waiver. Possible values are application, organization, repository, repository_manager, and repository_container.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the id for the `ownerType` provided above. E.g. `applicationId` if the `ownerType` is application.")],
        policy_waiver_id: Annotated[StrictStr, Field(description="Enter the id for the policy waiver.")],
        api_waiver_options_dto: Annotated[ApiWaiverOptionsDTO, Field(description="Enter the policy waiver details to update. Note that updating `matcherStrategy` is currently unsupported.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """update_policy_waiver

        Use this method to update an existing policy waiver.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the policy waiver. Possible values are application, organization, repository, repository_manager, and repository_container. (required)
        :type owner_type: str
        :param owner_id: Enter the id for the `ownerType` provided above. E.g. `applicationId` if the `ownerType` is application. (required)
        :type owner_id: str
        :param policy_waiver_id: Enter the id for the policy waiver. (required)
        :type policy_waiver_id: str
        :param api_waiver_options_dto: Enter the policy waiver details to update. Note that updating `matcherStrategy` is currently unsupported. (required)
        :type api_waiver_options_dto: ApiWaiverOptionsDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_policy_waiver_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            policy_waiver_id=policy_waiver_id,
            api_waiver_options_dto=api_waiver_options_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_policy_waiver_without_preload_content(
        self,
        owner_type: Annotated[str, Field(strict=True, description="Indicates the scope of the policy waiver. Possible values are application, organization, repository, repository_manager, and repository_container.")],
        owner_id: Annotated[StrictStr, Field(description="Enter the id for the `ownerType` provided above. E.g. `applicationId` if the `ownerType` is application.")],
        policy_waiver_id: Annotated[StrictStr, Field(description="Enter the id for the policy waiver.")],
        api_waiver_options_dto: Annotated[ApiWaiverOptionsDTO, Field(description="Enter the policy waiver details to update. Note that updating `matcherStrategy` is currently unsupported.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """update_policy_waiver

        Use this method to update an existing policy waiver.  Permissions required: Waive Policy Violations

        :param owner_type: Indicates the scope of the policy waiver. Possible values are application, organization, repository, repository_manager, and repository_container. (required)
        :type owner_type: str
        :param owner_id: Enter the id for the `ownerType` provided above. E.g. `applicationId` if the `ownerType` is application. (required)
        :type owner_id: str
        :param policy_waiver_id: Enter the id for the policy waiver. (required)
        :type policy_waiver_id: str
        :param api_waiver_options_dto: Enter the policy waiver details to update. Note that updating `matcherStrategy` is currently unsupported. (required)
        :type api_waiver_options_dto: ApiWaiverOptionsDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_policy_waiver_serialize(
            owner_type=owner_type,
            owner_id=owner_id,
            policy_waiver_id=policy_waiver_id,
            api_waiver_options_dto=api_waiver_options_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_policy_waiver_serialize(
        self,
        owner_type,
        owner_id,
        policy_waiver_id,
        api_waiver_options_dto,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if owner_type is not None:
            _path_params['ownerType'] = owner_type
        if owner_id is not None:
            _path_params['ownerId'] = owner_id
        if policy_waiver_id is not None:
            _path_params['policyWaiverId'] = policy_waiver_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if api_waiver_options_dto is not None:
            _body_params = api_waiver_options_dto



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/policyWaivers/{ownerType}/{ownerId}/{policyWaiverId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


