# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/health/v3/hds.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "Capability",
    "CapabilityProtocol",
    "ClusterEndpointsHealth",
    "ClusterHealthCheck",
    "EndpointHealth",
    "EndpointHealthResponse",
    "HdsDummy",
    "HealthCheckRequest",
    "HealthCheckRequestOrEndpointHealthResponse",
    "HealthCheckSpecifier",
    "HealthDiscoveryServiceAsyncStub",
    "HealthDiscoveryServiceBase",
    "HealthDiscoveryServiceSyncStub",
    "LocalityEndpoints",
    "LocalityEndpointsHealth",
)

import datetime
import warnings
from collections.abc import AsyncIterable, AsyncIterator, Iterable, Iterator
from dataclasses import dataclass
from typing import TYPE_CHECKING

import betterproto2
import grpc
import grpclib
from betterproto2 import grpclib as betterproto2_grpclib

from .....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpclib.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class CapabilityProtocol(betterproto2.Enum):
    """
    Different Envoy instances may have different capabilities (e.g. Redis)
    and/or have ports enabled for different protocols.
    """

    HTTP = 0

    TCP = 1

    REDIS = 2


@dataclass(eq=False, repr=False)
class Capability(betterproto2.Message):
    """
    Defines supported protocols etc, so the management server can assign proper
    endpoints to healthcheck.
    """

    health_check_protocols: "list[CapabilityProtocol]" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.health.v3", "Capability", Capability
)


@dataclass(eq=False, repr=False)
class ClusterEndpointsHealth(betterproto2.Message):
    """
    The health status of endpoints in a cluster. The cluster name and locality
    should match the corresponding fields in ClusterHealthCheck message.
    """

    cluster_name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    locality_endpoints_health: "list[LocalityEndpointsHealth]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.health.v3", "ClusterEndpointsHealth", ClusterEndpointsHealth
)


@dataclass(eq=False, repr=False)
class ClusterHealthCheck(betterproto2.Message):
    """
    The cluster name and locality is provided to Envoy for the endpoints that it
    health checks to support statistics reporting, logging and debugging by the
    Envoy instance (outside of HDS). For maximum usefulness, it should match the
    same cluster structure as that provided by EDS.
    [#next-free-field: 6]
    """

    cluster_name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    health_checks: "list[___config__core__v3__.HealthCheck]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )

    locality_endpoints: "list[LocalityEndpoints]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )

    transport_socket_matches: "list[___config__cluster__v3__.ClusterTransportSocketMatch]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional map that gets filtered by :ref:`health_checks.transport_socket_match_criteria <envoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>`
    on connection when health checking. For more details, see
    :ref:`config.cluster.v3.Cluster.transport_socket_matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`.
    """

    upstream_bind_config: "___config__core__v3__.BindConfig | None" = (
        betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Optional configuration used to bind newly established upstream connections.
    If the address and port are empty, no bind will be performed.
    """


default_message_pool.register_message(
    "envoy.service.health.v3", "ClusterHealthCheck", ClusterHealthCheck
)


@dataclass(eq=False, repr=False)
class EndpointHealth(betterproto2.Message):
    endpoint: "___config__endpoint__v3__.Endpoint | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    health_status: "___config__core__v3__.HealthStatus" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ___config__core__v3__.HealthStatus(0),
    )


default_message_pool.register_message(
    "envoy.service.health.v3", "EndpointHealth", EndpointHealth
)


@dataclass(eq=False, repr=False)
class EndpointHealthResponse(betterproto2.Message):
    endpoints_health: "list[EndpointHealth]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Deprecated - Flat list of endpoint health information.
    """

    cluster_endpoints_health: "list[ClusterEndpointsHealth]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Organize Endpoint health information by cluster.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("endpoints_health"):
            warnings.warn(
                "EndpointHealthResponse.endpoints_health is deprecated",
                DeprecationWarning,
            )


default_message_pool.register_message(
    "envoy.service.health.v3", "EndpointHealthResponse", EndpointHealthResponse
)


@dataclass(eq=False, repr=False)
class HdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221 and protoxform to upgrade the file.
    """

    pass


default_message_pool.register_message("envoy.service.health.v3", "HdsDummy", HdsDummy)


@dataclass(eq=False, repr=False)
class HealthCheckRequest(betterproto2.Message):
    node: "___config__core__v3__.Node | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    capability: "Capability | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "envoy.service.health.v3", "HealthCheckRequest", HealthCheckRequest
)


@dataclass(eq=False, repr=False)
class HealthCheckRequestOrEndpointHealthResponse(betterproto2.Message):
    """


    Oneofs:
        - request_type:
    """

    health_check_request: "HealthCheckRequest | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="request_type"
    )

    endpoint_health_response: "EndpointHealthResponse | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="request_type"
    )


default_message_pool.register_message(
    "envoy.service.health.v3",
    "HealthCheckRequestOrEndpointHealthResponse",
    HealthCheckRequestOrEndpointHealthResponse,
)


@dataclass(eq=False, repr=False)
class HealthCheckSpecifier(betterproto2.Message):
    cluster_health_checks: "list[ClusterHealthCheck]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )

    interval: "datetime.timedelta | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The default is 1 second.
    """


default_message_pool.register_message(
    "envoy.service.health.v3", "HealthCheckSpecifier", HealthCheckSpecifier
)


@dataclass(eq=False, repr=False)
class LocalityEndpoints(betterproto2.Message):
    locality: "___config__core__v3__.Locality | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    endpoints: "list[___config__endpoint__v3__.Endpoint]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.health.v3", "LocalityEndpoints", LocalityEndpoints
)


@dataclass(eq=False, repr=False)
class LocalityEndpointsHealth(betterproto2.Message):
    """
    Group endpoint health by locality under each cluster.
    """

    locality: "___config__core__v3__.Locality | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    endpoints_health: "list[EndpointHealth]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.health.v3", "LocalityEndpointsHealth", LocalityEndpointsHealth
)


class HealthDiscoveryServiceSyncStub:
    """
    [#protodoc-title: Health discovery service (HDS)]

    HDS is Health Discovery Service. It compliments Envoyâ€™s health checking
    service by designating this Envoy to be a healthchecker for a subset of hosts
    in the cluster. The status of these health checks will be reported to the
    management server, where it can be aggregated etc and redistributed back to
    Envoy through EDS.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_health_check(
        self, messages: "Iterable[HealthCheckRequestOrEndpointHealthResponse]"
    ) -> "Iterator[HealthCheckSpecifier]":
        """
        1. Envoy starts up and if its can_healthcheck option in the static
           bootstrap config is enabled, sends HealthCheckRequest to the management
           server. It supplies its capabilities (which protocol it can health check
           with, what zone it resides in, etc.).
        2. In response to (1), the management server designates this Envoy as a
           healthchecker to health check a subset of all upstream hosts for a given
           cluster (for example upstream Host 1 and Host 2). It streams
           HealthCheckSpecifier messages with cluster related configuration for all
           clusters this Envoy is designated to health check. Subsequent
           HealthCheckSpecifier message will be sent on changes to:
           a. Endpoints to health checks
           b. Per cluster configuration change
        3. Envoy creates a health probe based on the HealthCheck config and sends
           it to endpoint(ip:port) of Host 1 and 2. Based on the HealthCheck
           configuration Envoy waits upon the arrival of the probe response and
           looks at the content of the response to decide whether the endpoint is
           healthy or not. If a response hasn't been received within the timeout
           interval, the endpoint health status is considered TIMEOUT.
        4. Envoy reports results back in an EndpointHealthResponse message.
           Envoy streams responses as often as the interval configured by the
           management server in HealthCheckSpecifier.
        5. The management Server collects health statuses for all endpoints in the
           cluster (for all clusters) and uses this information to construct
           EndpointDiscoveryResponse messages.
        6. Once Envoy has a list of upstream endpoints to send traffic to, it load
           balances traffic to them without additional health checking. It may
           use inline healthcheck (i.e. consider endpoint UNHEALTHY if connection
           failed to a particular endpoint to account for health status propagation
           delay between HDS and EDS).
        By default, can_healthcheck is true. If can_healthcheck is false, Cluster
        configuration may not contain HealthCheck message.
        TODO(htuch): How is can_healthcheck communicated to CDS to ensure the above
        invariant?
        TODO(htuch): Add @amb67's diagram.
        """

        yield from self._channel.stream_stream(
            "/envoy.service.health.v3.HealthDiscoveryService/StreamHealthCheck",
            HealthCheckRequestOrEndpointHealthResponse.SerializeToString,
            HealthCheckSpecifier.FromString,
        )(iter(messages))

    def fetch_health_check(
        self, message: "HealthCheckRequestOrEndpointHealthResponse"
    ) -> "HealthCheckSpecifier":
        """
        TODO(htuch): Unlike the gRPC version, there is no stream-based binding of
        request/response. Should we add an identifier to the HealthCheckSpecifier
        to bind with the response?
        """

        return self._channel.unary_unary(
            "/envoy.service.health.v3.HealthDiscoveryService/FetchHealthCheck",
            HealthCheckRequestOrEndpointHealthResponse.SerializeToString,
            HealthCheckSpecifier.FromString,
        )(message)


class HealthDiscoveryServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: Health discovery service (HDS)]

    HDS is Health Discovery Service. It compliments Envoyâ€™s health checking
    service by designating this Envoy to be a healthchecker for a subset of hosts
    in the cluster. The status of these health checks will be reported to the
    management server, where it can be aggregated etc and redistributed back to
    Envoy through EDS.
    """

    async def stream_health_check(
        self,
        messages: "AsyncIterable[HealthCheckRequestOrEndpointHealthResponse] | Iterable[HealthCheckRequestOrEndpointHealthResponse]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[HealthCheckSpecifier]":
        """
        1. Envoy starts up and if its can_healthcheck option in the static
           bootstrap config is enabled, sends HealthCheckRequest to the management
           server. It supplies its capabilities (which protocol it can health check
           with, what zone it resides in, etc.).
        2. In response to (1), the management server designates this Envoy as a
           healthchecker to health check a subset of all upstream hosts for a given
           cluster (for example upstream Host 1 and Host 2). It streams
           HealthCheckSpecifier messages with cluster related configuration for all
           clusters this Envoy is designated to health check. Subsequent
           HealthCheckSpecifier message will be sent on changes to:
           a. Endpoints to health checks
           b. Per cluster configuration change
        3. Envoy creates a health probe based on the HealthCheck config and sends
           it to endpoint(ip:port) of Host 1 and 2. Based on the HealthCheck
           configuration Envoy waits upon the arrival of the probe response and
           looks at the content of the response to decide whether the endpoint is
           healthy or not. If a response hasn't been received within the timeout
           interval, the endpoint health status is considered TIMEOUT.
        4. Envoy reports results back in an EndpointHealthResponse message.
           Envoy streams responses as often as the interval configured by the
           management server in HealthCheckSpecifier.
        5. The management Server collects health statuses for all endpoints in the
           cluster (for all clusters) and uses this information to construct
           EndpointDiscoveryResponse messages.
        6. Once Envoy has a list of upstream endpoints to send traffic to, it load
           balances traffic to them without additional health checking. It may
           use inline healthcheck (i.e. consider endpoint UNHEALTHY if connection
           failed to a particular endpoint to account for health status propagation
           delay between HDS and EDS).
        By default, can_healthcheck is true. If can_healthcheck is false, Cluster
        configuration may not contain HealthCheck message.
        TODO(htuch): How is can_healthcheck communicated to CDS to ensure the above
        invariant?
        TODO(htuch): Add @amb67's diagram.
        """

        async for response in self._stream_stream(
            "/envoy.service.health.v3.HealthDiscoveryService/StreamHealthCheck",
            messages,
            HealthCheckRequestOrEndpointHealthResponse,
            HealthCheckSpecifier,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def fetch_health_check(
        self,
        message: "HealthCheckRequestOrEndpointHealthResponse",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "HealthCheckSpecifier":
        """
        TODO(htuch): Unlike the gRPC version, there is no stream-based binding of
        request/response. Should we add an identifier to the HealthCheckSpecifier
        to bind with the response?
        """

        return await self._unary_unary(
            "/envoy.service.health.v3.HealthDiscoveryService/FetchHealthCheck",
            message,
            HealthCheckSpecifier,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from .....google import protobuf as ____google__protobuf__
from ....config.cluster import v3 as ___config__cluster__v3__
from ....config.core import v3 as ___config__core__v3__
from ....config.endpoint import v3 as ___config__endpoint__v3__


class HealthDiscoveryServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: Health discovery service (HDS)]

    HDS is Health Discovery Service. It compliments Envoyâ€™s health checking
    service by designating this Envoy to be a healthchecker for a subset of hosts
    in the cluster. The status of these health checks will be reported to the
    management server, where it can be aggregated etc and redistributed back to
    Envoy through EDS.
    """

    async def stream_health_check(
        self, messages: "AsyncIterator[HealthCheckRequestOrEndpointHealthResponse]"
    ) -> "AsyncIterator[HealthCheckSpecifier]":
        """
        1. Envoy starts up and if its can_healthcheck option in the static
           bootstrap config is enabled, sends HealthCheckRequest to the management
           server. It supplies its capabilities (which protocol it can health check
           with, what zone it resides in, etc.).
        2. In response to (1), the management server designates this Envoy as a
           healthchecker to health check a subset of all upstream hosts for a given
           cluster (for example upstream Host 1 and Host 2). It streams
           HealthCheckSpecifier messages with cluster related configuration for all
           clusters this Envoy is designated to health check. Subsequent
           HealthCheckSpecifier message will be sent on changes to:
           a. Endpoints to health checks
           b. Per cluster configuration change
        3. Envoy creates a health probe based on the HealthCheck config and sends
           it to endpoint(ip:port) of Host 1 and 2. Based on the HealthCheck
           configuration Envoy waits upon the arrival of the probe response and
           looks at the content of the response to decide whether the endpoint is
           healthy or not. If a response hasn't been received within the timeout
           interval, the endpoint health status is considered TIMEOUT.
        4. Envoy reports results back in an EndpointHealthResponse message.
           Envoy streams responses as often as the interval configured by the
           management server in HealthCheckSpecifier.
        5. The management Server collects health statuses for all endpoints in the
           cluster (for all clusters) and uses this information to construct
           EndpointDiscoveryResponse messages.
        6. Once Envoy has a list of upstream endpoints to send traffic to, it load
           balances traffic to them without additional health checking. It may
           use inline healthcheck (i.e. consider endpoint UNHEALTHY if connection
           failed to a particular endpoint to account for health status propagation
           delay between HDS and EDS).
        By default, can_healthcheck is true. If can_healthcheck is false, Cluster
        configuration may not contain HealthCheck message.
        TODO(htuch): How is can_healthcheck communicated to CDS to ensure the above
        invariant?
        TODO(htuch): Add @amb67's diagram.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield HealthCheckSpecifier()

    async def fetch_health_check(
        self, message: "HealthCheckRequestOrEndpointHealthResponse"
    ) -> "HealthCheckSpecifier":
        """
        TODO(htuch): Unlike the gRPC version, there is no stream-based binding of
        request/response. Should we add an identifier to the HealthCheckSpecifier
        to bind with the response?
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_health_check(
        self,
        stream: "grpclib.server.Stream[HealthCheckRequestOrEndpointHealthResponse, HealthCheckSpecifier]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_health_check,
            stream,
            request,
        )

    async def __rpc_fetch_health_check(
        self,
        stream: "grpclib.server.Stream[HealthCheckRequestOrEndpointHealthResponse, HealthCheckSpecifier]",
    ) -> None:
        request = await stream.recv_message()
        assert request is not None
        response = await self.fetch_health_check(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.health.v3.HealthDiscoveryService/StreamHealthCheck": grpclib.const.Handler(
                self.__rpc_stream_health_check,
                grpclib.const.Cardinality.STREAM_STREAM,
                HealthCheckRequestOrEndpointHealthResponse,
                HealthCheckSpecifier,
            ),
            "/envoy.service.health.v3.HealthDiscoveryService/FetchHealthCheck": grpclib.const.Handler(
                self.__rpc_fetch_health_check,
                grpclib.const.Cardinality.UNARY_UNARY,
                HealthCheckRequestOrEndpointHealthResponse,
                HealthCheckSpecifier,
            ),
        }
