# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: cel/expr/checked.proto, cel/expr/syntax.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "CheckedExpr",
    "Constant",
    "Decl",
    "DeclFunctionDecl",
    "DeclFunctionDeclOverload",
    "DeclIdentDecl",
    "Expr",
    "ExprCall",
    "ExprComprehension",
    "ExprCreateList",
    "ExprCreateStruct",
    "ExprCreateStructEntry",
    "ExprIdent",
    "ExprSelect",
    "ParsedExpr",
    "Reference",
    "SourceInfo",
    "SourceInfoExtension",
    "SourceInfoExtensionComponent",
    "SourceInfoExtensionVersion",
    "Type",
    "TypeAbstractType",
    "TypeFunctionType",
    "TypeListType",
    "TypeMapType",
    "TypePrimitiveType",
    "TypeWellKnownType",
)

import datetime
import warnings
from dataclasses import dataclass

import betterproto2

from ...message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class SourceInfoExtensionComponent(betterproto2.Enum):
    """
    CEL component specifier.
    """

    UNSPECIFIED = 0
    """
    Unspecified, default.
    """

    PARSER = 1
    """
    Parser. Converts a CEL string to an AST.
    """

    TYPE_CHECKER = 2
    """
    Type checker. Checks that references in an AST are defined and types
    agree.
    """

    RUNTIME = 3
    """
    Runtime. Evaluates a parsed and optionally checked CEL AST against a
    context.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "COMPONENT_UNSPECIFIED",
            1: "COMPONENT_PARSER",
            2: "COMPONENT_TYPE_CHECKER",
            3: "COMPONENT_RUNTIME",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "COMPONENT_UNSPECIFIED": 0,
            "COMPONENT_PARSER": 1,
            "COMPONENT_TYPE_CHECKER": 2,
            "COMPONENT_RUNTIME": 3,
        }


class TypePrimitiveType(betterproto2.Enum):
    """
    CEL primitive types.
    """

    PRIMITIVE_TYPE_UNSPECIFIED = 0
    """
    Unspecified type.
    """

    BOOL = 1
    """
    Boolean type.
    """

    INT64 = 2
    """
    Int64 type.

    32-bit integer values are widened to int64.
    """

    UINT64 = 3
    """
    Uint64 type.

    32-bit unsigned integer values are widened to uint64.
    """

    DOUBLE = 4
    """
    Double type.

    32-bit float values are widened to double values.
    """

    STRING = 5
    """
    String type.
    """

    BYTES = 6
    """
    Bytes type.
    """


class TypeWellKnownType(betterproto2.Enum):
    """
    Well-known protobuf types treated with first-class support in CEL.
    """

    WELL_KNOWN_TYPE_UNSPECIFIED = 0
    """
    Unspecified type.
    """

    ANY = 1
    """
    Well-known protobuf.Any type.

    Any types are a polymorphic message type. During type-checking they are
    treated like `DYN` types, but at runtime they are resolved to a specific
    message type specified at evaluation time.
    """

    TIMESTAMP = 2
    """
    Well-known protobuf.Timestamp type, internally referenced as `timestamp`.
    """

    DURATION = 3
    """
    Well-known protobuf.Duration type, internally referenced as `duration`.
    """


@dataclass(eq=False, repr=False)
class CheckedExpr(betterproto2.Message):
    """
    Protos for representing CEL declarations and typed checked expressions.

    A CEL expression which has been successfully type checked.
    """

    reference_map: "dict[int, Reference]" = betterproto2.field(
        2,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_INT64, betterproto2.TYPE_MESSAGE
        ),
    )
    """
    A map from expression ids to resolved references.

    The following entries are in this table:

    - An Ident or Select expression is represented here if it resolves to a
      declaration. For instance, if `a.b.c` is represented by
      `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
      while `c` is a field selection, then the reference is attached to the
      nested select expression (but not to the id or or the outer select).
      In turn, if `a` resolves to a declaration and `b.c` are field selections,
      the reference is attached to the ident expression.
    - Every Call expression has an entry here, identifying the function being
      called.
    - Every CreateStruct expression for a message has an entry, identifying
      the message.
    """

    type_map: "dict[int, Type]" = betterproto2.field(
        3,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_INT64, betterproto2.TYPE_MESSAGE
        ),
    )
    """
    A map from expression ids to types.

    Every expression node which has a type different than DYN has a mapping
    here. If an expression has type DYN, it is omitted from this map to save
    space.
    """

    source_info: "SourceInfo | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The source info derived from input that generated the parsed `expr` and
    any optimizations made during the type-checking pass.
    """

    expr_version: "str" = betterproto2.field(6, betterproto2.TYPE_STRING)
    """
    The expr version indicates the major / minor version number of the `expr`
    representation.

    The most common reason for a version change will be to indicate to the CEL
    runtimes that transformations have been performed on the expr during static
    analysis. In some cases, this will save the runtime the work of applying
    the same or similar transformations prior to evaluation.
    """

    expr: "Expr | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The checked expression. Semantically equivalent to the parsed `expr`, but
    may have structural differences.
    """


default_message_pool.register_message("cel.expr", "CheckedExpr", CheckedExpr)


@dataclass(eq=False, repr=False)
class Constant(betterproto2.Message):
    """
    Represents a primitive literal.

    Named 'Constant' here for backwards compatibility.

    This is similar as the primitives supported in the well-known type
    `google.protobuf.Value`, but richer so it can represent CEL's full range of
    primitives.

    Lists and structs are not included as constants as these aggregate types may
    contain [Expr][cel.expr.Expr] elements which require evaluation and
    are thus not constant.

    Examples of constants include: `"hello"`, `b'bytes'`, `1u`, `4.2`, `-2`,
    `true`, `null`.

    Oneofs:
        - constant_kind: Required. The valid constant kinds.
    """

    null_value: "__google__protobuf__.NullValue | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True, group="constant_kind"
    )
    """
    null value.
    """

    bool_value: "bool | None" = betterproto2.field(
        2, betterproto2.TYPE_BOOL, optional=True, group="constant_kind"
    )
    """
    boolean value.
    """

    int64_value: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_INT64, optional=True, group="constant_kind"
    )
    """
    int64 value.
    """

    uint64_value: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, optional=True, group="constant_kind"
    )
    """
    uint64 value.
    """

    double_value: "float | None" = betterproto2.field(
        5, betterproto2.TYPE_DOUBLE, optional=True, group="constant_kind"
    )
    """
    double value.
    """

    string_value: "str | None" = betterproto2.field(
        6, betterproto2.TYPE_STRING, optional=True, group="constant_kind"
    )
    """
    string value.
    """

    bytes_value: "bytes | None" = betterproto2.field(
        7, betterproto2.TYPE_BYTES, optional=True, group="constant_kind"
    )
    """
    bytes value.
    """

    duration_value: "datetime.timedelta | None" = betterproto2.field(
        8,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: __google__protobuf__.Duration,
        optional=True,
        group="constant_kind",
    )
    """
    protobuf.Duration value.

    Deprecated: duration is no longer considered a builtin cel type.
    """

    timestamp_value: "datetime.datetime | None" = betterproto2.field(
        9,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: __google__protobuf__.Timestamp,
        optional=True,
        group="constant_kind",
    )
    """
    protobuf.Timestamp value.

    Deprecated: timestamp is no longer considered a builtin cel type.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("duration_value"):
            warnings.warn("Constant.duration_value is deprecated", DeprecationWarning)
        if self.is_set("timestamp_value"):
            warnings.warn("Constant.timestamp_value is deprecated", DeprecationWarning)


default_message_pool.register_message("cel.expr", "Constant", Constant)


@dataclass(eq=False, repr=False)
class Decl(betterproto2.Message):
    """
    Represents a declaration of a named value or function.

    A declaration is part of the contract between the expression, the agent
    evaluating that expression, and the caller requesting evaluation.

    Oneofs:
        - decl_kind: Required. The declaration kind.
    """

    name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    The fully qualified name of the declaration.

    Declarations are organized in containers and this represents the full path
    to the declaration in its container, as in `cel.expr.Decl`.

    Declarations used as
    [FunctionDecl.Overload][cel.expr.Decl.FunctionDecl.Overload]
    parameters may or may not have a name depending on whether the overload is
    function declaration or a function definition containing a result
    [Expr][cel.expr.Expr].
    """

    ident: "DeclIdentDecl | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="decl_kind"
    )
    """
    Identifier declaration.
    """

    function: "DeclFunctionDecl | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="decl_kind"
    )
    """
    Function declaration.
    """


default_message_pool.register_message("cel.expr", "Decl", Decl)


@dataclass(eq=False, repr=False)
class DeclFunctionDecl(betterproto2.Message):
    """
    Function declaration specifies one or more overloads which indicate the
    function's parameter types and return type.

    Functions have no observable side-effects (there may be side-effects like
    logging which are not observable from CEL).
    """

    overloads: "list[DeclFunctionDeclOverload]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Required. List of function overloads, must contain at least one overload.
    """

    doc: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Documentation string for the function that indicates the general purpose
    of the function and its behavior.

    Documentation strings for the function should be general purpose with
    specific examples provided in the overload doc string.

    Examples:

        The 'in' operator tests whether an item exists in a collection.

        The 'substring' function returns a substring of a target string.
    """


default_message_pool.register_message("cel.expr", "Decl.FunctionDecl", DeclFunctionDecl)


@dataclass(eq=False, repr=False)
class DeclFunctionDeclOverload(betterproto2.Message):
    """
    An overload indicates a function's parameter types and return type, and
    may optionally include a function body described in terms of
    [Expr][cel.expr.Expr] values.

    Functions overloads are declared in either a function or method
    call-style. For methods, the `params[0]` is the expected type of the
    target receiver.

    Overloads must have non-overlapping argument types after erasure of all
    parameterized type variables (similar as type erasure in Java).
    """

    overload_id: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    Required. Globally unique overload name of the function which reflects
    the function name and argument types.

    This will be used by a [Reference][cel.expr.Reference] to
    indicate the `overload_id` that was resolved for the function `name`.
    """

    params: "list[Type]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of function parameter [Type][cel.expr.Type] values.

    Param types are disjoint after generic type parameters have been
    replaced with the type `DYN`. Since the `DYN` type is compatible with
    any other type, this means that if `A` is a type parameter, the
    function types `int<A>` and `int<int>` are not disjoint. Likewise,
    `map<string, string>` is not disjoint from `map<K, V>`.

    When the `result_type` of a function is a generic type param, the
    type param name also appears as the `type` of on at least one params.
    """

    type_params: "list[str]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )
    """
    The type param names associated with the function declaration.

    For example, `function ex<K,V>(K key, map<K, V> map) : V` would yield
    the type params of `K, V`.
    """

    result_type: "Type | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Required. The result type of the function. For example, the operator
    `string.isEmpty()` would have `result_type` of `kind: BOOL`.
    """

    is_instance_function: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    Whether the function is to be used in a method call-style `x.f(...)`
    of a function call-style `f(x, ...)`.

    For methods, the first parameter declaration, `params[0]` is the
    expected type of the target receiver.
    """

    doc: "str" = betterproto2.field(6, betterproto2.TYPE_STRING)
    """
    Documentation string for the overload.

    Provide examples of the overload behavior, preferring to use literal
    values as input with a comment on the return value.

    Examples:

       // Determine whether a value of type <V> exists within a list<V>.
       2 in [1, 2, 3] // returns true

       // Determine whether a key of type <K> exists within a map<K,V>.
       'hello' in {'hi': 'you', 'hello': 'there'}  // returns true
       'help' in {'hi': 'you', 'hello': 'there'}  // returns false

       // Take the substring of a string starting at a specific character
       // offset (inclusive).
       "tacocat".substring(1) // returns "acocat"
       "tacocat".substring(20) // error

       // Take the substring of a string starting at a specific character
       // offset (inclusive) and ending at the given offset (exclusive).
       "tacocat".substring(1, 6) // returns "acoca"
    """


default_message_pool.register_message(
    "cel.expr", "Decl.FunctionDecl.Overload", DeclFunctionDeclOverload
)


@dataclass(eq=False, repr=False)
class DeclIdentDecl(betterproto2.Message):
    """
    Identifier declaration which specifies its type and optional `Expr` value.

    An identifier without a value is a declaration that must be provided at
    evaluation time. An identifier with a value should resolve to a constant,
    but may be used in conjunction with other identifiers bound at evaluation
    time.
    """

    type: "Type | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Required. The type of the identifier.
    """

    value: "Constant | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The constant value of the identifier. If not specified, the identifier
    must be supplied at evaluation time.
    """

    doc: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    Documentation string for the identifier.

    Provide a brief description of what the variable represents and whether
    there are any constraints on the formatting or supported value range.

    Examples:

       'request.auth.principal' - string which uniquely identifies an
       authenticated principal. For JSON Web Tokens (JWTs), the principal
       is the combination of the issuer ('iss') and subject ('sub') token
       fields concatenated by a forward slash: iss + `/` + sub.

       'min_cpus' - integer value indicates the minimum number of CPUs
       required for a compute cluster. The 'min_cpus' value must be 
       greater than zero and less than 'max_cpus' or 64 whichever is less.
    """


default_message_pool.register_message("cel.expr", "Decl.IdentDecl", DeclIdentDecl)


@dataclass(eq=False, repr=False)
class Expr(betterproto2.Message):
    """
    An abstract representation of a common expression.

    Expressions are abstractly represented as a collection of identifiers,
    select statements, function calls, literals, and comprehensions. All
    operators with the exception of the '.' operator are modelled as function
    calls. This makes it easy to represent new operators into the existing AST.

    All references within expressions must resolve to a
    [Decl][cel.expr.Decl] provided at type-check for an expression to be
    valid. A reference may either be a bare identifier `name` or a qualified
    identifier `google.api.name`. References may either refer to a value or a
    function declaration.

    For example, the expression `google.api.name.startsWith('expr')` references
    the declaration `google.api.name` within a
    [Expr.Select][cel.expr.Expr.Select] expression, and the function
    declaration `startsWith`.

    Oneofs:
        - expr_kind: Required. Variants of expressions.
    """

    id: "int" = betterproto2.field(2, betterproto2.TYPE_INT64)
    """
    Required. An id assigned to this node by the parser which is unique in a
    given expression tree. This is used to associate type information and other
    attributes to a node in the parse tree.
    """

    const_expr: "Constant | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="expr_kind"
    )
    """
    A constant expression.
    """

    ident_expr: "ExprIdent | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="expr_kind"
    )
    """
    An identifier expression.
    """

    select_expr: "ExprSelect | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="expr_kind"
    )
    """
    A field selection expression, e.g. `request.auth`.
    """

    call_expr: "ExprCall | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="expr_kind"
    )
    """
    A call expression, including calls to predefined functions and operators.
    """

    list_expr: "ExprCreateList | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="expr_kind"
    )
    """
    A list creation expression.
    """

    struct_expr: "ExprCreateStruct | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="expr_kind"
    )
    """
    A map or message creation expression.
    """

    comprehension_expr: "ExprComprehension | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="expr_kind"
    )
    """
    A comprehension expression.
    """


default_message_pool.register_message("cel.expr", "Expr", Expr)


@dataclass(eq=False, repr=False)
class ExprCall(betterproto2.Message):
    """
    A call expression, including calls to predefined functions and operators.

    For example, `value == 10`, `size(map_value)`.
    """

    target: "Expr | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The target of an method call-style expression. For example, `x` in
    `x.f()`.
    """

    function: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Required. The name of the function or method being called.
    """

    args: "list[Expr]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    The arguments.
    """


default_message_pool.register_message("cel.expr", "Expr.Call", ExprCall)


@dataclass(eq=False, repr=False)
class ExprComprehension(betterproto2.Message):
    """
    A comprehension expression applied to a list or map.

    Comprehensions are not part of the core syntax, but enabled with macros.
    A macro matches a specific call signature within a parsed AST and replaces
    the call with an alternate AST block. Macro expansion happens at parse
    time.

    The following macros are supported within CEL:

    Aggregate type macros may be applied to all elements in a list or all keys
    in a map:

    *  `all`, `exists`, `exists_one` -  test a predicate expression against
       the inputs and return `true` if the predicate is satisfied for all,
       any, or only one value `list.all(x, x < 10)`.
    *  `filter` - test a predicate expression against the inputs and return
       the subset of elements which satisfy the predicate:
       `payments.filter(p, p > 1000)`.
    *  `map` - apply an expression to all elements in the input and return the
       output aggregate type: `[1, 2, 3].map(i, i * i)`.

    The `has(m.x)` macro tests whether the property `x` is present in struct
    `m`. The semantics of this macro depend on the type of `m`. For proto2
    messages `has(m.x)` is defined as 'defined, but not set`. For proto3, the
    macro tests whether the property is set to its default. For map and struct
    types, the macro tests whether the property `x` is defined on `m`.

    Comprehensions for the standard environment macros evaluation can be best
    visualized as the following pseudocode:

    ```
    let `accu_var` = `accu_init`
    for (let `iter_var` in `iter_range`) {
      if (!`loop_condition`) {
        break
      }
      `accu_var` = `loop_step`
    }
    return `result`
    ```

    Comprehensions for the optional V2 macros which support map-to-map
    translation differ slightly from the standard environment macros in that
    they expose both the key or index in addition to the value for each list
    or map entry:

    ```
    let `accu_var` = `accu_init`
    for (let `iter_var`, `iter_var2` in `iter_range`) {
      if (!`loop_condition`) {
        break
      }
      `accu_var` = `loop_step`
    }
    return `result`
    ```
    """

    iter_var: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    The name of the first iteration variable.
    For the single iteration variable macros, when iter_range is a list, this
    variable is the list element and when the iter_range is a map, this
    variable is the map key.
    """

    iter_var2: "str" = betterproto2.field(8, betterproto2.TYPE_STRING)
    """
    The name of the second iteration variable, empty if not set.
    This field is only set for comprehension v2 macros.
    """

    iter_range: "Expr | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The range over which the comprehension iterates.
    """

    accu_var: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    The name of the variable used for accumulation of the result.
    """

    accu_init: "Expr | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The initial value of the accumulator.
    """

    loop_condition: "Expr | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    An expression which can contain iter_var, iter_var2, and accu_var.

    Returns false when the result has been computed and may be used as
    a hint to short-circuit the remainder of the comprehension.
    """

    loop_step: "Expr | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    An expression which can contain iter_var, iter_var2, and accu_var.

    Computes the next value of accu_var.
    """

    result: "Expr | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    An expression which can contain accu_var.

    Computes the result.
    """


default_message_pool.register_message(
    "cel.expr", "Expr.Comprehension", ExprComprehension
)


@dataclass(eq=False, repr=False)
class ExprCreateList(betterproto2.Message):
    """
    A list creation expression.

    Lists may either be homogenous, e.g. `[1, 2, 3]`, or heterogeneous, e.g.
    `dyn([1, 'hello', 2.0])`
    """

    elements: "list[Expr]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The elements part of the list.
    """

    optional_indices: "list[int]" = betterproto2.field(
        2, betterproto2.TYPE_INT32, repeated=True
    )
    """
    The indices within the elements list which are marked as optional
    elements.

    When an optional-typed value is present, the value it contains
    is included in the list. If the optional-typed value is absent, the list
    element is omitted from the CreateList result.
    """


default_message_pool.register_message("cel.expr", "Expr.CreateList", ExprCreateList)


@dataclass(eq=False, repr=False)
class ExprCreateStruct(betterproto2.Message):
    """
    A map or message creation expression.

    Maps are constructed as `{'key_name': 'value'}`. Message construction is
    similar, but prefixed with a type name and composed of field ids:
    `types.MyType{field_id: 'value'}`.
    """

    message_name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    The type name of the message to be created, empty when creating map
    literals.
    """

    entries: "list[ExprCreateStructEntry]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The entries in the creation expression.
    """


default_message_pool.register_message("cel.expr", "Expr.CreateStruct", ExprCreateStruct)


@dataclass(eq=False, repr=False)
class ExprCreateStructEntry(betterproto2.Message):
    """
    Represents an entry.

    Oneofs:
        - key_kind: The `Entry` key kinds.
    """

    id: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)
    """
    Required. An id assigned to this node by the parser which is unique
    in a given expression tree. This is used to associate type
    information and other attributes to the node.
    """

    field_key: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="key_kind"
    )
    """
    The field key for a message creator statement.
    """

    map_key: "Expr | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="key_kind"
    )
    """
    The key expression for a map creation statement.
    """

    value: "Expr | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Required. The value assigned to the key.

    If the optional_entry field is true, the expression must resolve to an
    optional-typed value. If the optional value is present, the key will be
    set; however, if the optional value is absent, the key will be unset.
    """

    optional_entry: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    Whether the key-value pair is optional.
    """


default_message_pool.register_message(
    "cel.expr", "Expr.CreateStruct.Entry", ExprCreateStructEntry
)


@dataclass(eq=False, repr=False)
class ExprIdent(betterproto2.Message):
    """
    An identifier expression. e.g. `request`.
    """

    name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    Required. Holds a single, unqualified identifier, possibly preceded by a
    '.'.

    Qualified names are represented by the
    [Expr.Select][cel.expr.Expr.Select] expression.
    """


default_message_pool.register_message("cel.expr", "Expr.Ident", ExprIdent)


@dataclass(eq=False, repr=False)
class ExprSelect(betterproto2.Message):
    """
    A field selection expression. e.g. `request.auth`.
    """

    operand: "Expr | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Required. The target of the selection expression.

    For example, in the select expression `request.auth`, the `request`
    portion of the expression is the `operand`.
    """

    field: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Required. The name of the field to select.

    For example, in the select expression `request.auth`, the `auth` portion
    of the expression would be the `field`.
    """

    test_only: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    Whether the select is to be interpreted as a field presence test.

    This results from the macro `has(request.auth)`.
    """


default_message_pool.register_message("cel.expr", "Expr.Select", ExprSelect)


@dataclass(eq=False, repr=False)
class ParsedExpr(betterproto2.Message):
    """
    A representation of the abstract syntax of the Common Expression Language.

    An expression together with source information as returned by the parser.
    """

    expr: "Expr | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The parsed expression.
    """

    source_info: "SourceInfo | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The source info derived from input that generated the parsed `expr`.
    """


default_message_pool.register_message("cel.expr", "ParsedExpr", ParsedExpr)


@dataclass(eq=False, repr=False)
class Reference(betterproto2.Message):
    """
    Describes a resolved reference to a declaration.
    """

    name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    The fully qualified name of the declaration.
    """

    overload_id: "list[str]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )
    """
    For references to functions, this is a list of `Overload.overload_id`
    values which match according to typing rules.

    If the list has more than one element, overload resolution among the
    presented candidates must happen at runtime because of dynamic types. The
    type checker attempts to narrow down this list as much as possible.

    Empty if this is not a reference to a
    [Decl.FunctionDecl][cel.expr.Decl.FunctionDecl].
    """

    value: "Constant | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    For references to constants, this may contain the value of the
    constant if known at compile time.
    """


default_message_pool.register_message("cel.expr", "Reference", Reference)


@dataclass(eq=False, repr=False)
class SourceInfo(betterproto2.Message):
    """
    Source information collected at parse time.
    """

    syntax_version: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    The syntax version of the source, e.g. `cel1`.
    """

    location: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    The location name. All position information attached to an expression is
    relative to this location.

    The location could be a file, UI element, or similar. For example,
    `acme/app/AnvilPolicy.cel`.
    """

    line_offsets: "list[int]" = betterproto2.field(
        3, betterproto2.TYPE_INT32, repeated=True
    )
    """
    Monotonically increasing list of code point offsets where newlines
    `\\n` appear.

    The line number of a given position is the index `i` where for a given
    `id` the `line_offsets[i] < id_positions[id] < line_offsets[i+1]`. The
    column may be derived from `id_positions[id] - line_offsets[i]`.
    """

    positions: "dict[int, int]" = betterproto2.field(
        4,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_INT64, betterproto2.TYPE_INT32
        ),
    )
    """
    A map from the parse node id (e.g. `Expr.id`) to the code point offset
    within the source.
    """

    macro_calls: "dict[int, Expr]" = betterproto2.field(
        5,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_INT64, betterproto2.TYPE_MESSAGE
        ),
    )
    """
    A map from the parse node id where a macro replacement was made to the
    call `Expr` that resulted in a macro expansion.

    For example, `has(value.field)` is a function call that is replaced by a
    `test_only` field selection in the AST. Likewise, the call
    `list.exists(e, e > 10)` translates to a comprehension expression. The key
    in the map corresponds to the expression id of the expanded macro, and the
    value is the call `Expr` that was replaced.
    """

    extensions: "list[SourceInfoExtension]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of tags for extensions that were used while parsing or type checking
    the source expression. For example, optimizations that require special
    runtime support may be specified.

    These are used to check feature support between components in separate
    implementations. This can be used to either skip redundant work or
    report an error if the extension is unsupported.
    """


default_message_pool.register_message("cel.expr", "SourceInfo", SourceInfo)


@dataclass(eq=False, repr=False)
class SourceInfoExtension(betterproto2.Message):
    """
    An extension that was requested for the source expression.
    """

    id: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    Identifier for the extension. Example: constant_folding
    """

    affected_components: "list[SourceInfoExtensionComponent]" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, repeated=True
    )
    """
    If set, the listed components must understand the extension for the
    expression to evaluate correctly.

    This field has set semantics, repeated values should be deduplicated.
    """

    version: "SourceInfoExtensionVersion | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Version info. May be skipped if it isn't meaningful for the extension.
    (for example constant_folding might always be v0.0).
    """


default_message_pool.register_message(
    "cel.expr", "SourceInfo.Extension", SourceInfoExtension
)


@dataclass(eq=False, repr=False)
class SourceInfoExtensionVersion(betterproto2.Message):
    """
    Version
    """

    major: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)
    """
    Major version changes indicate different required support level from
    the required components.
    """

    minor: "int" = betterproto2.field(2, betterproto2.TYPE_INT64)
    """
    Minor version changes must not change the observed behavior from
    existing implementations, but may be provided informationally.
    """


default_message_pool.register_message(
    "cel.expr", "SourceInfo.Extension.Version", SourceInfoExtensionVersion
)


@dataclass(eq=False, repr=False)
class Type(betterproto2.Message):
    """
    Represents a CEL type.

    Oneofs:
        - type_kind: The kind of type.
    """

    dyn: "__google__protobuf__.Empty | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="type_kind"
    )
    """
    Dynamic type.
    """

    null: "__google__protobuf__.NullValue | None" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, optional=True, group="type_kind"
    )
    """
    Null value.
    """

    primitive: "TypePrimitiveType | None" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, optional=True, group="type_kind"
    )
    """
    Primitive types: `true`, `1u`, `-2.0`, `'string'`, `b'bytes'`.
    """

    wrapper: "TypePrimitiveType | None" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, optional=True, group="type_kind"
    )
    """
    Wrapper of a primitive type, e.g. `google.protobuf.Int64Value`.
    """

    well_known: "TypeWellKnownType | None" = betterproto2.field(
        5, betterproto2.TYPE_ENUM, optional=True, group="type_kind"
    )
    """
    Well-known protobuf type such as `google.protobuf.Timestamp`.
    """

    list_type: "TypeListType | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="type_kind"
    )
    """
    Parameterized list with elements of `list_type`, e.g. `list<timestamp>`.
    """

    map_type: "TypeMapType | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="type_kind"
    )
    """
    Parameterized map with typed keys and values.
    """

    function: "TypeFunctionType | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="type_kind"
    )
    """
    Function type.
    """

    message_type: "str | None" = betterproto2.field(
        9, betterproto2.TYPE_STRING, optional=True, group="type_kind"
    )
    """
    Protocol buffer message type.

    The `message_type` string specifies the qualified message type name. For
    example, `google.type.PhoneNumber`.
    """

    type_param: "str | None" = betterproto2.field(
        10, betterproto2.TYPE_STRING, optional=True, group="type_kind"
    )
    """
    Type param type.

    The `type_param` string specifies the type parameter name, e.g. `list<E>`
    would be a `list_type` whose element type was a `type_param` type
    named `E`.
    """

    type: "Type | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="type_kind"
    )
    """
    Type type.

    The `type` value specifies the target type. e.g. int is type with a
    target type of `Primitive.INT64`.
    """

    error: "__google__protobuf__.Empty | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True, group="type_kind"
    )
    """
    Error type.

    During type-checking if an expression is an error, its type is propagated
    as the `ERROR` type. This permits the type-checker to discover other
    errors present in the expression.
    """

    abstract_type: "TypeAbstractType | None" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, optional=True, group="type_kind"
    )
    """
    Abstract, application defined type.

    An abstract type has no accessible field names, and it can only be
    inspected via helper / member functions.
    """


default_message_pool.register_message("cel.expr", "Type", Type)


@dataclass(eq=False, repr=False)
class TypeAbstractType(betterproto2.Message):
    """
    Application defined abstract type.
    """

    name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    The fully qualified name of this abstract type.
    """

    parameter_types: "list[Type]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Parameter types for this abstract type.
    """


default_message_pool.register_message("cel.expr", "Type.AbstractType", TypeAbstractType)


@dataclass(eq=False, repr=False)
class TypeFunctionType(betterproto2.Message):
    """
    Function type with result and arg types.
    """

    result_type: "Type | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Result type of the function.
    """

    arg_types: "list[Type]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Argument types of the function.
    """


default_message_pool.register_message("cel.expr", "Type.FunctionType", TypeFunctionType)


@dataclass(eq=False, repr=False)
class TypeListType(betterproto2.Message):
    """
    List type with typed elements, e.g. `list<example.proto.MyMessage>`.
    """

    elem_type: "Type | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The element type.
    """


default_message_pool.register_message("cel.expr", "Type.ListType", TypeListType)


@dataclass(eq=False, repr=False)
class TypeMapType(betterproto2.Message):
    """
    Map type with parameterized key and value types, e.g. `map<string, int>`.
    """

    key_type: "Type | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The type of the key.
    """

    value_type: "Type | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The type of the value.
    """


default_message_pool.register_message("cel.expr", "Type.MapType", TypeMapType)


from ...google import protobuf as __google__protobuf__
