# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: xds/type/matcher/v3/matcher.proto, xds/type/matcher/v3/regex.proto, xds/type/matcher/v3/string.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "ListStringMatcher",
    "Matcher",
    "MatcherMatcherList",
    "MatcherMatcherListFieldMatcher",
    "MatcherMatcherListPredicate",
    "MatcherMatcherListPredicatePredicateList",
    "MatcherMatcherListPredicateSinglePredicate",
    "MatcherMatcherTree",
    "MatcherMatcherTreeMatchMap",
    "MatcherOnMatch",
    "RegexMatcher",
    "RegexMatcherGoogleRe2",
    "StringMatcher",
)

import typing

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ListStringMatcher(betterproto2.Message):
    """
    Specifies a list of ways to match a string.
    """

    patterns: "list[StringMatcher]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "xds.type.matcher.v3", "ListStringMatcher", ListStringMatcher
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Matcher(betterproto2.Message):
    """
    [#protodoc-title: Unified Matcher API]

    A matcher, which may traverse a matching tree in order to result in a match action.
    During matching, the tree will be traversed until a match is found, or if no match
    is found the action specified by the most specific on_no_match will be evaluated.
    As an on_no_match might result in another matching tree being evaluated, this process
    might repeat several times until the final OnMatch (or no match) is decided.

    Oneofs:
        - matcher_type:
    """

    matcher_list: "MatcherMatcherList | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="matcher_type"
    )
    """
    A linear list of matchers to evaluate.
    """

    matcher_tree: "MatcherMatcherTree | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="matcher_type"
    )
    """
    A match tree to evaluate.
    """

    on_no_match: "MatcherOnMatch | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional OnMatch to use if no matcher above matched (e.g., if there are no matchers specified
    above, or if none of the matches specified above succeeded).
    If no matcher above matched and this field is not populated, the match will be considered unsuccessful.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("xds.type.matcher.v3", "Matcher", Matcher)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherList(betterproto2.Message):
    """
    A linear list of field matchers.
    The field matchers are evaluated in order, and the first match
    wins.
    """

    matchers: "list[MatcherMatcherListFieldMatcher]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of matchers. First match wins.
    """


default_message_pool.register_message(
    "xds.type.matcher.v3", "Matcher.MatcherList", MatcherMatcherList
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherListFieldMatcher(betterproto2.Message):
    """
    An individual matcher.
    """

    predicate: "MatcherMatcherListPredicate | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Determines if the match succeeds.
    """

    on_match: "MatcherOnMatch | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    What to do if the match succeeds.
    """


default_message_pool.register_message(
    "xds.type.matcher.v3",
    "Matcher.MatcherList.FieldMatcher",
    MatcherMatcherListFieldMatcher,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherListPredicate(betterproto2.Message):
    """
    Predicate to determine if a match is successful.

    Oneofs:
        - match_type:
    """

    single_predicate: "MatcherMatcherListPredicateSinglePredicate | None" = (
        betterproto2.field(
            1, betterproto2.TYPE_MESSAGE, optional=True, group="match_type"
        )
    )
    """
    A single predicate to evaluate.
    """

    or_matcher: "MatcherMatcherListPredicatePredicateList | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="match_type"
    )
    """
    A list of predicates to be OR-ed together.
    """

    and_matcher: "MatcherMatcherListPredicatePredicateList | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="match_type"
    )
    """
    A list of predicates to be AND-ed together.
    """

    not_matcher: "MatcherMatcherListPredicate | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="match_type"
    )
    """
    The invert of a predicate
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "xds.type.matcher.v3", "Matcher.MatcherList.Predicate", MatcherMatcherListPredicate
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherListPredicatePredicateList(betterproto2.Message):
    """
    A list of two or more matchers. Used to allow using a list within a oneof.
    """

    predicate: "list[MatcherMatcherListPredicate]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "xds.type.matcher.v3",
    "Matcher.MatcherList.Predicate.PredicateList",
    MatcherMatcherListPredicatePredicateList,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherListPredicateSinglePredicate(betterproto2.Message):
    """
    Predicate for a single input field.

    Oneofs:
        - matcher:
    """

    input: "___core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Protocol-specific specification of input field to match on.
    [#extension-category: envoy.matching.common_inputs]
    """

    value_match: "StringMatcher | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="matcher"
    )
    """
    Built-in string matcher.
    """

    custom_match: "___core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="matcher"
    )
    """
    Extension for custom matching logic.
    [#extension-category: envoy.matching.input_matchers]
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "xds.type.matcher.v3",
    "Matcher.MatcherList.Predicate.SinglePredicate",
    MatcherMatcherListPredicateSinglePredicate,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherTree(betterproto2.Message):
    """


    Oneofs:
        - tree_type: Exact or prefix match maps in which to look up the input value.
            If the lookup succeeds, the match is considered successful, and
            the corresponding OnMatch is used.
    """

    input: "___core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Protocol-specific specification of input field to match on.
    """

    exact_match_map: "MatcherMatcherTreeMatchMap | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="tree_type"
    )

    prefix_match_map: "MatcherMatcherTreeMatchMap | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="tree_type"
    )
    """
    Longest matching prefix wins.
    """

    custom_match: "___core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="tree_type"
    )
    """
    Extension for custom matching logic.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "xds.type.matcher.v3", "Matcher.MatcherTree", MatcherMatcherTree
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherTreeMatchMap(betterproto2.Message):
    """
    A map of configured matchers. Used to allow using a map within a oneof.
    """

    map: "dict[str, MatcherOnMatch]" = betterproto2.field(
        1,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
        ),
    )


default_message_pool.register_message(
    "xds.type.matcher.v3", "Matcher.MatcherTree.MatchMap", MatcherMatcherTreeMatchMap
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherOnMatch(betterproto2.Message):
    """
    What to do if a match is successful.

    Oneofs:
        - on_match:
    """

    matcher: "Matcher | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="on_match"
    )
    """
    Nested matcher to evaluate.
    If the nested matcher does not match and does not specify
    on_no_match, then this matcher is considered not to have
    matched, even if a predicate at this level or above returned
    true.
    """

    action: "___core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="on_match"
    )
    """
    Protocol-specific action to take.
    """

    keep_matching: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    If true and the Matcher matches, the action will be taken but the caller
    will behave as if the Matcher did not match. A subsequent matcher or
    on_no_match action will be used instead.
    This field is not supported in all contexts in which the matcher API is
    used. If this field is set in a context in which it's not supported,
    the resource will be rejected.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "xds.type.matcher.v3", "Matcher.OnMatch", MatcherOnMatch
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RegexMatcher(betterproto2.Message):
    """
    [#protodoc-title: Regex matcher]

    A regex matcher designed for safety when used with untrusted input.

    Oneofs:
        - engine_type:
    """

    google_re2: "RegexMatcherGoogleRe2 | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="engine_type"
    )
    """
    Google's RE2 regex engine.
    """

    regex: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The regex match string. The string must be supported by the configured
    engine.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "xds.type.matcher.v3", "RegexMatcher", RegexMatcher
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RegexMatcherGoogleRe2(betterproto2.Message):
    """
    Google's `RE2 <https://github.com/google/re2>`_ regex engine. The regex
    string must adhere to the documented `syntax
    <https://github.com/google/re2/wiki/Syntax>`_. The engine is designed to
    complete execution in linear time as well as limit the amount of memory
    used.

    Envoy supports program size checking via runtime. The runtime keys
    `re2.max_program_size.error_level` and `re2.max_program_size.warn_level`
    can be set to integers as the maximum program size or complexity that a
    compiled regex can have before an exception is thrown or a warning is
    logged, respectively. `re2.max_program_size.error_level` defaults to 100,
    and `re2.max_program_size.warn_level` has no default if unset (will not
    check/log a warning).

    Envoy emits two stats for tracking the program size of regexes: the
    histogram `re2.program_size`, which records the program size, and the
    counter `re2.exceeded_warn_level`, which is incremented each time the
    program size exceeds the warn level threshold.
    """

    pass


default_message_pool.register_message(
    "xds.type.matcher.v3", "RegexMatcher.GoogleRE2", RegexMatcherGoogleRe2
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StringMatcher(betterproto2.Message):
    """
    [#protodoc-title: String matcher]

    Specifies the way to match a string.
    [#next-free-field: 9]

    Oneofs:
        - match_pattern:
    """

    exact: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="match_pattern"
    )
    """
    The input string must match exactly the string specified here.

    Examples:

    * *abc* only matches the value *abc*.
    """

    prefix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="match_pattern"
    )
    """
    The input string must have the prefix specified here.
    Note: empty prefix is not allowed, please use regex instead.

    Examples:

    * *abc* matches the value *abc.xyz*
    """

    suffix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True, group="match_pattern"
    )
    """
    The input string must have the suffix specified here.
    Note: empty prefix is not allowed, please use regex instead.

    Examples:

    * *abc* matches the value *xyz.abc*
    """

    safe_regex: "RegexMatcher | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="match_pattern"
    )
    """
    The input string must match the regular expression specified here.
    """

    contains: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        7, betterproto2.TYPE_STRING, optional=True, group="match_pattern"
    )
    """
    The input string must have the substring specified here.
    Note: empty contains match is not allowed, please use regex instead.

    Examples:

    * *abc* matches the value *xyz.abc.def*
    """

    custom: "___core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="match_pattern"
    )
    """
    Use an extension as the matcher type.
    [#extension-category: envoy.string_matcher]
    """

    ignore_case: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)
    """
    If true, indicates the exact/prefix/suffix matching should be case insensitive. This has no
    effect for the safe_regex match.
    For example, the matcher *data* will match both input string *Data* and *data* if set to true.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "xds.type.matcher.v3", "StringMatcher", StringMatcher
)


from ....core import v3 as ___core__v3__
