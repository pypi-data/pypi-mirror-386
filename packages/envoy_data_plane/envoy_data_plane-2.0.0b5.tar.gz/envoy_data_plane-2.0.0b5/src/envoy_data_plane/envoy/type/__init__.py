# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/type/hash_policy.proto, envoy/type/http.proto, envoy/type/http_status.proto, envoy/type/percent.proto, envoy/type/range.proto, envoy/type/semantic_version.proto, envoy/type/token_bucket.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "CodecClientType",
    "DoubleRange",
    "FractionalPercent",
    "FractionalPercentDenominatorType",
    "HashPolicy",
    "HashPolicySourceIp",
    "HttpStatus",
    "Int32Range",
    "Int64Range",
    "Percent",
    "SemanticVersion",
    "StatusCode",
    "TokenBucket",
)

import datetime
import typing

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from ...message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class CodecClientType(betterproto2.Enum):
    """
    [#protodoc-title: HTTP]
    """

    HTTP1 = 0

    HTTP2 = 1

    HTTP3 = 2
    """
    [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
    caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
    to distinguish HTTP1 and HTTP2 traffic.
    """


class FractionalPercentDenominatorType(betterproto2.Enum):
    """
    Fraction percentages support several fixed denominator values.
    """

    HUNDRED = 0
    """
    100.

    **Example**: 1/100 = 1%.
    """

    TEN_THOUSAND = 1
    """
    10,000.

    **Example**: 1/10000 = 0.01%.
    """

    MILLION = 2
    """
    1,000,000.

    **Example**: 1/1000000 = 0.0001%.
    """


class StatusCode(betterproto2.Enum):
    """
    [#protodoc-title: HTTP status codes]

    HTTP response codes supported in Envoy.
    For more details: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
    """

    Empty = 0
    """
    Empty - This code not part of the HTTP status code specification, but it is needed for proto
    `enum` type.
    """

    Continue = 100

    OK = 200

    Created = 201

    Accepted = 202

    NonAuthoritativeInformation = 203

    NoContent = 204

    ResetContent = 205

    PartialContent = 206

    MultiStatus = 207

    AlreadyReported = 208

    IMUsed = 226

    MultipleChoices = 300

    MovedPermanently = 301

    Found = 302

    SeeOther = 303

    NotModified = 304

    UseProxy = 305

    TemporaryRedirect = 307

    PermanentRedirect = 308

    BadRequest = 400

    Unauthorized = 401

    PaymentRequired = 402

    Forbidden = 403

    NotFound = 404

    MethodNotAllowed = 405

    NotAcceptable = 406

    ProxyAuthenticationRequired = 407

    RequestTimeout = 408

    Conflict = 409

    Gone = 410

    LengthRequired = 411

    PreconditionFailed = 412

    PayloadTooLarge = 413

    URITooLong = 414

    UnsupportedMediaType = 415

    RangeNotSatisfiable = 416

    ExpectationFailed = 417

    MisdirectedRequest = 421

    UnprocessableEntity = 422

    Locked = 423

    FailedDependency = 424

    UpgradeRequired = 426

    PreconditionRequired = 428

    TooManyRequests = 429

    RequestHeaderFieldsTooLarge = 431

    InternalServerError = 500

    NotImplemented = 501

    BadGateway = 502

    ServiceUnavailable = 503

    GatewayTimeout = 504

    HTTPVersionNotSupported = 505

    VariantAlsoNegotiates = 506

    InsufficientStorage = 507

    LoopDetected = 508

    NotExtended = 510

    NetworkAuthenticationRequired = 511


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DoubleRange(betterproto2.Message):
    """
    Specifies the double start and end of the range using half-open interval semantics [start,
    end).
    """

    start: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    start of the range (inclusive)
    """

    end: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    end of the range (exclusive)
    """


default_message_pool.register_message("envoy.type", "DoubleRange", DoubleRange)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class FractionalPercent(betterproto2.Message):
    """
    A fractional percentage is used in cases in which for performance reasons performing floating
    point to integer conversions during randomness calculations is undesirable. The message includes
    both a numerator and denominator that together determine the final fractional value.

    * **Example**: 1/100 = 1%.
    * **Example**: 3/10000 = 0.03%.
    """

    numerator: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT32)
    )
    """
    Specifies the numerator. Defaults to 0.
    """

    denominator: "FractionalPercentDenominatorType" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: FractionalPercentDenominatorType(0),
    )
    """
    Specifies the denominator. If the denominator specified is less than the numerator, the final
    fractional percentage is capped at 1 (100%).
    """


default_message_pool.register_message(
    "envoy.type", "FractionalPercent", FractionalPercent
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HashPolicy(betterproto2.Message):
    """
    [#protodoc-title: Hash Policy]

    Specifies the hash policy

    Oneofs:
        - policy_specifier:
    """

    source_ip: "HashPolicySourceIp | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="policy_specifier"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.type", "HashPolicy", HashPolicy)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HashPolicySourceIp(betterproto2.Message):
    """
    The source IP will be used to compute the hash used by hash-based load balancing
    algorithms.
    """

    pass


default_message_pool.register_message(
    "envoy.type", "HashPolicy.SourceIp", HashPolicySourceIp
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpStatus(betterproto2.Message):
    """
    HTTP status.
    """

    code: "StatusCode" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: StatusCode(0)
    )
    """
    Supplies HTTP response code.
    """


default_message_pool.register_message("envoy.type", "HttpStatus", HttpStatus)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Int32Range(betterproto2.Message):
    """
    Specifies the int32 start and end of the range using half-open interval semantics [start,
    end).
    """

    start: "typing.Annotated[int, pydantic.Field(ge=-2**31, le=2**31 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_INT32)
    )
    """
    start of the range (inclusive)
    """

    end: "typing.Annotated[int, pydantic.Field(ge=-2**31, le=2**31 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_INT32)
    )
    """
    end of the range (exclusive)
    """


default_message_pool.register_message("envoy.type", "Int32Range", Int32Range)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Int64Range(betterproto2.Message):
    """
    [#protodoc-title: Range]

    Specifies the int64 start and end of the range using half-open interval semantics [start,
    end).
    """

    start: "typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_INT64)
    )
    """
    start of the range (inclusive)
    """

    end: "typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_INT64)
    )
    """
    end of the range (exclusive)
    """


default_message_pool.register_message("envoy.type", "Int64Range", Int64Range)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Percent(betterproto2.Message):
    """
    [#protodoc-title: Percent]

    Identifies a percentage, in the range [0.0, 100.0].
    """

    value: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)


default_message_pool.register_message("envoy.type", "Percent", Percent)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SemanticVersion(betterproto2.Message):
    """
    [#protodoc-title: Semantic Version]

    Envoy uses SemVer (https://semver.org/). Major/minor versions indicate
    expected behaviors and APIs, the patch version field is used only
    for security fixes and can be generally ignored.
    """

    major_number: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT32)
    )

    minor_number: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32)
    )

    patch: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT32)
    )


default_message_pool.register_message("envoy.type", "SemanticVersion", SemanticVersion)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TokenBucket(betterproto2.Message):
    """
    [#protodoc-title: Token bucket]

    Configures a token bucket, typically used for rate limiting.
    """

    max_tokens: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT32)
    )
    """
    The maximum tokens that the bucket can hold. This is also the number of tokens that the bucket
    initially contains.
    """

    tokens_per_fill: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: __google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The number of tokens added to the bucket during each fill interval. If not specified, defaults
    to a single token.
    """

    fill_interval: "datetime.timedelta | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: __google__protobuf__.Duration,
        optional=True,
    )
    """
    The fill interval that tokens are added to the bucket. During each fill interval
    `tokens_per_fill` are added to the bucket. The bucket will never contain more than
    `max_tokens` tokens.
    """


default_message_pool.register_message("envoy.type", "TokenBucket", TokenBucket)


from ...google import protobuf as __google__protobuf__
