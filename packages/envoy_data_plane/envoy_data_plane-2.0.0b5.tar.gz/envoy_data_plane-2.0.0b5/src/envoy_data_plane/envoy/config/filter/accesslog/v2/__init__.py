# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/filter/accesslog/v2/accesslog.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "AccessLog",
    "AccessLogFilter",
    "AndFilter",
    "ComparisonFilter",
    "ComparisonFilterOp",
    "DurationFilter",
    "ExtensionFilter",
    "GrpcStatusFilter",
    "GrpcStatusFilterStatus",
    "HeaderFilter",
    "NotHealthCheckFilter",
    "OrFilter",
    "ResponseFlagFilter",
    "RuntimeFilter",
    "StatusCodeFilter",
    "TraceableFilter",
)

import typing
import warnings

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from ......message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class ComparisonFilterOp(betterproto2.Enum):
    EQ = 0
    """
    =
    """

    GE = 1
    """
    >=
    """

    LE = 2
    """
    <=
    """


class GrpcStatusFilterStatus(betterproto2.Enum):
    OK = 0

    CANCELED = 1

    UNKNOWN = 2

    INVALID_ARGUMENT = 3

    DEADLINE_EXCEEDED = 4

    NOT_FOUND = 5

    ALREADY_EXISTS = 6

    PERMISSION_DENIED = 7

    RESOURCE_EXHAUSTED = 8

    FAILED_PRECONDITION = 9

    ABORTED = 10

    OUT_OF_RANGE = 11

    UNIMPLEMENTED = 12

    INTERNAL = 13

    UNAVAILABLE = 14

    DATA_LOSS = 15

    UNAUTHENTICATED = 16


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AccessLog(betterproto2.Message):
    """
    [#protodoc-title: Common access log types]

    Oneofs:
        - config_type: Custom configuration that depends on the access log being instantiated. Built-in
            configurations include:

            #. "envoy.access_loggers.file": :ref:`FileAccessLog
               <envoy_api_msg_config.accesslog.v2.FileAccessLog>`
            #. "envoy.access_loggers.http_grpc": :ref:`HttpGrpcAccessLogConfig
               <envoy_api_msg_config.accesslog.v2.HttpGrpcAccessLogConfig>`
            #. "envoy.access_loggers.tcp_grpc": :ref:`TcpGrpcAccessLogConfig
               <envoy_api_msg_config.accesslog.v2.TcpGrpcAccessLogConfig>`
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the access log implementation to instantiate. The name must
    match a statically registered access log. Current built-in loggers include:

    #. "envoy.access_loggers.file"
    #. "envoy.access_loggers.http_grpc"
    #. "envoy.access_loggers.tcp_grpc"
    """

    filter: "AccessLogFilter | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Filter which is used to determine if the access log needs to be written.
    """

    config: "_____google__protobuf__.Struct | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="config_type"
    )

    typed_config: "_____google__protobuf__.Any | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="config_type"
    )

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("config"):
            warnings.warn("AccessLog.config is deprecated", DeprecationWarning)

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "AccessLog", AccessLog
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AccessLogFilter(betterproto2.Message):
    """
    [#next-free-field: 12]

    Oneofs:
        - filter_specifier:
    """

    status_code_filter: "StatusCodeFilter | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="filter_specifier"
    )
    """
    Status code filter.
    """

    duration_filter: "DurationFilter | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="filter_specifier"
    )
    """
    Duration filter.
    """

    not_health_check_filter: "NotHealthCheckFilter | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="filter_specifier"
    )
    """
    Not health check filter.
    """

    traceable_filter: "TraceableFilter | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="filter_specifier"
    )
    """
    Traceable filter.
    """

    runtime_filter: "RuntimeFilter | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="filter_specifier"
    )
    """
    Runtime filter.
    """

    and_filter: "AndFilter | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="filter_specifier"
    )
    """
    And filter.
    """

    or_filter: "OrFilter | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="filter_specifier"
    )
    """
    Or filter.
    """

    header_filter: "HeaderFilter | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="filter_specifier"
    )
    """
    Header filter.
    """

    response_flag_filter: "ResponseFlagFilter | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="filter_specifier"
    )
    """
    Response flag filter.
    """

    grpc_status_filter: "GrpcStatusFilter | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="filter_specifier"
    )
    """
    gRPC status filter.
    """

    extension_filter: "ExtensionFilter | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="filter_specifier"
    )
    """
    Extension filter.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "AccessLogFilter", AccessLogFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AndFilter(betterproto2.Message):
    """
    Performs a logical “and” operation on the result of each filter in filters.
    Filters are evaluated sequentially and if one of them returns false, the
    filter returns false immediately.
    """

    filters: "list[AccessLogFilter]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "AndFilter", AndFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ComparisonFilter(betterproto2.Message):
    """
    Filter on an integer comparison.
    """

    op: "ComparisonFilterOp" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: ComparisonFilterOp(0)
    )
    """
    Comparison operator.
    """

    value: "____api__v2__core__.RuntimeUInt32 | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Value to compare against.
    """


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "ComparisonFilter", ComparisonFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DurationFilter(betterproto2.Message):
    """
    Filters on total request duration in milliseconds.
    """

    comparison: "ComparisonFilter | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Comparison.
    """


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "DurationFilter", DurationFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ExtensionFilter(betterproto2.Message):
    """
    Extension filter is statically registered at runtime.

    Oneofs:
        - config_type: Custom configuration that depends on the filter being instantiated.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the filter implementation to instantiate. The name must
    match a statically registered filter.
    """

    config: "_____google__protobuf__.Struct | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="config_type"
    )

    typed_config: "_____google__protobuf__.Any | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="config_type"
    )

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("config"):
            warnings.warn("ExtensionFilter.config is deprecated", DeprecationWarning)

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "ExtensionFilter", ExtensionFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcStatusFilter(betterproto2.Message):
    """
    Filters gRPC requests based on their response status. If a gRPC status is not provided, the
    filter will infer the status from the HTTP status code.
    """

    statuses: "list[GrpcStatusFilterStatus]" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, repeated=True
    )
    """
    Logs only responses that have any one of the gRPC statuses in this field.
    """

    exclude: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)
    """
    If included and set to true, the filter will instead block all responses with a gRPC status or
    inferred gRPC status enumerated in statuses, and allow all other responses.
    """


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "GrpcStatusFilter", GrpcStatusFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HeaderFilter(betterproto2.Message):
    """
    Filters requests based on the presence or value of a request header.
    """

    header: "____api__v2__route__.HeaderMatcher | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Only requests with a header which matches the specified HeaderMatcher will pass the filter
    check.
    """


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "HeaderFilter", HeaderFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class NotHealthCheckFilter(betterproto2.Message):
    """
    Filters for requests that are not health check requests. A health check
    request is marked by the health check filter.
    """

    pass


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "NotHealthCheckFilter", NotHealthCheckFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class OrFilter(betterproto2.Message):
    """
    Performs a logical “or” operation on the result of each individual filter.
    Filters are evaluated sequentially and if one of them returns true, the
    filter returns true immediately.
    """

    filters: "list[AccessLogFilter]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "OrFilter", OrFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ResponseFlagFilter(betterproto2.Message):
    """
    Filters requests that received responses with an Envoy response flag set.
    A list of the response flags can be found
    in the access log formatter :ref:`documentation<config_access_log_format_response_flags>`.
    """

    flags: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        1, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Only responses with the any of the flags listed in this field will be logged.
    This field is optional. If it is not specified, then any response flag will pass
    the filter check.
    """


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "ResponseFlagFilter", ResponseFlagFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RuntimeFilter(betterproto2.Message):
    """
    Filters for random sampling of requests.
    """

    runtime_key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Runtime key to get an optional overridden numerator for use in the *percent_sampled* field.
    If found in runtime, this value will replace the default numerator.
    """

    percent_sampled: "____type__.FractionalPercent | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The default sampling percentage. If not specified, defaults to 0% with denominator of 100.
    """

    use_independent_randomness: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    By default, sampling pivots on the header
    :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` being present. If
    :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` is present, the filter will
    consistently sample across multiple hosts based on the runtime key value and the value
    extracted from :ref:`x-request-id<config_http_conn_man_headers_x-request-id>`. If it is
    missing, or *use_independent_randomness* is set to true, the filter will randomly sample based
    on the runtime key value alone. *use_independent_randomness* can be used for logging kill
    switches within complex nested :ref:`AndFilter
    <envoy_api_msg_config.filter.accesslog.v2.AndFilter>` and :ref:`OrFilter
    <envoy_api_msg_config.filter.accesslog.v2.OrFilter>` blocks that are easier to reason about
    from a probability perspective (i.e., setting to true will cause the filter to behave like
    an independent random variable when composed within logical operator filters).
    """


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "RuntimeFilter", RuntimeFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StatusCodeFilter(betterproto2.Message):
    """
    Filters on HTTP response/status code.
    """

    comparison: "ComparisonFilter | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Comparison.
    """


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "StatusCodeFilter", StatusCodeFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TraceableFilter(betterproto2.Message):
    """
    Filters for requests that are traceable. See the tracing overview for more
    information on how a request becomes traceable.
    """

    pass


default_message_pool.register_message(
    "envoy.config.filter.accesslog.v2", "TraceableFilter", TraceableFilter
)


from ......google import protobuf as _____google__protobuf__
from ..... import type as ____type__
from .....api.v2 import core as ____api__v2__core__
from .....api.v2 import route as ____api__v2__route__
