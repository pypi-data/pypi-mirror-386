# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/data/tap/v3/common.proto, envoy/data/tap/v3/http.proto, envoy/data/tap/v3/transport.proto, envoy/data/tap/v3/wrapper.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "Body",
    "Connection",
    "HttpBufferedTrace",
    "HttpBufferedTraceMessage",
    "HttpStreamedTraceSegment",
    "SocketBufferedTrace",
    "SocketEvent",
    "SocketEventClosed",
    "SocketEventRead",
    "SocketEventWrite",
    "SocketEvents",
    "SocketStreamedTraceSegment",
    "TraceWrapper",
)

import datetime
import typing

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Body(betterproto2.Message):
    """
    [#protodoc-title: Tap common data]

    Wrapper for tapped body data. This includes HTTP request/response body, transport socket received
    and transmitted data, etc.

    Oneofs:
        - body_type:
    """

    as_bytes: "bytes | None" = betterproto2.field(
        1, betterproto2.TYPE_BYTES, optional=True, group="body_type"
    )
    """
    Body data as bytes. By default, tap body data will be present in this field, as the proto
    ``bytes`` type can contain any valid byte.
    """

    as_string: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="body_type"
    )
    """
    Body data as string. This field is only used when the :ref:`JSON_BODY_AS_STRING
    <envoy_v3_api_enum_value_config.tap.v3.OutputSink.Format.JSON_BODY_AS_STRING>` sink
    format type is selected. See the documentation for that option for why this is useful.
    """

    truncated: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    Specifies whether body data has been truncated to fit within the specified
    :ref:`max_buffered_rx_bytes
    <envoy_v3_api_field_config.tap.v3.OutputConfig.max_buffered_rx_bytes>` and
    :ref:`max_buffered_tx_bytes
    <envoy_v3_api_field_config.tap.v3.OutputConfig.max_buffered_tx_bytes>` settings.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.data.tap.v3", "Body", Body)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Connection(betterproto2.Message):
    """
    Connection properties.
    """

    local_address: "___config__core__v3__.Address | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Local address.
    """

    remote_address: "___config__core__v3__.Address | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Remote address.
    """


default_message_pool.register_message("envoy.data.tap.v3", "Connection", Connection)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpBufferedTrace(betterproto2.Message):
    """
    [#protodoc-title: HTTP tap data]

    A fully buffered HTTP trace message.
    """

    request: "HttpBufferedTraceMessage | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Request message.
    """

    response: "HttpBufferedTraceMessage | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Response message.
    """

    downstream_connection: "Connection | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    downstream connection
    """

    upstream_connection: "Connection | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    upstream connection
    """


default_message_pool.register_message(
    "envoy.data.tap.v3", "HttpBufferedTrace", HttpBufferedTrace
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpBufferedTraceMessage(betterproto2.Message):
    """
    HTTP message wrapper.
    """

    headers: "list[___config__core__v3__.HeaderValue]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Message headers.
    """

    body: "Body | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Message body.
    """

    trailers: "list[___config__core__v3__.HeaderValue]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Message trailers.
    """

    headers_received_time: "datetime.datetime | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Timestamp,
        optional=True,
    )
    """
    The timestamp after receiving the message headers.
    """


default_message_pool.register_message(
    "envoy.data.tap.v3", "HttpBufferedTrace.Message", HttpBufferedTraceMessage
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpStreamedTraceSegment(betterproto2.Message):
    """
    A streamed HTTP trace segment. Multiple segments make up a full trace.
    [#next-free-field: 8]

    Oneofs:
        - message_piece:
    """

    trace_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )
    """
    Trace ID unique to the originating Envoy only. Trace IDs can repeat and should not be used
    for long term stable uniqueness.
    """

    request_headers: "___config__core__v3__.HeaderMap | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="message_piece"
    )
    """
    Request headers.
    """

    request_body_chunk: "Body | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="message_piece"
    )
    """
    Request body chunk.
    """

    request_trailers: "___config__core__v3__.HeaderMap | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="message_piece"
    )
    """
    Request trailers.
    """

    response_headers: "___config__core__v3__.HeaderMap | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="message_piece"
    )
    """
    Response headers.
    """

    response_body_chunk: "Body | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="message_piece"
    )
    """
    Response body chunk.
    """

    response_trailers: "___config__core__v3__.HeaderMap | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="message_piece"
    )
    """
    Response trailers.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.data.tap.v3", "HttpStreamedTraceSegment", HttpStreamedTraceSegment
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketBufferedTrace(betterproto2.Message):
    """
    Sequence of read/write events that constitute a buffered trace on a socket.
    [#next-free-field: 6]
    """

    trace_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )
    """
    Trace ID unique to the originating Envoy only. Trace IDs can repeat and should not be used
    for long term stable uniqueness. Matches connection IDs used in Envoy logs.
    """

    connection: "Connection | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Connection properties.
    """

    events: "list[SocketEvent]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Sequence of observed events.
    """

    read_truncated: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)
    """
    Set to true if read events were truncated due to the :ref:`max_buffered_rx_bytes
    <envoy_v3_api_field_config.tap.v3.OutputConfig.max_buffered_rx_bytes>` setting.
    """

    write_truncated: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    Set to true if write events were truncated due to the :ref:`max_buffered_tx_bytes
    <envoy_v3_api_field_config.tap.v3.OutputConfig.max_buffered_tx_bytes>` setting.
    """


default_message_pool.register_message(
    "envoy.data.tap.v3", "SocketBufferedTrace", SocketBufferedTrace
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketEvent(betterproto2.Message):
    """
    [#protodoc-title: Transport tap data]
    Trace format for the tap transport socket extension. This dumps plain text read/write
    sequences on a socket.

    Event in a socket trace.
    [#next-free-field: 6]

    Oneofs:
        - event_selector: Read or write with content as bytes string.
    """

    timestamp: "datetime.datetime | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Timestamp,
        optional=True,
    )
    """
    Timestamp for event.
    """

    read: "SocketEventRead | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="event_selector"
    )

    write: "SocketEventWrite | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="event_selector"
    )

    closed: "SocketEventClosed | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="event_selector"
    )

    connection: "Connection | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Connection information per event
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.data.tap.v3", "SocketEvent", SocketEvent)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketEventClosed(betterproto2.Message):
    """
    The connection was closed.

    TODO(mattklein123): Close event type.
    """

    pass


default_message_pool.register_message(
    "envoy.data.tap.v3", "SocketEvent.Closed", SocketEventClosed
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketEventRead(betterproto2.Message):
    """
    Data read by Envoy from the transport socket.

    TODO(htuch): Half-close for reads.
    """

    data: "Body | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Binary data read.
    """


default_message_pool.register_message(
    "envoy.data.tap.v3", "SocketEvent.Read", SocketEventRead
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketEventWrite(betterproto2.Message):
    """
    Data written by Envoy to the transport socket.
    """

    data: "Body | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Binary data written.
    """

    end_stream: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)
    """
    Stream was half closed after this write.
    """


default_message_pool.register_message(
    "envoy.data.tap.v3", "SocketEvent.Write", SocketEventWrite
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketEvents(betterproto2.Message):
    """
    A message for the sequence of observed events
    """

    events: "list[SocketEvent]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("envoy.data.tap.v3", "SocketEvents", SocketEvents)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketStreamedTraceSegment(betterproto2.Message):
    """
    A streamed socket trace segment. Multiple segments make up a full trace.

    Oneofs:
        - message_piece:
    """

    trace_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )
    """
    Trace ID unique to the originating Envoy only. Trace IDs can repeat and should not be used
    for long term stable uniqueness. Matches connection IDs used in Envoy logs.
    """

    connection: "Connection | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="message_piece"
    )
    """
    Connection properties.
    """

    event: "SocketEvent | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="message_piece"
    )
    """
    Socket event.
    """

    events: "SocketEvents | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="message_piece"
    )
    """
    Sequence of observed events.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.data.tap.v3", "SocketStreamedTraceSegment", SocketStreamedTraceSegment
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TraceWrapper(betterproto2.Message):
    """
    [#protodoc-title: Tap data wrappers]

    Wrapper for all fully buffered and streamed tap traces that Envoy emits. This is required for
    sending traces over gRPC APIs or more easily persisting binary messages to files.

    Oneofs:
        - trace:
    """

    http_buffered_trace: "HttpBufferedTrace | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="trace"
    )
    """
    An HTTP buffered tap trace.
    """

    http_streamed_trace_segment: "HttpStreamedTraceSegment | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="trace"
    )
    """
    An HTTP streamed tap trace segment.
    """

    socket_buffered_trace: "SocketBufferedTrace | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="trace"
    )
    """
    A socket buffered tap trace.
    """

    socket_streamed_trace_segment: "SocketStreamedTraceSegment | None" = (
        betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True, group="trace")
    )
    """
    A socket streamed tap trace segment.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.data.tap.v3", "TraceWrapper", TraceWrapper)


from .....google import protobuf as ____google__protobuf__
from ....config.core import v3 as ___config__core__v3__
