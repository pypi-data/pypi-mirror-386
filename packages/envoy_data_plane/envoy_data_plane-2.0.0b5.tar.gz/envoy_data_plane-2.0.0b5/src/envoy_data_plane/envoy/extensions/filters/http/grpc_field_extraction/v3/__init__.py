# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/extensions/filters/http/grpc_field_extraction/v3/config.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "FieldExtractions",
    "GrpcFieldExtractionConfig",
    "RequestFieldValueDisposition",
)

import typing

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .......message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class FieldExtractions(betterproto2.Message):
    """
    This message can be used to support per route config approach later even
    though the Istio doesn't support that so far.
    """

    request_field_extractions: "dict[str, RequestFieldValueDisposition]" = (
        betterproto2.field(
            1,
            betterproto2.TYPE_MAP,
            map_meta=betterproto2.map_meta(
                betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
            ),
        )
    )
    """
    The field extractions for requests.
    The key is the field path within the grpc request.
    For example, we can define ``foo.bar.name`` if we want to extract
    ``Request.foo.bar.name``.

    .. code-block:: proto

     message Request {
       Foo foo = 1;
     }

     message Foo {
       Bar bar = 1;
     }

     message Bar {
       string name = 1;
     }
    """


default_message_pool.register_message(
    "envoy.extensions.filters.http.grpc_field_extraction.v3",
    "FieldExtractions",
    FieldExtractions,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcFieldExtractionConfig(betterproto2.Message):
    """
    [#protodoc-title: gRPC Field Extraction]

    [#extension: envoy.filters.http.grpc_field_extraction]

    Overview
    --------

    This filter supports extracting the fields from the first gRPC
    request message no matter if it is unary or streaming and writing the result
    to the destination, for which currently only the static Envoy dynamic metadata `envoy.filters.http.grpc_field_extraction` is supported.

    Assumptions
    -----------

    This filter assumes

    1. this filter is only applicable for gRPC with Protobuf as payload.
    2. for bi-directional and client-side gRPC streaming, the initial message from the client should not depend on receiving the server initial metadata.

    Process Flow
    ------------

    When a request reaches the filter, it will check

    1. if the request is the gRPC request configured for extraction, the filter tries to:

      a. block the incoming data before decoding the first complete gRPC message
      b. look up the target field from the buffered gRPC message
      c. write the extraction result into the dynamic metadata and resume the request propagation.

    2. otherwise, pass through the request.

    If the request is a malformed one found during 1.a or 1.b, the filter will reject the request.

    Config Requirements
    -------------------

    Here are config requirements

    1. the target field should be among the following primitive types: `string`,
    `uint32`, `uint64`, `int32`, `int64`, `sint32`, `sint64`, `fixed32`,
    `fixed64`, `sfixed32`, `sfixed64`, `float`, `double`, `map<string, string>`.

    2. the target field could be repeated.

    3. the intermediate type could also be repeated.

    Output Format
    -------------

    1. the extracted field names/values will be wrapped in be ``field<StringValue
    or MapValue>`` -> ``values<ListValue of StringValue or StructValue>``, which will be added in the dynamic ``metadata<google.protobuf.Struct>``.

    2. if the field value is empty, an empty ``Value`` will be set.

    Performance
    -----------

    This filter should be performant as it

    1. converts between the gRPC message from EnvoyBuffer without data copy.
    2. parse the gRPC message binary directly without deserialization.

    though buffering the first message introduces some latency.

    Example
    -------

    We have the following request definition for the gRPC method `pkg.svc.Method`.

    .. code-block:: proto

        message MethodRequest {
              string foo = 1;
              Nested nested = 2;
              uint32 baz = 3;
              ...
        }

        message Nested {
             repeated string bar = 1;
        }

    This is the filter config in JSON.

    .. code-block:: json

        {
              "descriptor_set":{},
              "extractions_by_method":{
                 "pkg.svc.Method":{
                    "request_field_extractions":{
                       "foo":{
                       },
                       "nested.bar":{
                       }
                       "baz":{
                       }
                    }
                 }
              }
        }

    During runtime, the filter receives the following `MethodRequest` message in JSON.

    .. code-block:: json

        {
              "foo": "val_foo",
              "nested": { "bar": ["val_bar1", "val_bar2"]}
        }

    The filter will write the following dynamic metadata(`envoy.filters.http.grpc_field_extraction`) in JSON.

    .. code-block:: json

        {
              "foo":[
                 "val_foo"
              ],
              "nested.bar":[
                 "val_bar1", "val_bar2"
              ]
              "baz":[
              ]
        }
    """

    descriptor_set: "_____config__core__v3__.DataSource | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The proto descriptor set binary for the gRPC services.

    It could be passed by a local file through ``Datasource.filename`` or embedded in the
    ``Datasource.inline_bytes``.
    """

    extractions_by_method: "dict[str, FieldExtractions]" = betterproto2.field(
        2,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
        ),
    )
    """
    Specify the extraction info.
    The key is the fully qualified gRPC method name.
    ``${package}.${Service}.${Method}``, like
    ``endpoints.examples.bookstore.BookStore.GetShelf``

    The value is the field extractions for individual gRPC method.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.http.grpc_field_extraction.v3",
    "GrpcFieldExtractionConfig",
    GrpcFieldExtractionConfig,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RequestFieldValueDisposition(betterproto2.Message):
    """


    Oneofs:
        - disposition:
    """

    dynamic_metadata: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="disposition"
    )
    """
    The dynamic metadata namespace. If empty, "envoy.filters.http.grpc_field_extraction" will be used by default.

    Unimplemented. Uses "envoy.filters.http.grpc_field_extraction" for now.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.filters.http.grpc_field_extraction.v3",
    "RequestFieldValueDisposition",
    RequestFieldValueDisposition,
)


from ......config.core import v3 as _____config__core__v3__
