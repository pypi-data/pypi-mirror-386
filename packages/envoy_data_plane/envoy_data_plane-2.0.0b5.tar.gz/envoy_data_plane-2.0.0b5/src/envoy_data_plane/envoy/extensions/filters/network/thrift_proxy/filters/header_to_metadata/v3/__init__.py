# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/extensions/filters/network/thrift_proxy/filters/header_to_metadata/v3/header_to_metadata.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "HeaderToMetadata",
    "HeaderToMetadataKeyValuePair",
    "HeaderToMetadataRule",
    "HeaderToMetadataValueEncode",
    "HeaderToMetadataValueType",
)

import typing

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .........message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class HeaderToMetadataValueEncode(betterproto2.Enum):
    """
    ValueEncode defines the encoding algorithm.
    """

    NONE = 0
    """
    The value is not encoded.
    """

    BASE64 = 1
    """
    The value is encoded in `Base64 <https://tools.ietf.org/html/rfc4648#section-4>`_.
    Note: this is mostly used for STRING and PROTOBUF_VALUE to escape the
    non-ASCII characters in the header.
    """


class HeaderToMetadataValueType(betterproto2.Enum):
    STRING = 0

    NUMBER = 1

    PROTOBUF_VALUE = 2
    """
    The value is a serialized `protobuf.Value
    <https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/struct.proto#L62>`_.
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HeaderToMetadata(betterproto2.Message):
    """
    [#protodoc-title: Header-To-Metadata Filter]

    The configuration for transforming headers into metadata. This is useful
    for matching load balancer subsets, logging, etc.

    Header to Metadata :ref:`configuration overview <config_thrift_filters_header_to_metadata>`.
    [#extension: envoy.filters.thrift.header_to_metadata]
    """

    request_rules: "list[HeaderToMetadataRule]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of rules to apply to requests.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.thrift_proxy.filters.header_to_metadata.v3",
    "HeaderToMetadata",
    HeaderToMetadata,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HeaderToMetadataKeyValuePair(betterproto2.Message):
    """
    [#next-free-field: 7]

    Oneofs:
        - value_type:
    """

    metadata_namespace: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The namespace — if this is empty, the filter's namespace will be used.
    """

    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The key to use within the namespace.
    """

    value: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True, group="value_type"
    )
    """
    The value to pair with the given key.

    When used for on_present case, if value is non-empty it'll be used instead
    of the header value. If both are empty, the header value is used as-is.

    When used for on_missing case, a non-empty value must be provided.
    """

    regex_value_rewrite: "_______type__matcher__v3__.RegexMatchAndSubstitute | None" = (
        betterproto2.field(
            4, betterproto2.TYPE_MESSAGE, optional=True, group="value_type"
        )
    )
    """
    If present, the header's value will be matched and substituted with this.
    If there is no match or substitution, the header value is used as-is.

    This is only used for on_present.
    """

    type: "HeaderToMetadataValueType" = betterproto2.field(
        5, betterproto2.TYPE_ENUM, default_factory=lambda: HeaderToMetadataValueType(0)
    )
    """
    The value's type — defaults to string.
    """

    encode: "HeaderToMetadataValueEncode" = betterproto2.field(
        6,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: HeaderToMetadataValueEncode(0),
    )
    """
    How is the value encoded, default is NONE (not encoded).
    The value will be decoded accordingly before storing to metadata.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.filters.network.thrift_proxy.filters.header_to_metadata.v3",
    "HeaderToMetadata.KeyValuePair",
    HeaderToMetadataKeyValuePair,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HeaderToMetadataRule(betterproto2.Message):
    """
    A Rule defines what metadata to apply when a header is present or missing.
    """

    header: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Specifies that a match will be performed on the value of a header.

    The header to be extracted.
    """

    on_present: "HeaderToMetadataKeyValuePair | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If the header is present, apply this metadata KeyValuePair.

    If the value in the KeyValuePair is non-empty, it'll be used instead
    of the header value.
    """

    on_missing: "HeaderToMetadataKeyValuePair | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If the header is not present, apply this metadata KeyValuePair.

    The value in the KeyValuePair must be set, since it'll be used in lieu
    of the missing header value.
    """

    remove: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)
    """
    Whether or not to remove the header after a rule is applied.

    This prevents headers from leaking.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.thrift_proxy.filters.header_to_metadata.v3",
    "HeaderToMetadata.Rule",
    HeaderToMetadataRule,
)


from ........type.matcher import v3 as _______type__matcher__v3__
