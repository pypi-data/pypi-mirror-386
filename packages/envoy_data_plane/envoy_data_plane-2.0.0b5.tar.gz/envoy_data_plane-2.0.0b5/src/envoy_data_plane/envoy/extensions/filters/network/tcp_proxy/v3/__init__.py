# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "TcpProxy",
    "TcpProxyOnDemand",
    "TcpProxyTcpAccessLogOptions",
    "TcpProxyTunnelingConfig",
    "TcpProxyWeightedCluster",
    "TcpProxyWeightedClusterClusterWeight",
)

import datetime
import typing
import warnings

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .......message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpProxy(betterproto2.Message):
    """
    [#protodoc-title: TCP Proxy]
    TCP Proxy :ref:`configuration overview <config_network_filters_tcp_proxy>`.
    [#extension: envoy.filters.network.tcp_proxy]

    [#next-free-field: 21]

    Oneofs:
        - cluster_specifier:
    """

    stat_prefix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The prefix to use when emitting :ref:`statistics
    <config_network_filters_tcp_proxy_stats>`.
    """

    cluster: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="cluster_specifier"
    )
    """
    The upstream cluster to connect to.
    """

    weighted_clusters: "TcpProxyWeightedCluster | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="cluster_specifier"
    )
    """
    Multiple upstream clusters can be specified. The request is routed to one of the upstream clusters
    based on the weights assigned to each cluster.
    """

    on_demand: "TcpProxyOnDemand | None" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The on demand policy for the upstream cluster.
    It applies to both
    :ref:`TcpProxy.cluster <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.cluster>`
    and
    :ref:`TcpProxy.weighted_clusters <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.weighted_clusters>`.
    """

    metadata_match: "_____config__core__v3__.Metadata | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
    in the upstream cluster with metadata matching what is set in this field will be considered
    for load balancing. The filter name should be specified as ``envoy.lb``.
    """

    idle_timeout: "datetime.timedelta | None" = betterproto2.field(
        8,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.Duration,
        optional=True,
    )
    """
    The idle timeout for connections managed by the TCP proxy filter. The idle timeout is defined as the
    period in which there are no bytes sent or received on either the upstream or downstream connection.
    If not set, the default idle timeout is 1 hour. If set to ``0s``, the timeout is disabled.
    It is possible to dynamically override this configuration by setting a per-connection filter state
    object for the key ``envoy.tcp_proxy.per_connection_idle_timeout_ms``.

    .. warning::
      Disabling this timeout is likely to yield connection leaks due to lost TCP FIN packets, etc.
    """

    downstream_idle_timeout: "datetime.timedelta | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.Duration,
        optional=True,
    )
    """
    [#not-implemented-hide:] The idle timeout for connections managed by the TCP proxy
    filter. The idle timeout is defined as the period in which there is no
    active traffic. If not set, there is no idle timeout. When the idle timeout
    is reached the connection will be closed. The distinction between
    downstream_idle_timeout/upstream_idle_timeout provides a means to set
    timeout based on the last byte sent on the downstream/upstream connection.
    """

    upstream_idle_timeout: "datetime.timedelta | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.Duration,
        optional=True,
    )
    """
    [#not-implemented-hide:]
    """

    access_log: "list[_____config__accesslog__v3__.AccessLog]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Configuration for :ref:`access logs <arch_overview_access_logs>` emitted by this TCP proxy.
    """

    max_connect_attempts: "int | None" = betterproto2.field(
        7,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The maximum number of unsuccessful connection attempts that will be made before
    giving up. If the parameter is not specified, 1 connection attempt will be made.
    """

    backoff_options: "_____config__core__v3__.BackoffStrategy | None" = (
        betterproto2.field(18, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Sets the backoff strategy. If not set, the retries are performed without backoff.
    """

    hash_policy: "list[_____type__v3__.HashPolicy]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional configuration for TCP proxy hash policy. If hash_policy is not set, the hash-based
    load balancing algorithms will select a host randomly. Currently the number of hash policies is
    limited to 1.
    """

    tunneling_config: "TcpProxyTunnelingConfig | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If set, this configures tunneling, for example configuration options to tunnel TCP payload over
    HTTP CONNECT. If this message is absent, the payload is proxied upstream as usual.
    It is possible to dynamically override this configuration and disable tunneling per connection by
    setting a per-connection filter state object for the key ``envoy.tcp_proxy.disable_tunneling``.
    """

    max_downstream_connection_duration: "datetime.timedelta | None" = (
        betterproto2.field(
            13,
            betterproto2.TYPE_MESSAGE,
            unwrap=lambda: ______google__protobuf__.Duration,
            optional=True,
        )
    )
    """
    The maximum duration of a connection. The duration is defined as the period since a connection was
    established. If not set, there is no maximum duration. When ``max_downstream_connection_duration`` is
    reached, the connection is closed. The duration must be at least ``1ms``.
    """

    max_downstream_connection_duration_jitter_percentage: "_____type__v3__.Percent | None" = betterproto2.field(
        20, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Percentage-based jitter for ``max_downstream_connection_duration``. The jitter increases the
    ``max_downstream_connection_duration`` by a random duration up to the provided percentage.
    This field is ignored if ``max_downstream_connection_duration`` is not set. If not set, no jitter
    is added.
    """

    access_log_flush_interval: "datetime.timedelta | None" = betterproto2.field(
        15,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.Duration,
        optional=True,
    )
    """
    If both this field and :ref:`access_log_flush_interval
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.access_log_flush_interval>`
    are specified, the former (deprecated field) is ignored.

    .. attention::
      This field is deprecated in favor of
      :ref:`access_log_flush_interval
      <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.access_log_flush_interval>`.
    """

    flush_access_log_on_connected: "bool" = betterproto2.field(
        16, betterproto2.TYPE_BOOL
    )
    """
    If both this field and :ref:`flush_access_log_on_connected
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.flush_access_log_on_connected>`
    are specified, the former (deprecated field) is ignored.

    .. attention::
      This field is deprecated in favor of
      :ref:`flush_access_log_on_connected
      <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.flush_access_log_on_connected>`.
    """

    access_log_options: "TcpProxyTcpAccessLogOptions | None" = betterproto2.field(
        17, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional access log options for the TCP proxy.
    """

    proxy_protocol_tlvs: "list[_____config__core__v3__.TlvEntry]" = betterproto2.field(
        19, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    If set, the specified ``PROXY`` protocol TLVs (Type-Length-Value) are added to the ``PROXY`` protocol state
    created by the TCP proxy filter. These TLVs are sent in the PROXY protocol v2 header to the upstream.

    This field only takes effect when the TCP proxy filter is creating new ``PROXY`` protocol state and an
    upstream proxy protocol transport socket is configured in the cluster. If the connection already
    contains ``PROXY`` protocol state (including any TLVs) parsed by a downstream proxy protocol listener
    upstream proxy protocol transport socket is configured in the cluster. If the connection already
    contains PROXY protocol state (including any TLVs) parsed by a downstream proxy protocol listener
    filter, the TLVs specified here are ignored.

    .. note::
      To ensure the specified TLVs are allowed in the upstream ``PROXY`` protocol header, you must also
      configure passthrough TLVs on the upstream proxy protocol transport. See
      :ref:`core.v3.ProxyProtocolConfig.pass_through_tlvs <envoy_v3_api_field_config.core.v3.ProxyProtocolConfig.pass_through_tlvs>`
      for details.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("access_log_flush_interval"):
            warnings.warn(
                "TcpProxy.access_log_flush_interval is deprecated", DeprecationWarning
            )
        if self.is_set("flush_access_log_on_connected"):
            warnings.warn(
                "TcpProxy.flush_access_log_on_connected is deprecated",
                DeprecationWarning,
            )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.filters.network.tcp_proxy.v3", "TcpProxy", TcpProxy
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpProxyOnDemand(betterproto2.Message):
    odcds_config: "_____config__core__v3__.ConfigSource | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional configuration for the on-demand cluster discovery service.
    If not specified, on-demand cluster discovery is disabled. When specified, the filter pauses a request
    to an unknown cluster and begins a cluster discovery process. When discovery completes (successfully
    or not), the request is resumed.
    """

    resources_locator: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    xdstp:// resource locator for on-demand cluster collection.
    [#not-implemented-hide:]
    """

    timeout: "datetime.timedelta | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.Duration,
        optional=True,
    )
    """
    The timeout for on-demand cluster lookup. If the CDS cannot return the required cluster,
    the downstream request will be closed with the error code detail NO_CLUSTER_FOUND.
    [#not-implemented-hide:]
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.tcp_proxy.v3",
    "TcpProxy.OnDemand",
    TcpProxyOnDemand,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpProxyTcpAccessLogOptions(betterproto2.Message):
    access_log_flush_interval: "datetime.timedelta | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.Duration,
        optional=True,
    )
    """
    The interval for flushing access logs. By default, the TCP proxy flushes a single access log when the
    connection is closed. If this field is set, the TCP proxy flushes access logs periodically at the
    specified interval.
    The interval must be at least 1ms.
    """

    flush_access_log_on_connected: "bool" = betterproto2.field(
        2, betterproto2.TYPE_BOOL
    )
    """
    If set to true, the access log is flushed when the TCP proxy successfully establishes a
    connection with the upstream. If the connection fails, the access log is not flushed.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.tcp_proxy.v3",
    "TcpProxy.TcpAccessLogOptions",
    TcpProxyTcpAccessLogOptions,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpProxyTunnelingConfig(betterproto2.Message):
    """
    Configuration for tunneling TCP over other transports or application layers.
    Tunneling is supported over HTTP/1.1 and HTTP/2. The upstream protocol is
    determined by the cluster configuration.
    [#next-free-field: 10]
    """

    hostname: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The hostname to send in the synthesized CONNECT headers to the upstream proxy.
    This field evaluates command operators if present; otherwise, the value is used as-is.

    For example, dynamically set the hostname using downstream SNI:

    .. code-block:: yaml

       tunneling_config:
         hostname: "%REQUESTED_SERVER_NAME%:443"

    For example, dynamically set the hostname using dynamic metadata:

    .. code-block:: yaml

       tunneling_config:
         hostname: "%DYNAMIC_METADATA(tunnel:address)%"
    """

    use_post: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)
    """
    Use the ``POST`` method instead of the ``CONNECT`` method to tunnel the TCP stream.
    The ``protocol: bytestream`` header is not set for HTTP/2 to comply with the specification.

    The upstream proxy is expected to interpret the POST payload as raw TCP.
    """

    headers_to_add: "list[_____config__core__v3__.HeaderValueOption]" = (
        betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Additional request headers to send to the upstream proxy. This is mainly used to
    trigger the upstream to convert POST requests back to CONNECT requests.

    Neither ``:``-prefixed pseudo-headers like ``:path`` nor the ``host`` header can be overridden.
    """

    propagate_response_headers: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)
    """
    Save response headers to the downstream connection's filter state for consumption
    by network filters. The filter state key is ``envoy.tcp_proxy.propagate_response_headers``.
    """

    post_path: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )
    """
    The path used with the POST method. The default path is ``/``. If this field is specified and
    :ref:`use_post field <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.use_post>`
    is not set to true, the configuration will be rejected.
    """

    propagate_response_trailers: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)
    """
    Save response trailers to the downstream connection's filter state for consumption
    by network filters. The filter state key is ``envoy.tcp_proxy.propagate_response_trailers``.
    """

    request_id_extension: "__http_connection_manager__v3__.RequestIdExtension | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The configuration of the request ID extension used for generation, validation, and
    associated tracing operations when tunneling.

    If this field is set, a request ID is generated using the specified extension. If
    this field is not set, no request ID is generated.

    When a request ID is generated, it is also stored in the downstream connection's
    dynamic metadata under the namespace ``envoy.filters.network.tcp_proxy`` with the key
    ``tunnel_request_id`` to allow emission from TCP proxy access logs via the
    ``%DYNAMIC_METADATA(envoy.filters.network.tcp_proxy:tunnel_request_id)%`` formatter.
    [#extension-category: envoy.request_id]
    """

    request_id_header: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        8, betterproto2.TYPE_STRING
    )
    """
    The request header name to use for emitting the generated request ID on the tunneling
    HTTP request.

    If not specified or set to an empty string, the default header name ``x-request-id`` is
    used.

    .. note::
      This setting does not alter the internal request ID handling elsewhere in Envoy and
      only controls the header emitted on the tunneling request.
    """

    request_id_metadata_key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        9, betterproto2.TYPE_STRING
    )
    """
    The dynamic metadata key to use when storing the generated request ID. The metadata is
    stored under the namespace ``envoy.filters.network.tcp_proxy``.

    If not specified or set to an empty string, the default key ``tunnel_request_id`` is used.
    This enables customizing the key used by access log formatters such as
    ``%DYNAMIC_METADATA(envoy.filters.network.tcp_proxy:<key>)%``.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.tcp_proxy.v3",
    "TcpProxy.TunnelingConfig",
    TcpProxyTunnelingConfig,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpProxyWeightedCluster(betterproto2.Message):
    """
    Allows specification of multiple upstream clusters along with weights indicating the percentage of
    traffic forwarded to each cluster. The cluster selection is based on these weights.
    """

    clusters: "list[TcpProxyWeightedClusterClusterWeight]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies the upstream clusters associated with this configuration.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.tcp_proxy.v3",
    "TcpProxy.WeightedCluster",
    TcpProxyWeightedCluster,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpProxyWeightedClusterClusterWeight(betterproto2.Message):
    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Name of the upstream cluster.
    """

    weight: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32)
    )
    """
    When a request matches the route, the choice of an upstream cluster is
    determined by its weight. The sum of weights across all entries in the
    clusters array determines the total weight.
    """

    metadata_match: "_____config__core__v3__.Metadata | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
    in the upstream cluster with metadata matching what is set in this field will be considered
    for load balancing. Note that this will be merged with what's provided in
    :ref:`TcpProxy.metadata_match
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.metadata_match>`, with values
    here taking precedence. The filter name should be specified as ``envoy.lb``.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.tcp_proxy.v3",
    "TcpProxy.WeightedCluster.ClusterWeight",
    TcpProxyWeightedClusterClusterWeight,
)


from .......google import protobuf as ______google__protobuf__
from ......config.accesslog import v3 as _____config__accesslog__v3__
from ......config.core import v3 as _____config__core__v3__
from ......type import v3 as _____type__v3__
from ...http_connection_manager import v3 as __http_connection_manager__v3__
