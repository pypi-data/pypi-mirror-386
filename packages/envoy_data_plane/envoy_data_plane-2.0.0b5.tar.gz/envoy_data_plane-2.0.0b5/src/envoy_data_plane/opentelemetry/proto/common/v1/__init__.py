# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: opentelemetry/proto/common/v1/common.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "AnyValue",
    "ArrayValue",
    "InstrumentationLibrary",
    "KeyValue",
    "KeyValueList",
    "StringKeyValue",
)

import typing
import warnings

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AnyValue(betterproto2.Message):
    """
    AnyValue is used to represent any type of attribute value. AnyValue may contain a
    primitive value such as a string or integer or it may contain an arbitrary nested
    object containing arrays, key-value lists and primitives.

    Oneofs:
        - value: The value is one of the listed fields. It is valid for all values to be unspecified
            in which case this AnyValue is considered to be "null".
    """

    string_value: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="value"
    )

    bool_value: "bool | None" = betterproto2.field(
        2, betterproto2.TYPE_BOOL, optional=True, group="value"
    )

    int_value: "typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)] | None" = betterproto2.field(
        3, betterproto2.TYPE_INT64, optional=True, group="value"
    )

    double_value: "float | None" = betterproto2.field(
        4, betterproto2.TYPE_DOUBLE, optional=True, group="value"
    )

    array_value: "ArrayValue | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    kvlist_value: "KeyValueList | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    bytes_value: "bytes | None" = betterproto2.field(
        7, betterproto2.TYPE_BYTES, optional=True, group="value"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "opentelemetry.proto.common.v1", "AnyValue", AnyValue
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ArrayValue(betterproto2.Message):
    """
    ArrayValue is a list of AnyValue messages. We need ArrayValue as a message
    since oneof in AnyValue does not allow repeated fields.
    """

    values: "list[AnyValue]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Array of values. The array may be empty (contain 0 elements).
    """


default_message_pool.register_message(
    "opentelemetry.proto.common.v1", "ArrayValue", ArrayValue
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class InstrumentationLibrary(betterproto2.Message):
    """
    InstrumentationLibrary is a message representing the instrumentation library information
    such as the fully qualified name and version.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    An empty instrumentation library name means the name is unknown. 
    """

    version: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )


default_message_pool.register_message(
    "opentelemetry.proto.common.v1", "InstrumentationLibrary", InstrumentationLibrary
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class KeyValue(betterproto2.Message):
    """
    KeyValue is a key-value pair that is used to store Span attributes, Link
    attributes, etc.
    """

    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    value: "AnyValue | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "opentelemetry.proto.common.v1", "KeyValue", KeyValue
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class KeyValueList(betterproto2.Message):
    """
    KeyValueList is a list of KeyValue messages. We need KeyValueList as a message
    since `oneof` in AnyValue does not allow repeated fields. Everywhere else where we need
    a list of KeyValue messages (e.g. in Span) we use `repeated KeyValue` directly to
    avoid unnecessary extra wrapping (which slows down the protocol). The 2 approaches
    are semantically equivalent.
    """

    values: "list[KeyValue]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A collection of key/value pairs of key-value pairs. The list may be empty (may
    contain 0 elements).
    """


default_message_pool.register_message(
    "opentelemetry.proto.common.v1", "KeyValueList", KeyValueList
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StringKeyValue(betterproto2.Message):
    """
    StringKeyValue is a pair of key/value strings. This is the simpler (and faster) version
    of KeyValue that only supports string values.
    """

    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    value: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )

    def __post_init__(self) -> None:
        warnings.warn("StringKeyValue is deprecated", DeprecationWarning)
        super().__post_init__()


default_message_pool.register_message(
    "opentelemetry.proto.common.v1", "StringKeyValue", StringKeyValue
)
