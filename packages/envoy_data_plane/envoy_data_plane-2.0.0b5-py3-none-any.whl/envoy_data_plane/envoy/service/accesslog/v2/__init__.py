# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/accesslog/v2/als.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "AccessLogServiceAsyncStub",
    "AccessLogServiceBase",
    "AccessLogServiceSyncStub",
    "StreamAccessLogsMessage",
    "StreamAccessLogsMessageHttpAccessLogEntries",
    "StreamAccessLogsMessageIdentifier",
    "StreamAccessLogsMessageTcpAccessLogEntries",
    "StreamAccessLogsResponse",
)

import typing
from collections.abc import AsyncIterable, AsyncIterator, Iterable
from typing import TYPE_CHECKING

import betterproto2
import grpc
import grpclib
import pydantic
from betterproto2 import grpclib as betterproto2_grpclib
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpclib.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamAccessLogsMessage(betterproto2.Message):
    """
    Stream message for the StreamAccessLogs API. Envoy will open a stream to the server and stream
    access logs without ever expecting a response.

    Oneofs:
        - log_entries: Batches of log entries of a single type. Generally speaking, a given stream should only
            ever include one type of log entry.
    """

    identifier: "StreamAccessLogsMessageIdentifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Identifier data that will only be sent in the first message on the stream. This is effectively
    structured metadata and is a performance optimization.
    """

    http_logs: "StreamAccessLogsMessageHttpAccessLogEntries | None" = (
        betterproto2.field(
            2, betterproto2.TYPE_MESSAGE, optional=True, group="log_entries"
        )
    )

    tcp_logs: "StreamAccessLogsMessageTcpAccessLogEntries | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="log_entries"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.service.accesslog.v2", "StreamAccessLogsMessage", StreamAccessLogsMessage
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamAccessLogsMessageHttpAccessLogEntries(betterproto2.Message):
    """
    Wrapper for batches of HTTP access log entries.
    """

    log_entry: "list[___data__accesslog__v2__.HttpAccessLogEntry]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.accesslog.v2",
    "StreamAccessLogsMessage.HTTPAccessLogEntries",
    StreamAccessLogsMessageHttpAccessLogEntries,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamAccessLogsMessageIdentifier(betterproto2.Message):
    node: "___api__v2__core__.Node | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The node sending the access log messages over the stream.
    """

    log_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The friendly name of the log configured in :ref:`CommonGrpcAccessLogConfig
    <envoy_api_msg_config.accesslog.v2.CommonGrpcAccessLogConfig>`.
    """


default_message_pool.register_message(
    "envoy.service.accesslog.v2",
    "StreamAccessLogsMessage.Identifier",
    StreamAccessLogsMessageIdentifier,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamAccessLogsMessageTcpAccessLogEntries(betterproto2.Message):
    """
    Wrapper for batches of TCP access log entries.
    """

    log_entry: "list[___data__accesslog__v2__.TcpAccessLogEntry]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.accesslog.v2",
    "StreamAccessLogsMessage.TCPAccessLogEntries",
    StreamAccessLogsMessageTcpAccessLogEntries,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamAccessLogsResponse(betterproto2.Message):
    """
    Empty response for the StreamAccessLogs API. Will never be sent. See below.
    """

    pass


default_message_pool.register_message(
    "envoy.service.accesslog.v2", "StreamAccessLogsResponse", StreamAccessLogsResponse
)


class AccessLogServiceSyncStub:
    """
    [#protodoc-title: gRPC Access Log Service (ALS)]

    Service for streaming access logs from Envoy to an access log server.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_access_logs(
        self, messages: "Iterable[StreamAccessLogsMessage]"
    ) -> "StreamAccessLogsResponse":
        """
        Envoy will connect and send StreamAccessLogsMessage messages forever. It does not expect any
        response to be sent as nothing would be done in the case of failure. The server should
        disconnect if it expects Envoy to reconnect. In the future we may decide to add a different
        API for "critical" access logs in which Envoy will buffer access logs for some period of time
        until it gets an ACK so it could then retry. This API is designed for high throughput with the
        expectation that it might be lossy.
        """

        return self._channel.stream_unary(
            "/envoy.service.accesslog.v2.AccessLogService/StreamAccessLogs",
            StreamAccessLogsMessage.SerializeToString,
            StreamAccessLogsResponse.FromString,
        )(iter(messages))


class AccessLogServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: gRPC Access Log Service (ALS)]

    Service for streaming access logs from Envoy to an access log server.
    """

    async def stream_access_logs(
        self,
        messages: "AsyncIterable[StreamAccessLogsMessage] | Iterable[StreamAccessLogsMessage]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "StreamAccessLogsResponse":
        """
        Envoy will connect and send StreamAccessLogsMessage messages forever. It does not expect any
        response to be sent as nothing would be done in the case of failure. The server should
        disconnect if it expects Envoy to reconnect. In the future we may decide to add a different
        API for "critical" access logs in which Envoy will buffer access logs for some period of time
        until it gets an ACK so it could then retry. This API is designed for high throughput with the
        expectation that it might be lossy.
        """

        return await self._stream_unary(
            "/envoy.service.accesslog.v2.AccessLogService/StreamAccessLogs",
            messages,
            StreamAccessLogsMessage,
            StreamAccessLogsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from ....api.v2 import core as ___api__v2__core__
from ....data.accesslog import v2 as ___data__accesslog__v2__


class AccessLogServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: gRPC Access Log Service (ALS)]

    Service for streaming access logs from Envoy to an access log server.
    """

    async def stream_access_logs(
        self, messages: "AsyncIterator[StreamAccessLogsMessage]"
    ) -> "StreamAccessLogsResponse":
        """
        Envoy will connect and send StreamAccessLogsMessage messages forever. It does not expect any
        response to be sent as nothing would be done in the case of failure. The server should
        disconnect if it expects Envoy to reconnect. In the future we may decide to add a different
        API for "critical" access logs in which Envoy will buffer access logs for some period of time
        until it gets an ACK so it could then retry. This API is designed for high throughput with the
        expectation that it might be lossy.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_access_logs(
        self,
        stream: "grpclib.server.Stream[StreamAccessLogsMessage, StreamAccessLogsResponse]",
    ) -> None:
        request = stream.__aiter__()
        response = await self.stream_access_logs(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.accesslog.v2.AccessLogService/StreamAccessLogs": grpclib.const.Handler(
                self.__rpc_stream_access_logs,
                grpclib.const.Cardinality.STREAM_UNARY,
                StreamAccessLogsMessage,
                StreamAccessLogsResponse,
            ),
        }
