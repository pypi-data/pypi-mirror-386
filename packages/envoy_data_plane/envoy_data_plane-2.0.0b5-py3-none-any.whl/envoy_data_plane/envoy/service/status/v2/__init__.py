# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/status/v2/csds.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "ClientConfig",
    "ClientStatusDiscoveryServiceAsyncStub",
    "ClientStatusDiscoveryServiceBase",
    "ClientStatusDiscoveryServiceSyncStub",
    "ClientStatusRequest",
    "ClientStatusResponse",
    "ConfigStatus",
    "PerXdsConfig",
)

from collections.abc import AsyncIterable, AsyncIterator, Iterable, Iterator
from typing import TYPE_CHECKING

import betterproto2
import grpc
import grpclib
from betterproto2 import grpclib as betterproto2_grpclib
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpclib.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class ConfigStatus(betterproto2.Enum):
    """
    Status of a config.
    """

    UNKNOWN = 0
    """
    Status info is not available/unknown.
    """

    SYNCED = 1
    """
    Management server has sent the config to client and received ACK.
    """

    NOT_SENT = 2
    """
    Config is not sent.
    """

    STALE = 3
    """
    Management server has sent the config to client but hasnâ€™t received
    ACK/NACK.
    """

    ERROR = 4
    """
    Management server has sent the config to client but received NACK.
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClientConfig(betterproto2.Message):
    """
    All xds configs for a particular client.
    """

    node: "___api__v2__core__.Node | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Node for a particular client.
    """

    xds_config: "list[PerXdsConfig]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.status.v2", "ClientConfig", ClientConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClientStatusRequest(betterproto2.Message):
    """
    Request for client status of clients identified by a list of NodeMatchers.
    """

    node_matchers: "list[___type__matcher__.NodeMatcher]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Management server can use these match criteria to identify clients.
    The match follows OR semantics.
    """


default_message_pool.register_message(
    "envoy.service.status.v2", "ClientStatusRequest", ClientStatusRequest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClientStatusResponse(betterproto2.Message):
    config: "list[ClientConfig]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Client configs for the clients specified in the ClientStatusRequest.
    """


default_message_pool.register_message(
    "envoy.service.status.v2", "ClientStatusResponse", ClientStatusResponse
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PerXdsConfig(betterproto2.Message):
    """
    Detailed config (per xDS) with status.
    [#next-free-field: 6]

    Oneofs:
        - per_xds_config:
    """

    status: "ConfigStatus" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: ConfigStatus(0)
    )

    listener_config: "___admin__v2alpha__.ListenersConfigDump | None" = (
        betterproto2.field(
            2, betterproto2.TYPE_MESSAGE, optional=True, group="per_xds_config"
        )
    )

    cluster_config: "___admin__v2alpha__.ClustersConfigDump | None" = (
        betterproto2.field(
            3, betterproto2.TYPE_MESSAGE, optional=True, group="per_xds_config"
        )
    )

    route_config: "___admin__v2alpha__.RoutesConfigDump | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="per_xds_config"
    )

    scoped_route_config: "___admin__v2alpha__.ScopedRoutesConfigDump | None" = (
        betterproto2.field(
            5, betterproto2.TYPE_MESSAGE, optional=True, group="per_xds_config"
        )
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.service.status.v2", "PerXdsConfig", PerXdsConfig
)


class ClientStatusDiscoveryServiceSyncStub:
    """
    [#protodoc-title: Client Status Discovery Service (CSDS)]

    CSDS is Client Status Discovery Service. It can be used to get the status of
    an xDS-compliant client from the management server's point of view. In the
    future, it can potentially be used as an interface to get the current
    state directly from the client.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_client_status(
        self, messages: "Iterable[ClientStatusRequest]"
    ) -> "Iterator[ClientStatusResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.status.v2.ClientStatusDiscoveryService/StreamClientStatus",
            ClientStatusRequest.SerializeToString,
            ClientStatusResponse.FromString,
        )(iter(messages))

    def fetch_client_status(
        self, message: "ClientStatusRequest"
    ) -> "ClientStatusResponse":
        return self._channel.unary_unary(
            "/envoy.service.status.v2.ClientStatusDiscoveryService/FetchClientStatus",
            ClientStatusRequest.SerializeToString,
            ClientStatusResponse.FromString,
        )(message)


class ClientStatusDiscoveryServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: Client Status Discovery Service (CSDS)]

    CSDS is Client Status Discovery Service. It can be used to get the status of
    an xDS-compliant client from the management server's point of view. In the
    future, it can potentially be used as an interface to get the current
    state directly from the client.
    """

    async def stream_client_status(
        self,
        messages: "AsyncIterable[ClientStatusRequest] | Iterable[ClientStatusRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[ClientStatusResponse]":
        async for response in self._stream_stream(
            "/envoy.service.status.v2.ClientStatusDiscoveryService/StreamClientStatus",
            messages,
            ClientStatusRequest,
            ClientStatusResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def fetch_client_status(
        self,
        message: "ClientStatusRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ClientStatusResponse":
        return await self._unary_unary(
            "/envoy.service.status.v2.ClientStatusDiscoveryService/FetchClientStatus",
            message,
            ClientStatusResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from ....admin import v2alpha as ___admin__v2alpha__
from ....api.v2 import core as ___api__v2__core__
from ....type import matcher as ___type__matcher__


class ClientStatusDiscoveryServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: Client Status Discovery Service (CSDS)]

    CSDS is Client Status Discovery Service. It can be used to get the status of
    an xDS-compliant client from the management server's point of view. In the
    future, it can potentially be used as an interface to get the current
    state directly from the client.
    """

    async def stream_client_status(
        self, messages: "AsyncIterator[ClientStatusRequest]"
    ) -> "AsyncIterator[ClientStatusResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ClientStatusResponse()

    async def fetch_client_status(
        self, message: "ClientStatusRequest"
    ) -> "ClientStatusResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_client_status(
        self, stream: "grpclib.server.Stream[ClientStatusRequest, ClientStatusResponse]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_client_status,
            stream,
            request,
        )

    async def __rpc_fetch_client_status(
        self, stream: "grpclib.server.Stream[ClientStatusRequest, ClientStatusResponse]"
    ) -> None:
        request = await stream.recv_message()
        assert request is not None
        response = await self.fetch_client_status(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.status.v2.ClientStatusDiscoveryService/StreamClientStatus": grpclib.const.Handler(
                self.__rpc_stream_client_status,
                grpclib.const.Cardinality.STREAM_STREAM,
                ClientStatusRequest,
                ClientStatusResponse,
            ),
            "/envoy.service.status.v2.ClientStatusDiscoveryService/FetchClientStatus": grpclib.const.Handler(
                self.__rpc_fetch_client_status,
                grpclib.const.Cardinality.UNARY_UNARY,
                ClientStatusRequest,
                ClientStatusResponse,
            ),
        }
