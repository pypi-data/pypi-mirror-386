# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/status/v3/csds.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "ClientConfig",
    "ClientConfigGenericXdsConfig",
    "ClientConfigStatus",
    "ClientStatusDiscoveryServiceAsyncStub",
    "ClientStatusDiscoveryServiceBase",
    "ClientStatusDiscoveryServiceSyncStub",
    "ClientStatusRequest",
    "ClientStatusResponse",
    "ConfigStatus",
    "PerXdsConfig",
)

import datetime
import typing
import warnings
from collections.abc import AsyncIterable, AsyncIterator, Iterable, Iterator
from typing import TYPE_CHECKING

import betterproto2
import grpc
import grpclib
import pydantic
from betterproto2 import grpclib as betterproto2_grpclib
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpclib.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class ClientConfigStatus(betterproto2.Enum):
    """
    Config status from a client-side view.
    """

    CLIENT_UNKNOWN = 0
    """
    Config status is not available/unknown.
    """

    CLIENT_REQUESTED = 1
    """
    Client requested the config but hasn't received any config from management
    server yet.
    """

    CLIENT_ACKED = 2
    """
    Client received the config and replied with ACK.
    """

    CLIENT_NACKED = 3
    """
    Client received the config and replied with NACK. Notably, the attached
    config dump is not the NACKed version, but the most recent accepted one. If
    no config is accepted yet, the attached config dump will be empty.
    """

    CLIENT_RECEIVED_ERROR = 4
    """
    Client received an error from the control plane. The attached config
    dump is the most recent accepted one. If no config is accepted yet,
    the attached config dump will be empty.
    """


class ConfigStatus(betterproto2.Enum):
    """
    Status of a config from a management server view.
    """

    UNKNOWN = 0
    """
    Status info is not available/unknown.
    """

    SYNCED = 1
    """
    Management server has sent the config to client and received ACK.
    """

    NOT_SENT = 2
    """
    Config is not sent.
    """

    STALE = 3
    """
    Management server has sent the config to client but hasnâ€™t received
    ACK/NACK.
    """

    ERROR = 4
    """
    Management server has sent the config to client but received NACK. The
    attached config dump will be the latest config (the rejected one), since
    it is the persisted version in the management server.
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClientConfig(betterproto2.Message):
    """
    All xds configs for a particular client.
    """

    node: "___config__core__v3__.Node | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Node for a particular client.
    """

    xds_config: "list[PerXdsConfig]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    This field is deprecated in favor of generic_xds_configs which is
    much simpler and uniform in structure.
    """

    generic_xds_configs: "list[ClientConfigGenericXdsConfig]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Represents generic xDS config and the exact config structure depends on
    the type URL (like Cluster if it is CDS)
    """

    client_scope: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )
    """
    For xDS clients, the scope in which the data is used.
    For example, gRPC indicates the data plane target or that the data is
    associated with gRPC server(s).
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("xds_config"):
            warnings.warn("ClientConfig.xds_config is deprecated", DeprecationWarning)


default_message_pool.register_message(
    "envoy.service.status.v3", "ClientConfig", ClientConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClientConfigGenericXdsConfig(betterproto2.Message):
    """
    GenericXdsConfig is used to specify the config status and the dump
    of any xDS resource identified by their type URL. It is the generalized
    version of the now deprecated ListenersConfigDump, ClustersConfigDump etc
    [#next-free-field: 10]
    """

    type_url: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Type_url represents the fully qualified name of xDS resource type
    like envoy.v3.Cluster, envoy.v3.ClusterLoadAssignment etc.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Name of the xDS resource
    """

    version_info: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    This is the :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>`
    in the last processed xDS discovery response. If there are only
    static bootstrap listeners, this field will be ""
    """

    xds_config: "____google__protobuf__.Any | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The xDS resource config. Actual content depends on the type
    """

    last_updated: "datetime.datetime | None" = betterproto2.field(
        5,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Timestamp,
        optional=True,
    )
    """
    Timestamp when the xDS resource was last updated
    """

    config_status: "ConfigStatus" = betterproto2.field(
        6, betterproto2.TYPE_ENUM, default_factory=lambda: ConfigStatus(0)
    )
    """
    Per xDS resource config status. It is generated by management servers.
    It will not be present if the CSDS server is an xDS client.
    """

    client_status: "___admin__v3__.ClientResourceStatus" = betterproto2.field(
        7,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ___admin__v3__.ClientResourceStatus(0),
    )
    """
    Per xDS resource status from the view of a xDS client
    """

    error_state: "___admin__v3__.UpdateFailureState | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Set if the last update failed, cleared after the next successful
    update. The *error_state* field contains the rejected version of
    this particular resource along with the reason and timestamp. For
    successfully updated or acknowledged resource, this field should
    be empty.
    [#not-implemented-hide:]
    """

    is_static_resource: "bool" = betterproto2.field(9, betterproto2.TYPE_BOOL)
    """
    Is static resource is true if it is specified in the config supplied
    through the file at the startup.
    """


default_message_pool.register_message(
    "envoy.service.status.v3",
    "ClientConfig.GenericXdsConfig",
    ClientConfigGenericXdsConfig,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClientStatusRequest(betterproto2.Message):
    """
    Request for client status of clients identified by a list of NodeMatchers.
    """

    node_matchers: "list[___type__matcher__v3__.NodeMatcher]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Management server can use these match criteria to identify clients.
    The match follows OR semantics.
    """

    node: "___config__core__v3__.Node | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The node making the csds request.
    """

    exclude_resource_contents: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    If true, the server will not include the resource contents in the response
    (i.e., the generic_xds_configs.xds_config field will not be populated).
    [#not-implemented-hide:]
    """


default_message_pool.register_message(
    "envoy.service.status.v3", "ClientStatusRequest", ClientStatusRequest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClientStatusResponse(betterproto2.Message):
    config: "list[ClientConfig]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Client configs for the clients specified in the ClientStatusRequest.
    """


default_message_pool.register_message(
    "envoy.service.status.v3", "ClientStatusResponse", ClientStatusResponse
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PerXdsConfig(betterproto2.Message):
    """
    Detailed config (per xDS) with status.
    [#next-free-field: 8]

    Oneofs:
        - per_xds_config:
    """

    status: "ConfigStatus" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: ConfigStatus(0)
    )
    """
    Config status generated by management servers. Will not be present if the
    CSDS server is an xDS client.
    """

    client_status: "ClientConfigStatus" = betterproto2.field(
        7, betterproto2.TYPE_ENUM, default_factory=lambda: ClientConfigStatus(0)
    )
    """
    Client config status is populated by xDS clients. Will not be present if
    the CSDS server is an xDS server. No matter what the client config status
    is, xDS clients should always dump the most recent accepted xDS config.

    .. attention::
      This field is deprecated. Use :ref:`ClientResourceStatus
      <envoy_v3_api_enum_admin.v3.ClientResourceStatus>` for per-resource
      config status instead.
    """

    listener_config: "___admin__v3__.ListenersConfigDump | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="per_xds_config"
    )

    cluster_config: "___admin__v3__.ClustersConfigDump | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="per_xds_config"
    )

    route_config: "___admin__v3__.RoutesConfigDump | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="per_xds_config"
    )

    scoped_route_config: "___admin__v3__.ScopedRoutesConfigDump | None" = (
        betterproto2.field(
            5, betterproto2.TYPE_MESSAGE, optional=True, group="per_xds_config"
        )
    )

    endpoint_config: "___admin__v3__.EndpointsConfigDump | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="per_xds_config"
    )

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("client_status"):
            warnings.warn(
                "PerXdsConfig.client_status is deprecated", DeprecationWarning
            )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.service.status.v3", "PerXdsConfig", PerXdsConfig
)


class ClientStatusDiscoveryServiceSyncStub:
    """
    [#protodoc-title: Client status discovery service (CSDS)]

    CSDS is Client Status Discovery Service. It can be used to get the status of
    an xDS-compliant client from the management server's point of view. It can
    also be used to get the current xDS states directly from the client.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_client_status(
        self, messages: "Iterable[ClientStatusRequest]"
    ) -> "Iterator[ClientStatusResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.status.v3.ClientStatusDiscoveryService/StreamClientStatus",
            ClientStatusRequest.SerializeToString,
            ClientStatusResponse.FromString,
        )(iter(messages))

    def fetch_client_status(
        self, message: "ClientStatusRequest"
    ) -> "ClientStatusResponse":
        return self._channel.unary_unary(
            "/envoy.service.status.v3.ClientStatusDiscoveryService/FetchClientStatus",
            ClientStatusRequest.SerializeToString,
            ClientStatusResponse.FromString,
        )(message)


class ClientStatusDiscoveryServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: Client status discovery service (CSDS)]

    CSDS is Client Status Discovery Service. It can be used to get the status of
    an xDS-compliant client from the management server's point of view. It can
    also be used to get the current xDS states directly from the client.
    """

    async def stream_client_status(
        self,
        messages: "AsyncIterable[ClientStatusRequest] | Iterable[ClientStatusRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[ClientStatusResponse]":
        async for response in self._stream_stream(
            "/envoy.service.status.v3.ClientStatusDiscoveryService/StreamClientStatus",
            messages,
            ClientStatusRequest,
            ClientStatusResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def fetch_client_status(
        self,
        message: "ClientStatusRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ClientStatusResponse":
        return await self._unary_unary(
            "/envoy.service.status.v3.ClientStatusDiscoveryService/FetchClientStatus",
            message,
            ClientStatusResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from .....google import protobuf as ____google__protobuf__
from ....admin import v3 as ___admin__v3__
from ....config.core import v3 as ___config__core__v3__
from ....type.matcher import v3 as ___type__matcher__v3__


class ClientStatusDiscoveryServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: Client status discovery service (CSDS)]

    CSDS is Client Status Discovery Service. It can be used to get the status of
    an xDS-compliant client from the management server's point of view. It can
    also be used to get the current xDS states directly from the client.
    """

    async def stream_client_status(
        self, messages: "AsyncIterator[ClientStatusRequest]"
    ) -> "AsyncIterator[ClientStatusResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ClientStatusResponse()

    async def fetch_client_status(
        self, message: "ClientStatusRequest"
    ) -> "ClientStatusResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_client_status(
        self, stream: "grpclib.server.Stream[ClientStatusRequest, ClientStatusResponse]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_client_status,
            stream,
            request,
        )

    async def __rpc_fetch_client_status(
        self, stream: "grpclib.server.Stream[ClientStatusRequest, ClientStatusResponse]"
    ) -> None:
        request = await stream.recv_message()
        assert request is not None
        response = await self.fetch_client_status(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.status.v3.ClientStatusDiscoveryService/StreamClientStatus": grpclib.const.Handler(
                self.__rpc_stream_client_status,
                grpclib.const.Cardinality.STREAM_STREAM,
                ClientStatusRequest,
                ClientStatusResponse,
            ),
            "/envoy.service.status.v3.ClientStatusDiscoveryService/FetchClientStatus": grpclib.const.Handler(
                self.__rpc_fetch_client_status,
                grpclib.const.Cardinality.UNARY_UNARY,
                ClientStatusRequest,
                ClientStatusResponse,
            ),
        }
