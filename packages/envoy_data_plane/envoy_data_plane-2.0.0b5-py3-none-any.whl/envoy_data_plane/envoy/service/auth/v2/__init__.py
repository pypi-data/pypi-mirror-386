# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/auth/v2/attribute_context.proto, envoy/service/auth/v2/external_auth.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "AttributeContext",
    "AttributeContextHttpRequest",
    "AttributeContextPeer",
    "AttributeContextRequest",
    "AuthorizationAsyncStub",
    "AuthorizationBase",
    "AuthorizationSyncStub",
    "CheckRequest",
    "CheckResponse",
    "DeniedHttpResponse",
    "OkHttpResponse",
)

import datetime
import typing
from typing import TYPE_CHECKING

import betterproto2
import grpc
import grpclib
import pydantic
from betterproto2 import grpclib as betterproto2_grpclib
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpclib.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AttributeContext(betterproto2.Message):
    """
    [#protodoc-title: Attribute Context ]

    See :ref:`network filter configuration overview <config_network_filters_ext_authz>`
    and :ref:`HTTP filter configuration overview <config_http_filters_ext_authz>`.

    An attribute is a piece of metadata that describes an activity on a network.
    For example, the size of an HTTP request, or the status code of an HTTP response.

    Each attribute has a type and a name, which is logically defined as a proto message field
    of the `AttributeContext`. The `AttributeContext` is a collection of individual attributes
    supported by Envoy authorization system.
    [#comment: The following items are left out of this proto
    Request.Auth field for JWTs
    Request.Api for api management
    Origin peer that originated the request
    Caching Protocol
    request_context return values to inject back into the filter chain
    peer.claims -- from X.509 extensions
    Configuration
    - field mask to send
    - which return values from request_context are copied back
    - which return values are copied into request_headers]
    [#next-free-field: 12]
    """

    source: "AttributeContextPeer | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The source of a network activity, such as starting a TCP connection.
    In a multi hop network activity, the source represents the sender of the
    last hop.
    """

    destination: "AttributeContextPeer | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The destination of a network activity, such as accepting a TCP connection.
    In a multi hop network activity, the destination represents the receiver of
    the last hop.
    """

    request: "AttributeContextRequest | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Represents a network request, such as an HTTP request.
    """

    context_extensions: "dict[str, str]" = betterproto2.field(
        10,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_STRING
        ),
    )
    """
    This is analogous to http_request.headers, however these contents will not be sent to the
    upstream server. Context_extensions provide an extension mechanism for sending additional
    information to the auth server without modifying the proto definition. It maps to the
    internal opaque context in the filter chain.
    """

    metadata_context: "___api__v2__core__.Metadata | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Dynamic metadata associated with the request.
    """


default_message_pool.register_message(
    "envoy.service.auth.v2", "AttributeContext", AttributeContext
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AttributeContextHttpRequest(betterproto2.Message):
    """
    This message defines attributes for an HTTP request.
    HTTP/1.x, HTTP/2, gRPC are all considered as HTTP requests.
    [#next-free-field: 12]
    """

    id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The unique ID for a request, which can be propagated to downstream
    systems. The ID should have low probability of collision
    within a single day for a specific service.
    For HTTP requests, it should be X-Request-ID or equivalent.
    """

    method: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The HTTP request method, such as `GET`, `POST`.
    """

    headers: "dict[str, str]" = betterproto2.field(
        3,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_STRING
        ),
    )
    """
    The HTTP request headers. If multiple headers share the same key, they
    must be merged according to the HTTP spec. All header keys must be
    lower-cased, because HTTP header keys are case-insensitive.
    """

    path: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )
    """
    The request target, as it appears in the first line of the HTTP request. This includes
    the URL path and query-string. No decoding is performed.
    """

    host: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )
    """
    The HTTP request `Host` or 'Authority` header value.
    """

    scheme: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        6, betterproto2.TYPE_STRING
    )
    """
    The HTTP URL scheme, such as `http` and `https`. This is set for HTTP/2
    requests only. For HTTP/1.1, use "x-forwarded-for" header value to lookup
    the scheme of the request.
    """

    query: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        7, betterproto2.TYPE_STRING
    )
    """
    This field is always empty, and exists for compatibility reasons. The HTTP URL query is
    included in `path` field.
    """

    fragment: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        8, betterproto2.TYPE_STRING
    )
    """
    This field is always empty, and exists for compatibility reasons. The URL fragment is
    not submitted as part of HTTP requests; it is unknowable.
    """

    size: "typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)]" = (
        betterproto2.field(9, betterproto2.TYPE_INT64)
    )
    """
    The HTTP request size in bytes. If unknown, it must be -1.
    """

    protocol: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        10, betterproto2.TYPE_STRING
    )
    """
    The network protocol used with the request, such as "HTTP/1.0", "HTTP/1.1", or "HTTP/2".

    See :repo:`headers.h:ProtocolStrings <source/common/http/headers.h>` for a list of all
    possible values.
    """

    body: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        11, betterproto2.TYPE_STRING
    )
    """
    The HTTP request body.
    """


default_message_pool.register_message(
    "envoy.service.auth.v2", "AttributeContext.HttpRequest", AttributeContextHttpRequest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AttributeContextPeer(betterproto2.Message):
    """
    This message defines attributes for a node that handles a network request.
    The node can be either a service or an application that sends, forwards,
    or receives the request. Service peers should fill in the `service`,
    `principal`, and `labels` as appropriate.
    [#next-free-field: 6]
    """

    address: "___api__v2__core__.Address | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The address of the peer, this is typically the IP address.
    It can also be UDS path, or others.
    """

    service: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The canonical service name of the peer.
    It should be set to :ref:`the HTTP x-envoy-downstream-service-cluster
    <config_http_conn_man_headers_downstream-service-cluster>`
    If a more trusted source of the service name is available through mTLS/secure naming, it
    should be used.
    """

    labels: "dict[str, str]" = betterproto2.field(
        3,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_STRING
        ),
    )
    """
    The labels associated with the peer.
    These could be pod labels for Kubernetes or tags for VMs.
    The source of the labels could be an X.509 certificate or other configuration.
    """

    principal: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )
    """
    The authenticated identity of this peer.
    For example, the identity associated with the workload such as a service account.
    If an X.509 certificate is used to assert the identity this field should be sourced from
    `URI Subject Alternative Names`, `DNS Subject Alternate Names` or `Subject` in that order.
    The primary identity should be the principal. The principal format is issuer specific.

    Example:
    *    SPIFFE format is `spiffe://trust-domain/path`
    *    Google account format is `https://accounts.google.com/{userid}`
    """

    certificate: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )
    """
    The X.509 certificate used to authenticate the identify of this peer.
    When present, the certificate contents are encoded in URL and PEM format.
    """


default_message_pool.register_message(
    "envoy.service.auth.v2", "AttributeContext.Peer", AttributeContextPeer
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AttributeContextRequest(betterproto2.Message):
    """
    Represents a network request, such as an HTTP request.
    """

    time: "datetime.datetime | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Timestamp,
        optional=True,
    )
    """
    The timestamp when the proxy receives the first byte of the request.
    """

    http: "AttributeContextHttpRequest | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Represents an HTTP request or an HTTP-like request.
    """


default_message_pool.register_message(
    "envoy.service.auth.v2", "AttributeContext.Request", AttributeContextRequest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CheckRequest(betterproto2.Message):
    attributes: "AttributeContext | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The request attributes.
    """


default_message_pool.register_message(
    "envoy.service.auth.v2", "CheckRequest", CheckRequest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CheckResponse(betterproto2.Message):
    """
    Intended for gRPC and Network Authorization servers `only`.

    Oneofs:
        - http_response: An message that contains HTTP response attributes. This message is
            used when the authorization service needs to send custom responses to the
            downstream client or, to modify/add request headers being dispatched to the upstream.
    """

    status: "____google__rpc__.Status | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Status `OK` allows the request. Any other status indicates the request should be denied.
    """

    denied_response: "DeniedHttpResponse | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="http_response"
    )
    """
    Supplies http attributes for a denied response.
    """

    ok_response: "OkHttpResponse | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="http_response"
    )
    """
    Supplies http attributes for an ok response.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.service.auth.v2", "CheckResponse", CheckResponse
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DeniedHttpResponse(betterproto2.Message):
    """
    HTTP attributes for a denied response.
    """

    status: "___type__.HttpStatus | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    This field allows the authorization service to send a HTTP response status
    code to the downstream client other than 403 (Forbidden).
    """

    headers: "list[___api__v2__core__.HeaderValueOption]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    This field allows the authorization service to send HTTP response headers
    to the downstream client. Note that the `append` field in `HeaderValueOption` defaults to
    false when used in this message.
    """

    body: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    This field allows the authorization service to send a response body data
    to the downstream client.
    """


default_message_pool.register_message(
    "envoy.service.auth.v2", "DeniedHttpResponse", DeniedHttpResponse
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class OkHttpResponse(betterproto2.Message):
    """
    HTTP attributes for an ok response.
    """

    headers: "list[___api__v2__core__.HeaderValueOption]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    HTTP entity headers in addition to the original request headers. This allows the authorization
    service to append, to add or to override headers from the original request before
    dispatching it to the upstream. Note that the `append` field in `HeaderValueOption` defaults to
    false when used in this message. By setting the `append` field to `true`,
    the filter will append the correspondent header value to the matched request header.
    By leaving `append` as false, the filter will either add a new header, or override an existing
    one if there is a match.
    """


default_message_pool.register_message(
    "envoy.service.auth.v2", "OkHttpResponse", OkHttpResponse
)


class AuthorizationSyncStub:
    """
    [#protodoc-title: Authorization Service ]

    The authorization service request messages used by external authorization :ref:`network filter
    <config_network_filters_ext_authz>` and :ref:`HTTP filter <config_http_filters_ext_authz>`.

    A generic interface for performing authorization check on incoming
    requests to a networked service.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def check(self, message: "CheckRequest") -> "CheckResponse":
        """
        Performs authorization check based on the attributes associated with the
        incoming request, and returns status `OK` or not `OK`.
        """

        return self._channel.unary_unary(
            "/envoy.service.auth.v2.Authorization/Check",
            CheckRequest.SerializeToString,
            CheckResponse.FromString,
        )(message)


class AuthorizationAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: Authorization Service ]

    The authorization service request messages used by external authorization :ref:`network filter
    <config_network_filters_ext_authz>` and :ref:`HTTP filter <config_http_filters_ext_authz>`.

    A generic interface for performing authorization check on incoming
    requests to a networked service.
    """

    async def check(
        self,
        message: "CheckRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "CheckResponse":
        """
        Performs authorization check based on the attributes associated with the
        incoming request, and returns status `OK` or not `OK`.
        """

        return await self._unary_unary(
            "/envoy.service.auth.v2.Authorization/Check",
            message,
            CheckResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from .....google import protobuf as ____google__protobuf__
from .....google import rpc as ____google__rpc__
from .... import type as ___type__
from ....api.v2 import core as ___api__v2__core__


class AuthorizationBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: Authorization Service ]

    The authorization service request messages used by external authorization :ref:`network filter
    <config_network_filters_ext_authz>` and :ref:`HTTP filter <config_http_filters_ext_authz>`.

    A generic interface for performing authorization check on incoming
    requests to a networked service.
    """

    async def check(self, message: "CheckRequest") -> "CheckResponse":
        """
        Performs authorization check based on the attributes associated with the
        incoming request, and returns status `OK` or not `OK`.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_check(
        self, stream: "grpclib.server.Stream[CheckRequest, CheckResponse]"
    ) -> None:
        request = await stream.recv_message()
        assert request is not None
        response = await self.check(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.auth.v2.Authorization/Check": grpclib.const.Handler(
                self.__rpc_check,
                grpclib.const.Cardinality.UNARY_UNARY,
                CheckRequest,
                CheckResponse,
            ),
        }
