# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/discovery/v2/ads.proto, envoy/service/discovery/v2/hds.proto, envoy/service/discovery/v2/rtds.proto, envoy/service/discovery/v2/sds.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "AdsDummy",
    "AggregatedDiscoveryServiceAsyncStub",
    "AggregatedDiscoveryServiceBase",
    "AggregatedDiscoveryServiceSyncStub",
    "Capability",
    "CapabilityProtocol",
    "ClusterHealthCheck",
    "EndpointHealth",
    "EndpointHealthResponse",
    "HealthCheckRequest",
    "HealthCheckRequestOrEndpointHealthResponse",
    "HealthCheckSpecifier",
    "HealthDiscoveryServiceAsyncStub",
    "HealthDiscoveryServiceBase",
    "HealthDiscoveryServiceSyncStub",
    "LocalityEndpoints",
    "RtdsDummy",
    "Runtime",
    "RuntimeDiscoveryServiceAsyncStub",
    "RuntimeDiscoveryServiceBase",
    "RuntimeDiscoveryServiceSyncStub",
    "SdsDummy",
    "SecretDiscoveryServiceAsyncStub",
    "SecretDiscoveryServiceBase",
    "SecretDiscoveryServiceSyncStub",
)

import datetime
import typing
from collections.abc import AsyncIterable, AsyncIterator, Iterable, Iterator
from typing import TYPE_CHECKING

import betterproto2
import grpc
import grpclib
import pydantic
from betterproto2 import grpclib as betterproto2_grpclib
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpclib.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class CapabilityProtocol(betterproto2.Enum):
    """
    Different Envoy instances may have different capabilities (e.g. Redis)
    and/or have ports enabled for different protocols.
    """

    HTTP = 0

    TCP = 1

    REDIS = 2


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221
    """

    pass


default_message_pool.register_message(
    "envoy.service.discovery.v2", "AdsDummy", AdsDummy
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Capability(betterproto2.Message):
    """
    Defines supported protocols etc, so the management server can assign proper
    endpoints to healthcheck.
    """

    health_check_protocols: "list[CapabilityProtocol]" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.discovery.v2", "Capability", Capability
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterHealthCheck(betterproto2.Message):
    """
    The cluster name and locality is provided to Envoy for the endpoints that it
    health checks to support statistics reporting, logging and debugging by the
    Envoy instance (outside of HDS). For maximum usefulness, it should match the
    same cluster structure as that provided by EDS.
    """

    cluster_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    health_checks: "list[___api__v2__core__.HealthCheck]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )

    locality_endpoints: "list[LocalityEndpoints]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.discovery.v2", "ClusterHealthCheck", ClusterHealthCheck
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class EndpointHealth(betterproto2.Message):
    endpoint: "___api__v2__endpoint__.Endpoint | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    health_status: "___api__v2__core__.HealthStatus" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ___api__v2__core__.HealthStatus(0),
    )


default_message_pool.register_message(
    "envoy.service.discovery.v2", "EndpointHealth", EndpointHealth
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class EndpointHealthResponse(betterproto2.Message):
    endpoints_health: "list[EndpointHealth]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.discovery.v2", "EndpointHealthResponse", EndpointHealthResponse
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HealthCheckRequest(betterproto2.Message):
    node: "___api__v2__core__.Node | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    capability: "Capability | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "envoy.service.discovery.v2", "HealthCheckRequest", HealthCheckRequest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HealthCheckRequestOrEndpointHealthResponse(betterproto2.Message):
    """


    Oneofs:
        - request_type:
    """

    health_check_request: "HealthCheckRequest | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="request_type"
    )

    endpoint_health_response: "EndpointHealthResponse | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="request_type"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.service.discovery.v2",
    "HealthCheckRequestOrEndpointHealthResponse",
    HealthCheckRequestOrEndpointHealthResponse,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HealthCheckSpecifier(betterproto2.Message):
    cluster_health_checks: "list[ClusterHealthCheck]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )

    interval: "datetime.timedelta | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The default is 1 second.
    """


default_message_pool.register_message(
    "envoy.service.discovery.v2", "HealthCheckSpecifier", HealthCheckSpecifier
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class LocalityEndpoints(betterproto2.Message):
    locality: "___api__v2__core__.Locality | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    endpoints: "list[___api__v2__endpoint__.Endpoint]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.discovery.v2", "LocalityEndpoints", LocalityEndpoints
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RtdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221
    """

    pass


default_message_pool.register_message(
    "envoy.service.discovery.v2", "RtdsDummy", RtdsDummy
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Runtime(betterproto2.Message):
    """
    RTDS resource type. This describes a layer in the runtime virtual filesystem.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Runtime resource name. This makes the Runtime a self-describing xDS
    resource.
    """

    layer: "____google__protobuf__.Struct | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("envoy.service.discovery.v2", "Runtime", Runtime)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221
    """

    pass


default_message_pool.register_message(
    "envoy.service.discovery.v2", "SdsDummy", SdsDummy
)


class AggregatedDiscoveryServiceSyncStub:
    """
    [#protodoc-title: Aggregated Discovery Service (ADS)]

    Discovery services for endpoints, clusters, routes,
    and listeners are retained in the package `envoy.api.v2` for backwards
    compatibility with existing management servers. New development in discovery
    services should proceed in the package `envoy.service.discovery.v2`.

    See https://github.com/envoyproxy/envoy-api#apis for a description of the role of
    ADS and how it is intended to be used by a management server. ADS requests
    have the same structure as their singleton xDS counterparts, but can
    multiplex many resource types on a single stream. The type_url in the
    DiscoveryRequest/DiscoveryResponse provides sufficient information to recover
    the multiplexed singleton APIs at the Envoy instance and management server.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_aggregated_resources(
        self, messages: "Iterable[___api__v2__.DiscoveryRequest]"
    ) -> "Iterator[___api__v2__.DiscoveryResponse]":
        """
        This is a gRPC-only API.
        """

        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.AggregatedDiscoveryService/StreamAggregatedResources",
            ___api__v2__.DiscoveryRequest.SerializeToString,
            ___api__v2__.DiscoveryResponse.FromString,
        )(iter(messages))

    def delta_aggregated_resources(
        self, messages: "Iterable[___api__v2__.DeltaDiscoveryRequest]"
    ) -> "Iterator[___api__v2__.DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.AggregatedDiscoveryService/DeltaAggregatedResources",
            ___api__v2__.DeltaDiscoveryRequest.SerializeToString,
            ___api__v2__.DeltaDiscoveryResponse.FromString,
        )(iter(messages))


class AggregatedDiscoveryServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: Aggregated Discovery Service (ADS)]

    Discovery services for endpoints, clusters, routes,
    and listeners are retained in the package `envoy.api.v2` for backwards
    compatibility with existing management servers. New development in discovery
    services should proceed in the package `envoy.service.discovery.v2`.

    See https://github.com/envoyproxy/envoy-api#apis for a description of the role of
    ADS and how it is intended to be used by a management server. ADS requests
    have the same structure as their singleton xDS counterparts, but can
    multiplex many resource types on a single stream. The type_url in the
    DiscoveryRequest/DiscoveryResponse provides sufficient information to recover
    the multiplexed singleton APIs at the Envoy instance and management server.
    """

    async def stream_aggregated_resources(
        self,
        messages: "AsyncIterable[___api__v2__.DiscoveryRequest] | Iterable[___api__v2__.DiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[___api__v2__.DiscoveryResponse]":
        """
        This is a gRPC-only API.
        """

        async for response in self._stream_stream(
            "/envoy.service.discovery.v2.AggregatedDiscoveryService/StreamAggregatedResources",
            messages,
            ___api__v2__.DiscoveryRequest,
            ___api__v2__.DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delta_aggregated_resources(
        self,
        messages: "AsyncIterable[___api__v2__.DeltaDiscoveryRequest] | Iterable[___api__v2__.DeltaDiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[___api__v2__.DeltaDiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.service.discovery.v2.AggregatedDiscoveryService/DeltaAggregatedResources",
            messages,
            ___api__v2__.DeltaDiscoveryRequest,
            ___api__v2__.DeltaDiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class HealthDiscoveryServiceSyncStub:
    """
    [#protodoc-title: Health Discovery Service (HDS)]

    HDS is Health Discovery Service. It compliments Envoy’s health checking
    service by designating this Envoy to be a healthchecker for a subset of hosts
    in the cluster. The status of these health checks will be reported to the
    management server, where it can be aggregated etc and redistributed back to
    Envoy through EDS.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_health_check(
        self, messages: "Iterable[HealthCheckRequestOrEndpointHealthResponse]"
    ) -> "Iterator[HealthCheckSpecifier]":
        """
        1. Envoy starts up and if its can_healthcheck option in the static
           bootstrap config is enabled, sends HealthCheckRequest to the management
           server. It supplies its capabilities (which protocol it can health check
           with, what zone it resides in, etc.).
        2. In response to (1), the management server designates this Envoy as a
           healthchecker to health check a subset of all upstream hosts for a given
           cluster (for example upstream Host 1 and Host 2). It streams
           HealthCheckSpecifier messages with cluster related configuration for all
           clusters this Envoy is designated to health check. Subsequent
           HealthCheckSpecifier message will be sent on changes to:
           a. Endpoints to health checks
           b. Per cluster configuration change
        3. Envoy creates a health probe based on the HealthCheck config and sends
           it to endpoint(ip:port) of Host 1 and 2. Based on the HealthCheck
           configuration Envoy waits upon the arrival of the probe response and
           looks at the content of the response to decide whether the endpoint is
           healthy or not. If a response hasn't been received within the timeout
           interval, the endpoint health status is considered TIMEOUT.
        4. Envoy reports results back in an EndpointHealthResponse message.
           Envoy streams responses as often as the interval configured by the
           management server in HealthCheckSpecifier.
        5. The management Server collects health statuses for all endpoints in the
           cluster (for all clusters) and uses this information to construct
           EndpointDiscoveryResponse messages.
        6. Once Envoy has a list of upstream endpoints to send traffic to, it load
           balances traffic to them without additional health checking. It may
           use inline healthcheck (i.e. consider endpoint UNHEALTHY if connection
           failed to a particular endpoint to account for health status propagation
           delay between HDS and EDS).
        By default, can_healthcheck is true. If can_healthcheck is false, Cluster
        configuration may not contain HealthCheck message.
        TODO(htuch): How is can_healthcheck communicated to CDS to ensure the above
        invariant?
        TODO(htuch): Add @amb67's diagram.
        """

        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.HealthDiscoveryService/StreamHealthCheck",
            HealthCheckRequestOrEndpointHealthResponse.SerializeToString,
            HealthCheckSpecifier.FromString,
        )(iter(messages))

    def fetch_health_check(
        self, message: "HealthCheckRequestOrEndpointHealthResponse"
    ) -> "HealthCheckSpecifier":
        """
        TODO(htuch): Unlike the gRPC version, there is no stream-based binding of
        request/response. Should we add an identifier to the HealthCheckSpecifier
        to bind with the response?
        """

        return self._channel.unary_unary(
            "/envoy.service.discovery.v2.HealthDiscoveryService/FetchHealthCheck",
            HealthCheckRequestOrEndpointHealthResponse.SerializeToString,
            HealthCheckSpecifier.FromString,
        )(message)


class HealthDiscoveryServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: Health Discovery Service (HDS)]

    HDS is Health Discovery Service. It compliments Envoy’s health checking
    service by designating this Envoy to be a healthchecker for a subset of hosts
    in the cluster. The status of these health checks will be reported to the
    management server, where it can be aggregated etc and redistributed back to
    Envoy through EDS.
    """

    async def stream_health_check(
        self,
        messages: "AsyncIterable[HealthCheckRequestOrEndpointHealthResponse] | Iterable[HealthCheckRequestOrEndpointHealthResponse]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[HealthCheckSpecifier]":
        """
        1. Envoy starts up and if its can_healthcheck option in the static
           bootstrap config is enabled, sends HealthCheckRequest to the management
           server. It supplies its capabilities (which protocol it can health check
           with, what zone it resides in, etc.).
        2. In response to (1), the management server designates this Envoy as a
           healthchecker to health check a subset of all upstream hosts for a given
           cluster (for example upstream Host 1 and Host 2). It streams
           HealthCheckSpecifier messages with cluster related configuration for all
           clusters this Envoy is designated to health check. Subsequent
           HealthCheckSpecifier message will be sent on changes to:
           a. Endpoints to health checks
           b. Per cluster configuration change
        3. Envoy creates a health probe based on the HealthCheck config and sends
           it to endpoint(ip:port) of Host 1 and 2. Based on the HealthCheck
           configuration Envoy waits upon the arrival of the probe response and
           looks at the content of the response to decide whether the endpoint is
           healthy or not. If a response hasn't been received within the timeout
           interval, the endpoint health status is considered TIMEOUT.
        4. Envoy reports results back in an EndpointHealthResponse message.
           Envoy streams responses as often as the interval configured by the
           management server in HealthCheckSpecifier.
        5. The management Server collects health statuses for all endpoints in the
           cluster (for all clusters) and uses this information to construct
           EndpointDiscoveryResponse messages.
        6. Once Envoy has a list of upstream endpoints to send traffic to, it load
           balances traffic to them without additional health checking. It may
           use inline healthcheck (i.e. consider endpoint UNHEALTHY if connection
           failed to a particular endpoint to account for health status propagation
           delay between HDS and EDS).
        By default, can_healthcheck is true. If can_healthcheck is false, Cluster
        configuration may not contain HealthCheck message.
        TODO(htuch): How is can_healthcheck communicated to CDS to ensure the above
        invariant?
        TODO(htuch): Add @amb67's diagram.
        """

        async for response in self._stream_stream(
            "/envoy.service.discovery.v2.HealthDiscoveryService/StreamHealthCheck",
            messages,
            HealthCheckRequestOrEndpointHealthResponse,
            HealthCheckSpecifier,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def fetch_health_check(
        self,
        message: "HealthCheckRequestOrEndpointHealthResponse",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "HealthCheckSpecifier":
        """
        TODO(htuch): Unlike the gRPC version, there is no stream-based binding of
        request/response. Should we add an identifier to the HealthCheckSpecifier
        to bind with the response?
        """

        return await self._unary_unary(
            "/envoy.service.discovery.v2.HealthDiscoveryService/FetchHealthCheck",
            message,
            HealthCheckSpecifier,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class RuntimeDiscoveryServiceSyncStub:
    """
    [#protodoc-title: Runtime Discovery Service (RTDS)]
    RTDS :ref:`configuration overview <config_runtime_rtds>`

    Discovery service for Runtime resources.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_runtime(
        self, messages: "Iterable[___api__v2__.DiscoveryRequest]"
    ) -> "Iterator[___api__v2__.DiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.RuntimeDiscoveryService/StreamRuntime",
            ___api__v2__.DiscoveryRequest.SerializeToString,
            ___api__v2__.DiscoveryResponse.FromString,
        )(iter(messages))

    def delta_runtime(
        self, messages: "Iterable[___api__v2__.DeltaDiscoveryRequest]"
    ) -> "Iterator[___api__v2__.DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.RuntimeDiscoveryService/DeltaRuntime",
            ___api__v2__.DeltaDiscoveryRequest.SerializeToString,
            ___api__v2__.DeltaDiscoveryResponse.FromString,
        )(iter(messages))

    def fetch_runtime(
        self, message: "___api__v2__.DiscoveryRequest"
    ) -> "___api__v2__.DiscoveryResponse":
        return self._channel.unary_unary(
            "/envoy.service.discovery.v2.RuntimeDiscoveryService/FetchRuntime",
            ___api__v2__.DiscoveryRequest.SerializeToString,
            ___api__v2__.DiscoveryResponse.FromString,
        )(message)


class RuntimeDiscoveryServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: Runtime Discovery Service (RTDS)]
    RTDS :ref:`configuration overview <config_runtime_rtds>`

    Discovery service for Runtime resources.
    """

    async def stream_runtime(
        self,
        messages: "AsyncIterable[___api__v2__.DiscoveryRequest] | Iterable[___api__v2__.DiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[___api__v2__.DiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.service.discovery.v2.RuntimeDiscoveryService/StreamRuntime",
            messages,
            ___api__v2__.DiscoveryRequest,
            ___api__v2__.DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delta_runtime(
        self,
        messages: "AsyncIterable[___api__v2__.DeltaDiscoveryRequest] | Iterable[___api__v2__.DeltaDiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[___api__v2__.DeltaDiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.service.discovery.v2.RuntimeDiscoveryService/DeltaRuntime",
            messages,
            ___api__v2__.DeltaDiscoveryRequest,
            ___api__v2__.DeltaDiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def fetch_runtime(
        self,
        message: "___api__v2__.DiscoveryRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "___api__v2__.DiscoveryResponse":
        return await self._unary_unary(
            "/envoy.service.discovery.v2.RuntimeDiscoveryService/FetchRuntime",
            message,
            ___api__v2__.DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class SecretDiscoveryServiceSyncStub:
    """
    [#protodoc-title: Secret Discovery Service (SDS)]
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def delta_secrets(
        self, messages: "Iterable[___api__v2__.DeltaDiscoveryRequest]"
    ) -> "Iterator[___api__v2__.DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.SecretDiscoveryService/DeltaSecrets",
            ___api__v2__.DeltaDiscoveryRequest.SerializeToString,
            ___api__v2__.DeltaDiscoveryResponse.FromString,
        )(iter(messages))

    def stream_secrets(
        self, messages: "Iterable[___api__v2__.DiscoveryRequest]"
    ) -> "Iterator[___api__v2__.DiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.SecretDiscoveryService/StreamSecrets",
            ___api__v2__.DiscoveryRequest.SerializeToString,
            ___api__v2__.DiscoveryResponse.FromString,
        )(iter(messages))

    def fetch_secrets(
        self, message: "___api__v2__.DiscoveryRequest"
    ) -> "___api__v2__.DiscoveryResponse":
        return self._channel.unary_unary(
            "/envoy.service.discovery.v2.SecretDiscoveryService/FetchSecrets",
            ___api__v2__.DiscoveryRequest.SerializeToString,
            ___api__v2__.DiscoveryResponse.FromString,
        )(message)


class SecretDiscoveryServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: Secret Discovery Service (SDS)]
    """

    async def delta_secrets(
        self,
        messages: "AsyncIterable[___api__v2__.DeltaDiscoveryRequest] | Iterable[___api__v2__.DeltaDiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[___api__v2__.DeltaDiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.service.discovery.v2.SecretDiscoveryService/DeltaSecrets",
            messages,
            ___api__v2__.DeltaDiscoveryRequest,
            ___api__v2__.DeltaDiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def stream_secrets(
        self,
        messages: "AsyncIterable[___api__v2__.DiscoveryRequest] | Iterable[___api__v2__.DiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[___api__v2__.DiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.service.discovery.v2.SecretDiscoveryService/StreamSecrets",
            messages,
            ___api__v2__.DiscoveryRequest,
            ___api__v2__.DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def fetch_secrets(
        self,
        message: "___api__v2__.DiscoveryRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "___api__v2__.DiscoveryResponse":
        return await self._unary_unary(
            "/envoy.service.discovery.v2.SecretDiscoveryService/FetchSecrets",
            message,
            ___api__v2__.DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from .....google import protobuf as ____google__protobuf__
from ....api import v2 as ___api__v2__
from ....api.v2 import core as ___api__v2__core__
from ....api.v2 import endpoint as ___api__v2__endpoint__


class AggregatedDiscoveryServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: Aggregated Discovery Service (ADS)]

    Discovery services for endpoints, clusters, routes,
    and listeners are retained in the package `envoy.api.v2` for backwards
    compatibility with existing management servers. New development in discovery
    services should proceed in the package `envoy.service.discovery.v2`.

    See https://github.com/envoyproxy/envoy-api#apis for a description of the role of
    ADS and how it is intended to be used by a management server. ADS requests
    have the same structure as their singleton xDS counterparts, but can
    multiplex many resource types on a single stream. The type_url in the
    DiscoveryRequest/DiscoveryResponse provides sufficient information to recover
    the multiplexed singleton APIs at the Envoy instance and management server.
    """

    async def stream_aggregated_resources(
        self, messages: "AsyncIterator[___api__v2__.DiscoveryRequest]"
    ) -> "AsyncIterator[___api__v2__.DiscoveryResponse]":
        """
        This is a gRPC-only API.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ___api__v2__.DiscoveryResponse()

    async def delta_aggregated_resources(
        self, messages: "AsyncIterator[___api__v2__.DeltaDiscoveryRequest]"
    ) -> "AsyncIterator[___api__v2__.DeltaDiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ___api__v2__.DeltaDiscoveryResponse()

    async def __rpc_stream_aggregated_resources(
        self,
        stream: "grpclib.server.Stream[___api__v2__.DiscoveryRequest, ___api__v2__.DiscoveryResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_aggregated_resources,
            stream,
            request,
        )

    async def __rpc_delta_aggregated_resources(
        self,
        stream: "grpclib.server.Stream[___api__v2__.DeltaDiscoveryRequest, ___api__v2__.DeltaDiscoveryResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.delta_aggregated_resources,
            stream,
            request,
        )

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.discovery.v2.AggregatedDiscoveryService/StreamAggregatedResources": grpclib.const.Handler(
                self.__rpc_stream_aggregated_resources,
                grpclib.const.Cardinality.STREAM_STREAM,
                ___api__v2__.DiscoveryRequest,
                ___api__v2__.DiscoveryResponse,
            ),
            "/envoy.service.discovery.v2.AggregatedDiscoveryService/DeltaAggregatedResources": grpclib.const.Handler(
                self.__rpc_delta_aggregated_resources,
                grpclib.const.Cardinality.STREAM_STREAM,
                ___api__v2__.DeltaDiscoveryRequest,
                ___api__v2__.DeltaDiscoveryResponse,
            ),
        }


class HealthDiscoveryServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: Health Discovery Service (HDS)]

    HDS is Health Discovery Service. It compliments Envoy’s health checking
    service by designating this Envoy to be a healthchecker for a subset of hosts
    in the cluster. The status of these health checks will be reported to the
    management server, where it can be aggregated etc and redistributed back to
    Envoy through EDS.
    """

    async def stream_health_check(
        self, messages: "AsyncIterator[HealthCheckRequestOrEndpointHealthResponse]"
    ) -> "AsyncIterator[HealthCheckSpecifier]":
        """
        1. Envoy starts up and if its can_healthcheck option in the static
           bootstrap config is enabled, sends HealthCheckRequest to the management
           server. It supplies its capabilities (which protocol it can health check
           with, what zone it resides in, etc.).
        2. In response to (1), the management server designates this Envoy as a
           healthchecker to health check a subset of all upstream hosts for a given
           cluster (for example upstream Host 1 and Host 2). It streams
           HealthCheckSpecifier messages with cluster related configuration for all
           clusters this Envoy is designated to health check. Subsequent
           HealthCheckSpecifier message will be sent on changes to:
           a. Endpoints to health checks
           b. Per cluster configuration change
        3. Envoy creates a health probe based on the HealthCheck config and sends
           it to endpoint(ip:port) of Host 1 and 2. Based on the HealthCheck
           configuration Envoy waits upon the arrival of the probe response and
           looks at the content of the response to decide whether the endpoint is
           healthy or not. If a response hasn't been received within the timeout
           interval, the endpoint health status is considered TIMEOUT.
        4. Envoy reports results back in an EndpointHealthResponse message.
           Envoy streams responses as often as the interval configured by the
           management server in HealthCheckSpecifier.
        5. The management Server collects health statuses for all endpoints in the
           cluster (for all clusters) and uses this information to construct
           EndpointDiscoveryResponse messages.
        6. Once Envoy has a list of upstream endpoints to send traffic to, it load
           balances traffic to them without additional health checking. It may
           use inline healthcheck (i.e. consider endpoint UNHEALTHY if connection
           failed to a particular endpoint to account for health status propagation
           delay between HDS and EDS).
        By default, can_healthcheck is true. If can_healthcheck is false, Cluster
        configuration may not contain HealthCheck message.
        TODO(htuch): How is can_healthcheck communicated to CDS to ensure the above
        invariant?
        TODO(htuch): Add @amb67's diagram.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield HealthCheckSpecifier()

    async def fetch_health_check(
        self, message: "HealthCheckRequestOrEndpointHealthResponse"
    ) -> "HealthCheckSpecifier":
        """
        TODO(htuch): Unlike the gRPC version, there is no stream-based binding of
        request/response. Should we add an identifier to the HealthCheckSpecifier
        to bind with the response?
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_health_check(
        self,
        stream: "grpclib.server.Stream[HealthCheckRequestOrEndpointHealthResponse, HealthCheckSpecifier]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_health_check,
            stream,
            request,
        )

    async def __rpc_fetch_health_check(
        self,
        stream: "grpclib.server.Stream[HealthCheckRequestOrEndpointHealthResponse, HealthCheckSpecifier]",
    ) -> None:
        request = await stream.recv_message()
        assert request is not None
        response = await self.fetch_health_check(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.discovery.v2.HealthDiscoveryService/StreamHealthCheck": grpclib.const.Handler(
                self.__rpc_stream_health_check,
                grpclib.const.Cardinality.STREAM_STREAM,
                HealthCheckRequestOrEndpointHealthResponse,
                HealthCheckSpecifier,
            ),
            "/envoy.service.discovery.v2.HealthDiscoveryService/FetchHealthCheck": grpclib.const.Handler(
                self.__rpc_fetch_health_check,
                grpclib.const.Cardinality.UNARY_UNARY,
                HealthCheckRequestOrEndpointHealthResponse,
                HealthCheckSpecifier,
            ),
        }


class RuntimeDiscoveryServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: Runtime Discovery Service (RTDS)]
    RTDS :ref:`configuration overview <config_runtime_rtds>`

    Discovery service for Runtime resources.
    """

    async def stream_runtime(
        self, messages: "AsyncIterator[___api__v2__.DiscoveryRequest]"
    ) -> "AsyncIterator[___api__v2__.DiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ___api__v2__.DiscoveryResponse()

    async def delta_runtime(
        self, messages: "AsyncIterator[___api__v2__.DeltaDiscoveryRequest]"
    ) -> "AsyncIterator[___api__v2__.DeltaDiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ___api__v2__.DeltaDiscoveryResponse()

    async def fetch_runtime(
        self, message: "___api__v2__.DiscoveryRequest"
    ) -> "___api__v2__.DiscoveryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_runtime(
        self,
        stream: "grpclib.server.Stream[___api__v2__.DiscoveryRequest, ___api__v2__.DiscoveryResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_runtime,
            stream,
            request,
        )

    async def __rpc_delta_runtime(
        self,
        stream: "grpclib.server.Stream[___api__v2__.DeltaDiscoveryRequest, ___api__v2__.DeltaDiscoveryResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.delta_runtime,
            stream,
            request,
        )

    async def __rpc_fetch_runtime(
        self,
        stream: "grpclib.server.Stream[___api__v2__.DiscoveryRequest, ___api__v2__.DiscoveryResponse]",
    ) -> None:
        request = await stream.recv_message()
        assert request is not None
        response = await self.fetch_runtime(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.discovery.v2.RuntimeDiscoveryService/StreamRuntime": grpclib.const.Handler(
                self.__rpc_stream_runtime,
                grpclib.const.Cardinality.STREAM_STREAM,
                ___api__v2__.DiscoveryRequest,
                ___api__v2__.DiscoveryResponse,
            ),
            "/envoy.service.discovery.v2.RuntimeDiscoveryService/DeltaRuntime": grpclib.const.Handler(
                self.__rpc_delta_runtime,
                grpclib.const.Cardinality.STREAM_STREAM,
                ___api__v2__.DeltaDiscoveryRequest,
                ___api__v2__.DeltaDiscoveryResponse,
            ),
            "/envoy.service.discovery.v2.RuntimeDiscoveryService/FetchRuntime": grpclib.const.Handler(
                self.__rpc_fetch_runtime,
                grpclib.const.Cardinality.UNARY_UNARY,
                ___api__v2__.DiscoveryRequest,
                ___api__v2__.DiscoveryResponse,
            ),
        }


class SecretDiscoveryServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: Secret Discovery Service (SDS)]
    """

    async def delta_secrets(
        self, messages: "AsyncIterator[___api__v2__.DeltaDiscoveryRequest]"
    ) -> "AsyncIterator[___api__v2__.DeltaDiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ___api__v2__.DeltaDiscoveryResponse()

    async def stream_secrets(
        self, messages: "AsyncIterator[___api__v2__.DiscoveryRequest]"
    ) -> "AsyncIterator[___api__v2__.DiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ___api__v2__.DiscoveryResponse()

    async def fetch_secrets(
        self, message: "___api__v2__.DiscoveryRequest"
    ) -> "___api__v2__.DiscoveryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_delta_secrets(
        self,
        stream: "grpclib.server.Stream[___api__v2__.DeltaDiscoveryRequest, ___api__v2__.DeltaDiscoveryResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.delta_secrets,
            stream,
            request,
        )

    async def __rpc_stream_secrets(
        self,
        stream: "grpclib.server.Stream[___api__v2__.DiscoveryRequest, ___api__v2__.DiscoveryResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_secrets,
            stream,
            request,
        )

    async def __rpc_fetch_secrets(
        self,
        stream: "grpclib.server.Stream[___api__v2__.DiscoveryRequest, ___api__v2__.DiscoveryResponse]",
    ) -> None:
        request = await stream.recv_message()
        assert request is not None
        response = await self.fetch_secrets(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.discovery.v2.SecretDiscoveryService/DeltaSecrets": grpclib.const.Handler(
                self.__rpc_delta_secrets,
                grpclib.const.Cardinality.STREAM_STREAM,
                ___api__v2__.DeltaDiscoveryRequest,
                ___api__v2__.DeltaDiscoveryResponse,
            ),
            "/envoy.service.discovery.v2.SecretDiscoveryService/StreamSecrets": grpclib.const.Handler(
                self.__rpc_stream_secrets,
                grpclib.const.Cardinality.STREAM_STREAM,
                ___api__v2__.DiscoveryRequest,
                ___api__v2__.DiscoveryResponse,
            ),
            "/envoy.service.discovery.v2.SecretDiscoveryService/FetchSecrets": grpclib.const.Handler(
                self.__rpc_fetch_secrets,
                grpclib.const.Cardinality.UNARY_UNARY,
                ___api__v2__.DiscoveryRequest,
                ___api__v2__.DiscoveryResponse,
            ),
        }
