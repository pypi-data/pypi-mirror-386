# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/ratelimit/v2/rls.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "RateLimitRequest",
    "RateLimitResponse",
    "RateLimitResponseCode",
    "RateLimitResponseDescriptorStatus",
    "RateLimitResponseRateLimit",
    "RateLimitResponseRateLimitUnit",
    "RateLimitServiceAsyncStub",
    "RateLimitServiceBase",
    "RateLimitServiceSyncStub",
)

import typing
from typing import TYPE_CHECKING

import betterproto2
import grpc
import grpclib
import pydantic
from betterproto2 import grpclib as betterproto2_grpclib
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpclib.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class RateLimitResponseCode(betterproto2.Enum):
    UNKNOWN = 0
    """
    The response code is not known.
    """

    OK = 1
    """
    The response code to notify that the number of requests are under limit.
    """

    OVER_LIMIT = 2
    """
    The response code to notify that the number of requests are over limit.
    """


class RateLimitResponseRateLimitUnit(betterproto2.Enum):
    UNKNOWN = 0
    """
    The time unit is not known.
    """

    SECOND = 1
    """
    The time unit representing a second.
    """

    MINUTE = 2
    """
    The time unit representing a minute.
    """

    HOUR = 3
    """
    The time unit representing an hour.
    """

    DAY = 4
    """
    The time unit representing a day.
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RateLimitRequest(betterproto2.Message):
    """
    Main message for a rate limit request. The rate limit service is designed to be fully generic
    in the sense that it can operate on arbitrary hierarchical key/value pairs. The loaded
    configuration will parse the request and find the most specific limit to apply. In addition,
    a RateLimitRequest can contain multiple "descriptors" to limit on. When multiple descriptors
    are provided, the server will limit on *ALL* of them and return an OVER_LIMIT response if any
    of them are over limit. This enables more complex application level rate limiting scenarios
    if desired.
    """

    domain: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    All rate limit requests must specify a domain. This enables the configuration to be per
    application without fear of overlap. E.g., "envoy".
    """

    descriptors: "list[___api__v2__ratelimit__.RateLimitDescriptor]" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    All rate limit requests must specify at least one RateLimitDescriptor. Each descriptor is
    processed by the service (see below). If any of the descriptors are over limit, the entire
    request is considered to be over limit.
    """

    hits_addend: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT32)
    )
    """
    Rate limit requests can optionally specify the number of hits a request adds to the matched
    limit. If the value is not set in the message, a request increases the matched limit by 1.
    """


default_message_pool.register_message(
    "envoy.service.ratelimit.v2", "RateLimitRequest", RateLimitRequest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RateLimitResponse(betterproto2.Message):
    """
    A response from a ShouldRateLimit call.
    """

    overall_code: "RateLimitResponseCode" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: RateLimitResponseCode(0)
    )
    """
    The overall response code which takes into account all of the descriptors that were passed
    in the RateLimitRequest message.
    """

    statuses: "list[RateLimitResponseDescriptorStatus]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of DescriptorStatus messages which matches the length of the descriptor list passed
    in the RateLimitRequest. This can be used by the caller to determine which individual
    descriptors failed and/or what the currently configured limits are for all of them.
    """

    headers: "list[___api__v2__core__.HeaderValue]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of headers to add to the response
    """

    request_headers_to_add: "list[___api__v2__core__.HeaderValue]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of headers to add to the request when forwarded
    """


default_message_pool.register_message(
    "envoy.service.ratelimit.v2", "RateLimitResponse", RateLimitResponse
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RateLimitResponseDescriptorStatus(betterproto2.Message):
    code: "RateLimitResponseCode" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: RateLimitResponseCode(0)
    )
    """
    The response code for an individual descriptor.
    """

    current_limit: "RateLimitResponseRateLimit | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The current limit as configured by the server. Useful for debugging, etc.
    """

    limit_remaining: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT32)
    )
    """
    The limit remaining in the current time unit.
    """


default_message_pool.register_message(
    "envoy.service.ratelimit.v2",
    "RateLimitResponse.DescriptorStatus",
    RateLimitResponseDescriptorStatus,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RateLimitResponseRateLimit(betterproto2.Message):
    """
    Defines an actual rate limit in terms of requests per unit of time and the unit itself.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    A name or description of this limit.
    """

    requests_per_unit: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT32)
    )
    """
    The number of requests per unit of time.
    """

    unit: "RateLimitResponseRateLimitUnit" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: RateLimitResponseRateLimitUnit(0),
    )
    """
    The unit of time.
    """


default_message_pool.register_message(
    "envoy.service.ratelimit.v2",
    "RateLimitResponse.RateLimit",
    RateLimitResponseRateLimit,
)


class RateLimitServiceSyncStub:
    """
    [#protodoc-title: Rate Limit Service (RLS)]
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def should_rate_limit(self, message: "RateLimitRequest") -> "RateLimitResponse":
        """
        Determine whether rate limiting should take place.
        """

        return self._channel.unary_unary(
            "/envoy.service.ratelimit.v2.RateLimitService/ShouldRateLimit",
            RateLimitRequest.SerializeToString,
            RateLimitResponse.FromString,
        )(message)


class RateLimitServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: Rate Limit Service (RLS)]
    """

    async def should_rate_limit(
        self,
        message: "RateLimitRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "RateLimitResponse":
        """
        Determine whether rate limiting should take place.
        """

        return await self._unary_unary(
            "/envoy.service.ratelimit.v2.RateLimitService/ShouldRateLimit",
            message,
            RateLimitResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from ....api.v2 import core as ___api__v2__core__
from ....api.v2 import ratelimit as ___api__v2__ratelimit__


class RateLimitServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: Rate Limit Service (RLS)]
    """

    async def should_rate_limit(
        self, message: "RateLimitRequest"
    ) -> "RateLimitResponse":
        """
        Determine whether rate limiting should take place.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_should_rate_limit(
        self, stream: "grpclib.server.Stream[RateLimitRequest, RateLimitResponse]"
    ) -> None:
        request = await stream.recv_message()
        assert request is not None
        response = await self.should_rate_limit(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.ratelimit.v2.RateLimitService/ShouldRateLimit": grpclib.const.Handler(
                self.__rpc_should_rate_limit,
                grpclib.const.Cardinality.UNARY_UNARY,
                RateLimitRequest,
                RateLimitResponse,
            ),
        }
