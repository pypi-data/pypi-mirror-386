# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/extensions/path/match/uri_template/v3/uri_template_match.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = ("UriTemplateMatchConfig",)

import typing

import betterproto2
import pydantic
from pydantic.dataclasses import dataclass

from .......message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UriTemplateMatchConfig(betterproto2.Message):
    """
    [#protodoc-title: Uri Template Match Config]
    [#extension: envoy.path.match.uri_template.uri_template_matcher]

    If specified, the route is a template match rule meaning that the
    ``:path`` header (without the query string) must match the given
    ``path_template`` pattern.

    Path template matching types:

    * ``*`` : Matches a single path component, up to the next path separator: /

    * ``**`` : Matches zero or more path segments. If present, must be the last operator.

    * ``{name} or {name=*}`` :  A named variable matching one path segment up to the next path separator: /.

    * ``{name=videos/*}`` : A named variable matching more than one path segment.
         The path component matching videos/* is captured as the named variable.

    * ``{name=**}`` : A named variable matching zero or more path segments.

    For example:

    * ``/videos/*/*/*.m4s`` would match ``videos/123414/hls/1080p5000_00001.m4s``

    * ``/videos/{file}`` would match ``/videos/1080p5000_00001.m4s``

    * ``/**.mpd`` would match ``/content/123/india/dash/55/manifest.mpd``
    """

    path_template: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )


default_message_pool.register_message(
    "envoy.extensions.path.match.uri_template.v3",
    "UriTemplateMatchConfig",
    UriTemplateMatchConfig,
)
