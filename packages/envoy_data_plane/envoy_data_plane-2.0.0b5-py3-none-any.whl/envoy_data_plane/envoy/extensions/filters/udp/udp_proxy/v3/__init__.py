# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/extensions/filters/udp/udp_proxy/v3/route.proto, envoy/extensions/filters/udp/udp_proxy/v3/udp_proxy.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "Route",
    "UdpProxyConfig",
    "UdpProxyConfigHashPolicy",
    "UdpProxyConfigSessionFilter",
    "UdpProxyConfigUdpAccessLogOptions",
    "UdpProxyConfigUdpTunnelingConfig",
    "UdpProxyConfigUdpTunnelingConfigBufferOptions",
    "UdpProxyConfigUdpTunnelingConfigRetryOptions",
)

import datetime
import typing
import warnings

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .......message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Route(betterproto2.Message):
    """
    [#protodoc-title: UDP proxy route configuration]
    UDP proxy :ref:`configuration overview <config_udp_listener_filters_udp_proxy>`.
    """

    cluster: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Indicates the upstream cluster to which the request should be routed.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.udp.udp_proxy.v3", "Route", Route
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UdpProxyConfig(betterproto2.Message):
    """
    [#protodoc-title: UDP proxy]
    UDP proxy :ref:`configuration overview <config_udp_listener_filters_udp_proxy>`.
    [#extension: envoy.filters.udp_listener.udp_proxy]

    Configuration for the UDP proxy filter.
    [#next-free-field: 14]

    Oneofs:
        - route_specifier:
    """

    stat_prefix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The stat prefix used when emitting UDP proxy filter stats.
    """

    cluster: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="route_specifier"
    )
    """
    The upstream cluster to connect to.
    This field is deprecated in favor of
    :ref:`matcher <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.matcher>`.
    """

    matcher: "______xds__type__matcher__v3__.Matcher | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="route_specifier"
    )
    """
    The match tree to use when resolving route actions for incoming requests.
    See :ref:`Routing <config_udp_listener_filters_udp_proxy_routing>` for more information.
    """

    idle_timeout: "datetime.timedelta | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.Duration,
        optional=True,
    )
    """
    The idle timeout for sessions. Idle is defined as no datagrams between received or sent by
    the session. The default if not specified is 1 minute.
    """

    use_original_src_ip: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)
    """
    Use the remote downstream IP address as the sender IP address when sending packets to upstream hosts.
    This option requires Envoy to be run with the ``CAP_NET_ADMIN`` capability on Linux.
    And the IPv6 stack must be enabled on Linux kernel.
    This option does not preserve the remote downstream port.
    If this option is enabled, the IP address of sent datagrams will be changed to the remote downstream IP address.
    This means that Envoy will not receive packets that are sent by upstream hosts because the upstream hosts
    will send the packets with the remote downstream IP address as the destination. All packets will be routed
    to the remote downstream directly if there are route rules on the upstream host side.
    There are two options to return the packets back to the remote downstream.
    The first one is to use DSR (Direct Server Return).
    The other one is to configure routing rules on the upstream hosts to forward
    all packets back to Envoy and configure iptables rules on the host running Envoy to
    forward all packets from upstream hosts to the Envoy process so that Envoy can forward the packets to the downstream.
    If the platform does not support this option, Envoy will raise a configuration error.
    """

    hash_policies: "list[UdpProxyConfigHashPolicy]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional configuration for UDP proxy hash policies. If hash_policies is not set, the hash-based
    load balancing algorithms will select a host randomly. Currently the number of hash policies is
    limited to 1.
    """

    upstream_socket_config: "_____config__core__v3__.UdpSocketConfig | None" = (
        betterproto2.field(6, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    UDP socket configuration for upstream sockets. The default for
    :ref:`prefer_gro <envoy_v3_api_field_config.core.v3.UdpSocketConfig.prefer_gro>` is true for upstream
    sockets as the assumption is datagrams will be received from a single source.
    """

    use_per_packet_load_balancing: "bool" = betterproto2.field(
        7, betterproto2.TYPE_BOOL
    )
    """
    Perform per packet load balancing (upstream host selection) on each received data chunk.
    The default if not specified is false, that means each data chunk is forwarded
    to upstream host selected on first chunk receival for that "session" (identified by source IP/port and local IP/port).
    Only one of use_per_packet_load_balancing or session_filters can be used.
    """

    access_log: "list[_____config__accesslog__v3__.AccessLog]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Configuration for session access logs emitted by the UDP proxy. Note that certain UDP specific data is emitted as :ref:`Dynamic Metadata <config_access_log_format_dynamic_metadata>`.
    """

    proxy_access_log: "list[_____config__accesslog__v3__.AccessLog]" = (
        betterproto2.field(10, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Configuration for proxy access logs emitted by the UDP proxy. Note that certain UDP specific data is emitted as :ref:`Dynamic Metadata <config_access_log_format_dynamic_metadata>`.
    """

    session_filters: "list[UdpProxyConfigSessionFilter]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional session filters that will run for each UDP session.
    Only one of use_per_packet_load_balancing or session_filters can be used.
    [#extension-category: envoy.filters.udp.session]
    """

    tunneling_config: "UdpProxyConfigUdpTunnelingConfig | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If set, this configures UDP tunneling. See `Proxying UDP in HTTP <https://www.rfc-editor.org/rfc/rfc9298.html>`_.
    More information can be found in the UDP Proxy and HTTP upgrade documentation.
    """

    access_log_options: "UdpProxyConfigUdpAccessLogOptions | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional access log options for UDP Proxy.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("cluster"):
            warnings.warn("UdpProxyConfig.cluster is deprecated", DeprecationWarning)

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.filters.udp.udp_proxy.v3", "UdpProxyConfig", UdpProxyConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UdpProxyConfigHashPolicy(betterproto2.Message):
    """
    Specifies the UDP hash policy.
    The packets can be routed by hash policy.

    Oneofs:
        - policy_specifier:
    """

    source_ip: "bool | None" = betterproto2.field(
        1, betterproto2.TYPE_BOOL, optional=True, group="policy_specifier"
    )
    """
    The source IP will be used to compute the hash used by hash-based load balancing algorithms.
    """

    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="policy_specifier"
    )
    """
    A given key will be used to compute the hash used by hash-based load balancing algorithms.
    In certain cases there is a need to direct different UDP streams jointly towards the selected set of endpoints.
    A possible use-case is VoIP telephony, where media (RTP) and its corresponding control (RTCP) belong to the same logical session,
    although they travel in separate streams. To ensure that these pair of streams are load-balanced on session level
    (instead of individual stream level), dynamically created listeners can use the same hash key for each stream in the session.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.filters.udp.udp_proxy.v3",
    "UdpProxyConfig.HashPolicy",
    UdpProxyConfigHashPolicy,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UdpProxyConfigSessionFilter(betterproto2.Message):
    """
    Configuration for UDP session filters.

    Oneofs:
        - config_type:
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the filter configuration.
    """

    typed_config: "______google__protobuf__.Any | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="config_type"
    )
    """
    Filter specific configuration which depends on the filter being
    instantiated. See the supported filters for further documentation.
    """

    config_discovery: "_____config__core__v3__.ExtensionConfigSource | None" = (
        betterproto2.field(
            3, betterproto2.TYPE_MESSAGE, optional=True, group="config_type"
        )
    )
    """
    Configuration source specifier for an extension configuration discovery
    service. In case of a failure and without the default configuration, the
    UDP session will be removed.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.filters.udp.udp_proxy.v3",
    "UdpProxyConfig.SessionFilter",
    UdpProxyConfigSessionFilter,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UdpProxyConfigUdpAccessLogOptions(betterproto2.Message):
    access_log_flush_interval: "datetime.timedelta | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.Duration,
        optional=True,
    )
    """
    The interval to flush access log. The UDP proxy will flush only one access log when the session
    is ended by default. If this field is set, the UDP proxy will flush access log periodically with
    the specified interval.
    This field does not require on-tunnel-connected access logging enabled, and the other way around.
    The interval must be at least 1ms.
    """

    flush_access_log_on_tunnel_connected: "bool" = betterproto2.field(
        2, betterproto2.TYPE_BOOL
    )
    """
    If set to true and UDP tunneling is configured, access log will be flushed when the UDP proxy has successfully
    established a connection tunnel with the upstream. If the connection failed, the access log will not be flushed.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.udp.udp_proxy.v3",
    "UdpProxyConfig.UdpAccessLogOptions",
    UdpProxyConfigUdpAccessLogOptions,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UdpProxyConfigUdpTunnelingConfig(betterproto2.Message):
    """
    Configuration for tunneling UDP over other transports or application layers.
    Tunneling is currently supported over HTTP/2.
    [#next-free-field: 12]
    """

    proxy_host: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The hostname to send in the synthesized CONNECT headers to the upstream proxy.
    This field evaluates command operators if set, otherwise returns hostname as is.

    Example: dynamically set hostname using filter state

    .. code-block:: yaml

       tunneling_config:
         proxy_host: "%FILTER_STATE(proxy.host.key:PLAIN)%"
    """

    proxy_port: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Optional port value to add to the HTTP request URI.
    This value can be overridden per-session by setting the required port value for
    the filter state key ``udp.connect.proxy_port``.
    """

    target_host: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    The target host to send in the synthesized CONNECT headers to the upstream proxy.
    This field evaluates command operators if set, otherwise returns hostname as is.

    Example: dynamically set target host using filter state

    .. code-block:: yaml

       tunneling_config:
         target_host: "%FILTER_STATE(target.host.key:PLAIN)%"
    """

    default_target_port: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(4, betterproto2.TYPE_UINT32)
    )
    """
    The default target port to send in the CONNECT headers to the upstream proxy.
    This value can be overridden per-session by setting the required port value for
    the filter state key ``udp.connect.target_port``.
    """

    use_post: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    Use POST method instead of CONNECT method to tunnel the UDP stream.

    .. note::
      If use_post is set, the upstream stream does not comply with the connect-udp RFC, and
      instead it will be a POST request. the path used in the headers will be set from the
      post_path field, and the headers will not contain the target host and target port, as
      required by the connect-udp protocol. This flag should be used carefully.
    """

    post_path: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        6, betterproto2.TYPE_STRING
    )
    """
    The path used with POST method. Default path is ``/``. If post path is specified and
    use_post field isn't true, it will be rejected.
    """

    retry_options: "UdpProxyConfigUdpTunnelingConfigRetryOptions | None" = (
        betterproto2.field(7, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Optional retry options, in case connecting to the upstream failed.
    """

    headers_to_add: "list[_____config__core__v3__.HeaderValueOption]" = (
        betterproto2.field(8, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Additional request headers to upstream proxy. Neither ``:-prefixed`` pseudo-headers
    nor the Host: header can be overridden. Values of the added headers evaluates command
    operators if they are set in the value template.

    Example: dynamically set a header with the local port

    .. code-block:: yaml

       headers_to_add:
       - header:
           key: original_dst_port
           value: "%DOWNSTREAM_LOCAL_PORT%"
    """

    buffer_options: "UdpProxyConfigUdpTunnelingConfigBufferOptions | None" = (
        betterproto2.field(9, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    If configured, the filter will buffer datagrams in case that it is waiting for the upstream to be
    ready, whether if it is during the connection process or due to upstream buffer watermarks.
    If this field is not configured, there will be no buffering and downstream datagrams that arrive
    while the upstream is not ready will be dropped. In case this field is set but the options
    are not configured, the default values will be applied as described in the ``BufferOptions``.
    """

    propagate_response_headers: "bool" = betterproto2.field(10, betterproto2.TYPE_BOOL)
    """
    Save the response headers to the downstream info filter state for consumption
    by the session filters. The filter state key is ``envoy.udp_proxy.propagate_response_headers``.
    """

    propagate_response_trailers: "bool" = betterproto2.field(11, betterproto2.TYPE_BOOL)
    """
    Save the response trailers to the downstream info filter state for consumption
    by the session filters. The filter state key is ``envoy.udp_proxy.propagate_response_trailers``.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.udp.udp_proxy.v3",
    "UdpProxyConfig.UdpTunnelingConfig",
    UdpProxyConfigUdpTunnelingConfig,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UdpProxyConfigUdpTunnelingConfigBufferOptions(betterproto2.Message):
    """
    Configuration for UDP datagrams buffering.
    """

    max_buffered_datagrams: "int | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    If set, the filter will only buffer datagrams up to the requested limit, and will drop
    new UDP datagrams if the buffer contains the max_buffered_datagrams value at the time
    of a new datagram arrival. If not set, the default value is 1024 datagrams.
    """

    max_buffered_bytes: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.UInt64Value,
        optional=True,
    )
    """
    If set, the filter will only buffer datagrams up to the requested total buffered bytes limit,
    and will drop new UDP datagrams if the buffer contains the max_buffered_datagrams value
    at the time of a new datagram arrival. If not set, the default value is 16,384 (16KB).
    """


default_message_pool.register_message(
    "envoy.extensions.filters.udp.udp_proxy.v3",
    "UdpProxyConfig.UdpTunnelingConfig.BufferOptions",
    UdpProxyConfigUdpTunnelingConfigBufferOptions,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UdpProxyConfigUdpTunnelingConfigRetryOptions(betterproto2.Message):
    max_connect_attempts: "int | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The maximum number of unsuccessful connection attempts that will be made before giving up.
    If the parameter is not specified, 1 connection attempt will be made.
    """

    backoff_options: "_____config__core__v3__.BackoffStrategy | None" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Sets the backoff strategy. If not set, the retries are performed without backoff.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.udp.udp_proxy.v3",
    "UdpProxyConfig.UdpTunnelingConfig.RetryOptions",
    UdpProxyConfigUdpTunnelingConfigRetryOptions,
)


from .......google import protobuf as ______google__protobuf__
from .......xds.type.matcher import v3 as ______xds__type__matcher__v3__
from ......config.accesslog import v3 as _____config__accesslog__v3__
from ......config.core import v3 as _____config__core__v3__
