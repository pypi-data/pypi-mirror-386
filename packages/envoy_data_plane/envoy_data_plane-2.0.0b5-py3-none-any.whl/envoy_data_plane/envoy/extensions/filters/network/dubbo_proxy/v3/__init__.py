# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/extensions/filters/network/dubbo_proxy/v3/dubbo_proxy.proto, envoy/extensions/filters/network/dubbo_proxy/v3/route.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "Drds",
    "DubboFilter",
    "DubboProxy",
    "MethodMatch",
    "MethodMatchParameterMatchSpecifier",
    "MultipleRouteConfiguration",
    "ProtocolType",
    "Route",
    "RouteAction",
    "RouteConfiguration",
    "RouteMatch",
    "SerializationType",
)

import typing
import warnings

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .......message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class ProtocolType(betterproto2.Enum):
    """
    [#protodoc-title: Dubbo Proxy]
    Dubbo Proxy :ref:`configuration overview <config_network_filters_dubbo_proxy>`.
    [#extension: envoy.filters.network.dubbo_proxy]

    Dubbo Protocol types supported by Envoy.
    """

    Dubbo = 0
    """
    the default protocol.
    """


class SerializationType(betterproto2.Enum):
    """
    Dubbo Serialization types supported by Envoy.
    """

    Hessian2 = 0
    """
    the default serialization protocol.
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Drds(betterproto2.Message):
    config_source: "_____config__core__v3__.ConfigSource | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Configuration source specifier.
    In case of ``api_config_source`` only aggregated ``api_type`` is supported.
    """

    route_config_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The name of the multiple route configuration. This allows to use different multiple route
    configurations. Tells which multiple route configuration should be fetched from the configuration
    source. Leave unspecified is also valid and means the unnamed multiple route configuration.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.dubbo_proxy.v3", "Drds", Drds
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DubboFilter(betterproto2.Message):
    """
    DubboFilter configures a Dubbo filter.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the filter to instantiate. The name must match a supported
    filter.
    """

    config: "______google__protobuf__.Any | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Filter specific configuration which depends on the filter being
    instantiated. See the supported filters for further documentation.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.dubbo_proxy.v3", "DubboFilter", DubboFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DubboProxy(betterproto2.Message):
    """
    [#next-free-field: 8]

    Oneofs:
        - route_specifier:
    """

    stat_prefix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The human readable prefix to use when emitting statistics.
    """

    protocol_type: "ProtocolType" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: ProtocolType(0)
    )
    """
    Configure the protocol used.
    """

    serialization_type: "SerializationType" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: SerializationType(0)
    )
    """
    Configure the serialization protocol used.
    """

    route_config: "list[RouteConfiguration]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The route table for the connection manager is static and is specified in this property.

    .. note::

      This field is deprecated. Please use ``drds`` or ``multiple_route_config`` first.
    """

    drds: "Drds | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="route_specifier"
    )
    """
    Use xDS to fetch the route configuration. It is invalid to define both ``route_config`` and ``drds``.
    """

    multiple_route_config: "MultipleRouteConfiguration | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="route_specifier"
    )

    dubbo_filters: "list[DubboFilter]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of individual Dubbo filters that make up the filter chain for requests made to the
    Dubbo proxy. Order matters as the filters are processed sequentially. For backwards
    compatibility, if no dubbo_filters are specified, a default Dubbo router filter
    (``envoy.filters.dubbo.router``) is used.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("route_config"):
            warnings.warn("DubboProxy.route_config is deprecated", DeprecationWarning)

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.filters.network.dubbo_proxy.v3", "DubboProxy", DubboProxy
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MethodMatch(betterproto2.Message):
    name: "_____type__matcher__v3__.StringMatcher | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The name of the method.
    """

    params_match: "dict[int, MethodMatchParameterMatchSpecifier]" = betterproto2.field(
        2,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_UINT32, betterproto2.TYPE_MESSAGE
        ),
    )
    """
    Method parameter definition.
    The key is the parameter index, starting from 0.
    The value is the parameter matching type.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.dubbo_proxy.v3", "MethodMatch", MethodMatch
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MethodMatchParameterMatchSpecifier(betterproto2.Message):
    """
    The parameter matching type.

    Oneofs:
        - parameter_match_specifier:
    """

    exact_match: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True, group="parameter_match_specifier"
    )
    """
    If specified, header match will be performed based on the value of the header.
    """

    range_match: "_____type__v3__.Int64Range | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="parameter_match_specifier"
    )
    """
    If specified, header match will be performed based on range.
    The rule will match if the request header value is within this range.
    The entire request header value must represent an integer in base 10 notation: consisting
    of an optional plus or minus sign followed by a sequence of digits. The rule will not match
    if the header value does not represent an integer. Match will fail for empty values,
    floating point numbers or if only a subsequence of the header value is an integer.

    Examples:

    * For range [-10,0), route will match for header value -1, but not for 0,
      "somestring", 10.9, "-1somestring"
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.filters.network.dubbo_proxy.v3",
    "MethodMatch.ParameterMatchSpecifier",
    MethodMatchParameterMatchSpecifier,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MultipleRouteConfiguration(betterproto2.Message):
    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the named route configurations. This name is used in asynchronous route discovery.
    """

    route_config: "list[RouteConfiguration]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The route table of the dubbo connection manager.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.dubbo_proxy.v3",
    "MultipleRouteConfiguration",
    MultipleRouteConfiguration,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Route(betterproto2.Message):
    match: "RouteMatch | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Route matching parameters.
    """

    route: "RouteAction | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Route request to some upstream cluster.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.dubbo_proxy.v3", "Route", Route
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RouteAction(betterproto2.Message):
    """


    Oneofs:
        - cluster_specifier:
    """

    cluster: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="cluster_specifier"
    )
    """
    Indicates the upstream cluster to which the request should be routed.
    """

    weighted_clusters: "_____config__route__v3__.WeightedCluster | None" = (
        betterproto2.field(
            2, betterproto2.TYPE_MESSAGE, optional=True, group="cluster_specifier"
        )
    )
    """
    Multiple upstream clusters can be specified for a given route. The
    request is routed to one of the upstream clusters based on weights
    assigned to each cluster.
    Currently ClusterWeight only supports the name and weight fields.
    """

    metadata_match: "_____config__core__v3__.Metadata | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
    the upstream cluster with metadata matching what is set in this field will be considered for
    load balancing. The filter name should be specified as ``envoy.lb``.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.filters.network.dubbo_proxy.v3", "RouteAction", RouteAction
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RouteConfiguration(betterproto2.Message):
    """
    [#protodoc-title: Dubbo Proxy Route Configuration]
    Dubbo Proxy :ref:`configuration overview <config_network_filters_dubbo_proxy>`.

    [#next-free-field: 6]
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the route configuration. Reserved for future use in asynchronous route discovery.
    """

    interface: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The interface name of the service. Wildcard interface are supported in the suffix or prefix form.
    e.g. ``*.methods.add`` will match ``com.dev.methods.add``, ``com.prod.methods.add``, etc.
    ``com.dev.methods.*`` will match ``com.dev.methods.add``, ``com.dev.methods.update``, etc.
    Special wildcard ``*`` matching any interface.

    .. note::

     The wildcard will not match the empty string.
     e.g. ``*.methods.add`` will match ``com.dev.methods.add`` but not ``.methods.add``.
    """

    group: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    Which group does the interface belong to.
    """

    version: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )
    """
    The version number of the interface.
    """

    routes: "list[Route]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of routes that will be matched, in order, against incoming requests. The first route
    that matches will be used.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.dubbo_proxy.v3",
    "RouteConfiguration",
    RouteConfiguration,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RouteMatch(betterproto2.Message):
    method: "MethodMatch | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Method level routing matching.
    """

    headers: "list[_____config__route__v3__.HeaderMatcher]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies a set of headers that the route should match on. The router will check the request’s
    headers against all the specified headers in the route config. A match will happen if all the
    headers in the route are present in the request with the same values (or based on presence if
    the value field is not in the config).
    """


default_message_pool.register_message(
    "envoy.extensions.filters.network.dubbo_proxy.v3", "RouteMatch", RouteMatch
)


from .......google import protobuf as ______google__protobuf__
from ......config.core import v3 as _____config__core__v3__
from ......config.route import v3 as _____config__route__v3__
from ......type import v3 as _____type__v3__
from ......type.matcher import v3 as _____type__matcher__v3__
