# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/core/v3/address.proto, envoy/config/core/v3/backoff.proto, envoy/config/core/v3/base.proto, envoy/config/core/v3/config_source.proto, envoy/config/core/v3/event_service_config.proto, envoy/config/core/v3/extension.proto, envoy/config/core/v3/grpc_method_list.proto, envoy/config/core/v3/grpc_service.proto, envoy/config/core/v3/health_check.proto, envoy/config/core/v3/http_service.proto, envoy/config/core/v3/http_uri.proto, envoy/config/core/v3/protocol.proto, envoy/config/core/v3/proxy_protocol.proto, envoy/config/core/v3/resolver.proto, envoy/config/core/v3/socket_cmsg_headers.proto, envoy/config/core/v3/socket_option.proto, envoy/config/core/v3/substitution_format_string.proto, envoy/config/core/v3/udp_socket_config.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "Address",
    "AggregatedConfigSource",
    "AlternateProtocolsCacheOptions",
    "AlternateProtocolsCacheOptionsAlternateProtocolsCacheEntry",
    "ApiConfigSource",
    "ApiConfigSourceApiType",
    "ApiVersion",
    "AsyncDataSource",
    "BackoffStrategy",
    "BindConfig",
    "BuildVersion",
    "CidrRange",
    "ConfigSource",
    "ControlPlane",
    "DataSource",
    "DnsResolutionConfig",
    "DnsResolverOptions",
    "EnvoyInternalAddress",
    "EventServiceConfig",
    "Extension",
    "ExtensionConfigSource",
    "ExtraSourceAddress",
    "GrpcMethodList",
    "GrpcMethodListService",
    "GrpcProtocolOptions",
    "GrpcService",
    "GrpcServiceEnvoyGrpc",
    "GrpcServiceGoogleGrpc",
    "GrpcServiceGoogleGrpcCallCredentials",
    "GrpcServiceGoogleGrpcCallCredentialsGoogleIamCredentials",
    "GrpcServiceGoogleGrpcCallCredentialsMetadataCredentialsFromPlugin",
    "GrpcServiceGoogleGrpcCallCredentialsServiceAccountJwtAccessCredentials",
    "GrpcServiceGoogleGrpcCallCredentialsStsService",
    "GrpcServiceGoogleGrpcChannelArgs",
    "GrpcServiceGoogleGrpcChannelArgsValue",
    "GrpcServiceGoogleGrpcChannelCredentials",
    "GrpcServiceGoogleGrpcGoogleLocalCredentials",
    "GrpcServiceGoogleGrpcSslCredentials",
    "HeaderMap",
    "HeaderValue",
    "HeaderValueOption",
    "HeaderValueOptionHeaderAppendAction",
    "HealthCheck",
    "HealthCheckCustomHealthCheck",
    "HealthCheckGrpcHealthCheck",
    "HealthCheckHttpHealthCheck",
    "HealthCheckPayload",
    "HealthCheckRedisHealthCheck",
    "HealthCheckTcpHealthCheck",
    "HealthCheckTlsOptions",
    "HealthStatus",
    "HealthStatusSet",
    "Http1ProtocolOptions",
    "Http1ProtocolOptionsHeaderKeyFormat",
    "Http1ProtocolOptionsHeaderKeyFormatProperCaseWords",
    "Http2ProtocolOptions",
    "Http2ProtocolOptionsSettingsParameter",
    "Http3ProtocolOptions",
    "HttpProtocolOptions",
    "HttpProtocolOptionsHeadersWithUnderscoresAction",
    "HttpService",
    "HttpUri",
    "JsonFormatOptions",
    "KeepaliveSettings",
    "KeyValue",
    "KeyValueAppend",
    "KeyValueAppendKeyValueAppendAction",
    "KeyValueMutation",
    "KeyValuePair",
    "Locality",
    "Metadata",
    "Node",
    "PathConfigSource",
    "PerHostConfig",
    "Pipe",
    "ProxyProtocolConfig",
    "ProxyProtocolConfigVersion",
    "ProxyProtocolPassThroughTlVs",
    "ProxyProtocolPassThroughTlVsPassTlVsMatchType",
    "QueryParameter",
    "QuicKeepAliveSettings",
    "QuicProtocolOptions",
    "RateLimitSettings",
    "RemoteDataSource",
    "RequestMethod",
    "RetryPolicy",
    "RetryPolicyRetryHostPredicate",
    "RetryPolicyRetryPriority",
    "RoutingPriority",
    "RuntimeDouble",
    "RuntimeFeatureFlag",
    "RuntimeFractionalPercent",
    "RuntimePercent",
    "RuntimeUInt32",
    "SchemeHeaderTransformation",
    "SelfConfigSource",
    "SocketAddress",
    "SocketAddressProtocol",
    "SocketCmsgHeaders",
    "SocketOption",
    "SocketOptionSocketState",
    "SocketOptionSocketType",
    "SocketOptionSocketTypeDatagram",
    "SocketOptionSocketTypeStream",
    "SocketOptionsOverride",
    "SubstitutionFormatString",
    "TcpKeepalive",
    "TcpProtocolOptions",
    "TlvEntry",
    "TrafficDirection",
    "TransportSocket",
    "TypedExtensionConfig",
    "UdpSocketConfig",
    "UpstreamHttpProtocolOptions",
    "WatchedDirectory",
)

import datetime
import typing
import warnings

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class ApiConfigSourceApiType(betterproto2.Enum):
    """
    APIs may be fetched via either REST or gRPC.
    """

    DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE = 0
    """
    Ideally this would be 'reserved 0' but one can't reserve the default
    value. Instead we throw an exception if this is ever used.
    """

    REST = 1
    """
    REST-JSON v2 API. The `canonical JSON encoding
    <https://developers.google.com/protocol-buffers/docs/proto3#json>`_ for
    the v2 protos is used.
    """

    GRPC = 2
    """
    SotW gRPC service.
    """

    DELTA_GRPC = 3
    """
    Using the delta xDS gRPC service, i.e. DeltaDiscovery{Request,Response}
    rather than Discovery{Request,Response}. Rather than sending Envoy the entire state
    with every update, the xDS server only sends what has changed since the last update.
    """

    AGGREGATED_GRPC = 5
    """
    SotW xDS gRPC with ADS. All resources which resolve to this configuration source will be
    multiplexed on a single connection to an ADS endpoint.
    [#not-implemented-hide:]
    """

    AGGREGATED_DELTA_GRPC = 6
    """
    Delta xDS gRPC with ADS. All resources which resolve to this configuration source will be
    multiplexed on a single connection to an ADS endpoint.
    [#not-implemented-hide:]
    """


class ApiVersion(betterproto2.Enum):
    """
    [#protodoc-title: Configuration sources]

    xDS API and non-xDS services version. This is used to describe both resource and transport
    protocol versions (in distinct configuration fields).
    """

    AUTO = 0
    """
    When not specified, we assume v3; it is the only supported version.
    """

    V2 = 1
    """
    Use xDS v2 API. This is no longer supported.
    """

    V3 = 2
    """
    Use xDS v3 API.
    """


class HeaderValueOptionHeaderAppendAction(betterproto2.Enum):
    """
    Describes the supported actions types for header append action.
    """

    APPEND_IF_EXISTS_OR_ADD = 0
    """
    If the header already exists, this action will result in:

    - Comma-concatenated for predefined inline headers.
    - Duplicate header added in the ``HeaderMap`` for other headers.

    If the header doesn't exist then this will add new header with specified key and value.
    """

    ADD_IF_ABSENT = 1
    """
    This action will add the header if it doesn't already exist. If the header
    already exists then this will be a no-op.
    """

    OVERWRITE_IF_EXISTS_OR_ADD = 2
    """
    This action will overwrite the specified value by discarding any existing values if
    the header already exists. If the header doesn't exist then this will add the header
    with specified key and value.
    """

    OVERWRITE_IF_EXISTS = 3
    """
    This action will overwrite the specified value by discarding any existing values if
    the header already exists. If the header doesn't exist then this will be no-op.
    """


class HealthStatus(betterproto2.Enum):
    """
    [#protodoc-title: Health check]
    * Health checking :ref:`architecture overview <arch_overview_health_checking>`.
    * If health checking is configured for a cluster, additional statistics are emitted. They are
      documented :ref:`here <config_cluster_manager_cluster_stats>`.

    Endpoint health status.
    """

    UNKNOWN = 0
    """
    The health status is not known. This is interpreted by Envoy as ``HEALTHY``.
    """

    HEALTHY = 1
    """
    Healthy.
    """

    UNHEALTHY = 2
    """
    Unhealthy.
    """

    DRAINING = 3
    """
    Connection draining in progress. E.g.,
    `<https://aws.amazon.com/blogs/aws/elb-connection-draining-remove-instances-from-service-with-care/>`_
    or
    `<https://cloud.google.com/compute/docs/load-balancing/enabling-connection-draining>`_.
    This is interpreted by Envoy as ``UNHEALTHY``.
    """

    TIMEOUT = 4
    """
    Health check timed out. This is part of HDS and is interpreted by Envoy as
    ``UNHEALTHY``.
    """

    DEGRADED = 5
    """
    Degraded.
    """


class HttpProtocolOptionsHeadersWithUnderscoresAction(betterproto2.Enum):
    """
    Action to take when Envoy receives client request with header names containing underscore
    characters.
    Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
    as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
    characters.
    """

    ALLOW = 0
    """
    Allow headers with underscores. This is the default behavior.
    """

    REJECT_REQUEST = 1
    """
    Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
    end with the stream reset. The "httpN.requests_rejected_with_underscores_in_headers" counter
    is incremented for each rejected request.
    """

    DROP_HEADER = 2
    """
    Drop the client header with name containing underscores. The header is dropped before the filter chain is
    invoked and as such filters will not see dropped headers. The
    "httpN.dropped_headers_with_underscores" is incremented for each dropped header.
    """


class KeyValueAppendKeyValueAppendAction(betterproto2.Enum):
    """
    Describes the supported actions types for key/value pair append action.
    """

    APPEND_IF_EXISTS_OR_ADD = 0
    """
    If the key already exists, this action will result in the following behavior:

    - Comma-concatenated value if multiple values are not allowed.
    - New value added to the list of values if multiple values are allowed.

    If the key doesn't exist then this will add pair with specified key and value.
    """

    ADD_IF_ABSENT = 1
    """
    This action will add the key/value pair if it doesn't already exist. If the
    key already exists then this will be a no-op.
    """

    OVERWRITE_IF_EXISTS_OR_ADD = 2
    """
    This action will overwrite the specified value by discarding any existing
    values if the key already exists. If the key doesn't exist then this will add
    the pair with specified key and value.
    """

    OVERWRITE_IF_EXISTS = 3
    """
    This action will overwrite the specified value by discarding any existing
    values if the key already exists. If the key doesn't exist then this will
    be no-op.
    """


class ProxyProtocolConfigVersion(betterproto2.Enum):
    V1 = 0
    """
    PROXY protocol version 1. Human readable format.
    """

    V2 = 1
    """
    PROXY protocol version 2. Binary format.
    """


class ProxyProtocolPassThroughTlVsPassTlVsMatchType(betterproto2.Enum):
    INCLUDE_ALL = 0
    """
    Pass all TLVs.
    """

    INCLUDE = 1
    """
    Pass specific TLVs defined in tlv_type.
    """


class RequestMethod(betterproto2.Enum):
    """
    HTTP request method.
    """

    METHOD_UNSPECIFIED = 0

    GET = 1

    HEAD = 2

    POST = 3

    PUT = 4

    DELETE = 5

    CONNECT = 6

    OPTIONS = 7

    TRACE = 8

    PATCH = 9


class RoutingPriority(betterproto2.Enum):
    """
    [#protodoc-title: Common types]

    Envoy supports :ref:`upstream priority routing
    <arch_overview_http_routing_priority>` both at the route and the virtual
    cluster level. The current priority implementation uses different connection
    pool and circuit breaking settings for each priority level. This means that
    even for HTTP/2 requests, two physical connections will be used to an
    upstream host. In the future Envoy will likely support true HTTP/2 priority
    over a single upstream connection.
    """

    DEFAULT = 0

    HIGH = 1


class SocketAddressProtocol(betterproto2.Enum):
    TCP = 0

    UDP = 1


class SocketOptionSocketState(betterproto2.Enum):
    STATE_PREBIND = 0
    """
    Socket options are applied after socket creation but before binding the socket to a port
    """

    STATE_BOUND = 1
    """
    Socket options are applied after binding the socket to a port but before calling listen()
    """

    STATE_LISTENING = 2
    """
    Socket options are applied after calling listen()
    """


class TrafficDirection(betterproto2.Enum):
    """
    Identifies the direction of the traffic relative to the local Envoy.
    """

    UNSPECIFIED = 0
    """
    Default option is unspecified.
    """

    INBOUND = 1
    """
    The transport is used for incoming traffic.
    """

    OUTBOUND = 2
    """
    The transport is used for outgoing traffic.
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Address(betterproto2.Message):
    """
    Addresses specify either a logical or physical address and port, which are
    used to tell Envoy where to bind/listen, connect to upstream and find
    management servers.

    Oneofs:
        - address:
    """

    socket_address: "SocketAddress | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="address"
    )

    pipe: "Pipe | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="address"
    )

    envoy_internal_address: "EnvoyInternalAddress | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="address"
    )
    """
    Specifies a user-space address handled by :ref:`internal listeners
    <envoy_v3_api_field_config.listener.v3.Listener.internal_listener>`.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.config.core.v3", "Address", Address)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AggregatedConfigSource(betterproto2.Message):
    """
    Aggregated Discovery Service (ADS) options. This is currently empty, but when
    set in :ref:`ConfigSource <envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
    specify that ADS is to be used.
    """

    pass


default_message_pool.register_message(
    "envoy.config.core.v3", "AggregatedConfigSource", AggregatedConfigSource
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AlternateProtocolsCacheOptions(betterproto2.Message):
    """
    Configures the alternate protocols cache which tracks alternate protocols that can be used to
    make an HTTP connection to an origin server. See https://tools.ietf.org/html/rfc7838 for
    HTTP Alternative Services and https://datatracker.ietf.org/doc/html/draft-ietf-dnsop-svcb-https-04
    for the "HTTPS" DNS resource record.
    [#next-free-field: 6]
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the cache. Multiple named caches allow independent alternate protocols cache
    configurations to operate within a single Envoy process using different configurations. All
    alternate protocols cache options with the same name *must* be equal in all fields when
    referenced from different configuration components. Configuration will fail to load if this is
    not the case.
    """

    max_entries: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The maximum number of entries that the cache will hold. If not specified defaults to 1024.

    .. note:

      The implementation is approximate and enforced independently on each worker thread, thus
      it is possible for the maximum entries in the cache to go slightly above the configured
      value depending on timing. This is similar to how other circuit breakers work.
    """

    key_value_store_config: "TypedExtensionConfig | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Allows configuring a persistent
    :ref:`key value store <envoy_v3_api_msg_config.common.key_value.v3.KeyValueStoreConfig>` to flush
    alternate protocols entries to disk.
    This function is currently only supported if concurrency is 1
    Cached entries will take precedence over pre-populated entries below.
    """

    prepopulated_entries: "list[AlternateProtocolsCacheOptionsAlternateProtocolsCacheEntry]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Allows pre-populating the cache with entries, as described above.
    """

    canonical_suffixes: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        5, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Optional list of hostnames suffixes for which Alt-Svc entries can be shared. For example, if
    this list contained the value ``.c.example.com``, then an Alt-Svc entry for ``foo.c.example.com``
    could be shared with ``bar.c.example.com`` but would not be shared with ``baz.example.com``. On
    the other hand, if the list contained the value ``.example.com`` then all three hosts could share
    Alt-Svc entries. Each entry must start with ``.``. If a hostname matches multiple suffixes, the
    first listed suffix will be used.

    Since lookup in this list is O(n), it is recommended that the number of suffixes be limited.
    [#not-implemented-hide:]
    """


default_message_pool.register_message(
    "envoy.config.core.v3",
    "AlternateProtocolsCacheOptions",
    AlternateProtocolsCacheOptions,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AlternateProtocolsCacheOptionsAlternateProtocolsCacheEntry(betterproto2.Message):
    """
    Allows pre-populating the cache with HTTP/3 alternate protocols entries with a 7 day lifetime.
    This will cause Envoy to attempt HTTP/3 to those upstreams, even if the upstreams have not
    advertised HTTP/3 support. These entries will be overwritten by alt-svc
    response headers or cached values.
    As with regular cached entries, if the origin response would result in clearing an existing
    alternate protocol cache entry, pre-populated entries will also be cleared.
    Adding a cache entry with hostname=foo.com port=123 is the equivalent of getting
    response headers
    alt-svc: h3=:"123"; ma=86400" in a response to a request to foo.com:123
    """

    hostname: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The host name for the alternate protocol entry.
    """

    port: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32)
    )
    """
    The port for the alternate protocol entry.
    """


default_message_pool.register_message(
    "envoy.config.core.v3",
    "AlternateProtocolsCacheOptions.AlternateProtocolsCacheEntry",
    AlternateProtocolsCacheOptionsAlternateProtocolsCacheEntry,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ApiConfigSource(betterproto2.Message):
    """
    API configuration source. This identifies the API type and cluster that Envoy
    will use to fetch an xDS API.
    [#next-free-field: 10]
    """

    api_type: "ApiConfigSourceApiType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: ApiConfigSourceApiType(0)
    )
    """
    API type (gRPC, REST, delta gRPC)
    """

    transport_api_version: "ApiVersion" = betterproto2.field(
        8, betterproto2.TYPE_ENUM, default_factory=lambda: ApiVersion(0)
    )
    """
    API version for xDS transport protocol. This describes the xDS gRPC/REST
    endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
    """

    cluster_names: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        2, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Cluster names should be used only with REST. If > 1
    cluster is defined, clusters will be cycled through if any kind of failure
    occurs.

    .. note::

     The cluster with name ``cluster_name`` must be statically defined and its
     type must not be ``EDS``.
    """

    grpc_services: "list[GrpcService]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Multiple gRPC services be provided for GRPC. If > 1 cluster is defined,
    services will be cycled through if any kind of failure occurs.
    """

    refresh_delay: "datetime.timedelta | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    For REST APIs, the delay between successive polls.
    """

    request_timeout: "datetime.timedelta | None" = betterproto2.field(
        5,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    For REST APIs, the request timeout. If not set, a default value of 1s will be used.
    """

    rate_limit_settings: "RateLimitSettings | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    For GRPC APIs, the rate limit settings. If present, discovery requests made by Envoy will be
    rate limited.
    """

    set_node_on_first_message_only: "bool" = betterproto2.field(
        7, betterproto2.TYPE_BOOL
    )
    """
    Skip the node identifier in subsequent discovery requests for streaming gRPC config types.
    """

    config_validators: "list[TypedExtensionConfig]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of config validators that will be executed when a new update is
    received from the ApiConfigSource. Note that each validator handles a
    specific xDS service type, and only the validators corresponding to the
    type url (in ``:ref: DiscoveryResponse`` or ``:ref: DeltaDiscoveryResponse``)
    will be invoked.
    If the validator returns false or throws an exception, the config will be rejected by
    the client, and a NACK will be sent.
    [#extension-category: envoy.config.validators]
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "ApiConfigSource", ApiConfigSource
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AsyncDataSource(betterproto2.Message):
    """
    Async data source which support async data fetch.

    Oneofs:
        - specifier:
    """

    local: "DataSource | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="specifier"
    )
    """
    Local async data source.
    """

    remote: "RemoteDataSource | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="specifier"
    )
    """
    Remote async data source.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3", "AsyncDataSource", AsyncDataSource
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class BackoffStrategy(betterproto2.Message):
    """
    [#protodoc-title: Backoff strategy]

    Configuration defining a jittered exponential back off strategy.
    """

    base_interval: "datetime.timedelta | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The base interval to be used for the next back off computation. It should
    be greater than zero and less than or equal to :ref:`max_interval
    <envoy_v3_api_field_config.core.v3.BackoffStrategy.max_interval>`.
    """

    max_interval: "datetime.timedelta | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    Specifies the maximum interval between retries. This parameter is optional,
    but must be greater than or equal to the :ref:`base_interval
    <envoy_v3_api_field_config.core.v3.BackoffStrategy.base_interval>` if set. The default
    is 10 times the :ref:`base_interval
    <envoy_v3_api_field_config.core.v3.BackoffStrategy.base_interval>`.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "BackoffStrategy", BackoffStrategy
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class BindConfig(betterproto2.Message):
    """
    [#next-free-field: 7]
    """

    source_address: "SocketAddress | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The address to bind to when creating a socket.
    """

    freebind: "bool | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    Whether to set the ``IP_FREEBIND`` option when creating the socket. When this
    flag is set to true, allows the :ref:`source_address
    <envoy_v3_api_field_config.core.v3.BindConfig.source_address>` to be an IP address
    that is not configured on the system running Envoy. When this flag is set
    to false, the option ``IP_FREEBIND`` is disabled on the socket. When this
    flag is not set (default), the socket is not modified, i.e. the option is
    neither enabled nor disabled.
    """

    socket_options: "list[SocketOption]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Additional socket options that may not be present in Envoy source code or
    precompiled binaries.
    """

    extra_source_addresses: "list[ExtraSourceAddress]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Extra source addresses appended to the address specified in the ``source_address``
    field. This enables to specify multiple source addresses.
    The source address selection is determined by :ref:`local_address_selector
    <envoy_v3_api_field_config.core.v3.BindConfig.local_address_selector>`.
    """

    additional_source_addresses: "list[SocketAddress]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Deprecated by
    :ref:`extra_source_addresses <envoy_v3_api_field_config.core.v3.BindConfig.extra_source_addresses>`
    """

    local_address_selector: "TypedExtensionConfig | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Custom local address selector to override the default (i.e.
    :ref:`DefaultLocalAddressSelector
    <envoy_v3_api_msg_config.upstream.local_address_selector.v3.DefaultLocalAddressSelector>`).
    [#extension-category: envoy.upstream.local_address_selector]
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("additional_source_addresses"):
            warnings.warn(
                "BindConfig.additional_source_addresses is deprecated",
                DeprecationWarning,
            )


default_message_pool.register_message("envoy.config.core.v3", "BindConfig", BindConfig)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class BuildVersion(betterproto2.Message):
    """
    BuildVersion combines SemVer version of extension with free-form build information
    (i.e. 'alpha', 'private-build') as a set of strings.
    """

    version: "___type__v3__.SemanticVersion | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    SemVer version of extension.
    """

    metadata: "____google__protobuf__.Struct | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Free-form build information.
    Envoy defines several well known keys in the source/common/version/version.h file
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "BuildVersion", BuildVersion
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CidrRange(betterproto2.Message):
    """
    CidrRange specifies an IP Address and a prefix length to construct
    the subnet mask for a `CIDR <https://tools.ietf.org/html/rfc4632>`_ range.
    """

    address_prefix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``.
    """

    prefix_len: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Length of prefix, e.g. 0, 32. Defaults to 0 when unset.
    """


default_message_pool.register_message("envoy.config.core.v3", "CidrRange", CidrRange)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ConfigSource(betterproto2.Message):
    """
    Configuration for :ref:`listeners <config_listeners>`, :ref:`clusters
    <config_cluster_manager>`, :ref:`routes
    <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`, :ref:`endpoints
    <arch_overview_service_discovery>` etc. may either be sourced from the
    filesystem or from an xDS API source. Filesystem configs are watched with
    inotify for updates.
    [#next-free-field: 9]

    Oneofs:
        - config_source_specifier:
    """

    authorities: "list[____xds__core__v3__.Authority]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Authorities that this config source may be used for. An authority specified in a xdstp:// URL
    is resolved to a ``ConfigSource`` prior to configuration fetch. This field provides the
    association between authority name and configuration source.
    [#not-implemented-hide:]
    """

    path: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="config_source_specifier"
    )
    """
    Deprecated in favor of ``path_config_source``. Use that field instead.
    """

    path_config_source: "PathConfigSource | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="config_source_specifier"
    )
    """
    Local filesystem path configuration source.
    """

    api_config_source: "ApiConfigSource | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="config_source_specifier"
    )
    """
    API configuration source.
    """

    ads: "AggregatedConfigSource | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="config_source_specifier"
    )
    """
    When set, ADS will be used to fetch resources. The ADS API configuration
    source in the bootstrap configuration is used.
    """

    self: "SelfConfigSource | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="config_source_specifier"
    )
    """
    [#not-implemented-hide:]
    When set, the client will access the resources from the same server it got the
    ConfigSource from, although not necessarily from the same stream. This is similar to the
    :ref:`ads<envoy_v3_api_field.ConfigSource.ads>` field, except that the client may use a
    different stream to the same server. As a result, this field can be used for things
    like LRS that cannot be sent on an ADS stream. It can also be used to link from (e.g.)
    LDS to RDS on the same server without requiring the management server to know its name
    or required credentials.
    [#next-major-version: In xDS v3, consider replacing the ads field with this one, since
    this field can implicitly mean to use the same stream in the case where the ConfigSource
    is provided via ADS and the specified data can also be obtained via ADS.]
    """

    initial_fetch_timeout: "datetime.timedelta | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    When this timeout is specified, Envoy will wait no longer than the specified time for first
    config response on this xDS subscription during the :ref:`initialization process
    <arch_overview_initialization>`. After reaching the timeout, Envoy will move to the next
    initialization phase, even if the first config is not delivered yet. The timer is activated
    when the xDS API subscription starts, and is disarmed on first config update or on error. 0
    means no timeout - Envoy will wait indefinitely for the first xDS config (unless another
    timeout applies). The default is 15s.
    """

    resource_api_version: "ApiVersion" = betterproto2.field(
        6, betterproto2.TYPE_ENUM, default_factory=lambda: ApiVersion(0)
    )
    """
    API version for xDS resources. This implies the type URLs that the client
    will request for resources and the resource type that the client will in
    turn expect to be delivered.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("path"):
            warnings.warn("ConfigSource.path is deprecated", DeprecationWarning)

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3", "ConfigSource", ConfigSource
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ControlPlane(betterproto2.Message):
    """
    Identifies a specific ControlPlane instance that Envoy is connected to.
    """

    identifier: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    An opaque control plane identifier that uniquely identifies an instance
    of control plane. This can be used to identify which control plane instance,
    the Envoy is connected to.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "ControlPlane", ControlPlane
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataSource(betterproto2.Message):
    """
    Data source consisting of a file, an inline value, or an environment variable.
    [#next-free-field: 6]

    Oneofs:
        - specifier:
    """

    filename: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="specifier"
    )
    """
    Local filesystem data source.
    """

    inline_bytes: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True, group="specifier"
    )
    """
    Bytes inlined in the configuration.
    """

    inline_string: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True, group="specifier"
    )
    """
    String inlined in the configuration.
    """

    environment_variable: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True, group="specifier"
    )
    """
    Environment variable data source.
    """

    watched_directory: "WatchedDirectory | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Watched directory that is watched for file changes. If this is set explicitly, the file
    specified in the ``filename`` field will be reloaded when relevant file move events occur.

    .. note::
      This field only makes sense when the ``filename`` field is set.

    .. note::
      Envoy only updates when the file is replaced by a file move, and not when the file is
      edited in place.

    .. note::
      Not all use cases of ``DataSource`` support watching directories. It depends on the
      specific usage of the ``DataSource``. See the documentation of the parent message for
      details.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.config.core.v3", "DataSource", DataSource)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DnsResolutionConfig(betterproto2.Message):
    """
    DNS resolution configuration which includes the underlying dns resolver addresses and options.
    """

    resolvers: "list[Address]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of dns resolver addresses. If specified, the DNS client library will perform resolution
    via the underlying DNS resolvers. Otherwise, the default system resolvers
    (e.g., /etc/resolv.conf) will be used.
    """

    dns_resolver_options: "DnsResolverOptions | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Configuration of DNS resolver option flags which control the behavior of the DNS resolver.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "DnsResolutionConfig", DnsResolutionConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DnsResolverOptions(betterproto2.Message):
    """
    [#protodoc-title: Resolver]

    Configuration of DNS resolver option flags which control the behavior of the DNS resolver.
    """

    use_tcp_for_dns_lookups: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)
    """
    Use TCP for all DNS queries instead of the default protocol UDP.
    """

    no_default_search_domain: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)
    """
    Do not use the default search domains; only query hostnames as-is or as aliases.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "DnsResolverOptions", DnsResolverOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class EnvoyInternalAddress(betterproto2.Message):
    """
    The address represents an envoy internal listener.
    [#comment: TODO(asraa): When address available, remove workaround from test/server/server_fuzz_test.cc:30.]

    Oneofs:
        - address_name_specifier:
    """

    server_listener_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="address_name_specifier"
    )
    """
    Specifies the :ref:`name <envoy_v3_api_field_config.listener.v3.Listener.name>` of the
    internal listener.
    """

    endpoint_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Specifies an endpoint identifier to distinguish between multiple endpoints for the same internal listener in a
    single upstream pool. Only used in the upstream addresses for tracking changes to individual endpoints. This, for
    example, may be set to the final destination IP for the target internal listener.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3", "EnvoyInternalAddress", EnvoyInternalAddress
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class EventServiceConfig(betterproto2.Message):
    """
    [#not-implemented-hide:]
    Configuration of the event reporting service endpoint.

    Oneofs:
        - config_source_specifier:
    """

    grpc_service: "GrpcService | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="config_source_specifier"
    )
    """
    Specifies the gRPC service that hosts the event reporting service.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3", "EventServiceConfig", EventServiceConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Extension(betterproto2.Message):
    """
    Version and identification for an Envoy extension.
    [#next-free-field: 7]
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    This is the name of the Envoy filter as specified in the Envoy
    configuration, e.g. envoy.filters.http.router, com.acme.widget.
    """

    category: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Category of the extension.
    Extension category names use reverse DNS notation. For instance "envoy.filters.listener"
    for Envoy's built-in listener filters or "com.acme.filters.http" for HTTP filters from
    acme.com vendor.
    [#comment:TODO(yanavlasov): Link to the doc with existing envoy category names.]
    """

    type_descriptor: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    [#not-implemented-hide:] Type descriptor of extension configuration proto.
    [#comment:TODO(yanavlasov): Link to the doc with existing configuration protos.]
    [#comment:TODO(yanavlasov): Add tests when PR #9391 lands.]
    """

    version: "BuildVersion | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The version is a property of the extension and maintained independently
    of other extensions and the Envoy API.
    This field is not set when extension did not provide version information.
    """

    disabled: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    Indicates that the extension is present but was disabled via dynamic configuration.
    """

    type_urls: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        6, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Type URLs of extension configuration protos.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("type_descriptor"):
            warnings.warn("Extension.type_descriptor is deprecated", DeprecationWarning)


default_message_pool.register_message("envoy.config.core.v3", "Extension", Extension)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ExtensionConfigSource(betterproto2.Message):
    """
    Configuration source specifier for a late-bound extension configuration. The
    parent resource is warmed until all the initial extension configurations are
    received, unless the flag to apply the default configuration is set.
    Subsequent extension updates are atomic on a per-worker basis. Once an
    extension configuration is applied to a request or a connection, it remains
    constant for the duration of processing. If the initial delivery of the
    extension configuration fails, due to a timeout for example, the optional
    default configuration is applied. Without a default configuration, the
    extension is disabled, until an extension configuration is received. The
    behavior of a disabled extension depends on the context. For example, a
    filter chain with a disabled extension filter rejects all incoming streams.
    """

    config_source: "ConfigSource | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    default_config: "____google__protobuf__.Any | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional default configuration to use as the initial configuration if
    there is a failure to receive the initial extension configuration or if
    ``apply_default_config_without_warming`` flag is set.
    """

    apply_default_config_without_warming: "bool" = betterproto2.field(
        3, betterproto2.TYPE_BOOL
    )
    """
    Use the default config as the initial configuration without warming and
    waiting for the first discovery response. Requires the default configuration
    to be supplied.
    """

    type_urls: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        4, betterproto2.TYPE_STRING, repeated=True
    )
    """
    A set of permitted extension type URLs for the type encoded inside of the
    :ref:`TypedExtensionConfig <envoy_v3_api_msg_config.core.v3.TypedExtensionConfig>`. Extension
    configuration updates are rejected if they do not match any type URL in the set.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "ExtensionConfigSource", ExtensionConfigSource
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ExtraSourceAddress(betterproto2.Message):
    address: "SocketAddress | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The additional address to bind.
    """

    socket_options: "SocketOptionsOverride | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional socket options that may not be present in Envoy source code or
    precompiled binaries. If specified, this will override the
    :ref:`socket_options <envoy_v3_api_field_config.core.v3.BindConfig.socket_options>`
    in the BindConfig. If specified with no
    :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`
    or an empty list of :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`,
    it means no socket option will apply.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "ExtraSourceAddress", ExtraSourceAddress
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcMethodList(betterproto2.Message):
    """
    [#protodoc-title: gRPC method list]

    A list of gRPC methods which can be used as an allowlist, for example.
    """

    services: "list[GrpcMethodListService]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.config.core.v3", "GrpcMethodList", GrpcMethodList
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcMethodListService(betterproto2.Message):
    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the gRPC service.
    """

    method_names: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        2, betterproto2.TYPE_STRING, repeated=True
    )
    """
    The names of the gRPC methods in this service.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "GrpcMethodList.Service", GrpcMethodListService
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcProtocolOptions(betterproto2.Message):
    """
    [#not-implemented-hide:]
    """

    http2_protocol_options: "Http2ProtocolOptions | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "envoy.config.core.v3", "GrpcProtocolOptions", GrpcProtocolOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcService(betterproto2.Message):
    """
    [#protodoc-title: gRPC services]

    gRPC service configuration. This is used by :ref:`ApiConfigSource
    <envoy_v3_api_msg_config.core.v3.ApiConfigSource>` and filter configurations.
    [#next-free-field: 7]

    Oneofs:
        - target_specifier:
    """

    envoy_grpc: "GrpcServiceEnvoyGrpc | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="target_specifier"
    )
    """
    Envoy's in-built gRPC client.
    See the :ref:`gRPC services overview <arch_overview_grpc_services>`
    documentation for discussion on gRPC client selection.
    """

    google_grpc: "GrpcServiceGoogleGrpc | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="target_specifier"
    )
    """
    `Google C++ gRPC client <https://github.com/grpc/grpc>`_
    See the :ref:`gRPC services overview <arch_overview_grpc_services>`
    documentation for discussion on gRPC client selection.
    """

    timeout: "datetime.timedelta | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The timeout for the gRPC request. This is the timeout for a specific
    request.
    """

    initial_metadata: "list[HeaderValue]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Additional metadata to include in streams initiated to the GrpcService. This can be used for
    scenarios in which additional ad hoc authorization headers (e.g. ``x-foo-bar: baz-key``) are to
    be injected. For more information, including details on header value syntax, see the
    documentation on :ref:`custom request headers
    <config_http_conn_man_headers_custom_request_headers>`.
    """

    retry_policy: "RetryPolicy | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional default retry policy for streams toward the service.
    If an async stream doesn't have retry policy configured in its stream options, this retry policy is used.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3", "GrpcService", GrpcService
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcServiceEnvoyGrpc(betterproto2.Message):
    """
    [#next-free-field: 6]
    """

    cluster_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the upstream gRPC cluster. SSL credentials will be supplied
    in the :ref:`Cluster <envoy_v3_api_msg_config.cluster.v3.Cluster>` :ref:`transport_socket
    <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket>`.
    """

    authority: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The ``:authority`` header in the grpc request. If this field is not set, the authority header value will be ``cluster_name``.
    Note that this authority does not override the SNI. The SNI is provided by the transport socket of the cluster.
    """

    retry_policy: "RetryPolicy | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Indicates the retry policy for re-establishing the gRPC stream
    This field is optional. If max interval is not provided, it will be set to ten times the provided base interval.
    Currently only supported for xDS gRPC streams.
    If not set, xDS gRPC streams default base interval:500ms, maximum interval:30s will be applied.
    """

    max_receive_message_length: "int | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Maximum gRPC message size that is allowed to be received.
    If a message over this limit is received, the gRPC stream is terminated with the RESOURCE_EXHAUSTED error.
    This limit is applied to individual messages in the streaming response and not the total size of streaming response.
    Defaults to 0, which means unlimited.
    """

    skip_envoy_headers: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    This provides gRPC client level control over envoy generated headers.
    If false, the header will be sent but it can be overridden by per stream option.
    If true, the header will be removed and can not be overridden by per stream option.
    Default to false.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "GrpcService.EnvoyGrpc", GrpcServiceEnvoyGrpc
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcServiceGoogleGrpc(betterproto2.Message):
    """
    [#next-free-field: 11]
    """

    target_uri: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The target URI when using the `Google C++ gRPC client
    <https://github.com/grpc/grpc>`_.
    """

    channel_credentials: "GrpcServiceGoogleGrpcChannelCredentials | None" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    The channel credentials to use. See `channel credentials
    <https://grpc.io/docs/guides/auth.html#credential-types>`_.
    Ignored if ``channel_credentials_plugin`` is set.
    """

    channel_credentials_plugin: "list[____google__protobuf__.Any]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of channel credentials plugins.
    The data plane will iterate over the list in order and stop at the first credential type
    that it supports. This provides a mechanism for starting to use new credential types that
    are not yet supported by all data planes.
    [#not-implemented-hide:]
    """

    call_credentials: "list[GrpcServiceGoogleGrpcCallCredentials]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The call credentials to use. See `channel credentials
    <https://grpc.io/docs/guides/auth.html#credential-types>`_.
    Ignored if ``call_credentials_plugin`` is set.
    """

    call_credentials_plugin: "list[____google__protobuf__.Any]" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of call credentials plugins. All supported plugins will be used.
    Unsupported plugin types will be ignored.
    [#not-implemented-hide:]
    """

    stat_prefix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )
    """
    The human readable prefix to use when emitting statistics for the gRPC
    service.

    .. csv-table::
       :header: Name, Type, Description
       :widths: 1, 1, 2

       streams_total, Counter, Total number of streams opened
       streams_closed_<gRPC status code>, Counter, Total streams closed with <gRPC status code>
    """

    credentials_factory_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )
    """
    The name of the Google gRPC credentials factory to use. This must have been registered with
    Envoy. If this is empty, a default credentials factory will be used that sets up channel
    credentials based on other configuration parameters.
    """

    config: "____google__protobuf__.Struct | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional configuration for site-specific customizations of the Google
    gRPC library.
    """

    per_stream_buffer_limit_bytes: "int | None" = betterproto2.field(
        7,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    How many bytes each stream can buffer internally.
    If not set an implementation defined default is applied (1MiB).
    """

    channel_args: "GrpcServiceGoogleGrpcChannelArgs | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Custom channels args.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "GrpcService.GoogleGrpc", GrpcServiceGoogleGrpc
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcServiceGoogleGrpcCallCredentials(betterproto2.Message):
    """
    [#next-free-field: 8]

    Oneofs:
        - credential_specifier:
    """

    access_token: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="credential_specifier"
    )
    """
    Access token credentials.
    https://grpc.io/grpc/cpp/namespacegrpc.html#ad3a80da696ffdaea943f0f858d7a360d.
    """

    google_compute_engine: "____google__protobuf__.Empty | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="credential_specifier"
    )
    """
    Google Compute Engine credentials.
    https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61
    """

    google_refresh_token: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True, group="credential_specifier"
    )
    """
    Google refresh token credentials.
    https://grpc.io/grpc/cpp/namespacegrpc.html#a96901c997b91bc6513b08491e0dca37c.
    """

    service_account_jwt_access: "GrpcServiceGoogleGrpcCallCredentialsServiceAccountJwtAccessCredentials | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="credential_specifier"
    )
    """
    Service Account JWT Access credentials.
    https://grpc.io/grpc/cpp/namespacegrpc.html#a92a9f959d6102461f66ee973d8e9d3aa.
    """

    google_iam: "GrpcServiceGoogleGrpcCallCredentialsGoogleIamCredentials | None" = (
        betterproto2.field(
            5, betterproto2.TYPE_MESSAGE, optional=True, group="credential_specifier"
        )
    )
    """
    Google IAM credentials.
    https://grpc.io/grpc/cpp/namespacegrpc.html#a9fc1fc101b41e680d47028166e76f9d0.
    """

    from_plugin: "GrpcServiceGoogleGrpcCallCredentialsMetadataCredentialsFromPlugin | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="credential_specifier"
    )
    """
    Custom authenticator credentials.
    https://grpc.io/grpc/cpp/namespacegrpc.html#a823c6a4b19ffc71fb33e90154ee2ad07.
    https://grpc.io/docs/guides/auth.html#extending-grpc-to-support-other-authentication-mechanisms.
    """

    sts_service: "GrpcServiceGoogleGrpcCallCredentialsStsService | None" = (
        betterproto2.field(
            7, betterproto2.TYPE_MESSAGE, optional=True, group="credential_specifier"
        )
    )
    """
    Custom security token service which implements OAuth 2.0 token exchange.
    https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16
    See https://github.com/grpc/grpc/pull/19587.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3",
    "GrpcService.GoogleGrpc.CallCredentials",
    GrpcServiceGoogleGrpcCallCredentials,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcServiceGoogleGrpcCallCredentialsGoogleIamCredentials(betterproto2.Message):
    authorization_token: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    authority_selector: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )


default_message_pool.register_message(
    "envoy.config.core.v3",
    "GrpcService.GoogleGrpc.CallCredentials.GoogleIAMCredentials",
    GrpcServiceGoogleGrpcCallCredentialsGoogleIamCredentials,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcServiceGoogleGrpcCallCredentialsMetadataCredentialsFromPlugin(
    betterproto2.Message
):
    """


    Oneofs:
        - config_type: [#extension-category: envoy.grpc_credentials]
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    typed_config: "____google__protobuf__.Any | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="config_type"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3",
    "GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin",
    GrpcServiceGoogleGrpcCallCredentialsMetadataCredentialsFromPlugin,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcServiceGoogleGrpcCallCredentialsServiceAccountJwtAccessCredentials(
    betterproto2.Message
):
    json_key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    token_lifetime_seconds: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        2, betterproto2.TYPE_UINT64
    )


default_message_pool.register_message(
    "envoy.config.core.v3",
    "GrpcService.GoogleGrpc.CallCredentials.ServiceAccountJWTAccessCredentials",
    GrpcServiceGoogleGrpcCallCredentialsServiceAccountJwtAccessCredentials,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcServiceGoogleGrpcCallCredentialsStsService(betterproto2.Message):
    """
    Security token service configuration that allows Google gRPC to
    fetch security token from an OAuth 2.0 authorization server.
    See https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16 and
    https://github.com/grpc/grpc/pull/19587.
    [#next-free-field: 10]
    """

    token_exchange_service_uri: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    URI of the token exchange service that handles token exchange requests.
    [#comment:TODO(asraa): Add URI validation when implemented. Tracked by
    https://github.com/bufbuild/protoc-gen-validate/issues/303]
    """

    resource: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Location of the target service or resource where the client
    intends to use the requested security token.
    """

    audience: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    Logical name of the target service where the client intends to
    use the requested security token.
    """

    scope: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )
    """
    The desired scope of the requested security token in the
    context of the service or resource where the token will be used.
    """

    requested_token_type: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )
    """
    Type of the requested security token.
    """

    subject_token_path: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        6, betterproto2.TYPE_STRING
    )
    """
    The path of subject token, a security token that represents the
    identity of the party on behalf of whom the request is being made.
    """

    subject_token_type: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        7, betterproto2.TYPE_STRING
    )
    """
    Type of the subject token.
    """

    actor_token_path: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        8, betterproto2.TYPE_STRING
    )
    """
    The path of actor token, a security token that represents the identity
    of the acting party. The acting party is authorized to use the
    requested security token and act on behalf of the subject.
    """

    actor_token_type: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        9, betterproto2.TYPE_STRING
    )
    """
    Type of the actor token.
    """


default_message_pool.register_message(
    "envoy.config.core.v3",
    "GrpcService.GoogleGrpc.CallCredentials.StsService",
    GrpcServiceGoogleGrpcCallCredentialsStsService,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcServiceGoogleGrpcChannelArgs(betterproto2.Message):
    """
    Channel arguments.
    """

    args: "dict[str, GrpcServiceGoogleGrpcChannelArgsValue]" = betterproto2.field(
        1,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
        ),
    )
    """
    See grpc_types.h GRPC_ARG #defines for keys that work here.
    """


default_message_pool.register_message(
    "envoy.config.core.v3",
    "GrpcService.GoogleGrpc.ChannelArgs",
    GrpcServiceGoogleGrpcChannelArgs,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcServiceGoogleGrpcChannelArgsValue(betterproto2.Message):
    """


    Oneofs:
        - value_specifier: Pointer values are not supported, since they don't make any sense when
            delivered via the API.
    """

    string_value: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="value_specifier"
    )

    int_value: "typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)] | None" = betterproto2.field(
        2, betterproto2.TYPE_INT64, optional=True, group="value_specifier"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3",
    "GrpcService.GoogleGrpc.ChannelArgs.Value",
    GrpcServiceGoogleGrpcChannelArgsValue,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcServiceGoogleGrpcChannelCredentials(betterproto2.Message):
    """
    See https://grpc.io/docs/guides/auth.html#credential-types to understand Channel and Call
    credential types.

    Oneofs:
        - credential_specifier:
    """

    ssl_credentials: "GrpcServiceGoogleGrpcSslCredentials | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="credential_specifier"
    )

    google_default: "____google__protobuf__.Empty | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="credential_specifier"
    )
    """
    https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61
    """

    local_credentials: "GrpcServiceGoogleGrpcGoogleLocalCredentials | None" = (
        betterproto2.field(
            3, betterproto2.TYPE_MESSAGE, optional=True, group="credential_specifier"
        )
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3",
    "GrpcService.GoogleGrpc.ChannelCredentials",
    GrpcServiceGoogleGrpcChannelCredentials,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcServiceGoogleGrpcGoogleLocalCredentials(betterproto2.Message):
    """
    Local channel credentials. Only UDS is supported for now.
    See https://github.com/grpc/grpc/pull/15909.
    """

    pass


default_message_pool.register_message(
    "envoy.config.core.v3",
    "GrpcService.GoogleGrpc.GoogleLocalCredentials",
    GrpcServiceGoogleGrpcGoogleLocalCredentials,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GrpcServiceGoogleGrpcSslCredentials(betterproto2.Message):
    """
    See https://grpc.io/grpc/cpp/structgrpc_1_1_ssl_credentials_options.html.
    """

    root_certs: "DataSource | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    PEM encoded server root certificates.
    """

    private_key: "DataSource | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    PEM encoded client private key.
    """

    cert_chain: "DataSource | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    PEM encoded client certificate chain.
    """


default_message_pool.register_message(
    "envoy.config.core.v3",
    "GrpcService.GoogleGrpc.SslCredentials",
    GrpcServiceGoogleGrpcSslCredentials,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HeaderMap(betterproto2.Message):
    """
    Wrapper for a set of headers.
    """

    headers: "list[HeaderValue]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of header names and their values.
    """


default_message_pool.register_message("envoy.config.core.v3", "HeaderMap", HeaderMap)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HeaderValue(betterproto2.Message):
    """
    Header name/value pair.
    """

    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Header name.
    """

    value: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Header value.

    The same :ref:`format specifier <config_access_log_format>` as used for
    :ref:`HTTP access logging <config_access_log>` applies here, however
    unknown header values are replaced with the empty string instead of ``-``.
    Header value is encoded as string. This does not work for non-utf8 characters.
    Only one of ``value`` or ``raw_value`` can be set.
    """

    raw_value: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)
    """
    Header value is encoded as bytes which can support non-utf8 characters.
    Only one of ``value`` or ``raw_value`` can be set.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "HeaderValue", HeaderValue
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HeaderValueOption(betterproto2.Message):
    """
    Header name/value pair plus option to control append behavior.
    """

    header: "HeaderValue | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Header name/value pair that this option applies to.
    """

    append: "bool | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    Should the value be appended? If true (default), the value is appended to
    existing values. Otherwise it replaces any existing values.
    This field is deprecated and please use
    :ref:`append_action <envoy_v3_api_field_config.core.v3.HeaderValueOption.append_action>` as replacement.

    .. note::
      The :ref:`external authorization service <envoy_v3_api_msg_service.auth.v3.CheckResponse>` and
      :ref:`external processor service <envoy_v3_api_msg_service.ext_proc.v3.ProcessingResponse>` have
      default value (``false``) for this field.
    """

    append_action: "HeaderValueOptionHeaderAppendAction" = betterproto2.field(
        3,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: HeaderValueOptionHeaderAppendAction(0),
    )
    """
    Describes the action taken to append/overwrite the given value for an existing header
    or to only add this header if it's absent.
    Value defaults to :ref:`APPEND_IF_EXISTS_OR_ADD
    <envoy_v3_api_enum_value_config.core.v3.HeaderValueOption.HeaderAppendAction.APPEND_IF_EXISTS_OR_ADD>`.
    """

    keep_empty_value: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)
    """
    Is the header value allowed to be empty? If false (default), custom headers with empty values are dropped,
    otherwise they are added.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("append"):
            warnings.warn("HeaderValueOption.append is deprecated", DeprecationWarning)


default_message_pool.register_message(
    "envoy.config.core.v3", "HeaderValueOption", HeaderValueOption
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HealthCheck(betterproto2.Message):
    """
    [#next-free-field: 27]

    Oneofs:
        - health_checker:
    """

    timeout: "datetime.timedelta | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The time to wait for a health check response. If the timeout is reached the
    health check attempt will be considered a failure.
    """

    interval: "datetime.timedelta | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The interval between health checks.
    """

    initial_jitter: "datetime.timedelta | None" = betterproto2.field(
        20,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    An optional jitter amount in milliseconds. If specified, Envoy will start health
    checking after for a random time in ms between 0 and initial_jitter. This only
    applies to the first health check.
    """

    interval_jitter: "datetime.timedelta | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    An optional jitter amount in milliseconds. If specified, during every
    interval Envoy will add interval_jitter to the wait time.
    """

    interval_jitter_percent: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = betterproto2.field(
        18, betterproto2.TYPE_UINT32
    )
    """
    An optional jitter amount as a percentage of interval_ms. If specified,
    during every interval Envoy will add ``interval_ms`` *
    ``interval_jitter_percent`` / 100 to the wait time.

    If interval_jitter_ms and interval_jitter_percent are both set, both of
    them will be used to increase the wait time.
    """

    unhealthy_threshold: "int | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The number of unhealthy health checks required before a host is marked
    unhealthy. Note that for ``http`` health checking if a host responds with a code not in
    :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
    or :ref:`retriable_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses>`,
    this threshold is ignored and the host is considered immediately unhealthy.
    """

    healthy_threshold: "int | None" = betterproto2.field(
        5,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The number of healthy health checks required before a host is marked
    healthy. Note that during startup, only a single successful health check is
    required to mark a host healthy.
    """

    alt_port: "int | None" = betterproto2.field(
        6,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    [#not-implemented-hide:] Non-serving port for health checking.
    """

    reuse_connection: "bool | None" = betterproto2.field(
        7,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    Reuse health check connection between health checks. Default is true.
    """

    http_health_check: "HealthCheckHttpHealthCheck | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="health_checker"
    )
    """
    HTTP health check.
    """

    tcp_health_check: "HealthCheckTcpHealthCheck | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="health_checker"
    )
    """
    TCP health check.
    """

    grpc_health_check: "HealthCheckGrpcHealthCheck | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="health_checker"
    )
    """
    gRPC health check.
    """

    custom_health_check: "HealthCheckCustomHealthCheck | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True, group="health_checker"
    )
    """
    Custom health check.
    """

    no_traffic_interval: "datetime.timedelta | None" = betterproto2.field(
        12,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The "no traffic interval" is a special health check interval that is used when a cluster has
    never had traffic routed to it. This lower interval allows cluster information to be kept up to
    date, without sending a potentially large amount of active health checking traffic for no
    reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
    standard health check interval that is defined. Note that this interval takes precedence over
    any other.

    The default value for "no traffic interval" is 60 seconds.
    """

    no_traffic_healthy_interval: "datetime.timedelta | None" = betterproto2.field(
        24,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The "no traffic healthy interval" is a special health check interval that
    is used for hosts that are currently passing active health checking
    (including new hosts) when the cluster has received no traffic.

    This is useful for when we want to send frequent health checks with
    ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
    a host in the cluster is marked as healthy.

    Once a cluster has been used for traffic routing, Envoy will shift back to using the
    standard health check interval that is defined.

    If no_traffic_healthy_interval is not set, it will default to the
    no traffic interval and send that interval regardless of health state.
    """

    unhealthy_interval: "datetime.timedelta | None" = betterproto2.field(
        14,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The "unhealthy interval" is a health check interval that is used for hosts that are marked as
    unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
    standard health check interval that is defined.

    The default value for "unhealthy interval" is the same as "interval".
    """

    unhealthy_edge_interval: "datetime.timedelta | None" = betterproto2.field(
        15,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The "unhealthy edge interval" is a special health check interval that is used for the first
    health check right after a host is marked as unhealthy. For subsequent health checks
    Envoy will shift back to using either "unhealthy interval" if present or the standard health
    check interval that is defined.

    The default value for "unhealthy edge interval" is the same as "unhealthy interval".
    """

    healthy_edge_interval: "datetime.timedelta | None" = betterproto2.field(
        16,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The "healthy edge interval" is a special health check interval that is used for the first
    health check right after a host is marked as healthy. For subsequent health checks
    Envoy will shift back to using the standard health check interval that is defined.

    The default value for "healthy edge interval" is the same as the default interval.
    """

    event_log_path: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        17, betterproto2.TYPE_STRING
    )
    """
    Specifies the path to the :ref:`health check event log <arch_overview_health_check_logging>`.

    .. attention::
      This field is deprecated in favor of the extension
      :ref:`event_logger <envoy_v3_api_field_config.core.v3.HealthCheck.event_logger>` and
      :ref:`event_log_path <envoy_v3_api_field_extensions.health_check.event_sinks.file.v3.HealthCheckEventFileSink.event_log_path>`
      in the file sink extension.
    """

    event_logger: "list[TypedExtensionConfig]" = betterproto2.field(
        25, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of event log sinks to process the health check event.
    [#extension-category: envoy.health_check.event_sinks]
    """

    event_service: "EventServiceConfig | None" = betterproto2.field(
        22, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    [#not-implemented-hide:]
    The gRPC service for the health check event service.
    If empty, health check events won't be sent to a remote endpoint.
    """

    always_log_health_check_failures: "bool" = betterproto2.field(
        19, betterproto2.TYPE_BOOL
    )
    """
    If set to true, health check failure events will always be logged. If set to false, only the
    initial health check failure event will be logged.
    The default value is false.
    """

    always_log_health_check_success: "bool" = betterproto2.field(
        26, betterproto2.TYPE_BOOL
    )
    """
    If set to true, health check success events will always be logged. If set to false, only host addition event will be logged
    if it is the first successful health check, or if the healthy threshold is reached.
    The default value is false.
    """

    tls_options: "HealthCheckTlsOptions | None" = betterproto2.field(
        21, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    This allows overriding the cluster TLS settings, just for health check connections.
    """

    transport_socket_match_criteria: "____google__protobuf__.Struct | None" = (
        betterproto2.field(23, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
    :ref:`tranport socket matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`.
    For example, the following match criteria

    .. code-block:: yaml

     transport_socket_match_criteria:
       useMTLS: true

    Will match the following :ref:`cluster socket match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>`

    .. code-block:: yaml

     transport_socket_matches:
     - name: "useMTLS"
       match:
         useMTLS: true
       transport_socket:
         name: envoy.transport_sockets.tls
         config: { ... } # tls socket configuration

    If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
    :ref:`LbEndpoint.Metadata <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>`.
    This allows using different transport socket capabilities for health checking versus proxying to the
    endpoint.

    If the key/values pairs specified do not match any
    :ref:`transport socket matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`,
    the cluster's :ref:`transport socket <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket>`
    will be used for health check socket configuration.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("event_log_path"):
            warnings.warn(
                "HealthCheck.event_log_path is deprecated", DeprecationWarning
            )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3", "HealthCheck", HealthCheck
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HealthCheckCustomHealthCheck(betterproto2.Message):
    """
    Custom health check.

    Oneofs:
        - config_type: A custom health checker specific configuration which depends on the custom health checker
            being instantiated. See :api:`envoy/config/health_checker` for reference.
            [#extension-category: envoy.health_checkers]
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The registered name of the custom health checker.
    """

    typed_config: "____google__protobuf__.Any | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="config_type"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3",
    "HealthCheck.CustomHealthCheck",
    HealthCheckCustomHealthCheck,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HealthCheckGrpcHealthCheck(betterproto2.Message):
    """
    `grpc.health.v1.Health
    <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_-based
    healthcheck. See `gRPC doc <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_
    for details.
    """

    service_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    An optional service name parameter which will be sent to gRPC service in
    `grpc.health.v1.HealthCheckRequest
    <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20>`_.
    message. See `gRPC health-checking overview
    <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ for more information.
    """

    authority: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The value of the :authority header in the gRPC health check request. If
    left empty (default value), the name of the cluster this health check is associated
    with will be used. The authority header can be customized for a specific endpoint by setting
    the :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>` field.
    """

    initial_metadata: "list[HeaderValueOption]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
    that is sent to the health checked cluster. For more information, including details on header value syntax,
    see the documentation on :ref:`custom request headers
    <config_http_conn_man_headers_custom_request_headers>`.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "HealthCheck.GrpcHealthCheck", HealthCheckGrpcHealthCheck
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HealthCheckHttpHealthCheck(betterproto2.Message):
    """
    [#next-free-field: 15]
    """

    host: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The value of the host header in the HTTP health check request. If
    left empty (default value), the name of the cluster this health check is associated
    with will be used. The host header can be customized for a specific endpoint by setting the
    :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>` field.
    """

    path: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Specifies the HTTP path that will be requested during health checking. For example
    ``/healthcheck``.
    """

    send: "HealthCheckPayload | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    HTTP specific payload to be sent as the request body during health checking.
    If specified, the method should support a request body (POST, PUT, PATCH, etc.).
    """

    receive: "list[HealthCheckPayload]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
    If it is set, both the expected response check and status code determine the health check.
    When checking the response, “fuzzy” matching is performed such that each payload block must be found,
    and in the order specified, but not necessarily contiguous.

    .. note::

      It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
      The default buffer size is 1024 bytes when it is not set.
    """

    response_buffer_size: "int | None" = betterproto2.field(
        14,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt64Value,
        optional=True,
    )
    """
    Specifies the size of response buffer in bytes that is used to Payload match.
    The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
    """

    request_headers_to_add: "list[HeaderValueOption]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies a list of HTTP headers that should be added to each request that is sent to the
    health checked cluster. For more information, including details on header value syntax, see
    the documentation on :ref:`custom request headers
    <config_http_conn_man_headers_custom_request_headers>`.
    """

    request_headers_to_remove: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        8, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Specifies a list of HTTP headers that should be removed from each request that is sent to the
    health checked cluster.
    """

    expected_statuses: "list[___type__v3__.Int64Range]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
    200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
    semantics of :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each
    range are required. Only statuses in the range [100, 600) are allowed.
    """

    retriable_statuses: "list[___type__v3__.Int64Range]" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
    will count towards the configured :ref:`unhealthy_threshold <envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold>`,
    but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
    :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each range are required.
    Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
    field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
    be considered a successful health check. By default all responses not in
    :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>` will result in
    the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
    non-200 response will result in the host being marked unhealthy.
    """

    codec_client_type: "___type__v3__.CodecClientType" = betterproto2.field(
        10,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ___type__v3__.CodecClientType(0),
    )
    """
    Use specified application protocol for health checks.
    """

    service_name_matcher: "___type__matcher__v3__.StringMatcher | None" = (
        betterproto2.field(11, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    An optional service name parameter which is used to validate the identity of
    the health checked cluster using a :ref:`StringMatcher
    <envoy_v3_api_msg_type.matcher.v3.StringMatcher>`. See the :ref:`architecture overview
    <arch_overview_health_checking_identity>` for more information.
    """

    method: "RequestMethod" = betterproto2.field(
        13, betterproto2.TYPE_ENUM, default_factory=lambda: RequestMethod(0)
    )
    """
    HTTP Method that will be used for health checking, default is "GET".
    GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported.
    Request body payloads are supported for POST, PUT, PATCH, and OPTIONS methods only.
    CONNECT method is disallowed because it is not appropriate for health check request.
    If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "HealthCheck.HttpHealthCheck", HealthCheckHttpHealthCheck
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HealthCheckPayload(betterproto2.Message):
    """
    Describes the encoding of the payload bytes in the payload.

    Oneofs:
        - payload:
    """

    text: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="payload"
    )
    """
    Hex encoded payload. E.g., "000000FF".
    """

    binary: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True, group="payload"
    )
    """
    Binary payload.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3", "HealthCheck.Payload", HealthCheckPayload
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HealthCheckRedisHealthCheck(betterproto2.Message):
    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    If set, optionally perform ``EXISTS <key>`` instead of ``PING``. A return value
    from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
    than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
    by setting the specified key to any value and waiting for traffic to drain.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "HealthCheck.RedisHealthCheck", HealthCheckRedisHealthCheck
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HealthCheckTcpHealthCheck(betterproto2.Message):
    send: "HealthCheckPayload | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Empty payloads imply a connect-only health check.
    """

    receive: "list[HealthCheckPayload]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    When checking the response, “fuzzy” matching is performed such that each
    payload block must be found, and in the order specified, but not
    necessarily contiguous.
    """

    proxy_protocol_config: "ProxyProtocolConfig | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    When setting this value, it tries to attempt health check request with ProxyProtocol.
    When ``send`` is presented, they are sent after preceding ProxyProtocol header.
    Only ProxyProtocol header is sent when ``send`` is not presented.
    It allows to use both ProxyProtocol V1 and V2. In V1, it presents L3/L4. In V2, it includes
    LOCAL command and doesn't include L3/L4.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "HealthCheck.TcpHealthCheck", HealthCheckTcpHealthCheck
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HealthCheckTlsOptions(betterproto2.Message):
    """
    Health checks occur over the transport socket specified for the cluster. This implies that if a
    cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.

    This allows overriding the cluster TLS settings, just for health check connections.
    """

    alpn_protocols: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        1, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Specifies the ALPN protocols for health check connections. This is useful if the
    corresponding upstream is using ALPN-based :ref:`FilterChainMatch
    <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>` along with different protocols for health checks
    versus data connections. If empty, no ALPN protocols will be set on health check connections.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "HealthCheck.TlsOptions", HealthCheckTlsOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HealthStatusSet(betterproto2.Message):
    statuses: "list[HealthStatus]" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, repeated=True
    )
    """
    An order-independent set of health status.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "HealthStatusSet", HealthStatusSet
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Http1ProtocolOptions(betterproto2.Message):
    """
    [#next-free-field: 12]
    """

    allow_absolute_url: "bool | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    Handle HTTP requests with absolute URLs in the requests. These requests
    are generally sent by clients to forward/explicit proxies. This allows clients to configure
    envoy as their HTTP proxy. In Unix, for example, this is typically done by setting the
    ``http_proxy`` environment variable.
    """

    accept_http_10: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)
    """
    Handle incoming HTTP/1.0 and HTTP 0.9 requests.
    This is off by default, and not fully standards compliant. There is support for pre-HTTP/1.1
    style connect logic, dechunking, and handling lack of client host iff
    ``default_host_for_http_10`` is configured.
    """

    default_host_for_http_10: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    A default host for HTTP/1.0 requests. This is highly suggested if ``accept_http_10`` is true as
    Envoy does not otherwise support HTTP/1.0 without a Host header.
    This is a no-op if ``accept_http_10`` is not true.
    """

    header_key_format: "Http1ProtocolOptionsHeaderKeyFormat | None" = (
        betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Describes how the keys for response headers should be formatted. By default, all header keys
    are lower cased.
    """

    enable_trailers: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    Enables trailers for HTTP/1. By default the HTTP/1 codec drops proxied trailers.

    .. attention::

      Note that this only happens when Envoy is chunk encoding which occurs when:
      - The request is HTTP/1.1.
      - Is neither a HEAD only request nor a HTTP Upgrade.
      - Not a response to a HEAD request.
      - The content length header is not present.
    """

    allow_chunked_length: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)
    """
    Allows Envoy to process requests/responses with both ``Content-Length`` and ``Transfer-Encoding``
    headers set. By default such messages are rejected, but if option is enabled - Envoy will
    remove Content-Length header and process message.
    See `RFC7230, sec. 3.3.3 <https://tools.ietf.org/html/rfc7230#section-3.3.3>`_ for details.

    .. attention::
      Enabling this option might lead to request smuggling vulnerability, especially if traffic
      is proxied via multiple layers of proxies.
    [#comment:TODO: This field is ignored when the
    :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
    is present.]
    """

    override_stream_error_on_invalid_http_message: "bool | None" = betterproto2.field(
        7,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    Allows invalid HTTP messaging. When this option is false, then Envoy will terminate
    HTTP/1.1 connections upon receiving an invalid HTTP message. However,
    when this option is true, then Envoy will leave the HTTP/1.1 connection
    open where possible.
    If set, this overrides any HCM :ref:`stream_error_on_invalid_http_messaging
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`.
    """

    send_fully_qualified_url: "bool" = betterproto2.field(8, betterproto2.TYPE_BOOL)
    """
    Allows sending fully qualified URLs when proxying the first line of the
    response. By default, Envoy will only send the path components in the first line.
    If this is true, Envoy will create a fully qualified URI composing scheme
    (inferred if not present), host (from the host/:authority header) and path
    (from first line or :path header).
    """

    use_balsa_parser: "bool | None" = betterproto2.field(
        9,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    [#not-implemented-hide:] Hiding so that field can be removed after BalsaParser is rolled out.
    If set, force HTTP/1 parser: BalsaParser if true, http-parser if false.
    If unset, HTTP/1 parser is selected based on
    envoy.reloadable_features.http1_use_balsa_parser.
    See issue #21245.
    """

    allow_custom_methods: "bool" = betterproto2.field(10, betterproto2.TYPE_BOOL)
    """
    [#not-implemented-hide:] Hiding so that field can be removed.
    If true, and BalsaParser is used (either `use_balsa_parser` above is true,
    or `envoy.reloadable_features.http1_use_balsa_parser` is true and
    `use_balsa_parser` is unset), then every non-empty method with only valid
    characters is accepted. Otherwise, methods not on the hard-coded list are
    rejected.
    Once UHV is enabled, this field should be removed, and BalsaParser should
    allow any method. UHV validates the method, rejecting empty string or
    invalid characters, and provides :ref:`restrict_http_methods
    <envoy_v3_api_field_extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig.restrict_http_methods>`
    to reject custom methods.
    """

    ignore_http_11_upgrade: "list[___type__matcher__v3__.StringMatcher]" = (
        betterproto2.field(11, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Ignore HTTP/1.1 upgrade values matching any of the supplied matchers.

    .. note::

      ``h2c`` upgrades are always removed for backwards compatibility, regardless of the
      value in this setting.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("use_balsa_parser"):
            warnings.warn(
                "Http1ProtocolOptions.use_balsa_parser is deprecated",
                DeprecationWarning,
            )


default_message_pool.register_message(
    "envoy.config.core.v3", "Http1ProtocolOptions", Http1ProtocolOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Http1ProtocolOptionsHeaderKeyFormat(betterproto2.Message):
    """
    [#next-free-field: 9]

    Oneofs:
        - header_format:
    """

    proper_case_words: "Http1ProtocolOptionsHeaderKeyFormatProperCaseWords | None" = (
        betterproto2.field(
            1, betterproto2.TYPE_MESSAGE, optional=True, group="header_format"
        )
    )
    """
    Formats the header by proper casing words: the first character and any character following
    a special character will be capitalized if it's an alpha character. For example,
    "content-type" becomes "Content-Type", and "foo$b#$are" becomes "Foo$B#$Are".
    Note that while this results in most headers following conventional casing, certain headers
    are not covered. For example, the "TE" header will be formatted as "Te".
    """

    stateful_formatter: "TypedExtensionConfig | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="header_format"
    )
    """
    Configuration for stateful formatter extensions that allow using received headers to
    affect the output of encoding headers. E.g., preserving case during proxying.
    [#extension-category: envoy.http.stateful_header_formatters]
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3",
    "Http1ProtocolOptions.HeaderKeyFormat",
    Http1ProtocolOptionsHeaderKeyFormat,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Http1ProtocolOptionsHeaderKeyFormatProperCaseWords(betterproto2.Message):
    pass


default_message_pool.register_message(
    "envoy.config.core.v3",
    "Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords",
    Http1ProtocolOptionsHeaderKeyFormatProperCaseWords,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Http2ProtocolOptions(betterproto2.Message):
    """
    [#next-free-field: 18]
    """

    hpack_table_size: "int | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    `Maximum table size <https://httpwg.org/specs/rfc7541.html#rfc.section.4.2>`_
    (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
    range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
    compression.
    """

    max_concurrent_streams: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    `Maximum concurrent streams <https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2>`_
    allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
    and defaults to 1024 for safety and should be sufficient for most use cases.

    For upstream connections, this also limits how many streams Envoy will initiate concurrently
    on a single connection. If the limit is reached, Envoy may queue requests or establish
    additional connections (as allowed per circuit breaker limits).

    This acts as an upper bound: Envoy will lower the max concurrent streams allowed on a given
    connection based on upstream settings. Config dumps will reflect the configured upper bound,
    not the per-connection negotiated limits.
    """

    initial_stream_window_size: "int | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    `Initial stream-level flow-control window
    <https://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2>`_ size. Valid values range from 65535
    (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to
    16MiB (16 * 1024 * 1024).

    .. note::

      65535 is the initial window size from HTTP/2 spec. We only support increasing the default window size now,
      so it's also the minimum.

    This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
    HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
    stop the flow of data to the codec buffers.
    """

    initial_connection_window_size: "int | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Similar to ``initial_stream_window_size``, but for connection-level flow-control
    window. The default is 24MiB (24 * 1024 * 1024).
    """

    allow_connect: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    Allows proxying Websocket and other upgrades over H2 connect.
    """

    allow_metadata: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)
    """
    [#not-implemented-hide:] Hiding until Envoy has full metadata support.
    Still under implementation. DO NOT USE.

    Allows sending and receiving HTTP/2 METADATA frames. See [metadata
    docs](https://github.com/envoyproxy/envoy/blob/main/source/docs/h2_metadata.md) for more
    information.
    """

    max_outbound_frames: "int | None" = betterproto2.field(
        7,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Limit the number of pending outbound downstream frames of all types (frames that are waiting to
    be written into the socket). Exceeding this limit triggers flood mitigation and connection is
    terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
    to flood mitigation. The default limit is 10000.
    """

    max_outbound_control_frames: "int | None" = betterproto2.field(
        8,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
    preventing high memory utilization when receiving continuous stream of these frames. Exceeding
    this limit triggers flood mitigation and connection is terminated. The
    ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
    mitigation. The default limit is 1000.
    """

    max_consecutive_inbound_frames_with_empty_payload: "int | None" = (
        betterproto2.field(
            9,
            betterproto2.TYPE_MESSAGE,
            unwrap=lambda: ____google__protobuf__.UInt32Value,
            optional=True,
        )
    )
    """
    Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
    empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
    might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
    stat tracks the number of connections terminated due to flood mitigation.
    Setting this to 0 will terminate connection upon receiving first frame with an empty payload
    and no end stream flag. The default limit is 1.
    """

    max_inbound_priority_frames_per_stream: "int | None" = betterproto2.field(
        10,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
    of PRIORITY frames received over the lifetime of connection exceeds the value calculated
    using this formula::

      ``max_inbound_priority_frames_per_stream`` * (1 + ``opened_streams``)

    the connection is terminated. For downstream connections the ``opened_streams`` is incremented when
    Envoy receives complete response headers from the upstream server. For upstream connection the
    ``opened_streams`` is incremented when Envoy send the HEADERS frame for a new stream. The
    ``http2.inbound_priority_frames_flood`` stat tracks
    the number of connections terminated due to flood mitigation. The default limit is 100.
    """

    max_inbound_window_update_frames_per_data_frame_sent: "int | None" = (
        betterproto2.field(
            11,
            betterproto2.TYPE_MESSAGE,
            unwrap=lambda: ____google__protobuf__.UInt32Value,
            optional=True,
        )
    )
    """
    Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
    of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
    using this formula::

      5 + 2 * (``opened_streams`` +
               ``max_inbound_window_update_frames_per_data_frame_sent`` * ``outbound_data_frames``)

    the connection is terminated. For downstream connections the ``opened_streams`` is incremented when
    Envoy receives complete response headers from the upstream server. For upstream connections the
    ``opened_streams`` is incremented when Envoy sends the HEADERS frame for a new stream. The
    ``http2.inbound_priority_frames_flood`` stat tracks the number of connections terminated due to
    flood mitigation. The default max_inbound_window_update_frames_per_data_frame_sent value is 10.
    Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
    but more complex implementations that try to estimate available bandwidth require at least 2.
    """

    stream_error_on_invalid_http_messaging: "bool" = betterproto2.field(
        12, betterproto2.TYPE_BOOL
    )
    """
    Allows invalid HTTP messaging and headers. When this option is disabled (default), then
    the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
    when this option is enabled, only the offending stream is terminated.

    This is overridden by HCM :ref:`stream_error_on_invalid_http_messaging
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`
    iff present.

    This is deprecated in favor of :ref:`override_stream_error_on_invalid_http_message
    <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message>`

    See `RFC7540, sec. 8.1 <https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
    """

    override_stream_error_on_invalid_http_message: "bool | None" = betterproto2.field(
        14,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    Allows invalid HTTP messaging and headers. When this option is disabled (default), then
    the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
    when this option is enabled, only the offending stream is terminated.

    This overrides any HCM :ref:`stream_error_on_invalid_http_messaging
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`

    See `RFC7540, sec. 8.1 <https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
    """

    custom_settings_parameters: "list[Http2ProtocolOptionsSettingsParameter]" = (
        betterproto2.field(13, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    [#not-implemented-hide:]
    Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:

    1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
    Envoy.

    2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
    'allow_connect'.

    Note that custom parameters specified through this field can not also be set in the
    corresponding named parameters:

    .. code-block:: text

      ID    Field Name
      ----------------
      0x1   hpack_table_size
      0x3   max_concurrent_streams
      0x4   initial_stream_window_size

    Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
    between custom parameters with the same identifier will trigger a failure.

    See `IANA HTTP/2 Settings
    <https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings>`_ for
    standardized identifiers.
    """

    connection_keepalive: "KeepaliveSettings | None" = betterproto2.field(
        15, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Send HTTP/2 PING frames to verify that the connection is still healthy. If the remote peer
    does not respond within the configured timeout, the connection will be aborted.
    """

    use_oghttp2_codec: "bool | None" = betterproto2.field(
        16,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    [#not-implemented-hide:] Hiding so that the field can be removed after oghttp2 is rolled out.
    If set, force use of a particular HTTP/2 codec: oghttp2 if true, nghttp2 if false.
    If unset, HTTP/2 codec is selected based on envoy.reloadable_features.http2_use_oghttp2.
    """

    max_metadata_size: "int | None" = betterproto2.field(
        17,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt64Value,
        optional=True,
    )
    """
    Configure the maximum amount of metadata than can be handled per stream. Defaults to 1 MB.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("stream_error_on_invalid_http_messaging"):
            warnings.warn(
                "Http2ProtocolOptions.stream_error_on_invalid_http_messaging is deprecated",
                DeprecationWarning,
            )


default_message_pool.register_message(
    "envoy.config.core.v3", "Http2ProtocolOptions", Http2ProtocolOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Http2ProtocolOptionsSettingsParameter(betterproto2.Message):
    """
    Defines a parameter to be sent in the SETTINGS frame.
    See `RFC7540, sec. 6.5.1 <https://tools.ietf.org/html/rfc7540#section-6.5.1>`_ for details.
    """

    identifier: "int | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The 16 bit parameter identifier.
    """

    value: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The 32 bit parameter value.
    """


default_message_pool.register_message(
    "envoy.config.core.v3",
    "Http2ProtocolOptions.SettingsParameter",
    Http2ProtocolOptionsSettingsParameter,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Http3ProtocolOptions(betterproto2.Message):
    """
    A message which allows using HTTP/3.
    [#next-free-field: 9]
    """

    quic_protocol_options: "QuicProtocolOptions | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    override_stream_error_on_invalid_http_message: "bool | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    Allows invalid HTTP messaging and headers. When this option is disabled (default), then
    the whole HTTP/3 connection is terminated upon receiving invalid HEADERS frame. However,
    when this option is enabled, only the offending stream is terminated.

    If set, this overrides any HCM :ref:`stream_error_on_invalid_http_messaging
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`.
    """

    allow_extended_connect: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    Allows proxying Websocket and other upgrades over HTTP/3 CONNECT using
    the header mechanisms from the `HTTP/2 extended connect RFC
    <https://datatracker.ietf.org/doc/html/rfc8441>`_
    and settings `proposed for HTTP/3
    <https://datatracker.ietf.org/doc/draft-ietf-httpbis-h3-websockets/>`_
    Note that HTTP/3 CONNECT is not yet an RFC.
    """

    allow_metadata: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)
    """
    [#not-implemented-hide:] Hiding until Envoy has full metadata support.
    Still under implementation. DO NOT USE.

    Allows sending and receiving HTTP/3 METADATA frames. See [metadata
    docs](https://github.com/envoyproxy/envoy/blob/main/source/docs/h2_metadata.md) for more
    information.
    """

    disable_qpack: "bool" = betterproto2.field(7, betterproto2.TYPE_BOOL)
    """
    [#not-implemented-hide:] Hiding until Envoy has full HTTP/3 upstream support.
    Still under implementation. DO NOT USE.

    Disables QPACK compression related features for HTTP/3 including:
    No huffman encoding, zero dynamic table capacity and no cookie crumbing.
    This can be useful for trading off CPU vs bandwidth when an upstream HTTP/3 connection multiplexes multiple downstream connections.
    """

    disable_connection_flow_control_for_streams: "bool" = betterproto2.field(
        8, betterproto2.TYPE_BOOL
    )
    """
    Disables connection level flow control for HTTP/3 streams. This is useful in situations where the streams share the same connection
    but originate from different end-clients, so that each stream can make progress independently at non-front-line proxies.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "Http3ProtocolOptions", Http3ProtocolOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpProtocolOptions(betterproto2.Message):
    """
    [#next-free-field: 8]
    """

    idle_timeout: "datetime.timedelta | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The idle timeout for connections. The idle timeout is defined as the
    period in which there are no active requests. When the
    idle timeout is reached the connection will be closed. If the connection is an HTTP/2
    downstream connection a drain sequence will occur prior to closing the connection, see
    :ref:`drain_timeout
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout>`.
    Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
    If not specified, this defaults to 1 hour. To disable idle timeouts explicitly set this to 0.

    .. warning::
      Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
      FIN packets, etc.

    If the :ref:`overload action <config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
    is configured, this timeout is scaled for downstream connections according to the value for
    :ref:`HTTP_DOWNSTREAM_CONNECTION_IDLE <envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_CONNECTION_IDLE>`.
    """

    max_connection_duration: "datetime.timedelta | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The maximum duration of a connection. The duration is defined as a period since a connection
    was established. If not set, there is no max duration. When max_connection_duration is reached,
    the drain sequence will kick-in. The connection will be closed after the drain timeout period
    if there are no active streams. See :ref:`drain_timeout
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout>`.
    """

    max_headers_count: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The maximum number of headers (request headers if configured on HttpConnectionManager,
    response headers when configured on a cluster).
    If unconfigured, the default maximum number of headers allowed is 100.
    The default value for requests can be overridden by setting runtime key ``envoy.reloadable_features.max_request_headers_count``.
    The default value for responses can be overridden by setting runtime key ``envoy.reloadable_features.max_response_headers_count``.
    Downstream requests that exceed this limit will receive a 431 response for HTTP/1.x and cause a stream
    reset for HTTP/2.
    Upstream responses that exceed this limit will result in a 502 response.
    """

    max_response_headers_kb: "int | None" = betterproto2.field(
        7,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The maximum size of response headers.
    If unconfigured, the default is 60 KiB, except for HTTP/1 response headers which have a default
    of 80KiB.
    The default value can be overridden by setting runtime key ``envoy.reloadable_features.max_response_headers_size_kb``.
    Responses that exceed this limit will result in a 503 response.
    In Envoy, this setting is only valid when configured on an upstream cluster, not on the
    :ref:`HTTP Connection Manager
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.common_http_protocol_options>`.

    .. note::

      Currently some protocol codecs impose limits on the maximum size of a single header.

      * HTTP/2 (when using nghttp2) limits a single header to around 100kb.
      * HTTP/3 limits a single header to around 1024kb.
    """

    max_stream_duration: "datetime.timedelta | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    Total duration to keep alive an HTTP request/response stream. If the time limit is reached the stream will be
    reset independent of any other timeouts. If not specified, this value is not set.
    """

    headers_with_underscores_action: "HttpProtocolOptionsHeadersWithUnderscoresAction" = betterproto2.field(
        5,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: HttpProtocolOptionsHeadersWithUnderscoresAction(0),
    )
    """
    Action to take when a client request with a header name containing underscore characters is received.
    If this setting is not specified, the value defaults to ALLOW.

    .. note::

      Upstream responses are not affected by this setting.

    .. note::

      This only affects client headers. It does not affect headers added by Envoy filters and does not have any
      impact if added to cluster config.
    """

    max_requests_per_connection: "int | None" = betterproto2.field(
        6,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Optional maximum requests for both upstream and downstream connections.
    If not specified, there is no limit.
    Setting this parameter to 1 will effectively disable keep alive.
    For HTTP/2 and HTTP/3, due to concurrent stream processing, the limit is approximate.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "HttpProtocolOptions", HttpProtocolOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpService(betterproto2.Message):
    """
    [#protodoc-title: HTTP services]

    HTTP service configuration.
    """

    http_uri: "HttpUri | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The service's HTTP URI. For example:

    .. code-block:: yaml

       http_uri:
         uri: https://www.myserviceapi.com/v1/data
         cluster: www.myserviceapi.com|443
    """

    request_headers_to_add: "list[HeaderValueOption]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies a list of HTTP headers that should be added to each request
    handled by this virtual host.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "HttpService", HttpService
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpUri(betterproto2.Message):
    """
    [#protodoc-title: HTTP service URI ]

    Envoy external URI descriptor

    Oneofs:
        - http_upstream_type: Specify how ``uri`` is to be fetched. Today, this requires an explicit
            cluster, but in the future we may support dynamic cluster creation or
            inline DNS resolution. See `issue
            <https://github.com/envoyproxy/envoy/issues/1606>`_.
    """

    uri: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The HTTP server URI. It should be a full FQDN with protocol, host and path.

    Example:

    .. code-block:: yaml

       uri: https://www.googleapis.com/oauth2/v1/certs
    """

    cluster: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="http_upstream_type"
    )
    """
    A cluster is created in the Envoy "cluster_manager" config
    section. This field specifies the cluster name.

    Example:

    .. code-block:: yaml

       cluster: jwks_cluster
    """

    timeout: "datetime.timedelta | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    Sets the maximum duration in milliseconds that a response can take to arrive upon request.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.config.core.v3", "HttpUri", HttpUri)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class JsonFormatOptions(betterproto2.Message):
    """
    [#protodoc-title: Substitution format string]

    Optional configuration options to be used with json_format.
    """

    sort_properties: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)
    """
    The output JSON string properties will be sorted.

    .. note::
      As the properties are always sorted, this option has no effect and is deprecated.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("sort_properties"):
            warnings.warn(
                "JsonFormatOptions.sort_properties is deprecated", DeprecationWarning
            )


default_message_pool.register_message(
    "envoy.config.core.v3", "JsonFormatOptions", JsonFormatOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class KeepaliveSettings(betterproto2.Message):
    interval: "datetime.timedelta | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    Send HTTP/2 PING frames at this period, in order to test that the connection is still alive.
    If this is zero, interval PINGs will not be sent.
    """

    timeout: "datetime.timedelta | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    How long to wait for a response to a keepalive PING. If a response is not received within this
    time period, the connection will be aborted. Note that in order to prevent the influence of
    Head-of-line (HOL) blocking the timeout period is extended when *any* frame is received on
    the connection, under the assumption that if a frame is received the connection is healthy.
    """

    interval_jitter: "___type__v3__.Percent | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A random jitter amount as a percentage of interval that will be added to each interval.
    A value of zero means there will be no jitter.
    The default value is 15%.
    """

    connection_idle_interval: "datetime.timedelta | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    If the connection has been idle for this duration, send a HTTP/2 ping ahead
    of new stream creation, to quickly detect dead connections.
    If this is zero, this type of PING will not be sent.
    If an interval ping is outstanding, a second ping will not be sent as the
    interval ping will determine if the connection is dead.

    The same feature for HTTP/3 is given by inheritance from QUICHE which uses :ref:`connection idle_timeout <envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout>` and the current PTO of the connection to decide whether to probe before sending a new request.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "KeepaliveSettings", KeepaliveSettings
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class KeyValue(betterproto2.Message):
    """
    Please use :ref:`KeyValuePair <envoy_api_msg_config.core.v3.KeyValuePair>` instead.
    [#not-implemented-hide:]
    """

    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The key of the key/value pair.
    """

    value: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)
    """
    The value of the key/value pair.

    The ``bytes`` type is used. This means if JSON or YAML is used to to represent the
    configuration, the value must be base64 encoded. This is unfriendly for users in most
    use scenarios of this message.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("key"):
            warnings.warn("KeyValue.key is deprecated", DeprecationWarning)
        if self.is_set("value"):
            warnings.warn("KeyValue.value is deprecated", DeprecationWarning)


default_message_pool.register_message("envoy.config.core.v3", "KeyValue", KeyValue)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class KeyValueAppend(betterproto2.Message):
    """
    Key/value pair plus option to control append behavior. This is used to specify
    key/value pairs that should be appended to a set of existing key/value pairs.
    """

    record: "KeyValuePair | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The single key/value pair record to be appended or overridden. This field must be set.
    """

    entry: "KeyValue | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Key/value pair entry that this option to append or overwrite. This field is deprecated
    and please use :ref:`record <envoy_v3_api_field_config.core.v3.KeyValueAppend.record>`
    as replacement.
    [#not-implemented-hide:]
    """

    action: "KeyValueAppendKeyValueAppendAction" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: KeyValueAppendKeyValueAppendAction(0),
    )
    """
    Describes the action taken to append/overwrite the given value for an existing
    key or to only add this key if it's absent.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("entry"):
            warnings.warn("KeyValueAppend.entry is deprecated", DeprecationWarning)


default_message_pool.register_message(
    "envoy.config.core.v3", "KeyValueAppend", KeyValueAppend
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class KeyValueMutation(betterproto2.Message):
    """
    Key/value pair to append or remove.
    """

    append: "KeyValueAppend | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Key/value pair to append or overwrite. Only one of ``append`` or ``remove`` can be set or
    the configuration will be rejected.
    """

    remove: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Key to remove. Only one of ``append`` or ``remove`` can be set or the configuration will be
    rejected.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "KeyValueMutation", KeyValueMutation
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class KeyValuePair(betterproto2.Message):
    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The key of the key/value pair.
    """

    value: "____google__protobuf__.Value | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The value of the key/value pair.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "KeyValuePair", KeyValuePair
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Locality(betterproto2.Message):
    """
    Identifies location of where either Envoy runs or where upstream hosts run.
    """

    region: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Region this :ref:`zone <envoy_v3_api_field_config.core.v3.Locality.zone>` belongs to.
    """

    zone: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Defines the local service zone where Envoy is running. Though optional, it
    should be set if discovery service routing is used and the discovery
    service exposes :ref:`zone data <envoy_v3_api_field_config.endpoint.v3.LocalityLbEndpoints.locality>`,
    either in this message or via :option:`--service-zone`. The meaning of zone
    is context dependent, e.g. `Availability Zone (AZ)
    <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html>`_
    on AWS, `Zone <https://cloud.google.com/compute/docs/regions-zones/>`_ on
    GCP, etc.
    """

    sub_zone: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    When used for locality of upstream hosts, this field further splits zone
    into smaller chunks of sub-zones so they can be load balanced
    independently.
    """


default_message_pool.register_message("envoy.config.core.v3", "Locality", Locality)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Metadata(betterproto2.Message):
    """
    Metadata provides additional inputs to filters based on matched listeners,
    filter chains, routes and endpoints. It is structured as a map, usually from
    filter name (in reverse DNS format) to metadata specific to the filter. Metadata
    key-values for a filter are merged as connection and request handling occurs,
    with later values for the same key overriding earlier values.

    An example use of metadata is providing additional values to
    http_connection_manager in the envoy.http_connection_manager.access_log
    namespace.

    Another example use of metadata is to per service config info in cluster metadata, which may get
    consumed by multiple filters.

    For load balancing, Metadata provides a means to subset cluster endpoints.
    Endpoints have a Metadata object associated and routes contain a Metadata
    object to match against. There are some well defined metadata used today for
    this purpose:

    * ``{"envoy.lb": {"canary": <bool> }}`` This indicates the canary status of an
      endpoint and is also used during header processing
      (x-envoy-upstream-canary) and for stats purposes.
    [#next-major-version: move to type/metadata/v2]
    """

    filter_metadata: "dict[str, ____google__protobuf__.Struct]" = betterproto2.field(
        1,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
        ),
    )
    """
    Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*``
    namespace is reserved for Envoy's built-in filters.
    If both ``filter_metadata`` and
    :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>`
    fields are present in the metadata with same keys,
    only ``typed_filter_metadata`` field will be parsed.
    """

    typed_filter_metadata: "dict[str, ____google__protobuf__.Any]" = betterproto2.field(
        2,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
        ),
    )
    """
    Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*``
    namespace is reserved for Envoy's built-in filters.
    The value is encoded as google.protobuf.Any.
    If both :ref:`filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.filter_metadata>`
    and ``typed_filter_metadata`` fields are present in the metadata with same keys,
    only ``typed_filter_metadata`` field will be parsed.
    """


default_message_pool.register_message("envoy.config.core.v3", "Metadata", Metadata)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Node(betterproto2.Message):
    """
    Identifies a specific Envoy instance. The node identifier is presented to the
    management server, which may use this identifier to distinguish per Envoy
    configuration for serving.
    [#next-free-field: 13]

    Oneofs:
        - user_agent_version_type:
    """

    id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    An opaque node identifier for the Envoy node. This also provides the local
    service node name. It should be set if any of the following features are
    used: :ref:`statsd <arch_overview_statistics>`, :ref:`CDS
    <config_cluster_manager_cds>`, and :ref:`HTTP tracing
    <arch_overview_tracing>`, either in this message or via
    :option:`--service-node`.
    """

    cluster: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Defines the local service cluster name where Envoy is running. Though
    optional, it should be set if any of the following features are used:
    :ref:`statsd <arch_overview_statistics>`, :ref:`health check cluster
    verification
    <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.service_name_matcher>`,
    :ref:`runtime override directory <envoy_v3_api_msg_config.bootstrap.v3.Runtime>`,
    :ref:`user agent addition
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.add_user_agent>`,
    :ref:`HTTP global rate limiting <config_http_filters_rate_limit>`,
    :ref:`CDS <config_cluster_manager_cds>`, and :ref:`HTTP tracing
    <arch_overview_tracing>`, either in this message or via
    :option:`--service-cluster`.
    """

    metadata: "____google__protobuf__.Struct | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Opaque metadata extending the node identifier. Envoy will pass this
    directly to the management server.
    """

    dynamic_parameters: "dict[str, ____xds__core__v3__.ContextParams]" = (
        betterproto2.field(
            12,
            betterproto2.TYPE_MAP,
            map_meta=betterproto2.map_meta(
                betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
            ),
        )
    )
    """
    Map from xDS resource type URL to dynamic context parameters. These may vary at runtime (unlike
    other fields in this message). For example, the xDS client may have a shard identifier that
    changes during the lifetime of the xDS client. In Envoy, this would be achieved by updating the
    dynamic context on the Server::Instance's LocalInfo context provider. The shard ID dynamic
    parameter then appears in this field during future discovery requests.
    """

    locality: "Locality | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Locality specifying where the Envoy instance is running.
    """

    user_agent_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        6, betterproto2.TYPE_STRING
    )
    """
    Free-form string that identifies the entity requesting config.
    E.g. "envoy" or "grpc"
    """

    user_agent_version: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        7, betterproto2.TYPE_STRING, optional=True, group="user_agent_version_type"
    )
    """
    Free-form string that identifies the version of the entity requesting config.
    E.g. "1.12.2" or "abcd1234", or "SpecialEnvoyBuild"
    """

    user_agent_build_version: "BuildVersion | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="user_agent_version_type"
    )
    """
    Structured version of the entity requesting config.
    """

    extensions: "list[Extension]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of extensions and their versions supported by the node.
    """

    client_features: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        10, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Client feature support list. These are well known features described
    in the Envoy API repository for a given major version of an API. Client features
    use reverse DNS naming scheme, for example ``com.acme.feature``.
    See :ref:`the list of features <client_features>` that xDS client may
    support.
    """

    listening_addresses: "list[Address]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Known listening ports on the node as a generic hint to the management server
    for filtering :ref:`listeners <config_listeners>` to be returned. For example,
    if there is a listener bound to port 80, the list can optionally contain the
    SocketAddress ``(0.0.0.0,80)``. The field is optional and just a hint.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("listening_addresses"):
            warnings.warn("Node.listening_addresses is deprecated", DeprecationWarning)

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.config.core.v3", "Node", Node)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PathConfigSource(betterproto2.Message):
    """
    Local filesystem path configuration source.
    """

    path: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Path on the filesystem to source and watch for configuration updates.
    When sourcing configuration for a :ref:`secret <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.Secret>`,
    the certificate and key files are also watched for updates.

    .. note::

     The path to the source must exist at config load time.

    .. note::

      If ``watched_directory`` is *not* configured, Envoy will watch the file path for *moves*.
      This is because in general only moves are atomic. The same method of swapping files as is
      demonstrated in the :ref:`runtime documentation <config_runtime_symbolic_link_swap>` can be
      used here also. If ``watched_directory`` is configured, no watch will be placed directly on
      this path. Instead, the configured ``watched_directory`` will be used to trigger reloads of
      this path. This is required in certain deployment scenarios. See below for more information.
    """

    watched_directory: "WatchedDirectory | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If configured, this directory will be watched for *moves*. When an entry in this directory is
    moved to, the ``path`` will be reloaded. This is required in certain deployment scenarios.

    Specifically, if trying to load an xDS resource using a
    `Kubernetes ConfigMap <https://kubernetes.io/docs/concepts/configuration/configmap/>`_, the
    following configuration might be used:
    1. Store xds.yaml inside a ConfigMap.
    2. Mount the ConfigMap to ``/config_map/xds``
    3. Configure path ``/config_map/xds/xds.yaml``
    4. Configure watched directory ``/config_map/xds``

    The above configuration will ensure that Envoy watches the owning directory for moves which is
    required due to how Kubernetes manages ConfigMap symbolic links during atomic updates.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "PathConfigSource", PathConfigSource
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PerHostConfig(betterproto2.Message):
    added_tlvs: "list[TlvEntry]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Enables per-host configuration for Proxy Protocol.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "PerHostConfig", PerHostConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Pipe(betterproto2.Message):
    """
    [#protodoc-title: Network addresses]
    """

    path: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Unix Domain Socket path. On Linux, paths starting with '@' will use the
    abstract namespace. The starting '@' is replaced by a null byte by Envoy.
    Paths starting with '@' will result in an error in environments other than
    Linux.
    """

    mode: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32)
    )
    """
    The mode for the Pipe. Not applicable for abstract sockets.
    """


default_message_pool.register_message("envoy.config.core.v3", "Pipe", Pipe)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ProxyProtocolConfig(betterproto2.Message):
    version: "ProxyProtocolConfigVersion" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: ProxyProtocolConfigVersion(0)
    )
    """
    The PROXY protocol version to use. See https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt for details
    """

    pass_through_tlvs: "ProxyProtocolPassThroughTlVs | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    This config controls which TLVs can be passed to upstream if it is Proxy Protocol
    V2 header. If there is no setting for this field, no TLVs will be passed through.
    """

    added_tlvs: "list[TlvEntry]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    This config allows additional TLVs to be included in the upstream PROXY protocol
    V2 header. Unlike ``pass_through_tlvs``, which passes TLVs from the downstream request,
    ``added_tlvs`` provides an extension mechanism for defining new TLVs that are included
    with the upstream request. These TLVs may not be present in the downstream request and
    can be defined at either the transport socket level or the host level to provide more
    granular control over the TLVs that are included in the upstream request.

    Host-level TLVs are specified in the ``metadata.typed_filter_metadata`` field under the
    ``envoy.transport_sockets.proxy_protocol`` namespace.

    .. literalinclude:: /_configs/repo/proxy_protocol.yaml
       :language: yaml
       :lines: 49-57
       :linenos:
       :lineno-start: 49
       :caption: :download:`proxy_protocol.yaml </_configs/repo/proxy_protocol.yaml>`

    **Precedence behavior**:

    - When a TLV is defined at both the host level and the transport socket level, the value
      from the host level configuration takes precedence. This allows users to define default TLVs
      at the transport socket level and override them at the host level.
    - Any TLV defined in the ``pass_through_tlvs`` field will be overridden by either the host-level
      or transport socket-level TLV.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "ProxyProtocolConfig", ProxyProtocolConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ProxyProtocolPassThroughTlVs(betterproto2.Message):
    """
    [#protodoc-title: Proxy protocol]
    """

    match_type: "ProxyProtocolPassThroughTlVsPassTlVsMatchType" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ProxyProtocolPassThroughTlVsPassTlVsMatchType(0),
    )
    """
    The strategy to pass through TLVs. Default is INCLUDE_ALL.
    If INCLUDE_ALL is set, all TLVs will be passed through no matter the tlv_type field.
    """

    tlv_type: "list[typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32, repeated=True)
    )
    """
    The TLV types that are applied based on match_type.
    TLV type is defined as uint8_t in proxy protocol. See `the spec
    <https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt>`_ for details.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "ProxyProtocolPassThroughTLVs", ProxyProtocolPassThroughTlVs
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class QueryParameter(betterproto2.Message):
    """
    Query parameter name/value pair.
    """

    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The key of the query parameter. Case sensitive.
    """

    value: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The value of the query parameter.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "QueryParameter", QueryParameter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class QuicKeepAliveSettings(betterproto2.Message):
    """
    Config for keepalive probes in a QUIC connection.
    Note that QUIC keep-alive probing packets work differently from HTTP/2 keep-alive PINGs in a sense that the probing packet
    itself doesn't timeout waiting for a probing response. Quic has a shorter idle timeout than TCP, so it doesn't rely on such probing to discover dead connections. If the peer fails to respond, the connection will idle timeout eventually. Thus, they are configured differently from :ref:`connection_keepalive <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.connection_keepalive>`.
    """

    max_interval: "datetime.timedelta | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout <envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout>` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.

    If :ref:`initial_interval <envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval>` is absent or zero, a client connection will use this value to start probing.

    If zero, disable keepalive probing.
    If absent, use the QUICHE default interval to probe.
    """

    initial_interval: "datetime.timedelta | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval <envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval>`. And the probes afterwards will always use :ref:`max_interval <envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval>`.

    The value should be smaller than :ref:`connection idle_timeout <envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout>` to prevent idle timeout and smaller than max_interval to take effect.

    If absent, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval <envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval>` is zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "QuicKeepAliveSettings", QuicKeepAliveSettings
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class QuicProtocolOptions(betterproto2.Message):
    """
    QUIC protocol options which apply to both downstream and upstream connections.
    [#next-free-field: 10]
    """

    max_concurrent_streams: "int | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Maximum number of streams that the client can negotiate per connection. 100
    if not specified.
    """

    initial_stream_window_size: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    `Initial stream-level flow-control receive window
    <https://tools.ietf.org/html/draft-ietf-quic-transport-34#section-4.1>`_ size. Valid values range from
    1 to 16777216 (2^24, maximum supported by QUICHE) and defaults to 16777216 (16 * 1024 * 1024).

    .. note::

      16384 (2^14) is the minimum window size supported in Google QUIC. If configured smaller than it, we will use
      16384 instead. QUICHE IETF Quic implementation supports 1 bytes window. We only support increasing the default
      window size now, so it's also the minimum.

    This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
    QUIC stream send and receive buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
    stop the flow of data to the stream buffers.
    """

    initial_connection_window_size: "int | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Similar to ``initial_stream_window_size``, but for connection-level
    flow-control. Valid values range from 1 to 25165824 (24MB, maximum supported by QUICHE) and defaults
    to 25165824 (24 * 1024 * 1024).

    .. note::

      16384 (2^14) is the minimum window size supported in Google QUIC. We only support increasing the default
      window size now, so it's also the minimum.
    """

    num_timeouts_to_trigger_port_migration: "int | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The number of timeouts that can occur before port migration is triggered for QUIC clients.
    This defaults to 4. If set to 0, port migration will not occur on path degrading.
    Timeout here refers to QUIC internal path degrading timeout mechanism, such as PTO.
    This has no effect on server sessions.
    """

    connection_keepalive: "QuicKeepAliveSettings | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Probes the peer at the configured interval to solicit traffic, i.e. ACK or PATH_RESPONSE, from the peer to push back connection idle timeout.
    If absent, use the default keepalive behavior of which a client connection sends PINGs every 15s, and a server connection doesn't do anything.
    """

    connection_options: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        6, betterproto2.TYPE_STRING
    )
    """
    A comma-separated list of strings representing QUIC connection options defined in
    `QUICHE <https://github.com/google/quiche/blob/main/quiche/quic/core/crypto/crypto_protocol.h>`_ and to be sent by upstream connections.
    """

    client_connection_options: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        7, betterproto2.TYPE_STRING
    )
    """
    A comma-separated list of strings representing QUIC client connection options defined in
    `QUICHE <https://github.com/google/quiche/blob/main/quiche/quic/core/crypto/crypto_protocol.h>`_ and to be sent by upstream connections.
    """

    idle_network_timeout: "datetime.timedelta | None" = betterproto2.field(
        8,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The duration that a QUIC connection stays idle before it closes itself. If this field is not present, QUICHE
    default 600s will be applied.
    For internal corporate network, a long timeout is often fine.
    But for client facing network, 30s is usually a good choice.
    Do not add an upper bound here. A long idle timeout is useful for maintaining warm connections at non-front-line proxy for low QPS services."
    """

    max_packet_length: "int | None" = betterproto2.field(
        9,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt64Value,
        optional=True,
    )
    """
    Maximum packet length for QUIC connections. It refers to the largest size of a QUIC packet that can be transmitted over the connection.
    If not specified, one of the `default values in QUICHE <https://github.com/google/quiche/blob/main/quiche/quic/core/quic_constants.h>`_ is used.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "QuicProtocolOptions", QuicProtocolOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RateLimitSettings(betterproto2.Message):
    """
    Rate Limit settings to be applied for discovery requests made by Envoy.
    """

    max_tokens: "int | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Maximum number of tokens to be used for rate limiting discovery request calls. If not set, a
    default value of 100 will be used.
    """

    fill_rate: "float | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.DoubleValue,
        optional=True,
    )
    """
    Rate at which tokens will be filled per second. If not set, a default fill rate of 10 tokens
    per second will be used. The minimal fill rate is once per year. Lower
    fill rates will be set to once per year.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "RateLimitSettings", RateLimitSettings
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RemoteDataSource(betterproto2.Message):
    """
    The message specifies how to fetch data from remote and how to verify it.
    """

    http_uri: "HttpUri | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The HTTP URI to fetch the remote data.
    """

    sha256: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    SHA256 string for verifying data.
    """

    retry_policy: "RetryPolicy | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Retry policy for fetching remote data.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "RemoteDataSource", RemoteDataSource
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RetryPolicy(betterproto2.Message):
    """
    The message specifies the retry policy of remote data source when fetching fails.
    [#next-free-field: 7]
    """

    retry_back_off: "BackoffStrategy | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Specifies parameters that control :ref:`retry backoff strategy <envoy_v3_api_msg_config.core.v3.BackoffStrategy>`.
    This parameter is optional, in which case the default base interval is 1000 milliseconds. The
    default maximum interval is 10 times the base interval.
    """

    num_retries: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Specifies the allowed number of retries. This parameter is optional and
    defaults to 1.
    """

    retry_on: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    For details, see :ref:`retry_on <envoy_v3_api_field_config.route.v3.RetryPolicy.retry_on>`.
    """

    retry_priority: "RetryPolicyRetryPriority | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    For details, see :ref:`retry_priority <envoy_v3_api_field_config.route.v3.RetryPolicy.retry_priority>`.
    """

    retry_host_predicate: "list[RetryPolicyRetryHostPredicate]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    For details, see :ref:`RetryHostPredicate <envoy_v3_api_field_config.route.v3.RetryPolicy.retry_host_predicate>`.
    """

    host_selection_retry_max_attempts: "typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)]" = betterproto2.field(
        6, betterproto2.TYPE_INT64
    )
    """
    For details, see :ref:`host_selection_retry_max_attempts <envoy_v3_api_field_config.route.v3.RetryPolicy.host_selection_retry_max_attempts>`.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "RetryPolicy", RetryPolicy
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RetryPolicyRetryHostPredicate(betterproto2.Message):
    """
    See :ref:`RetryHostPredicate <envoy_v3_api_field_config.route.v3.RetryPolicy.retry_host_predicate>`.

    Oneofs:
        - config_type:
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    typed_config: "____google__protobuf__.Any | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="config_type"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3",
    "RetryPolicy.RetryHostPredicate",
    RetryPolicyRetryHostPredicate,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RetryPolicyRetryPriority(betterproto2.Message):
    """
    See :ref:`RetryPriority <envoy_v3_api_field_config.route.v3.RetryPolicy.retry_priority>`.

    Oneofs:
        - config_type:
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    typed_config: "____google__protobuf__.Any | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="config_type"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3", "RetryPolicy.RetryPriority", RetryPolicyRetryPriority
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RuntimeDouble(betterproto2.Message):
    """
    Runtime derived double with a default when not specified.
    """

    default_value: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Default value if runtime value is not available.
    """

    runtime_key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Runtime key to get value for comparison. This value is used if defined.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "RuntimeDouble", RuntimeDouble
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RuntimeFeatureFlag(betterproto2.Message):
    """
    Runtime derived bool with a default when not specified.
    """

    default_value: "bool | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    Default value if runtime value is not available.
    """

    runtime_key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Runtime key to get value for comparison. This value is used if defined. The boolean value must
    be represented via its
    `canonical JSON encoding <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "RuntimeFeatureFlag", RuntimeFeatureFlag
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RuntimeFractionalPercent(betterproto2.Message):
    """
    Runtime derived FractionalPercent with defaults for when the numerator or denominator is not
    specified via a runtime key.

    .. note::

      Parsing of the runtime key's data is implemented such that it may be represented as a
      :ref:`FractionalPercent <envoy_v3_api_msg_type.v3.FractionalPercent>` proto represented as JSON/YAML
      and may also be represented as an integer with the assumption that the value is an integral
      percentage out of 100. For instance, a runtime key lookup returning the value "42" would parse
      as a ``FractionalPercent`` whose numerator is 42 and denominator is HUNDRED.
    """

    default_value: "___type__v3__.FractionalPercent | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Default value if the runtime value's for the numerator/denominator keys are not available.
    """

    runtime_key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Runtime key for a YAML representation of a FractionalPercent.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "RuntimeFractionalPercent", RuntimeFractionalPercent
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RuntimePercent(betterproto2.Message):
    """
    Runtime derived percentage with a default when not specified.
    """

    default_value: "___type__v3__.Percent | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Default value if runtime value is not available.
    """

    runtime_key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Runtime key to get value for comparison. This value is used if defined.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "RuntimePercent", RuntimePercent
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RuntimeUInt32(betterproto2.Message):
    """
    Runtime derived uint32 with a default when not specified.
    """

    default_value: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32)
    )
    """
    Default value if runtime value is not available.
    """

    runtime_key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    Runtime key to get value for comparison. This value is used if defined.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "RuntimeUInt32", RuntimeUInt32
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SchemeHeaderTransformation(betterproto2.Message):
    """
    A message to control transformations to the :scheme header

    Oneofs:
        - transformation:
    """

    scheme_to_overwrite: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="transformation"
    )
    """
    Overwrite any Scheme header with the contents of this string.
    If set, takes precedence over match_upstream.
    """

    match_upstream: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)
    """
    Set the Scheme header to match the upstream transport protocol. For example, should a
    request be sent to the upstream over TLS, the scheme header will be set to "https". Should the
    request be sent over plaintext, the scheme header will be set to "http".
    If scheme_to_overwrite is set, this field is not used.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3", "SchemeHeaderTransformation", SchemeHeaderTransformation
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SelfConfigSource(betterproto2.Message):
    """
    [#not-implemented-hide:]
    Self-referencing config source options. This is currently empty, but when
    set in :ref:`ConfigSource <envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
    specify that other data can be obtained from the same server.
    """

    transport_api_version: "ApiVersion" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: ApiVersion(0)
    )
    """
    API version for xDS transport protocol. This describes the xDS gRPC/REST
    endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "SelfConfigSource", SelfConfigSource
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketAddress(betterproto2.Message):
    """
    [#next-free-field: 8]

    Oneofs:
        - port_specifier:
    """

    protocol: "SocketAddressProtocol" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: SocketAddressProtocol(0)
    )

    address: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The address for this socket. :ref:`Listeners <config_listeners>` will bind
    to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::``
    to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:
    It is possible to distinguish a Listener address via the prefix/suffix matching
    in :ref:`FilterChainMatch <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>`.] When used
    within an upstream :ref:`BindConfig <envoy_v3_api_msg_config.core.v3.BindConfig>`, the address
    controls the source address of outbound connections. For :ref:`clusters
    <envoy_v3_api_msg_config.cluster.v3.Cluster>`, the cluster type determines whether the
    address must be an IP (``STATIC`` or ``EDS`` clusters) or a hostname resolved by DNS
    (``STRICT_DNS`` or ``LOGICAL_DNS`` clusters). Address resolution can be customized
    via :ref:`resolver_name <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>`.
    """

    port_value: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)] | None" = (
        betterproto2.field(
            3, betterproto2.TYPE_UINT32, optional=True, group="port_specifier"
        )
    )

    named_port: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True, group="port_specifier"
    )
    """
    This is only valid if :ref:`resolver_name
    <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>` is specified below and the
    named resolver is capable of named port resolution.
    """

    resolver_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )
    """
    The name of the custom resolver. This must have been registered with Envoy. If
    this is empty, a context dependent default applies. If the address is a concrete
    IP address, no resolution will occur. If address is a hostname this
    should be set for resolution other than DNS. Specifying a custom resolver with
    ``STRICT_DNS`` or ``LOGICAL_DNS`` will generate an error at runtime.
    """

    ipv4_compat: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)
    """
    When binding to an IPv6 address above, this enables `IPv4 compatibility
    <https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to ``::`` will
    allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
    IPv6 space as ``::FFFF:<IPv4-address>``.
    """

    network_namespace_filepath: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        7, betterproto2.TYPE_STRING
    )
    """
    Filepath that specifies the Linux network namespace this socket will be created in (see ``man 7
    network_namespaces``). If this field is set, Envoy will create the socket in the specified
    network namespace.

    .. note::
       Setting this parameter requires Envoy to run with the ``CAP_NET_ADMIN`` capability.

    .. attention::
        Network namespaces are only configurable on Linux. Otherwise, this field has no effect.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3", "SocketAddress", SocketAddress
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketCmsgHeaders(betterproto2.Message):
    """
    [#protodoc-title: Socket CMSG headers]

    Configuration for socket cmsg headers.
    See `:ref:CMSG <https://man7.org/linux/man-pages/man3/cmsg.3.html>`_ for further information.
    """

    level: "int | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    cmsg level. Default is unset.
    """

    type: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    cmsg type. Default is unset.
    """

    expected_size: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT32)
    )
    """
    Expected size of cmsg value. Default is zero.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "SocketCmsgHeaders", SocketCmsgHeaders
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketOption(betterproto2.Message):
    """
    [#protodoc-title: Socket option]

    Generic socket option message. This would be used to set socket options that
    might not exist in upstream kernels or precompiled Envoy binaries.

    For example:

    .. code-block:: json

     {
       "description": "support tcp keep alive",
       "state": 0,
       "level": 1,
       "name": 9,
       "int_value": 1,
     }

    1 means SOL_SOCKET and 9 means SO_KEEPALIVE on Linux.
    With the above configuration, `TCP Keep-Alives <https://www.freesoft.org/CIE/RFC/1122/114.htm>`_
    can be enabled in socket with Linux, which can be used in
    :ref:`listener's<envoy_v3_api_field_config.listener.v3.Listener.socket_options>` or
    :ref:`admin's <envoy_v3_api_field_config.bootstrap.v3.Admin.socket_options>` socket_options etc.

    It should be noted that the name or level may have different values on different platforms.
    [#next-free-field: 8]

    Oneofs:
        - value:
    """

    description: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    An optional name to give this socket option for debugging, etc.
    Uniqueness is not required and no special meaning is assumed.
    """

    level: "typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_INT64)
    )
    """
    Corresponding to the level value passed to setsockopt, such as IPPROTO_TCP
    """

    name: "typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_INT64)
    )
    """
    The numeric name as passed to setsockopt
    """

    int_value: "typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)] | None" = betterproto2.field(
        4, betterproto2.TYPE_INT64, optional=True, group="value"
    )
    """
    Because many sockopts take an int value.
    """

    buf_value: "bytes | None" = betterproto2.field(
        5, betterproto2.TYPE_BYTES, optional=True, group="value"
    )
    """
    Otherwise it's a byte buffer.
    """

    state: "SocketOptionSocketState" = betterproto2.field(
        6, betterproto2.TYPE_ENUM, default_factory=lambda: SocketOptionSocketState(0)
    )
    """
    The state in which the option will be applied. When used in BindConfig
    STATE_PREBIND is currently the only valid value.
    """

    type: "SocketOptionSocketType | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Apply the socket option to the specified `socket type <https://linux.die.net/man/2/socket>`_.
    If not specified, the socket option will be applied to all socket types.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3", "SocketOption", SocketOption
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketOptionSocketType(betterproto2.Message):
    """
    The `socket type <https://linux.die.net/man/2/socket>`_ to apply the socket option to.
    Only one field should be set. If multiple fields are set, the precedence order will determine
    the selected one. If none of the fields is set, the socket option will be applied to all socket types.

    For example:
    If :ref:`stream <envoy_v3_api_field_config.core.v3.SocketOption.SocketType.stream>` is set,
    it takes precedence over :ref:`datagram <envoy_v3_api_field_config.core.v3.SocketOption.SocketType.datagram>`.
    """

    stream: "SocketOptionSocketTypeStream | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Apply the socket option to the stream socket type.
    """

    datagram: "SocketOptionSocketTypeDatagram | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Apply the socket option to the datagram socket type.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "SocketOption.SocketType", SocketOptionSocketType
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketOptionSocketTypeDatagram(betterproto2.Message):
    """
    The datagram socket type.
    """

    pass


default_message_pool.register_message(
    "envoy.config.core.v3",
    "SocketOption.SocketType.Datagram",
    SocketOptionSocketTypeDatagram,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketOptionSocketTypeStream(betterproto2.Message):
    """
    The stream socket type.
    """

    pass


default_message_pool.register_message(
    "envoy.config.core.v3",
    "SocketOption.SocketType.Stream",
    SocketOptionSocketTypeStream,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SocketOptionsOverride(betterproto2.Message):
    socket_options: "list[SocketOption]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.config.core.v3", "SocketOptionsOverride", SocketOptionsOverride
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SubstitutionFormatString(betterproto2.Message):
    """
    Configuration to use multiple :ref:`command operators <config_access_log_command_operators>`
    to generate a new string in either plain text or JSON format.
    [#next-free-field: 8]

    Oneofs:
        - format:
    """

    text_format: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="format"
    )
    """
    Specify a format with command operators to form a text string.
    Its details is described in :ref:`format string<config_access_log_format_strings>`.

    For example, setting ``text_format`` like below,

    .. validated-code-block:: yaml
      :type-name: envoy.config.core.v3.SubstitutionFormatString

      text_format: "%LOCAL_REPLY_BODY%:%RESPONSE_CODE%:path=%REQ(:path)%\\n"

    generates plain text similar to:

    .. code-block:: text

      upstream connect error:503:path=/foo

    Deprecated in favor of :ref:`text_format_source <envoy_v3_api_field_config.core.v3.SubstitutionFormatString.text_format_source>`. To migrate text format strings, use the :ref:`inline_string <envoy_v3_api_field_config.core.v3.DataSource.inline_string>` field.
    """

    json_format: "____google__protobuf__.Struct | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="format"
    )
    """
    Specify a format with command operators to form a JSON string.
    Its details is described in :ref:`format dictionary<config_access_log_format_dictionaries>`.
    Values are rendered as strings, numbers, or boolean values as appropriate.
    Nested JSON objects may be produced by some command operators (e.g. FILTER_STATE or DYNAMIC_METADATA).
    See the documentation for a specific command operator for details.

    .. validated-code-block:: yaml
      :type-name: envoy.config.core.v3.SubstitutionFormatString

      json_format:
        status: "%RESPONSE_CODE%"
        message: "%LOCAL_REPLY_BODY%"

    The following JSON object would be created:

    .. code-block:: json

     {
       "status": 500,
       "message": "My error message"
     }
    """

    text_format_source: "DataSource | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="format"
    )
    """
    Specify a format with command operators to form a text string.
    Its details is described in :ref:`format string<config_access_log_format_strings>`.

    For example, setting ``text_format`` like below,

    .. validated-code-block:: yaml
      :type-name: envoy.config.core.v3.SubstitutionFormatString

      text_format_source:
        inline_string: "%LOCAL_REPLY_BODY%:%RESPONSE_CODE%:path=%REQ(:path)%\\n"

    generates plain text similar to:

    .. code-block:: text

      upstream connect error:503:path=/foo
    """

    omit_empty_values: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    If set to true, when command operators are evaluated to null,

    * for ``text_format``, the output of the empty operator is changed from ``-`` to an
      empty string, so that empty values are omitted entirely.
    * for ``json_format`` the keys with null values are omitted in the output structure.

    .. note::
      This option does not work perfectly with ``json_format`` as keys with ``null`` values
      will still be included in the output. See https://github.com/envoyproxy/envoy/issues/37941
      for more details.
    """

    content_type: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )
    """
    Specify a ``content_type`` field.
    If this field is not set then ``text/plain`` is used for ``text_format`` and
    ``application/json`` is used for ``json_format``.

    .. validated-code-block:: yaml
      :type-name: envoy.config.core.v3.SubstitutionFormatString

      content_type: "text/html; charset=UTF-8"
    """

    formatters: "list[TypedExtensionConfig]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies a collection of Formatter plugins that can be called from the access log configuration.
    See the formatters extensions documentation for details.
    [#extension-category: envoy.formatter]
    """

    json_format_options: "JsonFormatOptions | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If json_format is used, the options will be applied to the output JSON string.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("text_format"):
            warnings.warn(
                "SubstitutionFormatString.text_format is deprecated", DeprecationWarning
            )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3", "SubstitutionFormatString", SubstitutionFormatString
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpKeepalive(betterproto2.Message):
    keepalive_probes: "int | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Maximum number of keepalive probes to send without response before deciding
    the connection is dead. Default is to use the OS level configuration (unless
    overridden, Linux defaults to 9.)
    """

    keepalive_time: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The number of seconds a connection needs to be idle before keep-alive probes
    start being sent. Default is to use the OS level configuration (unless
    overridden, Linux defaults to 7200s (i.e., 2 hours.)
    """

    keepalive_interval: "int | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The number of seconds between keep-alive probes. Default is to use the OS
    level configuration (unless overridden, Linux defaults to 75s.)
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "TcpKeepalive", TcpKeepalive
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpProtocolOptions(betterproto2.Message):
    """
    [#protodoc-title: Protocol options]

    [#not-implemented-hide:]
    """

    pass


default_message_pool.register_message(
    "envoy.config.core.v3", "TcpProtocolOptions", TcpProtocolOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TlvEntry(betterproto2.Message):
    """
    Represents a single Type-Length-Value (TLV) entry.
    """

    type: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT32)
    )
    """
    The type of the TLV. Must be a uint8 (0-255) as per the Proxy Protocol v2 specification.
    """

    value: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)
    """
    The static value of the TLV.
    Only one of ``value`` or ``format_string`` may be set.
    """

    format_string: "SubstitutionFormatString | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Uses the :ref:`format string <config_access_log_format_strings>` to dynamically
    populate the TLV value from stream information. This allows dynamic values
    such as metadata, filter state, or other stream properties to be included in
    the TLV.

    For example:

    .. code-block:: yaml

      type: 0xF0
      format_string:
        text_format_source:
          inline_string: "%DYNAMIC_METADATA(envoy.filters.network:key)%"

    The formatted string will be used directly as the TLV value.
    Only one of ``value`` or ``format_string`` may be set.
    """


default_message_pool.register_message("envoy.config.core.v3", "TlvEntry", TlvEntry)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TransportSocket(betterproto2.Message):
    """
    Configuration for transport socket in :ref:`listeners <config_listeners>` and
    :ref:`clusters <envoy_v3_api_msg_config.cluster.v3.Cluster>`. If the configuration is
    empty, a default transport socket implementation and configuration will be
    chosen based on the platform and existence of tls_context.

    Oneofs:
        - config_type: Implementation specific configuration which depends on the implementation being instantiated.
            See the supported transport socket implementations for further documentation.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the transport socket to instantiate. The name must match a supported transport
    socket implementation.
    """

    typed_config: "____google__protobuf__.Any | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="config_type"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.core.v3", "TransportSocket", TransportSocket
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TypedExtensionConfig(betterproto2.Message):
    """
    [#protodoc-title: Extension configuration]

    Message type for extension configuration.
    [#next-major-version: revisit all existing typed_config that doesn't use this wrapper.].
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of an extension. This is not used to select the extension, instead
    it serves the role of an opaque identifier.
    """

    typed_config: "____google__protobuf__.Any | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The typed config for the extension. The type URL will be used to identify
    the extension. In the case that the type URL is ``xds.type.v3.TypedStruct``
    (or, for historical reasons, ``udpa.type.v1.TypedStruct``), the inner type
    URL of ``TypedStruct`` will be utilized. See the
    :ref:`extension configuration overview
    <config_overview_extension_configuration>` for further details.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "TypedExtensionConfig", TypedExtensionConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UdpSocketConfig(betterproto2.Message):
    """
    [#protodoc-title: UDP socket config]

    Generic UDP socket configuration.
    """

    max_rx_datagram_size: "int | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt64Value,
        optional=True,
    )
    """
    The maximum size of received UDP datagrams. Using a larger size will cause Envoy to allocate
    more memory per socket. Received datagrams above this size will be dropped. If not set
    defaults to 1500 bytes.
    """

    prefer_gro: "bool | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    Configures whether Generic Receive Offload (GRO)
    <https://en.wikipedia.org/wiki/Large_receive_offload>_ is preferred when reading from the
    UDP socket. The default is context dependent and is documented where UdpSocketConfig is used.
    This option affects performance but not functionality. If GRO is not supported by the operating
    system, non-GRO receive will be used.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "UdpSocketConfig", UdpSocketConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UpstreamHttpProtocolOptions(betterproto2.Message):
    auto_sni: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)
    """
    Set transport socket `SNI <https://en.wikipedia.org/wiki/Server_Name_Indication>`_ for new
    upstream connections based on the downstream HTTP host/authority header or any other arbitrary
    header when :ref:`override_auto_sni_header <envoy_v3_api_field_config.core.v3.UpstreamHttpProtocolOptions.override_auto_sni_header>`
    is set, as seen by the :ref:`router filter <config_http_filters_router>`.
    Does nothing if a filter before the http router filter sets the corresponding metadata.

    See :ref:`SNI configuration <start_quick_start_securing_sni_client>` for details on how this
    interacts with other validation options.
    """

    auto_san_validation: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)
    """
    Automatic validate upstream presented certificate for new upstream connections based on the
    downstream HTTP host/authority header or any other arbitrary header when :ref:`override_auto_sni_header <envoy_v3_api_field_config.core.v3.UpstreamHttpProtocolOptions.override_auto_sni_header>`
    is set, as seen by the :ref:`router filter <config_http_filters_router>`.
    This field is intended to be set with ``auto_sni`` field.
    Does nothing if a filter before the http router filter sets the corresponding metadata.

    See :ref:`validation configuration <start_quick_start_securing_validation>` for how this interacts with
    other validation options.
    """

    override_auto_sni_header: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    An optional alternative to the host/authority header to be used for setting the SNI value.
    It should be a valid downstream HTTP header, as seen by the
    :ref:`router filter <config_http_filters_router>`.
    If unset, host/authority header will be used for populating the SNI. If the specified header
    is not found or the value is empty, host/authority header will be used instead.
    This field is intended to be set with ``auto_sni`` and/or ``auto_san_validation`` fields.
    If none of these fields are set then setting this would be a no-op.
    Does nothing if a filter before the http router filter sets the corresponding metadata.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "UpstreamHttpProtocolOptions", UpstreamHttpProtocolOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class WatchedDirectory(betterproto2.Message):
    """
    A directory that is watched for changes, e.g. by inotify on Linux. Move/rename
    events inside this directory trigger the watch.
    """

    path: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Directory path to watch.
    """


default_message_pool.register_message(
    "envoy.config.core.v3", "WatchedDirectory", WatchedDirectory
)


from .....google import protobuf as ____google__protobuf__
from .....xds.core import v3 as ____xds__core__v3__
from ....type import v3 as ___type__v3__
from ....type.matcher import v3 as ___type__matcher__v3__
