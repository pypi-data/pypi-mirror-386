r'''
# `datadog_observability_pipeline`

Refer to the Terraform Registry for docs: [`datadog_observability_pipeline`](https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline).
'''
from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from .._jsii import *

import cdktf as _cdktf_9a9027ec
import constructs as _constructs_77d1e7e8


class ObservabilityPipeline(
    _cdktf_9a9027ec.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipeline",
):
    '''Represents a {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline datadog_observability_pipeline}.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        name: builtins.str,
        config: typing.Optional[typing.Union["ObservabilityPipelineConfigA", typing.Dict[builtins.str, typing.Any]]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Create a new {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline datadog_observability_pipeline} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param name: The pipeline name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        :param config: config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#config ObservabilityPipeline#config}
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ee9d464e582ae9a75da04cd684e5ea244fdbe899fe3071650dd3238886db306)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        config_ = ObservabilityPipelineConfig(
            name=name,
            config=config,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, config_])

    @jsii.member(jsii_name="generateConfigForImport")
    @builtins.classmethod
    def generate_config_for_import(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        import_to_id: builtins.str,
        import_from_id: builtins.str,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    ) -> _cdktf_9a9027ec.ImportableResource:
        '''Generates CDKTF code for importing a ObservabilityPipeline resource upon running "cdktf plan ".

        :param scope: The scope in which to define this construct.
        :param import_to_id: The construct id used in the generated config for the ObservabilityPipeline to import.
        :param import_from_id: The id of the existing ObservabilityPipeline that should be imported. Refer to the {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#import import section} in the documentation of this resource for the id to use
        :param provider: ? Optional instance of the provider where the ObservabilityPipeline to import is found.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae63d30a4c57c3e8916b0bb55a37a0fe3c1c3b757f634d9aec4d4709eb51e2ad)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument import_to_id", value=import_to_id, expected_type=type_hints["import_to_id"])
            check_type(argname="argument import_from_id", value=import_from_id, expected_type=type_hints["import_from_id"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
        return typing.cast(_cdktf_9a9027ec.ImportableResource, jsii.sinvoke(cls, "generateConfigForImport", [scope, import_to_id, import_from_id, provider]))

    @jsii.member(jsii_name="putConfig")
    def put_config(
        self,
        *,
        destinations: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinations", typing.Dict[builtins.str, typing.Any]]] = None,
        processors: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessors", typing.Dict[builtins.str, typing.Any]]] = None,
        sources: typing.Optional[typing.Union["ObservabilityPipelineConfigSources", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param destinations: destinations block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#destinations ObservabilityPipeline#destinations}
        :param processors: processors block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#processors ObservabilityPipeline#processors}
        :param sources: sources block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sources ObservabilityPipeline#sources}
        '''
        value = ObservabilityPipelineConfigA(
            destinations=destinations, processors=processors, sources=sources
        )

        return typing.cast(None, jsii.invoke(self, "putConfig", [value]))

    @jsii.member(jsii_name="resetConfig")
    def reset_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfig", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @jsii.member(jsii_name="synthesizeHclAttributes")
    def _synthesize_hcl_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeHclAttributes", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="tfResourceType")
    def TF_RESOURCE_TYPE(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sget(cls, "tfResourceType"))

    @builtins.property
    @jsii.member(jsii_name="config")
    def config(self) -> "ObservabilityPipelineConfigAOutputReference":
        return typing.cast("ObservabilityPipelineConfigAOutputReference", jsii.get(self, "config"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property
    @jsii.member(jsii_name="configInput")
    def config_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigA"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigA"]], jsii.get(self, "configInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0d6e8aebcb558877887e4a1468bf5aaf290dffa6ecf66e6dcf4439bd42041f6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfig",
    jsii_struct_bases=[_cdktf_9a9027ec.TerraformMetaArguments],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "name": "name",
        "config": "config",
    },
)
class ObservabilityPipelineConfig(_cdktf_9a9027ec.TerraformMetaArguments):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        name: builtins.str,
        config: typing.Optional[typing.Union["ObservabilityPipelineConfigA", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param name: The pipeline name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        :param config: config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#config ObservabilityPipeline#config}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(config, dict):
            config = ObservabilityPipelineConfigA(**config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13b4c775c68f141781e3ef51e8999fecb62f12088f93e8e34e670cb2d92e51a4)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if config is not None:
            self._values["config"] = config

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The pipeline name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def config(self) -> typing.Optional["ObservabilityPipelineConfigA"]:
        '''config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#config ObservabilityPipeline#config}
        '''
        result = self._values.get("config")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigA"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigA",
    jsii_struct_bases=[],
    name_mapping={
        "destinations": "destinations",
        "processors": "processors",
        "sources": "sources",
    },
)
class ObservabilityPipelineConfigA:
    def __init__(
        self,
        *,
        destinations: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinations", typing.Dict[builtins.str, typing.Any]]] = None,
        processors: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessors", typing.Dict[builtins.str, typing.Any]]] = None,
        sources: typing.Optional[typing.Union["ObservabilityPipelineConfigSources", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param destinations: destinations block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#destinations ObservabilityPipeline#destinations}
        :param processors: processors block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#processors ObservabilityPipeline#processors}
        :param sources: sources block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sources ObservabilityPipeline#sources}
        '''
        if isinstance(destinations, dict):
            destinations = ObservabilityPipelineConfigDestinations(**destinations)
        if isinstance(processors, dict):
            processors = ObservabilityPipelineConfigProcessors(**processors)
        if isinstance(sources, dict):
            sources = ObservabilityPipelineConfigSources(**sources)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b66e7fb77d4a0ebfd34c20f92abdd7c2d541fe8acfad45ad868ed671d5351f48)
            check_type(argname="argument destinations", value=destinations, expected_type=type_hints["destinations"])
            check_type(argname="argument processors", value=processors, expected_type=type_hints["processors"])
            check_type(argname="argument sources", value=sources, expected_type=type_hints["sources"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if destinations is not None:
            self._values["destinations"] = destinations
        if processors is not None:
            self._values["processors"] = processors
        if sources is not None:
            self._values["sources"] = sources

    @builtins.property
    def destinations(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinations"]:
        '''destinations block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#destinations ObservabilityPipeline#destinations}
        '''
        result = self._values.get("destinations")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinations"], result)

    @builtins.property
    def processors(self) -> typing.Optional["ObservabilityPipelineConfigProcessors"]:
        '''processors block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#processors ObservabilityPipeline#processors}
        '''
        result = self._values.get("processors")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessors"], result)

    @builtins.property
    def sources(self) -> typing.Optional["ObservabilityPipelineConfigSources"]:
        '''sources block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sources ObservabilityPipeline#sources}
        '''
        result = self._values.get("sources")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSources"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigA(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigAOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigAOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e50c091225c9c55921a02474d1e20134231e0a986b3c223fd7b8d6fabfc37359)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putDestinations")
    def put_destinations(
        self,
        *,
        amazon_opensearch: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsAmazonOpensearch", typing.Dict[builtins.str, typing.Any]]]]] = None,
        amazon_s3: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsAmazonS3", typing.Dict[builtins.str, typing.Any]]]]] = None,
        amazon_security_lake: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsAmazonSecurityLake", typing.Dict[builtins.str, typing.Any]]]]] = None,
        azure_storage: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsAzureStorage", typing.Dict[builtins.str, typing.Any]]]]] = None,
        crowdstrike_next_gen_siem: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem", typing.Dict[builtins.str, typing.Any]]]]] = None,
        datadog_logs: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsDatadogLogs", typing.Dict[builtins.str, typing.Any]]]]] = None,
        elasticsearch: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsElasticsearch", typing.Dict[builtins.str, typing.Any]]]]] = None,
        google_chronicle: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsGoogleChronicle", typing.Dict[builtins.str, typing.Any]]]]] = None,
        google_cloud_storage: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsGoogleCloudStorage", typing.Dict[builtins.str, typing.Any]]]]] = None,
        google_pubsub: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsGooglePubsub", typing.Dict[builtins.str, typing.Any]]]]] = None,
        microsoft_sentinel: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsMicrosoftSentinel", typing.Dict[builtins.str, typing.Any]]]]] = None,
        new_relic: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsNewRelic", typing.Dict[builtins.str, typing.Any]]]]] = None,
        opensearch: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsOpensearch", typing.Dict[builtins.str, typing.Any]]]]] = None,
        rsyslog: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsRsyslog", typing.Dict[builtins.str, typing.Any]]]]] = None,
        sentinel_one: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSentinelOne", typing.Dict[builtins.str, typing.Any]]]]] = None,
        socket: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSocket", typing.Dict[builtins.str, typing.Any]]]]] = None,
        splunk_hec: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSplunkHec", typing.Dict[builtins.str, typing.Any]]]]] = None,
        sumo_logic: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSumoLogic", typing.Dict[builtins.str, typing.Any]]]]] = None,
        syslog_ng: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSyslogNg", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param amazon_opensearch: amazon_opensearch block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_opensearch ObservabilityPipeline#amazon_opensearch}
        :param amazon_s3: amazon_s3 block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_s3 ObservabilityPipeline#amazon_s3}
        :param amazon_security_lake: amazon_security_lake block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_security_lake ObservabilityPipeline#amazon_security_lake}
        :param azure_storage: azure_storage block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#azure_storage ObservabilityPipeline#azure_storage}
        :param crowdstrike_next_gen_siem: crowdstrike_next_gen_siem block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crowdstrike_next_gen_siem ObservabilityPipeline#crowdstrike_next_gen_siem}
        :param datadog_logs: datadog_logs block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#datadog_logs ObservabilityPipeline#datadog_logs}
        :param elasticsearch: elasticsearch block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#elasticsearch ObservabilityPipeline#elasticsearch}
        :param google_chronicle: google_chronicle block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#google_chronicle ObservabilityPipeline#google_chronicle}
        :param google_cloud_storage: google_cloud_storage block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#google_cloud_storage ObservabilityPipeline#google_cloud_storage}
        :param google_pubsub: google_pubsub block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#google_pubsub ObservabilityPipeline#google_pubsub}
        :param microsoft_sentinel: microsoft_sentinel block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#microsoft_sentinel ObservabilityPipeline#microsoft_sentinel}
        :param new_relic: new_relic block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#new_relic ObservabilityPipeline#new_relic}
        :param opensearch: opensearch block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#opensearch ObservabilityPipeline#opensearch}
        :param rsyslog: rsyslog block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rsyslog ObservabilityPipeline#rsyslog}
        :param sentinel_one: sentinel_one block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sentinel_one ObservabilityPipeline#sentinel_one}
        :param socket: socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#socket ObservabilityPipeline#socket}
        :param splunk_hec: splunk_hec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#splunk_hec ObservabilityPipeline#splunk_hec}
        :param sumo_logic: sumo_logic block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sumo_logic ObservabilityPipeline#sumo_logic}
        :param syslog_ng: syslog_ng block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#syslog_ng ObservabilityPipeline#syslog_ng}
        '''
        value = ObservabilityPipelineConfigDestinations(
            amazon_opensearch=amazon_opensearch,
            amazon_s3=amazon_s3,
            amazon_security_lake=amazon_security_lake,
            azure_storage=azure_storage,
            crowdstrike_next_gen_siem=crowdstrike_next_gen_siem,
            datadog_logs=datadog_logs,
            elasticsearch=elasticsearch,
            google_chronicle=google_chronicle,
            google_cloud_storage=google_cloud_storage,
            google_pubsub=google_pubsub,
            microsoft_sentinel=microsoft_sentinel,
            new_relic=new_relic,
            opensearch=opensearch,
            rsyslog=rsyslog,
            sentinel_one=sentinel_one,
            socket=socket,
            splunk_hec=splunk_hec,
            sumo_logic=sumo_logic,
            syslog_ng=syslog_ng,
        )

        return typing.cast(None, jsii.invoke(self, "putDestinations", [value]))

    @jsii.member(jsii_name="putProcessors")
    def put_processors(
        self,
        *,
        add_env_vars: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsAddEnvVars", typing.Dict[builtins.str, typing.Any]]]]] = None,
        add_fields: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsAddFields", typing.Dict[builtins.str, typing.Any]]]]] = None,
        custom_processor: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsCustomProcessor", typing.Dict[builtins.str, typing.Any]]]]] = None,
        datadog_tags: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsDatadogTags", typing.Dict[builtins.str, typing.Any]]]]] = None,
        dedupe: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsDedupe", typing.Dict[builtins.str, typing.Any]]]]] = None,
        enrichment_table: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsEnrichmentTable", typing.Dict[builtins.str, typing.Any]]]]] = None,
        filter: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsFilter", typing.Dict[builtins.str, typing.Any]]]]] = None,
        generate_datadog_metrics: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics", typing.Dict[builtins.str, typing.Any]]]]] = None,
        ocsf_mapper: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsOcsfMapper", typing.Dict[builtins.str, typing.Any]]]]] = None,
        parse_grok: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsParseGrok", typing.Dict[builtins.str, typing.Any]]]]] = None,
        parse_json: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsParseJson", typing.Dict[builtins.str, typing.Any]]]]] = None,
        quota: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsQuota", typing.Dict[builtins.str, typing.Any]]]]] = None,
        reduce: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsReduce", typing.Dict[builtins.str, typing.Any]]]]] = None,
        remove_fields: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsRemoveFields", typing.Dict[builtins.str, typing.Any]]]]] = None,
        rename_fields: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsRenameFields", typing.Dict[builtins.str, typing.Any]]]]] = None,
        sample: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsSample", typing.Dict[builtins.str, typing.Any]]]]] = None,
        sensitive_data_scanner: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScanner", typing.Dict[builtins.str, typing.Any]]]]] = None,
        throttle: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsThrottle", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param add_env_vars: add_env_vars block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#add_env_vars ObservabilityPipeline#add_env_vars}
        :param add_fields: add_fields block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#add_fields ObservabilityPipeline#add_fields}
        :param custom_processor: custom_processor block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#custom_processor ObservabilityPipeline#custom_processor}
        :param datadog_tags: datadog_tags block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#datadog_tags ObservabilityPipeline#datadog_tags}
        :param dedupe: dedupe block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#dedupe ObservabilityPipeline#dedupe}
        :param enrichment_table: enrichment_table block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#enrichment_table ObservabilityPipeline#enrichment_table}
        :param filter: filter block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#filter ObservabilityPipeline#filter}
        :param generate_datadog_metrics: generate_datadog_metrics block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#generate_datadog_metrics ObservabilityPipeline#generate_datadog_metrics}
        :param ocsf_mapper: ocsf_mapper block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ocsf_mapper ObservabilityPipeline#ocsf_mapper}
        :param parse_grok: parse_grok block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#parse_grok ObservabilityPipeline#parse_grok}
        :param parse_json: parse_json block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#parse_json ObservabilityPipeline#parse_json}
        :param quota: quota block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#quota ObservabilityPipeline#quota}
        :param reduce: reduce block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#reduce ObservabilityPipeline#reduce}
        :param remove_fields: remove_fields block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#remove_fields ObservabilityPipeline#remove_fields}
        :param rename_fields: rename_fields block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rename_fields ObservabilityPipeline#rename_fields}
        :param sample: sample block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sample ObservabilityPipeline#sample}
        :param sensitive_data_scanner: sensitive_data_scanner block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sensitive_data_scanner ObservabilityPipeline#sensitive_data_scanner}
        :param throttle: throttle block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#throttle ObservabilityPipeline#throttle}
        '''
        value = ObservabilityPipelineConfigProcessors(
            add_env_vars=add_env_vars,
            add_fields=add_fields,
            custom_processor=custom_processor,
            datadog_tags=datadog_tags,
            dedupe=dedupe,
            enrichment_table=enrichment_table,
            filter=filter,
            generate_datadog_metrics=generate_datadog_metrics,
            ocsf_mapper=ocsf_mapper,
            parse_grok=parse_grok,
            parse_json=parse_json,
            quota=quota,
            reduce=reduce,
            remove_fields=remove_fields,
            rename_fields=rename_fields,
            sample=sample,
            sensitive_data_scanner=sensitive_data_scanner,
            throttle=throttle,
        )

        return typing.cast(None, jsii.invoke(self, "putProcessors", [value]))

    @jsii.member(jsii_name="putSources")
    def put_sources(
        self,
        *,
        amazon_data_firehose: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesAmazonDataFirehose", typing.Dict[builtins.str, typing.Any]]]]] = None,
        amazon_s3: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesAmazonS3", typing.Dict[builtins.str, typing.Any]]]]] = None,
        datadog_agent: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesDatadogAgent", typing.Dict[builtins.str, typing.Any]]]]] = None,
        fluent_bit: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesFluentBit", typing.Dict[builtins.str, typing.Any]]]]] = None,
        fluentd: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesFluentd", typing.Dict[builtins.str, typing.Any]]]]] = None,
        google_pubsub: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesGooglePubsub", typing.Dict[builtins.str, typing.Any]]]]] = None,
        http_client: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesHttpClient", typing.Dict[builtins.str, typing.Any]]]]] = None,
        http_server: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesHttpServer", typing.Dict[builtins.str, typing.Any]]]]] = None,
        kafka: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesKafka", typing.Dict[builtins.str, typing.Any]]]]] = None,
        logstash: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesLogstash", typing.Dict[builtins.str, typing.Any]]]]] = None,
        rsyslog: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesRsyslog", typing.Dict[builtins.str, typing.Any]]]]] = None,
        socket: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSocket", typing.Dict[builtins.str, typing.Any]]]]] = None,
        splunk_hec: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSplunkHec", typing.Dict[builtins.str, typing.Any]]]]] = None,
        splunk_tcp: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSplunkTcp", typing.Dict[builtins.str, typing.Any]]]]] = None,
        sumo_logic: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSumoLogic", typing.Dict[builtins.str, typing.Any]]]]] = None,
        syslog_ng: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSyslogNg", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param amazon_data_firehose: amazon_data_firehose block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_data_firehose ObservabilityPipeline#amazon_data_firehose}
        :param amazon_s3: amazon_s3 block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_s3 ObservabilityPipeline#amazon_s3}
        :param datadog_agent: datadog_agent block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#datadog_agent ObservabilityPipeline#datadog_agent}
        :param fluent_bit: fluent_bit block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fluent_bit ObservabilityPipeline#fluent_bit}
        :param fluentd: fluentd block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fluentd ObservabilityPipeline#fluentd}
        :param google_pubsub: google_pubsub block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#google_pubsub ObservabilityPipeline#google_pubsub}
        :param http_client: http_client block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#http_client ObservabilityPipeline#http_client}
        :param http_server: http_server block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#http_server ObservabilityPipeline#http_server}
        :param kafka: kafka block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#kafka ObservabilityPipeline#kafka}
        :param logstash: logstash block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#logstash ObservabilityPipeline#logstash}
        :param rsyslog: rsyslog block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rsyslog ObservabilityPipeline#rsyslog}
        :param socket: socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#socket ObservabilityPipeline#socket}
        :param splunk_hec: splunk_hec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#splunk_hec ObservabilityPipeline#splunk_hec}
        :param splunk_tcp: splunk_tcp block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#splunk_tcp ObservabilityPipeline#splunk_tcp}
        :param sumo_logic: sumo_logic block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sumo_logic ObservabilityPipeline#sumo_logic}
        :param syslog_ng: syslog_ng block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#syslog_ng ObservabilityPipeline#syslog_ng}
        '''
        value = ObservabilityPipelineConfigSources(
            amazon_data_firehose=amazon_data_firehose,
            amazon_s3=amazon_s3,
            datadog_agent=datadog_agent,
            fluent_bit=fluent_bit,
            fluentd=fluentd,
            google_pubsub=google_pubsub,
            http_client=http_client,
            http_server=http_server,
            kafka=kafka,
            logstash=logstash,
            rsyslog=rsyslog,
            socket=socket,
            splunk_hec=splunk_hec,
            splunk_tcp=splunk_tcp,
            sumo_logic=sumo_logic,
            syslog_ng=syslog_ng,
        )

        return typing.cast(None, jsii.invoke(self, "putSources", [value]))

    @jsii.member(jsii_name="resetDestinations")
    def reset_destinations(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDestinations", []))

    @jsii.member(jsii_name="resetProcessors")
    def reset_processors(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProcessors", []))

    @jsii.member(jsii_name="resetSources")
    def reset_sources(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSources", []))

    @builtins.property
    @jsii.member(jsii_name="destinations")
    def destinations(self) -> "ObservabilityPipelineConfigDestinationsOutputReference":
        return typing.cast("ObservabilityPipelineConfigDestinationsOutputReference", jsii.get(self, "destinations"))

    @builtins.property
    @jsii.member(jsii_name="processors")
    def processors(self) -> "ObservabilityPipelineConfigProcessorsOutputReference":
        return typing.cast("ObservabilityPipelineConfigProcessorsOutputReference", jsii.get(self, "processors"))

    @builtins.property
    @jsii.member(jsii_name="sources")
    def sources(self) -> "ObservabilityPipelineConfigSourcesOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesOutputReference", jsii.get(self, "sources"))

    @builtins.property
    @jsii.member(jsii_name="destinationsInput")
    def destinations_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinations"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinations"]], jsii.get(self, "destinationsInput"))

    @builtins.property
    @jsii.member(jsii_name="processorsInput")
    def processors_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigProcessors"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigProcessors"]], jsii.get(self, "processorsInput"))

    @builtins.property
    @jsii.member(jsii_name="sourcesInput")
    def sources_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSources"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSources"]], jsii.get(self, "sourcesInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigA]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigA]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigA]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4eb701a3b55e459a4155b0cbce02ff5a2701688f282605ac8e14cf3599cff4cd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinations",
    jsii_struct_bases=[],
    name_mapping={
        "amazon_opensearch": "amazonOpensearch",
        "amazon_s3": "amazonS3",
        "amazon_security_lake": "amazonSecurityLake",
        "azure_storage": "azureStorage",
        "crowdstrike_next_gen_siem": "crowdstrikeNextGenSiem",
        "datadog_logs": "datadogLogs",
        "elasticsearch": "elasticsearch",
        "google_chronicle": "googleChronicle",
        "google_cloud_storage": "googleCloudStorage",
        "google_pubsub": "googlePubsub",
        "microsoft_sentinel": "microsoftSentinel",
        "new_relic": "newRelic",
        "opensearch": "opensearch",
        "rsyslog": "rsyslog",
        "sentinel_one": "sentinelOne",
        "socket": "socket",
        "splunk_hec": "splunkHec",
        "sumo_logic": "sumoLogic",
        "syslog_ng": "syslogNg",
    },
)
class ObservabilityPipelineConfigDestinations:
    def __init__(
        self,
        *,
        amazon_opensearch: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsAmazonOpensearch", typing.Dict[builtins.str, typing.Any]]]]] = None,
        amazon_s3: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsAmazonS3", typing.Dict[builtins.str, typing.Any]]]]] = None,
        amazon_security_lake: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsAmazonSecurityLake", typing.Dict[builtins.str, typing.Any]]]]] = None,
        azure_storage: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsAzureStorage", typing.Dict[builtins.str, typing.Any]]]]] = None,
        crowdstrike_next_gen_siem: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem", typing.Dict[builtins.str, typing.Any]]]]] = None,
        datadog_logs: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsDatadogLogs", typing.Dict[builtins.str, typing.Any]]]]] = None,
        elasticsearch: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsElasticsearch", typing.Dict[builtins.str, typing.Any]]]]] = None,
        google_chronicle: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsGoogleChronicle", typing.Dict[builtins.str, typing.Any]]]]] = None,
        google_cloud_storage: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsGoogleCloudStorage", typing.Dict[builtins.str, typing.Any]]]]] = None,
        google_pubsub: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsGooglePubsub", typing.Dict[builtins.str, typing.Any]]]]] = None,
        microsoft_sentinel: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsMicrosoftSentinel", typing.Dict[builtins.str, typing.Any]]]]] = None,
        new_relic: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsNewRelic", typing.Dict[builtins.str, typing.Any]]]]] = None,
        opensearch: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsOpensearch", typing.Dict[builtins.str, typing.Any]]]]] = None,
        rsyslog: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsRsyslog", typing.Dict[builtins.str, typing.Any]]]]] = None,
        sentinel_one: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSentinelOne", typing.Dict[builtins.str, typing.Any]]]]] = None,
        socket: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSocket", typing.Dict[builtins.str, typing.Any]]]]] = None,
        splunk_hec: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSplunkHec", typing.Dict[builtins.str, typing.Any]]]]] = None,
        sumo_logic: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSumoLogic", typing.Dict[builtins.str, typing.Any]]]]] = None,
        syslog_ng: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSyslogNg", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param amazon_opensearch: amazon_opensearch block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_opensearch ObservabilityPipeline#amazon_opensearch}
        :param amazon_s3: amazon_s3 block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_s3 ObservabilityPipeline#amazon_s3}
        :param amazon_security_lake: amazon_security_lake block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_security_lake ObservabilityPipeline#amazon_security_lake}
        :param azure_storage: azure_storage block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#azure_storage ObservabilityPipeline#azure_storage}
        :param crowdstrike_next_gen_siem: crowdstrike_next_gen_siem block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crowdstrike_next_gen_siem ObservabilityPipeline#crowdstrike_next_gen_siem}
        :param datadog_logs: datadog_logs block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#datadog_logs ObservabilityPipeline#datadog_logs}
        :param elasticsearch: elasticsearch block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#elasticsearch ObservabilityPipeline#elasticsearch}
        :param google_chronicle: google_chronicle block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#google_chronicle ObservabilityPipeline#google_chronicle}
        :param google_cloud_storage: google_cloud_storage block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#google_cloud_storage ObservabilityPipeline#google_cloud_storage}
        :param google_pubsub: google_pubsub block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#google_pubsub ObservabilityPipeline#google_pubsub}
        :param microsoft_sentinel: microsoft_sentinel block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#microsoft_sentinel ObservabilityPipeline#microsoft_sentinel}
        :param new_relic: new_relic block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#new_relic ObservabilityPipeline#new_relic}
        :param opensearch: opensearch block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#opensearch ObservabilityPipeline#opensearch}
        :param rsyslog: rsyslog block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rsyslog ObservabilityPipeline#rsyslog}
        :param sentinel_one: sentinel_one block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sentinel_one ObservabilityPipeline#sentinel_one}
        :param socket: socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#socket ObservabilityPipeline#socket}
        :param splunk_hec: splunk_hec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#splunk_hec ObservabilityPipeline#splunk_hec}
        :param sumo_logic: sumo_logic block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sumo_logic ObservabilityPipeline#sumo_logic}
        :param syslog_ng: syslog_ng block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#syslog_ng ObservabilityPipeline#syslog_ng}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ade6b9ae46e12b43fc9b2b75670b6fa0834fe8bd3c5a5c300bd8a93f9a303c6)
            check_type(argname="argument amazon_opensearch", value=amazon_opensearch, expected_type=type_hints["amazon_opensearch"])
            check_type(argname="argument amazon_s3", value=amazon_s3, expected_type=type_hints["amazon_s3"])
            check_type(argname="argument amazon_security_lake", value=amazon_security_lake, expected_type=type_hints["amazon_security_lake"])
            check_type(argname="argument azure_storage", value=azure_storage, expected_type=type_hints["azure_storage"])
            check_type(argname="argument crowdstrike_next_gen_siem", value=crowdstrike_next_gen_siem, expected_type=type_hints["crowdstrike_next_gen_siem"])
            check_type(argname="argument datadog_logs", value=datadog_logs, expected_type=type_hints["datadog_logs"])
            check_type(argname="argument elasticsearch", value=elasticsearch, expected_type=type_hints["elasticsearch"])
            check_type(argname="argument google_chronicle", value=google_chronicle, expected_type=type_hints["google_chronicle"])
            check_type(argname="argument google_cloud_storage", value=google_cloud_storage, expected_type=type_hints["google_cloud_storage"])
            check_type(argname="argument google_pubsub", value=google_pubsub, expected_type=type_hints["google_pubsub"])
            check_type(argname="argument microsoft_sentinel", value=microsoft_sentinel, expected_type=type_hints["microsoft_sentinel"])
            check_type(argname="argument new_relic", value=new_relic, expected_type=type_hints["new_relic"])
            check_type(argname="argument opensearch", value=opensearch, expected_type=type_hints["opensearch"])
            check_type(argname="argument rsyslog", value=rsyslog, expected_type=type_hints["rsyslog"])
            check_type(argname="argument sentinel_one", value=sentinel_one, expected_type=type_hints["sentinel_one"])
            check_type(argname="argument socket", value=socket, expected_type=type_hints["socket"])
            check_type(argname="argument splunk_hec", value=splunk_hec, expected_type=type_hints["splunk_hec"])
            check_type(argname="argument sumo_logic", value=sumo_logic, expected_type=type_hints["sumo_logic"])
            check_type(argname="argument syslog_ng", value=syslog_ng, expected_type=type_hints["syslog_ng"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if amazon_opensearch is not None:
            self._values["amazon_opensearch"] = amazon_opensearch
        if amazon_s3 is not None:
            self._values["amazon_s3"] = amazon_s3
        if amazon_security_lake is not None:
            self._values["amazon_security_lake"] = amazon_security_lake
        if azure_storage is not None:
            self._values["azure_storage"] = azure_storage
        if crowdstrike_next_gen_siem is not None:
            self._values["crowdstrike_next_gen_siem"] = crowdstrike_next_gen_siem
        if datadog_logs is not None:
            self._values["datadog_logs"] = datadog_logs
        if elasticsearch is not None:
            self._values["elasticsearch"] = elasticsearch
        if google_chronicle is not None:
            self._values["google_chronicle"] = google_chronicle
        if google_cloud_storage is not None:
            self._values["google_cloud_storage"] = google_cloud_storage
        if google_pubsub is not None:
            self._values["google_pubsub"] = google_pubsub
        if microsoft_sentinel is not None:
            self._values["microsoft_sentinel"] = microsoft_sentinel
        if new_relic is not None:
            self._values["new_relic"] = new_relic
        if opensearch is not None:
            self._values["opensearch"] = opensearch
        if rsyslog is not None:
            self._values["rsyslog"] = rsyslog
        if sentinel_one is not None:
            self._values["sentinel_one"] = sentinel_one
        if socket is not None:
            self._values["socket"] = socket
        if splunk_hec is not None:
            self._values["splunk_hec"] = splunk_hec
        if sumo_logic is not None:
            self._values["sumo_logic"] = sumo_logic
        if syslog_ng is not None:
            self._values["syslog_ng"] = syslog_ng

    @builtins.property
    def amazon_opensearch(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsAmazonOpensearch"]]]:
        '''amazon_opensearch block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_opensearch ObservabilityPipeline#amazon_opensearch}
        '''
        result = self._values.get("amazon_opensearch")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsAmazonOpensearch"]]], result)

    @builtins.property
    def amazon_s3(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsAmazonS3"]]]:
        '''amazon_s3 block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_s3 ObservabilityPipeline#amazon_s3}
        '''
        result = self._values.get("amazon_s3")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsAmazonS3"]]], result)

    @builtins.property
    def amazon_security_lake(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsAmazonSecurityLake"]]]:
        '''amazon_security_lake block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_security_lake ObservabilityPipeline#amazon_security_lake}
        '''
        result = self._values.get("amazon_security_lake")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsAmazonSecurityLake"]]], result)

    @builtins.property
    def azure_storage(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsAzureStorage"]]]:
        '''azure_storage block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#azure_storage ObservabilityPipeline#azure_storage}
        '''
        result = self._values.get("azure_storage")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsAzureStorage"]]], result)

    @builtins.property
    def crowdstrike_next_gen_siem(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem"]]]:
        '''crowdstrike_next_gen_siem block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crowdstrike_next_gen_siem ObservabilityPipeline#crowdstrike_next_gen_siem}
        '''
        result = self._values.get("crowdstrike_next_gen_siem")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem"]]], result)

    @builtins.property
    def datadog_logs(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsDatadogLogs"]]]:
        '''datadog_logs block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#datadog_logs ObservabilityPipeline#datadog_logs}
        '''
        result = self._values.get("datadog_logs")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsDatadogLogs"]]], result)

    @builtins.property
    def elasticsearch(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsElasticsearch"]]]:
        '''elasticsearch block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#elasticsearch ObservabilityPipeline#elasticsearch}
        '''
        result = self._values.get("elasticsearch")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsElasticsearch"]]], result)

    @builtins.property
    def google_chronicle(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsGoogleChronicle"]]]:
        '''google_chronicle block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#google_chronicle ObservabilityPipeline#google_chronicle}
        '''
        result = self._values.get("google_chronicle")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsGoogleChronicle"]]], result)

    @builtins.property
    def google_cloud_storage(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsGoogleCloudStorage"]]]:
        '''google_cloud_storage block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#google_cloud_storage ObservabilityPipeline#google_cloud_storage}
        '''
        result = self._values.get("google_cloud_storage")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsGoogleCloudStorage"]]], result)

    @builtins.property
    def google_pubsub(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsGooglePubsub"]]]:
        '''google_pubsub block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#google_pubsub ObservabilityPipeline#google_pubsub}
        '''
        result = self._values.get("google_pubsub")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsGooglePubsub"]]], result)

    @builtins.property
    def microsoft_sentinel(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsMicrosoftSentinel"]]]:
        '''microsoft_sentinel block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#microsoft_sentinel ObservabilityPipeline#microsoft_sentinel}
        '''
        result = self._values.get("microsoft_sentinel")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsMicrosoftSentinel"]]], result)

    @builtins.property
    def new_relic(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsNewRelic"]]]:
        '''new_relic block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#new_relic ObservabilityPipeline#new_relic}
        '''
        result = self._values.get("new_relic")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsNewRelic"]]], result)

    @builtins.property
    def opensearch(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsOpensearch"]]]:
        '''opensearch block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#opensearch ObservabilityPipeline#opensearch}
        '''
        result = self._values.get("opensearch")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsOpensearch"]]], result)

    @builtins.property
    def rsyslog(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsRsyslog"]]]:
        '''rsyslog block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rsyslog ObservabilityPipeline#rsyslog}
        '''
        result = self._values.get("rsyslog")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsRsyslog"]]], result)

    @builtins.property
    def sentinel_one(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSentinelOne"]]]:
        '''sentinel_one block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sentinel_one ObservabilityPipeline#sentinel_one}
        '''
        result = self._values.get("sentinel_one")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSentinelOne"]]], result)

    @builtins.property
    def socket(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSocket"]]]:
        '''socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#socket ObservabilityPipeline#socket}
        '''
        result = self._values.get("socket")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSocket"]]], result)

    @builtins.property
    def splunk_hec(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSplunkHec"]]]:
        '''splunk_hec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#splunk_hec ObservabilityPipeline#splunk_hec}
        '''
        result = self._values.get("splunk_hec")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSplunkHec"]]], result)

    @builtins.property
    def sumo_logic(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSumoLogic"]]]:
        '''sumo_logic block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sumo_logic ObservabilityPipeline#sumo_logic}
        '''
        result = self._values.get("sumo_logic")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSumoLogic"]]], result)

    @builtins.property
    def syslog_ng(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSyslogNg"]]]:
        '''syslog_ng block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#syslog_ng ObservabilityPipeline#syslog_ng}
        '''
        result = self._values.get("syslog_ng")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSyslogNg"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonOpensearch",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "inputs": "inputs",
        "auth": "auth",
        "bulk_index": "bulkIndex",
    },
)
class ObservabilityPipelineConfigDestinationsAmazonOpensearch:
    def __init__(
        self,
        *,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        auth: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        bulk_index: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the input for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param auth: auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        :param bulk_index: The index or datastream to write logs to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#bulk_index ObservabilityPipeline#bulk_index}
        '''
        if isinstance(auth, dict):
            auth = ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__731b51b4d2b1c245486d7a6bad980519cee1e501c059072a810efd89e869e50c)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument bulk_index", value=bulk_index, expected_type=type_hints["bulk_index"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "inputs": inputs,
        }
        if auth is not None:
            self._values["auth"] = auth
        if bulk_index is not None:
            self._values["bulk_index"] = bulk_index

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the input for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def auth(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth"]:
        '''auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth"], result)

    @builtins.property
    def bulk_index(self) -> typing.Optional[builtins.str]:
        '''The index or datastream to write logs to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#bulk_index ObservabilityPipeline#bulk_index}
        '''
        result = self._values.get("bulk_index")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsAmazonOpensearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth",
    jsii_struct_bases=[],
    name_mapping={
        "strategy": "strategy",
        "assume_role": "assumeRole",
        "aws_region": "awsRegion",
        "external_id": "externalId",
        "session_name": "sessionName",
    },
)
class ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth:
    def __init__(
        self,
        *,
        strategy: builtins.str,
        assume_role: typing.Optional[builtins.str] = None,
        aws_region: typing.Optional[builtins.str] = None,
        external_id: typing.Optional[builtins.str] = None,
        session_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param strategy: The authentication strategy to use (e.g. aws or basic). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#strategy ObservabilityPipeline#strategy}
        :param assume_role: ARN of the role to assume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        :param aws_region: AWS region override (if applicable). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#aws_region ObservabilityPipeline#aws_region}
        :param external_id: External ID for assumed role. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        :param session_name: Session name for assumed role. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__525775622076f1fadbc96e729027b66eb9a1a64a423aa37cc7ca28f3d998098d)
            check_type(argname="argument strategy", value=strategy, expected_type=type_hints["strategy"])
            check_type(argname="argument assume_role", value=assume_role, expected_type=type_hints["assume_role"])
            check_type(argname="argument aws_region", value=aws_region, expected_type=type_hints["aws_region"])
            check_type(argname="argument external_id", value=external_id, expected_type=type_hints["external_id"])
            check_type(argname="argument session_name", value=session_name, expected_type=type_hints["session_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "strategy": strategy,
        }
        if assume_role is not None:
            self._values["assume_role"] = assume_role
        if aws_region is not None:
            self._values["aws_region"] = aws_region
        if external_id is not None:
            self._values["external_id"] = external_id
        if session_name is not None:
            self._values["session_name"] = session_name

    @builtins.property
    def strategy(self) -> builtins.str:
        '''The authentication strategy to use (e.g. aws or basic).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#strategy ObservabilityPipeline#strategy}
        '''
        result = self._values.get("strategy")
        assert result is not None, "Required property 'strategy' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def assume_role(self) -> typing.Optional[builtins.str]:
        '''ARN of the role to assume.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        '''
        result = self._values.get("assume_role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def aws_region(self) -> typing.Optional[builtins.str]:
        '''AWS region override (if applicable).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#aws_region ObservabilityPipeline#aws_region}
        '''
        result = self._values.get("aws_region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def external_id(self) -> typing.Optional[builtins.str]:
        '''External ID for assumed role.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        '''
        result = self._values.get("external_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def session_name(self) -> typing.Optional[builtins.str]:
        '''Session name for assumed role.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        result = self._values.get("session_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsAmazonOpensearchAuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonOpensearchAuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e8fbbafa0997f22b3431b57b18f21994d7f58357f402799464d73aaf3ed7b8c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAssumeRole")
    def reset_assume_role(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAssumeRole", []))

    @jsii.member(jsii_name="resetAwsRegion")
    def reset_aws_region(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAwsRegion", []))

    @jsii.member(jsii_name="resetExternalId")
    def reset_external_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExternalId", []))

    @jsii.member(jsii_name="resetSessionName")
    def reset_session_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSessionName", []))

    @builtins.property
    @jsii.member(jsii_name="assumeRoleInput")
    def assume_role_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "assumeRoleInput"))

    @builtins.property
    @jsii.member(jsii_name="awsRegionInput")
    def aws_region_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "awsRegionInput"))

    @builtins.property
    @jsii.member(jsii_name="externalIdInput")
    def external_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "externalIdInput"))

    @builtins.property
    @jsii.member(jsii_name="sessionNameInput")
    def session_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sessionNameInput"))

    @builtins.property
    @jsii.member(jsii_name="strategyInput")
    def strategy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "strategyInput"))

    @builtins.property
    @jsii.member(jsii_name="assumeRole")
    def assume_role(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "assumeRole"))

    @assume_role.setter
    def assume_role(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__222ee7391e4f044b4a016d3c21ef5cb0739338247b8acb31e307554f6da7eaf2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "assumeRole", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="awsRegion")
    def aws_region(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "awsRegion"))

    @aws_region.setter
    def aws_region(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca9cfc04c60633b7910ce7fdb9502d265950f3baa1444d2e7cc49de8fc91c002)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "awsRegion", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="externalId")
    def external_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "externalId"))

    @external_id.setter
    def external_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0874e34b844e6258e81bde3895f31a5ec8a6388eb78a7571b5428296ac36f9e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "externalId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sessionName")
    def session_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sessionName"))

    @session_name.setter
    def session_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ed9f963036a71a44b2dbdb61729a0c7375ad82f75d214ad5216c76ad6dfc3d9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sessionName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def strategy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "strategy"))

    @strategy.setter
    def strategy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__500b6804db40092c287ffb1f95729a0d86658ec87187553a8984e7bf393aac77)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "strategy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62986e70dac77787513d1e1994b144e61e7b9ba8977191d4dfd99ef0a89dcb1a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsAmazonOpensearchList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonOpensearchList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e40a2332b9b271a2df10f22f323015ac9c8b14cfca5b546861160acbfcaf6e3f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsAmazonOpensearchOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74c21e8f0c499869f3b7346cfad43bd5a24b5c897a7cebaf0525434c776fb122)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsAmazonOpensearchOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__53ae92cabf273b2c5622d3e60943a8a59445dd7f6658ec1f7db2986658f1f8f2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__903ee2901ade7dd16751cadd2efd639105281793d34d43fb9eabb2751f90d1be)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5e7ed93bdfa3175211cbf103f20547510321095b41f26d632b4139761404b69)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonOpensearch]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonOpensearch]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonOpensearch]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05864d49f955d29943823eb304f8e30289b4e2bf0666be1f5a1a7794e20aadcc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsAmazonOpensearchOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonOpensearchOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__547d34c7d13eba851325251e2f3a356896c7cb30cd010ca00c911379632c59a5)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAuth")
    def put_auth(
        self,
        *,
        strategy: builtins.str,
        assume_role: typing.Optional[builtins.str] = None,
        aws_region: typing.Optional[builtins.str] = None,
        external_id: typing.Optional[builtins.str] = None,
        session_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param strategy: The authentication strategy to use (e.g. aws or basic). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#strategy ObservabilityPipeline#strategy}
        :param assume_role: ARN of the role to assume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        :param aws_region: AWS region override (if applicable). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#aws_region ObservabilityPipeline#aws_region}
        :param external_id: External ID for assumed role. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        :param session_name: Session name for assumed role. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        value = ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth(
            strategy=strategy,
            assume_role=assume_role,
            aws_region=aws_region,
            external_id=external_id,
            session_name=session_name,
        )

        return typing.cast(None, jsii.invoke(self, "putAuth", [value]))

    @jsii.member(jsii_name="resetAuth")
    def reset_auth(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAuth", []))

    @jsii.member(jsii_name="resetBulkIndex")
    def reset_bulk_index(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBulkIndex", []))

    @builtins.property
    @jsii.member(jsii_name="auth")
    def auth(
        self,
    ) -> ObservabilityPipelineConfigDestinationsAmazonOpensearchAuthOutputReference:
        return typing.cast(ObservabilityPipelineConfigDestinationsAmazonOpensearchAuthOutputReference, jsii.get(self, "auth"))

    @builtins.property
    @jsii.member(jsii_name="authInput")
    def auth_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth]], jsii.get(self, "authInput"))

    @builtins.property
    @jsii.member(jsii_name="bulkIndexInput")
    def bulk_index_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "bulkIndexInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="bulkIndex")
    def bulk_index(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "bulkIndex"))

    @bulk_index.setter
    def bulk_index(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9a35372cde4ae9344f918e9b5aff7ee6d89d6e8dc599b1979a86f418a6d41ee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bulkIndex", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1916dc863dd1fed5f49676b5e4b39ca58b3a56fa09ccab8684e13e2d05fb4080)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f3e891927ba929c2e08d5e8acceec5ebf5dd8b1cac213337e23666a18b930bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonOpensearch]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonOpensearch]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonOpensearch]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39154b2e1e47183c4fd78b895acf8aa0890faaedb6e987d54a824ceef828795f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonS3",
    jsii_struct_bases=[],
    name_mapping={
        "bucket": "bucket",
        "id": "id",
        "inputs": "inputs",
        "key_prefix": "keyPrefix",
        "region": "region",
        "storage_class": "storageClass",
        "auth": "auth",
    },
)
class ObservabilityPipelineConfigDestinationsAmazonS3:
    def __init__(
        self,
        *,
        bucket: builtins.str,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        key_prefix: builtins.str,
        region: builtins.str,
        storage_class: builtins.str,
        auth: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsAmazonS3Auth", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param bucket: S3 bucket name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#bucket ObservabilityPipeline#bucket}
        :param id: Unique identifier for the destination component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param key_prefix: Prefix for object keys. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_prefix ObservabilityPipeline#key_prefix}
        :param region: AWS region of the S3 bucket. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#region ObservabilityPipeline#region}
        :param storage_class: S3 storage class. Valid values are ``STANDARD``, ``REDUCED_REDUNDANCY``, ``INTELLIGENT_TIERING``, ``STANDARD_IA``, ``EXPRESS_ONEZONE``, ``ONEZONE_IA``, ``GLACIER``, ``GLACIER_IR``, ``DEEP_ARCHIVE``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#storage_class ObservabilityPipeline#storage_class}
        :param auth: auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        '''
        if isinstance(auth, dict):
            auth = ObservabilityPipelineConfigDestinationsAmazonS3Auth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc023ea1e9736f885f9c2c3af69f7738179b74d22274d1fb1a89a00e49a5d74a)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument key_prefix", value=key_prefix, expected_type=type_hints["key_prefix"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument storage_class", value=storage_class, expected_type=type_hints["storage_class"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bucket": bucket,
            "id": id,
            "inputs": inputs,
            "key_prefix": key_prefix,
            "region": region,
            "storage_class": storage_class,
        }
        if auth is not None:
            self._values["auth"] = auth

    @builtins.property
    def bucket(self) -> builtins.str:
        '''S3 bucket name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#bucket ObservabilityPipeline#bucket}
        '''
        result = self._values.get("bucket")
        assert result is not None, "Required property 'bucket' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def id(self) -> builtins.str:
        '''Unique identifier for the destination component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def key_prefix(self) -> builtins.str:
        '''Prefix for object keys.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_prefix ObservabilityPipeline#key_prefix}
        '''
        result = self._values.get("key_prefix")
        assert result is not None, "Required property 'key_prefix' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def region(self) -> builtins.str:
        '''AWS region of the S3 bucket.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#region ObservabilityPipeline#region}
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def storage_class(self) -> builtins.str:
        '''S3 storage class. Valid values are ``STANDARD``, ``REDUCED_REDUNDANCY``, ``INTELLIGENT_TIERING``, ``STANDARD_IA``, ``EXPRESS_ONEZONE``, ``ONEZONE_IA``, ``GLACIER``, ``GLACIER_IR``, ``DEEP_ARCHIVE``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#storage_class ObservabilityPipeline#storage_class}
        '''
        result = self._values.get("storage_class")
        assert result is not None, "Required property 'storage_class' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsAmazonS3Auth"]:
        '''auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsAmazonS3Auth"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsAmazonS3(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonS3Auth",
    jsii_struct_bases=[],
    name_mapping={
        "assume_role": "assumeRole",
        "external_id": "externalId",
        "session_name": "sessionName",
    },
)
class ObservabilityPipelineConfigDestinationsAmazonS3Auth:
    def __init__(
        self,
        *,
        assume_role: typing.Optional[builtins.str] = None,
        external_id: typing.Optional[builtins.str] = None,
        session_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param assume_role: The Amazon Resource Name (ARN) of the role to assume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        :param external_id: A unique identifier for cross-account role assumption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        :param session_name: A session identifier used for logging and tracing the assumed role session. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c459d41c7e8165ea1346bc4490a16e8a60a2a4af49deeb63e53211bc0c55a41)
            check_type(argname="argument assume_role", value=assume_role, expected_type=type_hints["assume_role"])
            check_type(argname="argument external_id", value=external_id, expected_type=type_hints["external_id"])
            check_type(argname="argument session_name", value=session_name, expected_type=type_hints["session_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if assume_role is not None:
            self._values["assume_role"] = assume_role
        if external_id is not None:
            self._values["external_id"] = external_id
        if session_name is not None:
            self._values["session_name"] = session_name

    @builtins.property
    def assume_role(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the role to assume.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        '''
        result = self._values.get("assume_role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def external_id(self) -> typing.Optional[builtins.str]:
        '''A unique identifier for cross-account role assumption.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        '''
        result = self._values.get("external_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def session_name(self) -> typing.Optional[builtins.str]:
        '''A session identifier used for logging and tracing the assumed role session.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        result = self._values.get("session_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsAmazonS3Auth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsAmazonS3AuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonS3AuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3058b65ec20fd2feb340c05008b150ef2b671025884698d8ffb3945b77b64755)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAssumeRole")
    def reset_assume_role(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAssumeRole", []))

    @jsii.member(jsii_name="resetExternalId")
    def reset_external_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExternalId", []))

    @jsii.member(jsii_name="resetSessionName")
    def reset_session_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSessionName", []))

    @builtins.property
    @jsii.member(jsii_name="assumeRoleInput")
    def assume_role_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "assumeRoleInput"))

    @builtins.property
    @jsii.member(jsii_name="externalIdInput")
    def external_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "externalIdInput"))

    @builtins.property
    @jsii.member(jsii_name="sessionNameInput")
    def session_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sessionNameInput"))

    @builtins.property
    @jsii.member(jsii_name="assumeRole")
    def assume_role(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "assumeRole"))

    @assume_role.setter
    def assume_role(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d357410bfe350b18f5e59538b1edf76314794d8fcd75c96a575739825b331b9f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "assumeRole", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="externalId")
    def external_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "externalId"))

    @external_id.setter
    def external_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b08c9764e59b4e26f9e56ed46192e150171c5e237faebd8253d86f13d8736046)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "externalId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sessionName")
    def session_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sessionName"))

    @session_name.setter
    def session_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b22a6e59c4e46038f73de7fac7605ebec83ea00be25f67c0419c3098935b5b29)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sessionName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonS3Auth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonS3Auth]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonS3Auth]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd90c994d1d916a7dbc7593c84b518e6663e93b8688eb0a08e5c1d4896b95730)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsAmazonS3List(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonS3List",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__128736745372392bd85317b441e62eb738e795e1b5723cd309ba4d59aca2778d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsAmazonS3OutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b22d2940cd382dd76943916787634fae27e1972394bb2c6246d01e2e5e54476c)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsAmazonS3OutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28cb865e7292c459519c081688285714c8112175ee770535b3c4b973a8d3e2f4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8aae0aaf83f26177109d6feac63defa290110382ad05c2c412456bf51f516263)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4198730b81c92ea779597df1fb7d03a2ffc089516b0c6e56c9de2836c5b2db13)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonS3]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonS3]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonS3]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7afababc0224be2af91e0df7824f243a2f7d6e0b0120b7bc7d39745a0f6240af)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsAmazonS3OutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonS3OutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fca199665e41e4706d02dfb3b3b64b69cf8996084b3d06dcf99e803f3ef03cd2)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAuth")
    def put_auth(
        self,
        *,
        assume_role: typing.Optional[builtins.str] = None,
        external_id: typing.Optional[builtins.str] = None,
        session_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param assume_role: The Amazon Resource Name (ARN) of the role to assume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        :param external_id: A unique identifier for cross-account role assumption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        :param session_name: A session identifier used for logging and tracing the assumed role session. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        value = ObservabilityPipelineConfigDestinationsAmazonS3Auth(
            assume_role=assume_role, external_id=external_id, session_name=session_name
        )

        return typing.cast(None, jsii.invoke(self, "putAuth", [value]))

    @jsii.member(jsii_name="resetAuth")
    def reset_auth(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAuth", []))

    @builtins.property
    @jsii.member(jsii_name="auth")
    def auth(
        self,
    ) -> ObservabilityPipelineConfigDestinationsAmazonS3AuthOutputReference:
        return typing.cast(ObservabilityPipelineConfigDestinationsAmazonS3AuthOutputReference, jsii.get(self, "auth"))

    @builtins.property
    @jsii.member(jsii_name="authInput")
    def auth_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonS3Auth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonS3Auth]], jsii.get(self, "authInput"))

    @builtins.property
    @jsii.member(jsii_name="bucketInput")
    def bucket_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "bucketInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="keyPrefixInput")
    def key_prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyPrefixInput"))

    @builtins.property
    @jsii.member(jsii_name="regionInput")
    def region_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regionInput"))

    @builtins.property
    @jsii.member(jsii_name="storageClassInput")
    def storage_class_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "storageClassInput"))

    @builtins.property
    @jsii.member(jsii_name="bucket")
    def bucket(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "bucket"))

    @bucket.setter
    def bucket(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6bc7d8c6a0ffe14df5be6731483af539c67909e294061eb1aaecce312482a8db)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bucket", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e320eaecb548345b89ffec2722a0cb1c9970817ee537cdbd01d0da1d771f35e0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9daef04b1651d718711baf5e3243edf3df88bf42a9719a061466959e96d7afbd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyPrefix")
    def key_prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyPrefix"))

    @key_prefix.setter
    def key_prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3adc47c1c7408723ab4b37c736847309d2440139eaa4d4edea295cbf4417f101)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyPrefix", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="region")
    def region(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "region"))

    @region.setter
    def region(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fab9879e42ee9fd6f6463c0da21edf999562a79246665f351ea5591230700d36)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "region", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="storageClass")
    def storage_class(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "storageClass"))

    @storage_class.setter
    def storage_class(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0dd8b2564c326776caea50f7f024c69bce8dd856c00607be3a0dc59d7207fc72)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "storageClass", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonS3]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonS3]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonS3]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__43c04465411bf1252b3a0946e2cb7f4e982c6ff95ed2fc9f98034ddbdb1d72e8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonSecurityLake",
    jsii_struct_bases=[],
    name_mapping={
        "bucket": "bucket",
        "custom_source_name": "customSourceName",
        "id": "id",
        "inputs": "inputs",
        "region": "region",
        "auth": "auth",
        "tls": "tls",
    },
)
class ObservabilityPipelineConfigDestinationsAmazonSecurityLake:
    def __init__(
        self,
        *,
        bucket: builtins.str,
        custom_source_name: builtins.str,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        region: builtins.str,
        auth: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param bucket: Name of the Amazon S3 bucket in Security Lake (3-63 characters). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#bucket ObservabilityPipeline#bucket}
        :param custom_source_name: Custom source name for the logs in Security Lake. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#custom_source_name ObservabilityPipeline#custom_source_name}
        :param id: Unique identifier for the destination component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param region: AWS region of the Security Lake bucket. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#region ObservabilityPipeline#region}
        :param auth: auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(auth, dict):
            auth = ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth(**auth)
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0f1e415a2d6412e0342623ad0f7a1fdc69f58b352b361c556aaa67e3f6f002d)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
            check_type(argname="argument custom_source_name", value=custom_source_name, expected_type=type_hints["custom_source_name"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bucket": bucket,
            "custom_source_name": custom_source_name,
            "id": id,
            "inputs": inputs,
            "region": region,
        }
        if auth is not None:
            self._values["auth"] = auth
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def bucket(self) -> builtins.str:
        '''Name of the Amazon S3 bucket in Security Lake (3-63 characters).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#bucket ObservabilityPipeline#bucket}
        '''
        result = self._values.get("bucket")
        assert result is not None, "Required property 'bucket' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def custom_source_name(self) -> builtins.str:
        '''Custom source name for the logs in Security Lake.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#custom_source_name ObservabilityPipeline#custom_source_name}
        '''
        result = self._values.get("custom_source_name")
        assert result is not None, "Required property 'custom_source_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def id(self) -> builtins.str:
        '''Unique identifier for the destination component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def region(self) -> builtins.str:
        '''AWS region of the Security Lake bucket.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#region ObservabilityPipeline#region}
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth"]:
        '''auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth"], result)

    @builtins.property
    def tls(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsAmazonSecurityLake(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth",
    jsii_struct_bases=[],
    name_mapping={
        "assume_role": "assumeRole",
        "external_id": "externalId",
        "session_name": "sessionName",
    },
)
class ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth:
    def __init__(
        self,
        *,
        assume_role: typing.Optional[builtins.str] = None,
        external_id: typing.Optional[builtins.str] = None,
        session_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param assume_role: The Amazon Resource Name (ARN) of the role to assume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        :param external_id: A unique identifier for cross-account role assumption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        :param session_name: A session identifier used for logging and tracing the assumed role session. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01e2e22c88c7c632b6ec106b16733acedf840d80970a9cdb8237117b83286a68)
            check_type(argname="argument assume_role", value=assume_role, expected_type=type_hints["assume_role"])
            check_type(argname="argument external_id", value=external_id, expected_type=type_hints["external_id"])
            check_type(argname="argument session_name", value=session_name, expected_type=type_hints["session_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if assume_role is not None:
            self._values["assume_role"] = assume_role
        if external_id is not None:
            self._values["external_id"] = external_id
        if session_name is not None:
            self._values["session_name"] = session_name

    @builtins.property
    def assume_role(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the role to assume.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        '''
        result = self._values.get("assume_role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def external_id(self) -> typing.Optional[builtins.str]:
        '''A unique identifier for cross-account role assumption.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        '''
        result = self._values.get("external_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def session_name(self) -> typing.Optional[builtins.str]:
        '''A session identifier used for logging and tracing the assumed role session.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        result = self._values.get("session_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9b5c64ce1b640b55c0113ec7b3ff50ee4bff13125b86512e241e547008ae3fa)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAssumeRole")
    def reset_assume_role(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAssumeRole", []))

    @jsii.member(jsii_name="resetExternalId")
    def reset_external_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExternalId", []))

    @jsii.member(jsii_name="resetSessionName")
    def reset_session_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSessionName", []))

    @builtins.property
    @jsii.member(jsii_name="assumeRoleInput")
    def assume_role_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "assumeRoleInput"))

    @builtins.property
    @jsii.member(jsii_name="externalIdInput")
    def external_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "externalIdInput"))

    @builtins.property
    @jsii.member(jsii_name="sessionNameInput")
    def session_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sessionNameInput"))

    @builtins.property
    @jsii.member(jsii_name="assumeRole")
    def assume_role(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "assumeRole"))

    @assume_role.setter
    def assume_role(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ebb436e3535e0c181d0fd676fc74f71ff21ccc1e4c88c02a8d8692e23a27b4e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "assumeRole", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="externalId")
    def external_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "externalId"))

    @external_id.setter
    def external_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68b20ada9871b4ab372bb7397afcade4b505872c0026566c674f13cd5931b9a9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "externalId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sessionName")
    def session_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sessionName"))

    @session_name.setter
    def session_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d93671de028c5fce6840d90d14b05494501098e13b4cdf31ac3d8eb4fa66971e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sessionName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69d51796777f20e52919eee4f1e154c7205590cff724b11c66f8ae1910f67258)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsAmazonSecurityLakeList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonSecurityLakeList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6df5714e88606c4e5a3e904ffa638809ca3a53d647ea6c28b7a4add9a065656f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsAmazonSecurityLakeOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f2ecfd67be50f77e93dfe9b452b5fb4aed77fa44deece8e14dc564da58006332)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsAmazonSecurityLakeOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bae8890e40071e3527a34d71eeb85017255ba95530b6e8d786f768496b608c58)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9007747358d381af563093eede59effe1aa4d93e20d20549564beb7463ab7d7a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c64d535e5ee0bf5e5d5b9ddccaeaccfa4ea47458a389988e733c0475802688c2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonSecurityLake]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonSecurityLake]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonSecurityLake]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17474d47ff2a97352d9ba25327c0c50f498902c434979f29c86c8a0a1cd8b712)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsAmazonSecurityLakeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonSecurityLakeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8425de9d4d73ee7ccaa67f7b162f8dbb9e7e0b9e61761e785c1ceacb4939bfc)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAuth")
    def put_auth(
        self,
        *,
        assume_role: typing.Optional[builtins.str] = None,
        external_id: typing.Optional[builtins.str] = None,
        session_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param assume_role: The Amazon Resource Name (ARN) of the role to assume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        :param external_id: A unique identifier for cross-account role assumption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        :param session_name: A session identifier used for logging and tracing the assumed role session. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        value = ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth(
            assume_role=assume_role, external_id=external_id, session_name=session_name
        )

        return typing.cast(None, jsii.invoke(self, "putAuth", [value]))

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetAuth")
    def reset_auth(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAuth", []))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="auth")
    def auth(
        self,
    ) -> ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuthOutputReference:
        return typing.cast(ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuthOutputReference, jsii.get(self, "auth"))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(
        self,
    ) -> "ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="authInput")
    def auth_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth]], jsii.get(self, "authInput"))

    @builtins.property
    @jsii.member(jsii_name="bucketInput")
    def bucket_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "bucketInput"))

    @builtins.property
    @jsii.member(jsii_name="customSourceNameInput")
    def custom_source_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "customSourceNameInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="regionInput")
    def region_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regionInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="bucket")
    def bucket(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "bucket"))

    @bucket.setter
    def bucket(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7071ed51fcbfd6d36274d22287700a2982c5a6371ffe84576d085647c70c934d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bucket", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="customSourceName")
    def custom_source_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "customSourceName"))

    @custom_source_name.setter
    def custom_source_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9900ba4b0c7e6e85c2cc3aea1110bc0ce7007151290b02026f3bb0c3bfb486e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "customSourceName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57ef4b9862654cfda85b3aa0c027e629314031e03791121e023aff4fc07a4f9d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8fe244d20230c44216c13c21d3e7a5772a733bb8230a16151507b290a368d4bf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="region")
    def region(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "region"))

    @region.setter
    def region(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5fab996d7a4d6b817cce21f28149eb234fa9ddc83f8b85160f314e53b207d7e3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "region", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLake]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLake]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLake]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2735877a8e658bbbc0ac268593938d33328d3607f411c549edde85c8ef4676c2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6c60e583ccc68cf9a353b7155c827e6b6b04594880ca4e8dc22ff64ba1c9318)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dfe51498573493fe8b3cabee454eaba99d12cb2be8c11f6cf0d5d0d4f6f1c0bd)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c73daf819fae19e63f19f187efc30e94ecf80406456225c6e7d900b1465ddc40)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89ac377deba321a0b3abc6c994306cf54c7d25785140bc8c47755dd35ea46b39)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d6a9b9bdf43173d8f6e98744cee031aa3e23cae9e31ac801fed2b1d65ec3784)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fdadc7b240b092f95505ceb1370c67cf0d2bbd24057d23ad1d4c60c617ca3009)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAzureStorage",
    jsii_struct_bases=[],
    name_mapping={
        "container_name": "containerName",
        "id": "id",
        "inputs": "inputs",
        "blob_prefix": "blobPrefix",
    },
)
class ObservabilityPipelineConfigDestinationsAzureStorage:
    def __init__(
        self,
        *,
        container_name: builtins.str,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        blob_prefix: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param container_name: The name of the Azure Blob Storage container to store logs in. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#container_name ObservabilityPipeline#container_name}
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param blob_prefix: Optional prefix for blobs written to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#blob_prefix ObservabilityPipeline#blob_prefix}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fdff26cda860ca33f7c2aa3e2de604c221ae52ad173232764abc5bc2fd67ea96)
            check_type(argname="argument container_name", value=container_name, expected_type=type_hints["container_name"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument blob_prefix", value=blob_prefix, expected_type=type_hints["blob_prefix"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "container_name": container_name,
            "id": id,
            "inputs": inputs,
        }
        if blob_prefix is not None:
            self._values["blob_prefix"] = blob_prefix

    @builtins.property
    def container_name(self) -> builtins.str:
        '''The name of the Azure Blob Storage container to store logs in.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#container_name ObservabilityPipeline#container_name}
        '''
        result = self._values.get("container_name")
        assert result is not None, "Required property 'container_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def blob_prefix(self) -> typing.Optional[builtins.str]:
        '''Optional prefix for blobs written to the container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#blob_prefix ObservabilityPipeline#blob_prefix}
        '''
        result = self._values.get("blob_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsAzureStorage(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsAzureStorageList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAzureStorageList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5734f10a1684173a4966cfd33916e08f53518ad191fa71dfe3193f050cc55910)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsAzureStorageOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a669c4ff3b69e689b3fc213ae253a3b82d004566ee524ca2fbe4a99071bc785)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsAzureStorageOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__014249dd672dadead4134c58256a34c0e9026d89c51a55878e3886468e565244)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b9e719cccd30341cc77e3bf501d1ef67ae778b801a9daf55f2ce074fdd7b21fc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14a51f00f147efd1b56c90e66c9d3a3baad6e40f5ca562b600c00470d55cd341)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAzureStorage]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAzureStorage]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAzureStorage]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d3174effc279baae4980f16ce53fffb22cd7910a587200abfdda506e5dfe422c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsAzureStorageOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsAzureStorageOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df6cf2a63bc0daf9c0167b9dabd0e07651c549ca84c9bcd7c47c739132834eec)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetBlobPrefix")
    def reset_blob_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBlobPrefix", []))

    @builtins.property
    @jsii.member(jsii_name="blobPrefixInput")
    def blob_prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "blobPrefixInput"))

    @builtins.property
    @jsii.member(jsii_name="containerNameInput")
    def container_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "containerNameInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="blobPrefix")
    def blob_prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "blobPrefix"))

    @blob_prefix.setter
    def blob_prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f68e6d7809d9a71fcd94948449d760b5053d691d4aee7219888dc3f52842f43d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "blobPrefix", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="containerName")
    def container_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "containerName"))

    @container_name.setter
    def container_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec2b5ec3a98c85574896875ac1a3b8f58766251a9f5e6820a22cd70822351e82)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "containerName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f43edc9de124e47a189c417f513878088220f83aa7bf88a3ed71c44a127fd69b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2653dcea9231e6abc6230ea6ab227ab61fee27c7b63ae7d2f03ee4b8870fc9c8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAzureStorage]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAzureStorage]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAzureStorage]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd483bc6fc17d177c79f5fac71e1116b726a1767d74ed9e1baa894fdf1babbc3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem",
    jsii_struct_bases=[],
    name_mapping={
        "encoding": "encoding",
        "id": "id",
        "inputs": "inputs",
        "compression": "compression",
        "tls": "tls",
    },
)
class ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem:
    def __init__(
        self,
        *,
        encoding: builtins.str,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        compression: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression", typing.Dict[builtins.str, typing.Any]]] = None,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param encoding: Encoding format for log events. Valid values are ``json``, ``raw_message``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        :param id: Unique identifier for the destination component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param compression: compression block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#compression ObservabilityPipeline#compression}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(compression, dict):
            compression = ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression(**compression)
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__48991e904ebd3292529afd2230975cb5d73edc28c142a36df03b3f5b4ddd364b)
            check_type(argname="argument encoding", value=encoding, expected_type=type_hints["encoding"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument compression", value=compression, expected_type=type_hints["compression"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "encoding": encoding,
            "id": id,
            "inputs": inputs,
        }
        if compression is not None:
            self._values["compression"] = compression
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def encoding(self) -> builtins.str:
        '''Encoding format for log events. Valid values are ``json``, ``raw_message``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        '''
        result = self._values.get("encoding")
        assert result is not None, "Required property 'encoding' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def id(self) -> builtins.str:
        '''Unique identifier for the destination component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def compression(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression"]:
        '''compression block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#compression ObservabilityPipeline#compression}
        '''
        result = self._values.get("compression")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression"], result)

    @builtins.property
    def tls(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression",
    jsii_struct_bases=[],
    name_mapping={"algorithm": "algorithm", "level": "level"},
)
class ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression:
    def __init__(
        self,
        *,
        algorithm: typing.Optional[builtins.str] = None,
        level: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param algorithm: Compression algorithm for log events. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#algorithm ObservabilityPipeline#algorithm}
        :param level: Compression level. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#level ObservabilityPipeline#level}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c3723e779f374c8ffc3f69a50d23ba1c3edd50378e609839091025cc07553a4)
            check_type(argname="argument algorithm", value=algorithm, expected_type=type_hints["algorithm"])
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if algorithm is not None:
            self._values["algorithm"] = algorithm
        if level is not None:
            self._values["level"] = level

    @builtins.property
    def algorithm(self) -> typing.Optional[builtins.str]:
        '''Compression algorithm for log events.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#algorithm ObservabilityPipeline#algorithm}
        '''
        result = self._values.get("algorithm")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def level(self) -> typing.Optional[jsii.Number]:
        '''Compression level.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#level ObservabilityPipeline#level}
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompressionOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompressionOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__156ad62c481da5ecf275a79e95a001e213568c9a6952d8448521c95262ac41f5)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAlgorithm")
    def reset_algorithm(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAlgorithm", []))

    @jsii.member(jsii_name="resetLevel")
    def reset_level(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLevel", []))

    @builtins.property
    @jsii.member(jsii_name="algorithmInput")
    def algorithm_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "algorithmInput"))

    @builtins.property
    @jsii.member(jsii_name="levelInput")
    def level_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "levelInput"))

    @builtins.property
    @jsii.member(jsii_name="algorithm")
    def algorithm(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "algorithm"))

    @algorithm.setter
    def algorithm(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b49b17b14c359e0899c935262842796685c126d693c12110b0aebcf39841992)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "algorithm", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="level")
    def level(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "level"))

    @level.setter
    def level(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9026eae6fdb6675aeab565913967da900e690970657c9676ddda4573d72494a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "level", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d8a14a38e73efb8c19d6a7ccbab7baddbd1b2b04b57cd9a530c074ebcd1cd67)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9506647104068b6e97642118a8830318f295049b4d2a26713bf3c5417d0156a2)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f13cc1aca198b0571263ece63691a67de39a84142773ac803285c447f0deaf4e)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2397744c92358f1fac973645c0efc02dfe7dfc0855ba67fde0ae57baa002681e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e94b63ae600e2b0c90b494d96f9f943ea16d9a5060b7af9cb5996c5fc1afe4d6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19cc633943ad8e67952b50f09be5e171917ec4787b0d2bc4e5f998180ab19abf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5752c6e5cb8bff2443e6dd5bdd8e52d59cb98f3280db62213005d495cae8f14)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__013492682ba0a6553fed67a0b98113d3e55fb85e260d1cb4f42a742a2f58d884)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putCompression")
    def put_compression(
        self,
        *,
        algorithm: typing.Optional[builtins.str] = None,
        level: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param algorithm: Compression algorithm for log events. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#algorithm ObservabilityPipeline#algorithm}
        :param level: Compression level. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#level ObservabilityPipeline#level}
        '''
        value = ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression(
            algorithm=algorithm, level=level
        )

        return typing.cast(None, jsii.invoke(self, "putCompression", [value]))

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetCompression")
    def reset_compression(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCompression", []))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="compression")
    def compression(
        self,
    ) -> ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompressionOutputReference:
        return typing.cast(ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompressionOutputReference, jsii.get(self, "compression"))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(
        self,
    ) -> "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="compressionInput")
    def compression_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression]], jsii.get(self, "compressionInput"))

    @builtins.property
    @jsii.member(jsii_name="encodingInput")
    def encoding_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "encodingInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="encoding")
    def encoding(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "encoding"))

    @encoding.setter
    def encoding(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbf11639e363efd1472817f8feb962f0d278f323fc5f01735670a76dc23aca56)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "encoding", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ef30b10c95cda4d9d1dcb057fc0eb6ba7f14c83ebe6c96eb631d1bea23d082e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1ece930e991f4a5c9a74b5c6a3dc9961f03c24d7417453cd8fb89acca35e198)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb55fe901f44e0daa6ca0afb535aaaca98fb7d79aedb7264464e4facea6db5d0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e7d9a78330966d8db12e2c7dde1c1068f6a177ba78ad8d4b85136a593b4c675)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b93e45da63cb5c3db8e29227155e178128826bc0b8e36f6fcce2f599db0a42eb)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c4078ffa140a7b901466f98e6d66b061272c1fb12e42f03204ea6d52d7c6777)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89f1c3d77ba2c15a31bbec39a49e517eaf081792da125dbb09b487b39e2e5a34)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24122b854ebfa6ad0601d8734082aba4fc484aa6a530483b3df24da12e36535e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e9cdcd97a0f632aa553f44910f172284f71b21482dd7f432c928a24e41f8be8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsDatadogLogs",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "inputs": "inputs"},
)
class ObservabilityPipelineConfigDestinationsDatadogLogs:
    def __init__(
        self,
        *,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param id: The unique ID of the destination. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: The inputs for the destination. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ac7dd044594db6b267b5b808b4b6d3114fd6b446568da2576017b50d75475a7)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "inputs": inputs,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique ID of the destination.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''The inputs for the destination.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsDatadogLogs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsDatadogLogsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsDatadogLogsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5aabd92b775f32011ac2e7c257e22adbcd8f1cc95689369e1bc39040d06b101)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsDatadogLogsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7730a2c775288521ccf5fe9a4bf19fbe0208607b7721f4e02690fdaec0813e71)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsDatadogLogsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c80e697f29b37aa467228bf645facf5643366f52d772a5b26ab343ce57431a98)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b37d312314900c4ee7072fe40ad009230acc902afa1f1c79afe052e78176b518)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__02d3ae4b31ed8c50bc5f045efbb15e93a74afe9af5d85caf73e21ef7e8f71195)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsDatadogLogs]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsDatadogLogs]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsDatadogLogs]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35a7af2a4bc4915faa207bf9d70e66986d25038f3950fde7a83fb1bb05d427c7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsDatadogLogsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsDatadogLogsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a59e02a3d3fd3807823df3b953ee8ce8489fc4dd14463c24a91ea8304691f9b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2412e932c2485a20cb00476081bb7c21bd62c57159657dbfce7459ae074e7447)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__030a941fbd0ab1862c8f1031d29b9bd12dfc521fbad9065c9db6caa73d110383)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsDatadogLogs]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsDatadogLogs]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsDatadogLogs]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d59598cc5cfe643183aead5dba514126bc63c910e89924c6b3bb39969841463)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsElasticsearch",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "inputs": "inputs",
        "api_version": "apiVersion",
        "bulk_index": "bulkIndex",
    },
)
class ObservabilityPipelineConfigDestinationsElasticsearch:
    def __init__(
        self,
        *,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        api_version: typing.Optional[builtins.str] = None,
        bulk_index: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param api_version: The Elasticsearch API version to use. Set to ``auto`` to auto-detect. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#api_version ObservabilityPipeline#api_version}
        :param bulk_index: The index or datastream to write logs to in Elasticsearch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#bulk_index ObservabilityPipeline#bulk_index}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29df4ece8f2b3bb42fa2f2347fb7f7f89f8e8032060c23d6f7bf97d3d8cd67c4)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument bulk_index", value=bulk_index, expected_type=type_hints["bulk_index"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "inputs": inputs,
        }
        if api_version is not None:
            self._values["api_version"] = api_version
        if bulk_index is not None:
            self._values["bulk_index"] = bulk_index

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''The Elasticsearch API version to use. Set to ``auto`` to auto-detect.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#api_version ObservabilityPipeline#api_version}
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def bulk_index(self) -> typing.Optional[builtins.str]:
        '''The index or datastream to write logs to in Elasticsearch.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#bulk_index ObservabilityPipeline#bulk_index}
        '''
        result = self._values.get("bulk_index")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsElasticsearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsElasticsearchList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsElasticsearchList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86b6b4057038bd264a80e5f04878990d00d9a3777125aa7fd8c5c5bab670aa9e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsElasticsearchOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cda7688bdebfde07f0b5c5e31fb18b01df7c29c5b7a446a173e6a83c8c13b441)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsElasticsearchOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c246a4a942f9feffbb30a8dce89ac5b55da7cbf253498bd6478350ac71217b3e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f5236f0f1d96d7ea448a67517a90d85b02eb4873963ddae30a19252fe3869c5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e99345a2881a1a840abda8b2a32e8c5eb821bf5256c182a7413942c04407a493)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsElasticsearch]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsElasticsearch]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsElasticsearch]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aaa83750bb1a3e8486d93d357cb2a41e6012a6a94901a0855fffc7de8e0ff030)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsElasticsearchOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsElasticsearchOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f4d8ad045e721ce3d9360b0e4aa8132ef0d6bca800390f214b7a8f62d0b4f83)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetApiVersion")
    def reset_api_version(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetApiVersion", []))

    @jsii.member(jsii_name="resetBulkIndex")
    def reset_bulk_index(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBulkIndex", []))

    @builtins.property
    @jsii.member(jsii_name="apiVersionInput")
    def api_version_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiVersionInput"))

    @builtins.property
    @jsii.member(jsii_name="bulkIndexInput")
    def bulk_index_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "bulkIndexInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="apiVersion")
    def api_version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiVersion"))

    @api_version.setter
    def api_version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb30d6c1892ce64be241e4ca78ecb58e926a6872efa0187e65915fcb88ff3fd9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "apiVersion", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="bulkIndex")
    def bulk_index(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "bulkIndex"))

    @bulk_index.setter
    def bulk_index(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9be7d09411f53a39501b1e974386f7d2700eaa05739049e14511ac755aeee137)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bulkIndex", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e977949e7c267fba18d9a3b78ab7a4b6960f79682514cfef58abc5b8a9f592a3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9faa573887c077aaee6a094d93dc6512b8561c9d4fa4a27ea587a74a93bebf32)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsElasticsearch]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsElasticsearch]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsElasticsearch]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03dc57c8e26aac73c98fcbd0728733bcbdb5c76a8e297ee32072a337cf2d3bd8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGoogleChronicle",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "inputs": "inputs",
        "auth": "auth",
        "customer_id": "customerId",
        "encoding": "encoding",
        "log_type": "logType",
    },
)
class ObservabilityPipelineConfigDestinationsGoogleChronicle:
    def __init__(
        self,
        *,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        auth: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsGoogleChronicleAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        customer_id: typing.Optional[builtins.str] = None,
        encoding: typing.Optional[builtins.str] = None,
        log_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param auth: auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        :param customer_id: The Google Chronicle customer ID. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#customer_id ObservabilityPipeline#customer_id}
        :param encoding: The encoding format for the logs sent to Chronicle. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        :param log_type: The log type metadata associated with the Chronicle destination. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#log_type ObservabilityPipeline#log_type}
        '''
        if isinstance(auth, dict):
            auth = ObservabilityPipelineConfigDestinationsGoogleChronicleAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71ac06731aba28b0ea70956e64fc45683a79b5c73df71da414b1dfd9d1f317ef)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument customer_id", value=customer_id, expected_type=type_hints["customer_id"])
            check_type(argname="argument encoding", value=encoding, expected_type=type_hints["encoding"])
            check_type(argname="argument log_type", value=log_type, expected_type=type_hints["log_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "inputs": inputs,
        }
        if auth is not None:
            self._values["auth"] = auth
        if customer_id is not None:
            self._values["customer_id"] = customer_id
        if encoding is not None:
            self._values["encoding"] = encoding
        if log_type is not None:
            self._values["log_type"] = log_type

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def auth(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsGoogleChronicleAuth"]:
        '''auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsGoogleChronicleAuth"], result)

    @builtins.property
    def customer_id(self) -> typing.Optional[builtins.str]:
        '''The Google Chronicle customer ID.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#customer_id ObservabilityPipeline#customer_id}
        '''
        result = self._values.get("customer_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def encoding(self) -> typing.Optional[builtins.str]:
        '''The encoding format for the logs sent to Chronicle.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        '''
        result = self._values.get("encoding")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_type(self) -> typing.Optional[builtins.str]:
        '''The log type metadata associated with the Chronicle destination.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#log_type ObservabilityPipeline#log_type}
        '''
        result = self._values.get("log_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsGoogleChronicle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGoogleChronicleAuth",
    jsii_struct_bases=[],
    name_mapping={"credentials_file": "credentialsFile"},
)
class ObservabilityPipelineConfigDestinationsGoogleChronicleAuth:
    def __init__(
        self,
        *,
        credentials_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param credentials_file: Path to the GCP service account key file. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#credentials_file ObservabilityPipeline#credentials_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5be395439c532bdbb290e7c9d2e28c95627b1dd534f903bfbfc182d9e64091b3)
            check_type(argname="argument credentials_file", value=credentials_file, expected_type=type_hints["credentials_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if credentials_file is not None:
            self._values["credentials_file"] = credentials_file

    @builtins.property
    def credentials_file(self) -> typing.Optional[builtins.str]:
        '''Path to the GCP service account key file.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#credentials_file ObservabilityPipeline#credentials_file}
        '''
        result = self._values.get("credentials_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsGoogleChronicleAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsGoogleChronicleAuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGoogleChronicleAuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e7aba2f587509591d30b88f1053635ae9f9f6cecb4faf8ff7456c79a2421bdc)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCredentialsFile")
    def reset_credentials_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCredentialsFile", []))

    @builtins.property
    @jsii.member(jsii_name="credentialsFileInput")
    def credentials_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "credentialsFileInput"))

    @builtins.property
    @jsii.member(jsii_name="credentialsFile")
    def credentials_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "credentialsFile"))

    @credentials_file.setter
    def credentials_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b21c339b44d85637cd3cbbc9107170c18cfe61aadc0e406e4fde9d2c8f9d333)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "credentialsFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleChronicleAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleChronicleAuth]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleChronicleAuth]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a80d5b3dce05587d2a702828e17c12d7e251c8e0af1a48a340081ab66dc8a64c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsGoogleChronicleList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGoogleChronicleList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1527a7f65c834406856b24132e5683418d8f4b5a7263b1e51656f04e3341e84)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsGoogleChronicleOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__caa115d8d7b99e207039d620fe742786834fea22a6f357946342c3202228e742)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsGoogleChronicleOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c49944d185fa500d138764b4b8a8923e1772ba3f988fc12c93fa9740a044ef14)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2bcb25e3d1359f9baf009e8c12a0558a73addb6b60f67e52fd4ea3ee4f0b5c5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ade585fa653e60c9e697726fb0eea6c3da3011846fd4dd2ec9bfb62ee564d9c9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleChronicle]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleChronicle]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleChronicle]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be8dc30cf9c0817989c8ea8c7e0d8a6006b0343a1627b7656c2fd500b34e402e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsGoogleChronicleOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGoogleChronicleOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3495e8a465f69e6b647a2143d4472f794ab4f48c5006a197c3cad95ab8cc5d78)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAuth")
    def put_auth(
        self,
        *,
        credentials_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param credentials_file: Path to the GCP service account key file. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#credentials_file ObservabilityPipeline#credentials_file}
        '''
        value = ObservabilityPipelineConfigDestinationsGoogleChronicleAuth(
            credentials_file=credentials_file
        )

        return typing.cast(None, jsii.invoke(self, "putAuth", [value]))

    @jsii.member(jsii_name="resetAuth")
    def reset_auth(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAuth", []))

    @jsii.member(jsii_name="resetCustomerId")
    def reset_customer_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCustomerId", []))

    @jsii.member(jsii_name="resetEncoding")
    def reset_encoding(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEncoding", []))

    @jsii.member(jsii_name="resetLogType")
    def reset_log_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogType", []))

    @builtins.property
    @jsii.member(jsii_name="auth")
    def auth(
        self,
    ) -> ObservabilityPipelineConfigDestinationsGoogleChronicleAuthOutputReference:
        return typing.cast(ObservabilityPipelineConfigDestinationsGoogleChronicleAuthOutputReference, jsii.get(self, "auth"))

    @builtins.property
    @jsii.member(jsii_name="authInput")
    def auth_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleChronicleAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleChronicleAuth]], jsii.get(self, "authInput"))

    @builtins.property
    @jsii.member(jsii_name="customerIdInput")
    def customer_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "customerIdInput"))

    @builtins.property
    @jsii.member(jsii_name="encodingInput")
    def encoding_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "encodingInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="logTypeInput")
    def log_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="customerId")
    def customer_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "customerId"))

    @customer_id.setter
    def customer_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af158b8dff960333f548da2a42afd6431fe66108cfd8294dab775121a2f210e1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "customerId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="encoding")
    def encoding(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "encoding"))

    @encoding.setter
    def encoding(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d13b508da21650f8ceab9d80b0d3d578adae2640ff81fd519ab10b6eacae634a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "encoding", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36dc43a2e8c24d063715f1dfc25867feede2bca533954c4bfad3a370e8f1c39f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84e4322714fd521597e9a315c46e1fd7f378c3bf325c2e89353c784b439a8a1a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="logType")
    def log_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "logType"))

    @log_type.setter
    def log_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb0648e8f23dd4ab9c702a0fea8242ca3a00a62e5d00468a770ec6f9334caa7f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "logType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleChronicle]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleChronicle]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleChronicle]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00b1e0d4e84f3a87765464afccd34ded16e61bbeb9b235724bdb81efb836dccc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGoogleCloudStorage",
    jsii_struct_bases=[],
    name_mapping={
        "acl": "acl",
        "auth": "auth",
        "bucket": "bucket",
        "id": "id",
        "inputs": "inputs",
        "storage_class": "storageClass",
        "key_prefix": "keyPrefix",
        "metadata": "metadata",
    },
)
class ObservabilityPipelineConfigDestinationsGoogleCloudStorage:
    def __init__(
        self,
        *,
        acl: builtins.str,
        auth: typing.Union["ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth", typing.Dict[builtins.str, typing.Any]],
        bucket: builtins.str,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        storage_class: builtins.str,
        key_prefix: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param acl: Access control list setting for objects written to the bucket. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#acl ObservabilityPipeline#acl}
        :param auth: auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        :param bucket: Name of the GCS bucket. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#bucket ObservabilityPipeline#bucket}
        :param id: Unique identifier for the destination component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param storage_class: Storage class used for objects stored in GCS. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#storage_class ObservabilityPipeline#storage_class}
        :param key_prefix: Optional prefix for object keys within the GCS bucket. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_prefix ObservabilityPipeline#key_prefix}
        :param metadata: metadata block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#metadata ObservabilityPipeline#metadata}
        '''
        if isinstance(auth, dict):
            auth = ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__617f80393aa7b57c49eec1771181ad2762d3ce9009e0a4af68d4e1191b7a7016)
            check_type(argname="argument acl", value=acl, expected_type=type_hints["acl"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument storage_class", value=storage_class, expected_type=type_hints["storage_class"])
            check_type(argname="argument key_prefix", value=key_prefix, expected_type=type_hints["key_prefix"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "acl": acl,
            "auth": auth,
            "bucket": bucket,
            "id": id,
            "inputs": inputs,
            "storage_class": storage_class,
        }
        if key_prefix is not None:
            self._values["key_prefix"] = key_prefix
        if metadata is not None:
            self._values["metadata"] = metadata

    @builtins.property
    def acl(self) -> builtins.str:
        '''Access control list setting for objects written to the bucket.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#acl ObservabilityPipeline#acl}
        '''
        result = self._values.get("acl")
        assert result is not None, "Required property 'acl' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(self) -> "ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth":
        '''auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth", result)

    @builtins.property
    def bucket(self) -> builtins.str:
        '''Name of the GCS bucket.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#bucket ObservabilityPipeline#bucket}
        '''
        result = self._values.get("bucket")
        assert result is not None, "Required property 'bucket' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def id(self) -> builtins.str:
        '''Unique identifier for the destination component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def storage_class(self) -> builtins.str:
        '''Storage class used for objects stored in GCS.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#storage_class ObservabilityPipeline#storage_class}
        '''
        result = self._values.get("storage_class")
        assert result is not None, "Required property 'storage_class' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key_prefix(self) -> typing.Optional[builtins.str]:
        '''Optional prefix for object keys within the GCS bucket.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_prefix ObservabilityPipeline#key_prefix}
        '''
        result = self._values.get("key_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata"]]]:
        '''metadata block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#metadata ObservabilityPipeline#metadata}
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsGoogleCloudStorage(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth",
    jsii_struct_bases=[],
    name_mapping={"credentials_file": "credentialsFile"},
)
class ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth:
    def __init__(self, *, credentials_file: builtins.str) -> None:
        '''
        :param credentials_file: Path to the GCP service account key file. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#credentials_file ObservabilityPipeline#credentials_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ffe2f18e27788651e759fae90358a23c5fdf1ca18fbd6df56f2105d7ffc60589)
            check_type(argname="argument credentials_file", value=credentials_file, expected_type=type_hints["credentials_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "credentials_file": credentials_file,
        }

    @builtins.property
    def credentials_file(self) -> builtins.str:
        '''Path to the GCP service account key file.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#credentials_file ObservabilityPipeline#credentials_file}
        '''
        result = self._values.get("credentials_file")
        assert result is not None, "Required property 'credentials_file' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e4cce83c2cafa1e9364191995d0e991f13a83e777d2e14cef3a48f38e00b7f4)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="credentialsFileInput")
    def credentials_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "credentialsFileInput"))

    @builtins.property
    @jsii.member(jsii_name="credentialsFile")
    def credentials_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "credentialsFile"))

    @credentials_file.setter
    def credentials_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea8bf59e9d24eb10631c148eb448d82331c707ca020132ee7557cf5b9f456e81)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "credentialsFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c269eca8543ba49134cc68c79cfbb4b7cdd49965b50d93eccecdd37247970bea)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsGoogleCloudStorageList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGoogleCloudStorageList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f86cd0eafc824fbaab60918cb68a5cbda5dc7ae98deff6cda37851cbb895a14a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsGoogleCloudStorageOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3ce691a634283aa00c1f53762b716f7439152472af7daa6ca3973cbee797747)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsGoogleCloudStorageOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5aa3c020d6e3ab1cf70528c25f31207c009bba942b1022bad4b2d441278adb63)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81c58edd0fe665d173f3e10775a031a766536163b2c0c53571503bfea1d1610c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8dc44364a991187b975196261bd5881f15e17bd323a1185fab0df47986bfe24d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleCloudStorage]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleCloudStorage]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleCloudStorage]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6b22388714a8b3464443ecc90605e31aa46a392327bebb2c31c22fba2ae9a043)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: The metadata key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        :param value: The metadata value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#value ObservabilityPipeline#value}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c92e2586a228070ed58a447abaf69d4c53ebf7b1fe1d7020fb44fa29cbd33303)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''The metadata key.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''The metadata value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#value ObservabilityPipeline#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadataList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadataList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__831fa85735bca62f8bc558d6a689e770e6d392115f6d3bee28870b99213aef98)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadataOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c58183bbf878fecc5c0d76a2de23f2f52bd3cd44dcd934abccbf0832a3746876)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadataOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__109a0bc3aeafeaad2dc3443933b7194d645e088557e3f61d3bacfb923987b5da)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47992d4837c60c0fcab464d6e6a1209aa8f9db32158d376df61688359846107b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a1014a4ebf4ec8c302b2da5bb9dfd0d61087a1017b64211ce35a4addaf51345)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__466e2defe5fb4519d3897a3eb1d13e350044ee5ac42453844fbc46dbb1a781e2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadataOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadataOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fcf9ff353ff7a21fd19bfa0c0e2a10d22221ea3a24ce7496bd1531e8cf1dd942)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f446f4a0464765c911c227e3a4192e1dc85eee9705ef21340888ec422c7a2935)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bb4a817ffd8db8b4314366406e363c6bdda56d4b9fbbc1dabf2cc1206b03d80)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19b389abf44b8964736be1966f4ed7f49639a0acc1b95b85dbaf876889a0db3f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsGoogleCloudStorageOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGoogleCloudStorageOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f38fe7793defeda8d79accdce705937ab72abb78e13052ef95e8b3ec217bf5c8)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAuth")
    def put_auth(self, *, credentials_file: builtins.str) -> None:
        '''
        :param credentials_file: Path to the GCP service account key file. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#credentials_file ObservabilityPipeline#credentials_file}
        '''
        value = ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth(
            credentials_file=credentials_file
        )

        return typing.cast(None, jsii.invoke(self, "putAuth", [value]))

    @jsii.member(jsii_name="putMetadata")
    def put_metadata(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__955ac1c2dcfc4e027632c7f92efe1125f207b9d1367d924db991d5caa4f945c2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putMetadata", [value]))

    @jsii.member(jsii_name="resetKeyPrefix")
    def reset_key_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyPrefix", []))

    @jsii.member(jsii_name="resetMetadata")
    def reset_metadata(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMetadata", []))

    @builtins.property
    @jsii.member(jsii_name="auth")
    def auth(
        self,
    ) -> ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuthOutputReference:
        return typing.cast(ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuthOutputReference, jsii.get(self, "auth"))

    @builtins.property
    @jsii.member(jsii_name="metadata")
    def metadata(
        self,
    ) -> ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadataList:
        return typing.cast(ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadataList, jsii.get(self, "metadata"))

    @builtins.property
    @jsii.member(jsii_name="aclInput")
    def acl_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "aclInput"))

    @builtins.property
    @jsii.member(jsii_name="authInput")
    def auth_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth]], jsii.get(self, "authInput"))

    @builtins.property
    @jsii.member(jsii_name="bucketInput")
    def bucket_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "bucketInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="keyPrefixInput")
    def key_prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyPrefixInput"))

    @builtins.property
    @jsii.member(jsii_name="metadataInput")
    def metadata_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata]]], jsii.get(self, "metadataInput"))

    @builtins.property
    @jsii.member(jsii_name="storageClassInput")
    def storage_class_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "storageClassInput"))

    @builtins.property
    @jsii.member(jsii_name="acl")
    def acl(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "acl"))

    @acl.setter
    def acl(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d916fc2496ce19908ff4cffcbb64f546e582b2466f52b22e12bc52ace20ac20)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "acl", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="bucket")
    def bucket(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "bucket"))

    @bucket.setter
    def bucket(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__955de0bc14457d5ff099224f9fc78f37b95f01a741c0b8c809800b49129e36ed)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bucket", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20c07dc2f28522421c4bde9fbb79832fd4b8e527ed3861ac2e70f1b2c2a9657f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57af8f596fdc500719f0df919b6d18a4b07de499d02dd9b01d8d0d5365d71046)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyPrefix")
    def key_prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyPrefix"))

    @key_prefix.setter
    def key_prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__245577b79cc6a8740fda66e438062157a2c142999491202ba54975b06099fd23)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyPrefix", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="storageClass")
    def storage_class(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "storageClass"))

    @storage_class.setter
    def storage_class(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2afa504a250fe5ef5bb50479381e92d503af2aface9cdd653b9aeb319169ad28)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "storageClass", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorage]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorage]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorage]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fa0a40cbaeca85067f5c65368d40eac937cf034a43c5ebce005bc067e4ee5685)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGooglePubsub",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "inputs": "inputs",
        "project": "project",
        "topic": "topic",
        "auth": "auth",
        "encoding": "encoding",
        "tls": "tls",
    },
)
class ObservabilityPipelineConfigDestinationsGooglePubsub:
    def __init__(
        self,
        *,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        project: builtins.str,
        topic: builtins.str,
        auth: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsGooglePubsubAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        encoding: typing.Optional[builtins.str] = None,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsGooglePubsubTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param project: The GCP project ID that owns the Pub/Sub topic. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#project ObservabilityPipeline#project}
        :param topic: The Pub/Sub topic name to publish logs to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#topic ObservabilityPipeline#topic}
        :param auth: auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        :param encoding: Encoding format for log events. Valid values: ``json``, ``raw_message``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(auth, dict):
            auth = ObservabilityPipelineConfigDestinationsGooglePubsubAuth(**auth)
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigDestinationsGooglePubsubTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5663f7927e25cec417d7911eac06c0c550a05b8f90c9e1d1e0312cf6e4d488c)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument encoding", value=encoding, expected_type=type_hints["encoding"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "inputs": inputs,
            "project": project,
            "topic": topic,
        }
        if auth is not None:
            self._values["auth"] = auth
        if encoding is not None:
            self._values["encoding"] = encoding
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def project(self) -> builtins.str:
        '''The GCP project ID that owns the Pub/Sub topic.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#project ObservabilityPipeline#project}
        '''
        result = self._values.get("project")
        assert result is not None, "Required property 'project' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def topic(self) -> builtins.str:
        '''The Pub/Sub topic name to publish logs to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#topic ObservabilityPipeline#topic}
        '''
        result = self._values.get("topic")
        assert result is not None, "Required property 'topic' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsGooglePubsubAuth"]:
        '''auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsGooglePubsubAuth"], result)

    @builtins.property
    def encoding(self) -> typing.Optional[builtins.str]:
        '''Encoding format for log events. Valid values: ``json``, ``raw_message``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        '''
        result = self._values.get("encoding")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tls(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsGooglePubsubTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsGooglePubsubTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsGooglePubsub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGooglePubsubAuth",
    jsii_struct_bases=[],
    name_mapping={"credentials_file": "credentialsFile"},
)
class ObservabilityPipelineConfigDestinationsGooglePubsubAuth:
    def __init__(
        self,
        *,
        credentials_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param credentials_file: Path to the GCP service account key file. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#credentials_file ObservabilityPipeline#credentials_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89f3272a88770be098030aac1db0c339273d4ea19c5839af5611a4484e00864f)
            check_type(argname="argument credentials_file", value=credentials_file, expected_type=type_hints["credentials_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if credentials_file is not None:
            self._values["credentials_file"] = credentials_file

    @builtins.property
    def credentials_file(self) -> typing.Optional[builtins.str]:
        '''Path to the GCP service account key file.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#credentials_file ObservabilityPipeline#credentials_file}
        '''
        result = self._values.get("credentials_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsGooglePubsubAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsGooglePubsubAuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGooglePubsubAuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8da459416fea9a3ac0e965f1a25e855598a1609b8e6252adb957fad46e7c08ac)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCredentialsFile")
    def reset_credentials_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCredentialsFile", []))

    @builtins.property
    @jsii.member(jsii_name="credentialsFileInput")
    def credentials_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "credentialsFileInput"))

    @builtins.property
    @jsii.member(jsii_name="credentialsFile")
    def credentials_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "credentialsFile"))

    @credentials_file.setter
    def credentials_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c41cf30e708e455f7919037e010efc9a39e557c4dd4d4f061ada2afcc70c7073)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "credentialsFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsubAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsubAuth]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsubAuth]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__911aea1a14df5874c7f6929d6a1fd9e9359c4cc7d113c1c8517d9270741f41ee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsGooglePubsubList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGooglePubsubList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85952b0831b97fadc0505d308426b91f6e235d117826ee7fbfdcd2ce18c918df)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsGooglePubsubOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4673749ec791f1516a2bf22fe2165e4b85742ccd340dd89179e63764677780aa)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsGooglePubsubOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b36cca813ddde7b293422374f5f4979bdeeb64ed63d636a6966e2591af1a402)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11b5cb245a4de370a622cbf7a2569f85000d60527cb0033978063002525fd7c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14fba43bc4504f5efb535d59d1498be0fcb51722c235f34d8974f1d5c9dffcf8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGooglePubsub]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGooglePubsub]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGooglePubsub]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ebe54e3dc1c25644bc3cfb12a7d7e0320b5515cea4f8a6425b5a326648a813cb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsGooglePubsubOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGooglePubsubOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae5b453188d8b24c98829187df067b711cbcc8baefc4c8b919c32c1f2f8b4ebc)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAuth")
    def put_auth(
        self,
        *,
        credentials_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param credentials_file: Path to the GCP service account key file. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#credentials_file ObservabilityPipeline#credentials_file}
        '''
        value = ObservabilityPipelineConfigDestinationsGooglePubsubAuth(
            credentials_file=credentials_file
        )

        return typing.cast(None, jsii.invoke(self, "putAuth", [value]))

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigDestinationsGooglePubsubTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetAuth")
    def reset_auth(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAuth", []))

    @jsii.member(jsii_name="resetEncoding")
    def reset_encoding(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEncoding", []))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="auth")
    def auth(
        self,
    ) -> ObservabilityPipelineConfigDestinationsGooglePubsubAuthOutputReference:
        return typing.cast(ObservabilityPipelineConfigDestinationsGooglePubsubAuthOutputReference, jsii.get(self, "auth"))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(
        self,
    ) -> "ObservabilityPipelineConfigDestinationsGooglePubsubTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigDestinationsGooglePubsubTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="authInput")
    def auth_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsubAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsubAuth]], jsii.get(self, "authInput"))

    @builtins.property
    @jsii.member(jsii_name="encodingInput")
    def encoding_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "encodingInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="projectInput")
    def project_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "projectInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinationsGooglePubsubTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinationsGooglePubsubTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="topicInput")
    def topic_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "topicInput"))

    @builtins.property
    @jsii.member(jsii_name="encoding")
    def encoding(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "encoding"))

    @encoding.setter
    def encoding(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e5261413718c26ba68dbf0210300240792e1965945dc5700bc149667ef05d0c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "encoding", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__afae61bddbbb09cbf94d054a05df93b319c34c0dacb9d561862a4cf96a0ec8ad)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73bd5b80d008dfd4ba6898685720717a87d1217a178ab88655f5f4ec6a286949)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="project")
    def project(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "project"))

    @project.setter
    def project(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__343888629adcfaab8d591bbc6fa02a6a97038efbdb727c45be71224d9e5c761e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "project", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="topic")
    def topic(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "topic"))

    @topic.setter
    def topic(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0f373335ff526e06f32e57df4590094fc87de73fe52f4edee09a10a75d6d922)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "topic", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsub]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsub]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsub]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__247bde76cac79ce1b21451e1d8ace72bdfa2a5d267b7623732b5a1dc6a0e96e1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGooglePubsubTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigDestinationsGooglePubsubTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e1eb16582f09399bf10219487c6436fe91e1a38c6eab9c0936e4022f8318f60f)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsGooglePubsubTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsGooglePubsubTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsGooglePubsubTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__589bc80d1d55ac211e294e73a67d6a9898b43fe18093493e3cb1871df8d36d65)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__834b9e4397d2c58750b0ecd7f43cfc8b7b4437ff5af7c613e113219c097a6af9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d59d994244536694a4065a0f630b97bc61f562f2c492559be6f0595e7fe18d2f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b4fa8413d71f5b122e104623b18501a7465da153131a924b2e2b813feb466aa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsubTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsubTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsubTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e11c91cbb594e907c0125461f2fbfda24c674523f057f5efb9add288af3829d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsMicrosoftSentinel",
    jsii_struct_bases=[],
    name_mapping={
        "client_id": "clientId",
        "dcr_immutable_id": "dcrImmutableId",
        "id": "id",
        "inputs": "inputs",
        "table": "table",
        "tenant_id": "tenantId",
    },
)
class ObservabilityPipelineConfigDestinationsMicrosoftSentinel:
    def __init__(
        self,
        *,
        client_id: builtins.str,
        dcr_immutable_id: builtins.str,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        table: builtins.str,
        tenant_id: builtins.str,
    ) -> None:
        '''
        :param client_id: Azure AD client ID used for authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#client_id ObservabilityPipeline#client_id}
        :param dcr_immutable_id: The immutable ID of the Data Collection Rule (DCR). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#dcr_immutable_id ObservabilityPipeline#dcr_immutable_id}
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param table: The name of the Log Analytics table where logs will be sent. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#table ObservabilityPipeline#table}
        :param tenant_id: Azure AD tenant ID. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tenant_id ObservabilityPipeline#tenant_id}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5d1333b2b22a045717582ca114e95a2acdf71ec74041d3ac5f44f0d1b818530)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument dcr_immutable_id", value=dcr_immutable_id, expected_type=type_hints["dcr_immutable_id"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "client_id": client_id,
            "dcr_immutable_id": dcr_immutable_id,
            "id": id,
            "inputs": inputs,
            "table": table,
            "tenant_id": tenant_id,
        }

    @builtins.property
    def client_id(self) -> builtins.str:
        '''Azure AD client ID used for authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#client_id ObservabilityPipeline#client_id}
        '''
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def dcr_immutable_id(self) -> builtins.str:
        '''The immutable ID of the Data Collection Rule (DCR).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#dcr_immutable_id ObservabilityPipeline#dcr_immutable_id}
        '''
        result = self._values.get("dcr_immutable_id")
        assert result is not None, "Required property 'dcr_immutable_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def table(self) -> builtins.str:
        '''The name of the Log Analytics table where logs will be sent.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#table ObservabilityPipeline#table}
        '''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tenant_id(self) -> builtins.str:
        '''Azure AD tenant ID.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tenant_id ObservabilityPipeline#tenant_id}
        '''
        result = self._values.get("tenant_id")
        assert result is not None, "Required property 'tenant_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsMicrosoftSentinel(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsMicrosoftSentinelList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsMicrosoftSentinelList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0fef03f1dcfe55a6632c4176141fdb4c3597e9e709178e868dd08d3768bd3a1f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsMicrosoftSentinelOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__264e0273b8d7efcb6ae2c3a27c6b5202261edb458b23540a8df0858c5f255667)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsMicrosoftSentinelOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c98045f03fbd2e0ea59020b91e96f820c390094fe1883a01f8ccce2dcef0e00)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1011a14e8e3a4d8f433e57170fe5ed87e3107ec8a3e03c903c030499fcd7dc2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1926546ddea0465dffbd0a2dabc8daa2f6632d8e0b7abd8e8afcda062aa8bba9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsMicrosoftSentinel]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsMicrosoftSentinel]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsMicrosoftSentinel]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c2d9d8f9f89f4b2de7069f3ebc27fb620107b97d47a8c8ce192b13ce33f2200)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsMicrosoftSentinelOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsMicrosoftSentinelOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8c51267cf0c34d1fb3d7d9deaacb44b6e92cfd6f10f315fa3cdf0e04546d2eb)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="clientIdInput")
    def client_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientIdInput"))

    @builtins.property
    @jsii.member(jsii_name="dcrImmutableIdInput")
    def dcr_immutable_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dcrImmutableIdInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="tableInput")
    def table_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tableInput"))

    @builtins.property
    @jsii.member(jsii_name="tenantIdInput")
    def tenant_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tenantIdInput"))

    @builtins.property
    @jsii.member(jsii_name="clientId")
    def client_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clientId"))

    @client_id.setter
    def client_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b307a9c94c4e81eef9a3738ce9d0ba2bab0e8efe4271d196a87f375308d8afa7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clientId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="dcrImmutableId")
    def dcr_immutable_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dcrImmutableId"))

    @dcr_immutable_id.setter
    def dcr_immutable_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98b1b7ac6013b94742d3d75d4ce75dd213ba7588dc26ccd40bf8a2ad925c39a9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dcrImmutableId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25fb1af54bd5af9d93d3b1af0bf584e5888c664e7ed885fce854e4deede27921)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45e1032ef107b32f76bb00125b398cde20533951e327aea090e7790c895cb336)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="table")
    def table(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "table"))

    @table.setter
    def table(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64da05376fff1d1c394c42d98b5bbfff970add241ea1721480fd4a32a526b2a3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "table", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="tenantId")
    def tenant_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tenantId"))

    @tenant_id.setter
    def tenant_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f69edf98792808a4f185b9e60b3ae3e13d367a0452cadf4657114134b64bb651)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tenantId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsMicrosoftSentinel]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsMicrosoftSentinel]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsMicrosoftSentinel]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18ab9a1d98fd54fd4b609680a75ee0c44ac31881d0ee6c56a91e9ad3dbf81c0e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsNewRelic",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "inputs": "inputs", "region": "region"},
)
class ObservabilityPipelineConfigDestinationsNewRelic:
    def __init__(
        self,
        *,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        region: builtins.str,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param region: The New Relic region. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#region ObservabilityPipeline#region}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3590405e36a649991fc80cbac18c2ee354021483fccd4479f7a70643e5ead550)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "inputs": inputs,
            "region": region,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def region(self) -> builtins.str:
        '''The New Relic region.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#region ObservabilityPipeline#region}
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsNewRelic(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsNewRelicList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsNewRelicList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e5ff049961aa40e01ab9511b49c82922e81f9fd2fa2c1548dd2e51061a0bbc9)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsNewRelicOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2751707ff977f4b35268f6e66d830894e780b36d0f2ae948ee673ef852e34494)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsNewRelicOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5413c6984436a9066102374a5a0be5656dd4ac79157414379a23de97784a099f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f933ec2bba687ffbf82b42d13eb246074ac5c15e61375bcc3b3c985f6e25bc2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__322f1cc1ba55f0b3049e696b90e4b646f456a1c4d5756c198c69c8a3e4e284be)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsNewRelic]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsNewRelic]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsNewRelic]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08fb1c620214b8c0596428c967df6e16ba4f2ef4999ce4ccf7231fd69d3980db)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsNewRelicOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsNewRelicOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__352d6984388ffadf28687b15a583606237f0a8a96bff5e51f03b86863177d0f4)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="regionInput")
    def region_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regionInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__721d70e026a63f4e74c141f1b587018ccc3f34f6b4b248493e328956cbca2878)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51265eb6d303db74aa71215fff927a373f84bfc6a89aeb27dbfc51e90e15687d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="region")
    def region(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "region"))

    @region.setter
    def region(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61e1b39d255c4f2c782865e8fff773ca165210f224e09daf2dccb8216fda07c5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "region", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsNewRelic]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsNewRelic]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsNewRelic]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e5c33cd156afc80451b25cfcb466096e5dea0c2ddf24f64e10146d8747ffc7c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsOpensearch",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "inputs": "inputs", "bulk_index": "bulkIndex"},
)
class ObservabilityPipelineConfigDestinationsOpensearch:
    def __init__(
        self,
        *,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        bulk_index: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as input. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param bulk_index: The index or datastream to write logs to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#bulk_index ObservabilityPipeline#bulk_index}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25b464225c6c1920c39e9a11f9c5d4fb745177c225df7f30d7d93d2e2920de2e)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument bulk_index", value=bulk_index, expected_type=type_hints["bulk_index"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "inputs": inputs,
        }
        if bulk_index is not None:
            self._values["bulk_index"] = bulk_index

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as input.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def bulk_index(self) -> typing.Optional[builtins.str]:
        '''The index or datastream to write logs to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#bulk_index ObservabilityPipeline#bulk_index}
        '''
        result = self._values.get("bulk_index")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsOpensearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsOpensearchList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsOpensearchList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4016ec5a099990053727cf5b299dc22598fc4e4c9bd8b40c7e53cf32a5adb2a1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsOpensearchOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4701684eedb36bf91f17dacf10d6abef2362f40495d43073f51ea0d8a1da86d)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsOpensearchOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__421045375dfdef1a0df9680b238882f58d48bb3e078c4592c31abcabde055da9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45e5f7e88202c2bfda1ed0f3c0ee22a58186d9bbc7fbedee6382bdb04b40953d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__414a93bc0e5a00ccd836886590c4b77b5b68757dfc3812ff7e9cffb5b38c4c0f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsOpensearch]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsOpensearch]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsOpensearch]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62dbf696c9009d4cd23d294bcf40986f831c9db3478076d7d4446c2d307cf1d8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsOpensearchOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsOpensearchOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64fd5f98a19116c23c53dcb718f540b052c482e58aae23aa7b7016c7954d6a83)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetBulkIndex")
    def reset_bulk_index(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBulkIndex", []))

    @builtins.property
    @jsii.member(jsii_name="bulkIndexInput")
    def bulk_index_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "bulkIndexInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="bulkIndex")
    def bulk_index(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "bulkIndex"))

    @bulk_index.setter
    def bulk_index(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__717f66962bd50102ae7e1e76d1da7ac5a89bef16caaa587c58a67e7485a68aa6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bulkIndex", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6ef0f4f18bed6e3b7c8db6f7b8584e3bea1d3e0e0cd4901c9005d6d89349cd2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c5bc92e4e94cab914d95e4863def628d7e2719a1758092eed9e45b30c8533c7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsOpensearch]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsOpensearch]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsOpensearch]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d172ab5261f25b0c9f5348f4499190e7b82fba5f70e519bd14534561459ee6c3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d550d7a34086fead61f237cd33a839da16994ae1ae0a6e1ed11052f0f4a0d72d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAmazonOpensearch")
    def put_amazon_opensearch(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsAmazonOpensearch, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13162cfba8de22b94c689f178573fe9bdbb6efcc48487f1ef48f28341ca22f59)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAmazonOpensearch", [value]))

    @jsii.member(jsii_name="putAmazonS3")
    def put_amazon_s3(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsAmazonS3, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__593c94a76c6821ad44f9a5e1fb3db5b2f34c33eedfa5fcbe0dedbc3713113a95)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAmazonS3", [value]))

    @jsii.member(jsii_name="putAmazonSecurityLake")
    def put_amazon_security_lake(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsAmazonSecurityLake, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__edaa2883c9ff92c224fb648b41cb64c5af897b82a9a1b13356d4d1b90cd1bc73)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAmazonSecurityLake", [value]))

    @jsii.member(jsii_name="putAzureStorage")
    def put_azure_storage(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsAzureStorage, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2dd5baf36e811e4d5630d063f341216bc8fa3bbda9a18b233da53b1d2fa8d598)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAzureStorage", [value]))

    @jsii.member(jsii_name="putCrowdstrikeNextGenSiem")
    def put_crowdstrike_next_gen_siem(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__510b526328f2bd0f301f241d44a4f74ea24e4633fa794495fd30afd7b6632e35)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putCrowdstrikeNextGenSiem", [value]))

    @jsii.member(jsii_name="putDatadogLogs")
    def put_datadog_logs(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsDatadogLogs, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5293fc9e077a0355ad40233c6c1dc7cb838d8410b7c8d36324e07285acd173f7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putDatadogLogs", [value]))

    @jsii.member(jsii_name="putElasticsearch")
    def put_elasticsearch(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsElasticsearch, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e74f057d4cfe16b24eff0667c419a5cc345b8248d9c1cef7b5bba16162d44999)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putElasticsearch", [value]))

    @jsii.member(jsii_name="putGoogleChronicle")
    def put_google_chronicle(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsGoogleChronicle, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c50eacc408bfd0acd506cee8a56ccdbf17f106923033839111afea4fdfa25cf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putGoogleChronicle", [value]))

    @jsii.member(jsii_name="putGoogleCloudStorage")
    def put_google_cloud_storage(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsGoogleCloudStorage, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25ef8ff59886f45b35a599c5f6b1b5ad2431024fd61481666fa47cb7770eeaba)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putGoogleCloudStorage", [value]))

    @jsii.member(jsii_name="putGooglePubsub")
    def put_google_pubsub(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsGooglePubsub, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1de6122d98d3866a7743394e5fd7f803b143c510b1035242d4918b9dab2eeedc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putGooglePubsub", [value]))

    @jsii.member(jsii_name="putMicrosoftSentinel")
    def put_microsoft_sentinel(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsMicrosoftSentinel, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11e195ee81e8b513c8e7d781fc58f22377a83106da537f915d2bd8d166a788fe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putMicrosoftSentinel", [value]))

    @jsii.member(jsii_name="putNewRelic")
    def put_new_relic(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsNewRelic, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a88bb08a022f596729113055edd424affc46c8b12930c29830b8288a2a8ef6bb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putNewRelic", [value]))

    @jsii.member(jsii_name="putOpensearch")
    def put_opensearch(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsOpensearch, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__72b114996a928ee45dffb878e09e2d5578954e2599bb224845443be1a2184c32)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putOpensearch", [value]))

    @jsii.member(jsii_name="putRsyslog")
    def put_rsyslog(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsRsyslog", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5e064f511339f4e9d5c2b3e2d81bfd247e0029308ad00461f276cbe579610a6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putRsyslog", [value]))

    @jsii.member(jsii_name="putSentinelOne")
    def put_sentinel_one(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSentinelOne", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d1819704cc85ee8e8f09622774fe60cb3435845586c9d69aa6a9188ffc42a16)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSentinelOne", [value]))

    @jsii.member(jsii_name="putSocket")
    def put_socket(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSocket", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b87045b8550a30e099b9b46aa148aec7fc670def572179381eaac862fb4966b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSocket", [value]))

    @jsii.member(jsii_name="putSplunkHec")
    def put_splunk_hec(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSplunkHec", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ef44b77c657cd001906a4f5a068feec3dd54a287bfeadad728d215d823a7760)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSplunkHec", [value]))

    @jsii.member(jsii_name="putSumoLogic")
    def put_sumo_logic(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSumoLogic", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f6b60e811ebf4cc51efc225942698e1d8807675843215b486e2043bff697f107)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSumoLogic", [value]))

    @jsii.member(jsii_name="putSyslogNg")
    def put_syslog_ng(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSyslogNg", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6303fa9e519bd9b189cfd04be5710a86114accd8b9f82be7c15294c12d60fe38)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSyslogNg", [value]))

    @jsii.member(jsii_name="resetAmazonOpensearch")
    def reset_amazon_opensearch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAmazonOpensearch", []))

    @jsii.member(jsii_name="resetAmazonS3")
    def reset_amazon_s3(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAmazonS3", []))

    @jsii.member(jsii_name="resetAmazonSecurityLake")
    def reset_amazon_security_lake(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAmazonSecurityLake", []))

    @jsii.member(jsii_name="resetAzureStorage")
    def reset_azure_storage(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAzureStorage", []))

    @jsii.member(jsii_name="resetCrowdstrikeNextGenSiem")
    def reset_crowdstrike_next_gen_siem(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrowdstrikeNextGenSiem", []))

    @jsii.member(jsii_name="resetDatadogLogs")
    def reset_datadog_logs(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatadogLogs", []))

    @jsii.member(jsii_name="resetElasticsearch")
    def reset_elasticsearch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetElasticsearch", []))

    @jsii.member(jsii_name="resetGoogleChronicle")
    def reset_google_chronicle(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGoogleChronicle", []))

    @jsii.member(jsii_name="resetGoogleCloudStorage")
    def reset_google_cloud_storage(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGoogleCloudStorage", []))

    @jsii.member(jsii_name="resetGooglePubsub")
    def reset_google_pubsub(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGooglePubsub", []))

    @jsii.member(jsii_name="resetMicrosoftSentinel")
    def reset_microsoft_sentinel(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMicrosoftSentinel", []))

    @jsii.member(jsii_name="resetNewRelic")
    def reset_new_relic(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNewRelic", []))

    @jsii.member(jsii_name="resetOpensearch")
    def reset_opensearch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOpensearch", []))

    @jsii.member(jsii_name="resetRsyslog")
    def reset_rsyslog(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRsyslog", []))

    @jsii.member(jsii_name="resetSentinelOne")
    def reset_sentinel_one(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSentinelOne", []))

    @jsii.member(jsii_name="resetSocket")
    def reset_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSocket", []))

    @jsii.member(jsii_name="resetSplunkHec")
    def reset_splunk_hec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSplunkHec", []))

    @jsii.member(jsii_name="resetSumoLogic")
    def reset_sumo_logic(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSumoLogic", []))

    @jsii.member(jsii_name="resetSyslogNg")
    def reset_syslog_ng(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSyslogNg", []))

    @builtins.property
    @jsii.member(jsii_name="amazonOpensearch")
    def amazon_opensearch(
        self,
    ) -> ObservabilityPipelineConfigDestinationsAmazonOpensearchList:
        return typing.cast(ObservabilityPipelineConfigDestinationsAmazonOpensearchList, jsii.get(self, "amazonOpensearch"))

    @builtins.property
    @jsii.member(jsii_name="amazonS3")
    def amazon_s3(self) -> ObservabilityPipelineConfigDestinationsAmazonS3List:
        return typing.cast(ObservabilityPipelineConfigDestinationsAmazonS3List, jsii.get(self, "amazonS3"))

    @builtins.property
    @jsii.member(jsii_name="amazonSecurityLake")
    def amazon_security_lake(
        self,
    ) -> ObservabilityPipelineConfigDestinationsAmazonSecurityLakeList:
        return typing.cast(ObservabilityPipelineConfigDestinationsAmazonSecurityLakeList, jsii.get(self, "amazonSecurityLake"))

    @builtins.property
    @jsii.member(jsii_name="azureStorage")
    def azure_storage(self) -> ObservabilityPipelineConfigDestinationsAzureStorageList:
        return typing.cast(ObservabilityPipelineConfigDestinationsAzureStorageList, jsii.get(self, "azureStorage"))

    @builtins.property
    @jsii.member(jsii_name="crowdstrikeNextGenSiem")
    def crowdstrike_next_gen_siem(
        self,
    ) -> ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemList:
        return typing.cast(ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemList, jsii.get(self, "crowdstrikeNextGenSiem"))

    @builtins.property
    @jsii.member(jsii_name="datadogLogs")
    def datadog_logs(self) -> ObservabilityPipelineConfigDestinationsDatadogLogsList:
        return typing.cast(ObservabilityPipelineConfigDestinationsDatadogLogsList, jsii.get(self, "datadogLogs"))

    @builtins.property
    @jsii.member(jsii_name="elasticsearch")
    def elasticsearch(self) -> ObservabilityPipelineConfigDestinationsElasticsearchList:
        return typing.cast(ObservabilityPipelineConfigDestinationsElasticsearchList, jsii.get(self, "elasticsearch"))

    @builtins.property
    @jsii.member(jsii_name="googleChronicle")
    def google_chronicle(
        self,
    ) -> ObservabilityPipelineConfigDestinationsGoogleChronicleList:
        return typing.cast(ObservabilityPipelineConfigDestinationsGoogleChronicleList, jsii.get(self, "googleChronicle"))

    @builtins.property
    @jsii.member(jsii_name="googleCloudStorage")
    def google_cloud_storage(
        self,
    ) -> ObservabilityPipelineConfigDestinationsGoogleCloudStorageList:
        return typing.cast(ObservabilityPipelineConfigDestinationsGoogleCloudStorageList, jsii.get(self, "googleCloudStorage"))

    @builtins.property
    @jsii.member(jsii_name="googlePubsub")
    def google_pubsub(self) -> ObservabilityPipelineConfigDestinationsGooglePubsubList:
        return typing.cast(ObservabilityPipelineConfigDestinationsGooglePubsubList, jsii.get(self, "googlePubsub"))

    @builtins.property
    @jsii.member(jsii_name="microsoftSentinel")
    def microsoft_sentinel(
        self,
    ) -> ObservabilityPipelineConfigDestinationsMicrosoftSentinelList:
        return typing.cast(ObservabilityPipelineConfigDestinationsMicrosoftSentinelList, jsii.get(self, "microsoftSentinel"))

    @builtins.property
    @jsii.member(jsii_name="newRelic")
    def new_relic(self) -> ObservabilityPipelineConfigDestinationsNewRelicList:
        return typing.cast(ObservabilityPipelineConfigDestinationsNewRelicList, jsii.get(self, "newRelic"))

    @builtins.property
    @jsii.member(jsii_name="opensearch")
    def opensearch(self) -> ObservabilityPipelineConfigDestinationsOpensearchList:
        return typing.cast(ObservabilityPipelineConfigDestinationsOpensearchList, jsii.get(self, "opensearch"))

    @builtins.property
    @jsii.member(jsii_name="rsyslog")
    def rsyslog(self) -> "ObservabilityPipelineConfigDestinationsRsyslogList":
        return typing.cast("ObservabilityPipelineConfigDestinationsRsyslogList", jsii.get(self, "rsyslog"))

    @builtins.property
    @jsii.member(jsii_name="sentinelOne")
    def sentinel_one(self) -> "ObservabilityPipelineConfigDestinationsSentinelOneList":
        return typing.cast("ObservabilityPipelineConfigDestinationsSentinelOneList", jsii.get(self, "sentinelOne"))

    @builtins.property
    @jsii.member(jsii_name="socket")
    def socket(self) -> "ObservabilityPipelineConfigDestinationsSocketList":
        return typing.cast("ObservabilityPipelineConfigDestinationsSocketList", jsii.get(self, "socket"))

    @builtins.property
    @jsii.member(jsii_name="splunkHec")
    def splunk_hec(self) -> "ObservabilityPipelineConfigDestinationsSplunkHecList":
        return typing.cast("ObservabilityPipelineConfigDestinationsSplunkHecList", jsii.get(self, "splunkHec"))

    @builtins.property
    @jsii.member(jsii_name="sumoLogic")
    def sumo_logic(self) -> "ObservabilityPipelineConfigDestinationsSumoLogicList":
        return typing.cast("ObservabilityPipelineConfigDestinationsSumoLogicList", jsii.get(self, "sumoLogic"))

    @builtins.property
    @jsii.member(jsii_name="syslogNg")
    def syslog_ng(self) -> "ObservabilityPipelineConfigDestinationsSyslogNgList":
        return typing.cast("ObservabilityPipelineConfigDestinationsSyslogNgList", jsii.get(self, "syslogNg"))

    @builtins.property
    @jsii.member(jsii_name="amazonOpensearchInput")
    def amazon_opensearch_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonOpensearch]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonOpensearch]]], jsii.get(self, "amazonOpensearchInput"))

    @builtins.property
    @jsii.member(jsii_name="amazonS3Input")
    def amazon_s3_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonS3]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonS3]]], jsii.get(self, "amazonS3Input"))

    @builtins.property
    @jsii.member(jsii_name="amazonSecurityLakeInput")
    def amazon_security_lake_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonSecurityLake]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonSecurityLake]]], jsii.get(self, "amazonSecurityLakeInput"))

    @builtins.property
    @jsii.member(jsii_name="azureStorageInput")
    def azure_storage_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAzureStorage]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAzureStorage]]], jsii.get(self, "azureStorageInput"))

    @builtins.property
    @jsii.member(jsii_name="crowdstrikeNextGenSiemInput")
    def crowdstrike_next_gen_siem_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem]]], jsii.get(self, "crowdstrikeNextGenSiemInput"))

    @builtins.property
    @jsii.member(jsii_name="datadogLogsInput")
    def datadog_logs_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsDatadogLogs]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsDatadogLogs]]], jsii.get(self, "datadogLogsInput"))

    @builtins.property
    @jsii.member(jsii_name="elasticsearchInput")
    def elasticsearch_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsElasticsearch]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsElasticsearch]]], jsii.get(self, "elasticsearchInput"))

    @builtins.property
    @jsii.member(jsii_name="googleChronicleInput")
    def google_chronicle_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleChronicle]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleChronicle]]], jsii.get(self, "googleChronicleInput"))

    @builtins.property
    @jsii.member(jsii_name="googleCloudStorageInput")
    def google_cloud_storage_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleCloudStorage]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleCloudStorage]]], jsii.get(self, "googleCloudStorageInput"))

    @builtins.property
    @jsii.member(jsii_name="googlePubsubInput")
    def google_pubsub_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGooglePubsub]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGooglePubsub]]], jsii.get(self, "googlePubsubInput"))

    @builtins.property
    @jsii.member(jsii_name="microsoftSentinelInput")
    def microsoft_sentinel_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsMicrosoftSentinel]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsMicrosoftSentinel]]], jsii.get(self, "microsoftSentinelInput"))

    @builtins.property
    @jsii.member(jsii_name="newRelicInput")
    def new_relic_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsNewRelic]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsNewRelic]]], jsii.get(self, "newRelicInput"))

    @builtins.property
    @jsii.member(jsii_name="opensearchInput")
    def opensearch_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsOpensearch]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsOpensearch]]], jsii.get(self, "opensearchInput"))

    @builtins.property
    @jsii.member(jsii_name="rsyslogInput")
    def rsyslog_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsRsyslog"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsRsyslog"]]], jsii.get(self, "rsyslogInput"))

    @builtins.property
    @jsii.member(jsii_name="sentinelOneInput")
    def sentinel_one_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSentinelOne"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSentinelOne"]]], jsii.get(self, "sentinelOneInput"))

    @builtins.property
    @jsii.member(jsii_name="socketInput")
    def socket_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSocket"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSocket"]]], jsii.get(self, "socketInput"))

    @builtins.property
    @jsii.member(jsii_name="splunkHecInput")
    def splunk_hec_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSplunkHec"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSplunkHec"]]], jsii.get(self, "splunkHecInput"))

    @builtins.property
    @jsii.member(jsii_name="sumoLogicInput")
    def sumo_logic_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSumoLogic"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSumoLogic"]]], jsii.get(self, "sumoLogicInput"))

    @builtins.property
    @jsii.member(jsii_name="syslogNgInput")
    def syslog_ng_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSyslogNg"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSyslogNg"]]], jsii.get(self, "syslogNgInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinations]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinations]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinations]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ea7d9c6e23b6786f3a83833e91aeaf27174d080a81114a4ce9ca569d4ebc754)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsRsyslog",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "inputs": "inputs",
        "keepalive": "keepalive",
        "tls": "tls",
    },
)
class ObservabilityPipelineConfigDestinationsRsyslog:
    def __init__(
        self,
        *,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        keepalive: typing.Optional[jsii.Number] = None,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsRsyslogTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param keepalive: Optional socket keepalive duration in milliseconds. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#keepalive ObservabilityPipeline#keepalive}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigDestinationsRsyslogTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7142ccdf3ecc4b5e0dfb6d2012494aaa78c723090e8fe66526fdfefb3acae49d)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument keepalive", value=keepalive, expected_type=type_hints["keepalive"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "inputs": inputs,
        }
        if keepalive is not None:
            self._values["keepalive"] = keepalive
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def keepalive(self) -> typing.Optional[jsii.Number]:
        '''Optional socket keepalive duration in milliseconds.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#keepalive ObservabilityPipeline#keepalive}
        '''
        result = self._values.get("keepalive")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tls(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsRsyslogTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsRsyslogTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsRsyslog(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsRsyslogList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsRsyslogList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8babfbc54e4dadbede0307ff2c0d279992d3fce9630fceb753599343ed6d8ecc)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsRsyslogOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__63bd0529e5084ac62f0c6a9769bce980f4e3c3fae20142fbe78ee7393be817f3)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsRsyslogOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71b014c0773f882c465573ef8008c5694539c4236b79ec4794edd4425d02db75)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3750ca8fbe3ae8f4ea65523e59411403ed32faeaab9e2d382231d6b3140cfa21)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf1b9aa1a62f936b6ef88666e8ec1a64f8ee17bbe5af9f0c603789d4c26dc8a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsRsyslog]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsRsyslog]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsRsyslog]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__579d8a5722cdd33020ea5338324af8e0828b4f6eab1a0a3fb4d7d766438ac86c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsRsyslogOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsRsyslogOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5dea350c19f57f31615402a3b58ee72b7f923ed6183760f357e8c9793fe1cbd4)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigDestinationsRsyslogTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetKeepalive")
    def reset_keepalive(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeepalive", []))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigDestinationsRsyslogTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigDestinationsRsyslogTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="keepaliveInput")
    def keepalive_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "keepaliveInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinationsRsyslogTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinationsRsyslogTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fed19faf61572dd0f9ea3599c10be1319db40b2d35ade4ce6e08417e846ffb2a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2565ca5eff166cdfc95808ad94a00c917fb6201b90aa0508212c434717375c2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keepalive")
    def keepalive(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "keepalive"))

    @keepalive.setter
    def keepalive(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b072bbd09230156c35dc0cc93d53e6fc4cf9e0b584f68bd137f19751d9d0431f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keepalive", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsRsyslog]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsRsyslog]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsRsyslog]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__427d449a61f0196d8626c86d5fa3c3c24a140e7f2ac6a0fb3d8334679cd0d419)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsRsyslogTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigDestinationsRsyslogTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d853470c496bba4a13e2eb385a952ae7aefd1576219f535b02da200e1d8e755)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsRsyslogTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsRsyslogTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsRsyslogTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__070fce992a0f7063525e15af6cbfcecba2494c7991d35dc8660255a2c71a611c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3656cd55c3cce57bd8c7f055bacc163e67be6a6d889eeedad4685af7e712ca83)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f18778b2d1240d7954e29169f8f8f2860dad4e4ef34da861fe068a5e576e8b1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3fa63070c8be1147a7e38efe4d54724a02c3e487e33e7e21478a7c7561c07db3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsRsyslogTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsRsyslogTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsRsyslogTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d5f5363e0ac058b70ae96b26e26759a36025a241dfdf8fa4cc9a12e127bde73)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSentinelOne",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "inputs": "inputs", "region": "region"},
)
class ObservabilityPipelineConfigDestinationsSentinelOne:
    def __init__(
        self,
        *,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        region: builtins.str,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param region: The SentinelOne region to send logs to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#region ObservabilityPipeline#region}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a27ffd202ea09a0f3185a85650fd99806b242c6d5508da90ee95766050e0f87)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "inputs": inputs,
            "region": region,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def region(self) -> builtins.str:
        '''The SentinelOne region to send logs to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#region ObservabilityPipeline#region}
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsSentinelOne(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsSentinelOneList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSentinelOneList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__feefb8391524a5553d69706df192e65262a2d2136c48e41219198d33ced8fa25)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsSentinelOneOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05d391702b5f8c984d6495fb65e554a5252800c69a0bd01f27be21a5d43f2b7c)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsSentinelOneOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__445cbe616ca73bdff9ce033016db18f0083e3f4d023e40c667fdb97949b4e35a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f346b2940c9f1aab2df004b11241379f8615a3a5926bb8c9e115e4855a41a02a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4cf2f54dd26475ba442e20f0eecdfb50774a69e927fc1866a2a7559db8fc3dd0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSentinelOne]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSentinelOne]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSentinelOne]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7730a7280959d6dd706e5e99fa991d59940a1c5d9510e1ad7c6c9138583449f8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsSentinelOneOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSentinelOneOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0530b5844196e066d0d3f0be2249fd7b4e16f4d1ca8a72b0eb580ec2be6e4fab)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="regionInput")
    def region_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regionInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4332b829b5fe2d2737210992d42b3e0c128b5042bf3289521b06e4f6a4c06168)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ce73926b7affccbc0e8764df912690121f90084cf12fb87451b29d90ab49b33)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="region")
    def region(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "region"))

    @region.setter
    def region(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9793c2c76d802c940ed39940f96f5e97a94737823b8876419e9a8227256b5a72)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "region", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSentinelOne]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSentinelOne]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSentinelOne]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50ec37300e8542dbee37661f56f5cac7112d10d5dbe9ea94590ceb7e2cc9895a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSocket",
    jsii_struct_bases=[],
    name_mapping={
        "encoding": "encoding",
        "id": "id",
        "inputs": "inputs",
        "mode": "mode",
        "framing": "framing",
        "tls": "tls",
    },
)
class ObservabilityPipelineConfigDestinationsSocket:
    def __init__(
        self,
        *,
        encoding: builtins.str,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        mode: builtins.str,
        framing: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsSocketFraming", typing.Dict[builtins.str, typing.Any]]] = None,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsSocketTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param encoding: Encoding format for log events. Valid values are ``json``, ``raw_message``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        :param id: The unique identifier for this destination. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this destination. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param mode: The protocol used to send logs. Valid values are ``tcp``, ``udp``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mode ObservabilityPipeline#mode}
        :param framing: framing block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#framing ObservabilityPipeline#framing}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(framing, dict):
            framing = ObservabilityPipelineConfigDestinationsSocketFraming(**framing)
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigDestinationsSocketTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37107c617c953206850e31d89777c69eb036168de971ad9a63ebc9b5c8db552e)
            check_type(argname="argument encoding", value=encoding, expected_type=type_hints["encoding"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument framing", value=framing, expected_type=type_hints["framing"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "encoding": encoding,
            "id": id,
            "inputs": inputs,
            "mode": mode,
        }
        if framing is not None:
            self._values["framing"] = framing
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def encoding(self) -> builtins.str:
        '''Encoding format for log events. Valid values are ``json``, ``raw_message``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        '''
        result = self._values.get("encoding")
        assert result is not None, "Required property 'encoding' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this destination.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this destination.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def mode(self) -> builtins.str:
        '''The protocol used to send logs. Valid values are ``tcp``, ``udp``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mode ObservabilityPipeline#mode}
        '''
        result = self._values.get("mode")
        assert result is not None, "Required property 'mode' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def framing(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsSocketFraming"]:
        '''framing block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#framing ObservabilityPipeline#framing}
        '''
        result = self._values.get("framing")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsSocketFraming"], result)

    @builtins.property
    def tls(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsSocketTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsSocketTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSocketFraming",
    jsii_struct_bases=[],
    name_mapping={"method": "method", "character_delimited": "characterDelimited"},
)
class ObservabilityPipelineConfigDestinationsSocketFraming:
    def __init__(
        self,
        *,
        method: builtins.str,
        character_delimited: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param method: The framing method. Valid values are ``newline_delimited``, ``bytes``, ``character_delimited``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#method ObservabilityPipeline#method}
        :param character_delimited: character_delimited block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#character_delimited ObservabilityPipeline#character_delimited}
        '''
        if isinstance(character_delimited, dict):
            character_delimited = ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited(**character_delimited)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__53da89384831835df78c3388f3c94044dce9393516625420ce1a7f15b62ef0fc)
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument character_delimited", value=character_delimited, expected_type=type_hints["character_delimited"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "method": method,
        }
        if character_delimited is not None:
            self._values["character_delimited"] = character_delimited

    @builtins.property
    def method(self) -> builtins.str:
        '''The framing method. Valid values are ``newline_delimited``, ``bytes``, ``character_delimited``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#method ObservabilityPipeline#method}
        '''
        result = self._values.get("method")
        assert result is not None, "Required property 'method' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def character_delimited(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited"]:
        '''character_delimited block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#character_delimited ObservabilityPipeline#character_delimited}
        '''
        result = self._values.get("character_delimited")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsSocketFraming(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited",
    jsii_struct_bases=[],
    name_mapping={"delimiter": "delimiter"},
)
class ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited:
    def __init__(self, *, delimiter: typing.Optional[builtins.str] = None) -> None:
        '''
        :param delimiter: A single ASCII character used as a delimiter. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#delimiter ObservabilityPipeline#delimiter}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__07d8da17501f9167f80786e6c08fb3fc7ecae59ef2bdc9eb070c1e8b04222fb9)
            check_type(argname="argument delimiter", value=delimiter, expected_type=type_hints["delimiter"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if delimiter is not None:
            self._values["delimiter"] = delimiter

    @builtins.property
    def delimiter(self) -> typing.Optional[builtins.str]:
        '''A single ASCII character used as a delimiter.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#delimiter ObservabilityPipeline#delimiter}
        '''
        result = self._values.get("delimiter")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimitedOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimitedOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d961eea5dd547ef83593053af6bcc25a31275ceaeabf8df873474cee7049b058)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetDelimiter")
    def reset_delimiter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDelimiter", []))

    @builtins.property
    @jsii.member(jsii_name="delimiterInput")
    def delimiter_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "delimiterInput"))

    @builtins.property
    @jsii.member(jsii_name="delimiter")
    def delimiter(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "delimiter"))

    @delimiter.setter
    def delimiter(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9aabffa321676f262a02486561c92dad8eac1029b6fd79ad0d36c0c5ef607d1f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "delimiter", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__356f6248af0d99e7635e691b3383fc5cd2a1518b577bbc8a9635b4a507bc0450)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsSocketFramingOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSocketFramingOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__612960d0a8ace394cfce4329d6d41de04e87d513e8ee6598787fd0934e8b0b67)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putCharacterDelimited")
    def put_character_delimited(
        self,
        *,
        delimiter: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param delimiter: A single ASCII character used as a delimiter. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#delimiter ObservabilityPipeline#delimiter}
        '''
        value = ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited(
            delimiter=delimiter
        )

        return typing.cast(None, jsii.invoke(self, "putCharacterDelimited", [value]))

    @jsii.member(jsii_name="resetCharacterDelimited")
    def reset_character_delimited(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCharacterDelimited", []))

    @builtins.property
    @jsii.member(jsii_name="characterDelimited")
    def character_delimited(
        self,
    ) -> ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimitedOutputReference:
        return typing.cast(ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimitedOutputReference, jsii.get(self, "characterDelimited"))

    @builtins.property
    @jsii.member(jsii_name="characterDelimitedInput")
    def character_delimited_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited]], jsii.get(self, "characterDelimitedInput"))

    @builtins.property
    @jsii.member(jsii_name="methodInput")
    def method_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "methodInput"))

    @builtins.property
    @jsii.member(jsii_name="method")
    def method(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "method"))

    @method.setter
    def method(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96a12c5d85657f84e38f5d62d4ec7e9f312b6e7d78a1372ed123f33b2843b146)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "method", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketFraming]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketFraming]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketFraming]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b90e974b55d0e73159db922152750ec207e9c4e5cd65ea93877869a454f0c8e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsSocketList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSocketList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9cad02a2ca67d9ab7260624b83a1fea2c561c6d36f2841b863e3f1fc42eae8d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsSocketOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57bf402e0ebc3a49b76dce06cd32fb8978b6b5a00e8110b9b77ee1f91830089c)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsSocketOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c99f5eb9cda46fb8ba805257f7b288663cdf42533a847ec5474f158fcfef9e36)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5c5512a773aed42b9a5f373f8a32267a8ec1581a51dfba4c2df59284c1e7524)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2fd59deb86f4b9e17e69e8fed9bdb5122d279778cdd218c4286f5d063da99e7c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSocket]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSocket]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSocket]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8953425fc849a88473dcd6561574f14d41a0c0efe899b3753076076e42d6067)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3de4a6efc5376e1c1b83f9f6dd1d867fdf1639383ac74eee824f7fe08c68d67)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putFraming")
    def put_framing(
        self,
        *,
        method: builtins.str,
        character_delimited: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param method: The framing method. Valid values are ``newline_delimited``, ``bytes``, ``character_delimited``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#method ObservabilityPipeline#method}
        :param character_delimited: character_delimited block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#character_delimited ObservabilityPipeline#character_delimited}
        '''
        value = ObservabilityPipelineConfigDestinationsSocketFraming(
            method=method, character_delimited=character_delimited
        )

        return typing.cast(None, jsii.invoke(self, "putFraming", [value]))

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigDestinationsSocketTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetFraming")
    def reset_framing(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFraming", []))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="framing")
    def framing(
        self,
    ) -> ObservabilityPipelineConfigDestinationsSocketFramingOutputReference:
        return typing.cast(ObservabilityPipelineConfigDestinationsSocketFramingOutputReference, jsii.get(self, "framing"))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigDestinationsSocketTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigDestinationsSocketTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="encodingInput")
    def encoding_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "encodingInput"))

    @builtins.property
    @jsii.member(jsii_name="framingInput")
    def framing_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketFraming]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketFraming]], jsii.get(self, "framingInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinationsSocketTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinationsSocketTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="encoding")
    def encoding(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "encoding"))

    @encoding.setter
    def encoding(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f60050755b3b7dd5c0d4bc0f57be366f430ba1689cd5d12a2c3379baa28d503b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "encoding", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89dc4fbd861e423b1616446175ef789b4e8998e5e34c25d96048600236ca12c8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbb6b53f991d6649f98c02389fec8af1d417965806cc4b05aa6b670d7c3775e3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b90e94b3d142abf090e74c8eabfc91d78e782fdd77f462dd56a852cbfe5821bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocket]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocket]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocket]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da7c85ece859912aea322f15291883ad2c5ee874b39ac9b5973c366905767b36)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSocketTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigDestinationsSocketTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32df6246bb369d86e627e636ca37d577978318831121c879a612d7a5aba48eec)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsSocketTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsSocketTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSocketTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4b7d5a05a851898c64b87ac76845bf87c058bfffb600485f767a6dd9602d59c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad0bbe36b691a05166bffb31c8c1a0c1954c86d28231bc50220768bf381ac221)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5e789722965deefdc5754f43ecb7d9c122f8aab942a8aef31898025cedbe040)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__10d212d3c4006675f09d7ee1d6273123744dc8a81c437e7125e15e2e9856a01b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e779506aa05ae68094cc018663c65a4e393e3d0a122f3525d504a352a5318450)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSplunkHec",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "inputs": "inputs",
        "auto_extract_timestamp": "autoExtractTimestamp",
        "encoding": "encoding",
        "index": "index",
        "sourcetype": "sourcetype",
    },
)
class ObservabilityPipelineConfigDestinationsSplunkHec:
    def __init__(
        self,
        *,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        auto_extract_timestamp: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        encoding: typing.Optional[builtins.str] = None,
        index: typing.Optional[builtins.str] = None,
        sourcetype: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (e.g., as input to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param auto_extract_timestamp: If ``true``, Splunk tries to extract timestamps from incoming log events. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auto_extract_timestamp ObservabilityPipeline#auto_extract_timestamp}
        :param encoding: Encoding format for log events. Valid values: ``json``, ``raw_message``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        :param index: Optional name of the Splunk index where logs are written. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#index ObservabilityPipeline#index}
        :param sourcetype: The Splunk sourcetype to assign to log events. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sourcetype ObservabilityPipeline#sourcetype}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a56eb75721f7d1a494fd219c4e2d05edc81273d7beca6c8190f72b21bbf6154)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument auto_extract_timestamp", value=auto_extract_timestamp, expected_type=type_hints["auto_extract_timestamp"])
            check_type(argname="argument encoding", value=encoding, expected_type=type_hints["encoding"])
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
            check_type(argname="argument sourcetype", value=sourcetype, expected_type=type_hints["sourcetype"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "inputs": inputs,
        }
        if auto_extract_timestamp is not None:
            self._values["auto_extract_timestamp"] = auto_extract_timestamp
        if encoding is not None:
            self._values["encoding"] = encoding
        if index is not None:
            self._values["index"] = index
        if sourcetype is not None:
            self._values["sourcetype"] = sourcetype

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (e.g., as input to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def auto_extract_timestamp(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''If ``true``, Splunk tries to extract timestamps from incoming log events.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auto_extract_timestamp ObservabilityPipeline#auto_extract_timestamp}
        '''
        result = self._values.get("auto_extract_timestamp")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def encoding(self) -> typing.Optional[builtins.str]:
        '''Encoding format for log events. Valid values: ``json``, ``raw_message``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        '''
        result = self._values.get("encoding")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def index(self) -> typing.Optional[builtins.str]:
        '''Optional name of the Splunk index where logs are written.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#index ObservabilityPipeline#index}
        '''
        result = self._values.get("index")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sourcetype(self) -> typing.Optional[builtins.str]:
        '''The Splunk sourcetype to assign to log events.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sourcetype ObservabilityPipeline#sourcetype}
        '''
        result = self._values.get("sourcetype")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsSplunkHec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsSplunkHecList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSplunkHecList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2177f6145adcf515cb5437fa8e525ed227a2ee31b8887c6d78691a53bf013704)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsSplunkHecOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12b4215c61190efb840f9c57b77bf804a569d697c04579cdeffe24c1838f9611)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsSplunkHecOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5930d757f75101330915919b14da97c6970592e4b9cd3ac12351d7bedec44eb9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32b30953c7f6152ae78f2a92514976896c6776a075c7dc11d130ae45c63f87a7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25d6087c8f9efd317e0d08f3c160d9d063958d100ed846b11e63bd4842e991f6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSplunkHec]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSplunkHec]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSplunkHec]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28fd5180b2ed19cff642be29e1b679ac3d421618c8bc2ffda3c674accd5a4ed2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsSplunkHecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSplunkHecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fc5eb4958d73b70391e4aea0ae7758678450d9b7460a77155afa6e9633967b7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetAutoExtractTimestamp")
    def reset_auto_extract_timestamp(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAutoExtractTimestamp", []))

    @jsii.member(jsii_name="resetEncoding")
    def reset_encoding(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEncoding", []))

    @jsii.member(jsii_name="resetIndex")
    def reset_index(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIndex", []))

    @jsii.member(jsii_name="resetSourcetype")
    def reset_sourcetype(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSourcetype", []))

    @builtins.property
    @jsii.member(jsii_name="autoExtractTimestampInput")
    def auto_extract_timestamp_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "autoExtractTimestampInput"))

    @builtins.property
    @jsii.member(jsii_name="encodingInput")
    def encoding_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "encodingInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="indexInput")
    def index_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "indexInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="sourcetypeInput")
    def sourcetype_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourcetypeInput"))

    @builtins.property
    @jsii.member(jsii_name="autoExtractTimestamp")
    def auto_extract_timestamp(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "autoExtractTimestamp"))

    @auto_extract_timestamp.setter
    def auto_extract_timestamp(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60f1439c3d8ae7ec1d137b7796061019be8bc04a145a2f8d3aa6d23cb02f7eee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoExtractTimestamp", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="encoding")
    def encoding(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "encoding"))

    @encoding.setter
    def encoding(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a84fd61289db017e65cadd011cd4bdea9b941f6452b5f46fdc6f4a0f6a5ec56)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "encoding", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f80a47aee23f000ef3fe31b0b19000194afae8f0b4d0055c393e5d2c2dfea4a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="index")
    def index(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "index"))

    @index.setter
    def index(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23e0404bd36ad51ca05007dc330d08d0b4fde49e2d82934cc2db0dc2edd31caa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "index", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7a250a03aef39c99028f9960fbdac6747e38c9db7221cd536245f6c674a3218)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sourcetype")
    def sourcetype(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourcetype"))

    @sourcetype.setter
    def sourcetype(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__939d931d406dddb8c8cebe878dd84ccb850850efa022f9b9a9320446e61f5567)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourcetype", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSplunkHec]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSplunkHec]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSplunkHec]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__daea4c0fdbea36699bd732e7a58010109cd7743fded3f9d8f6e381bd462a4837)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSumoLogic",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "inputs": "inputs",
        "encoding": "encoding",
        "header_custom_fields": "headerCustomFields",
        "header_host_name": "headerHostName",
        "header_source_category": "headerSourceCategory",
        "header_source_name": "headerSourceName",
    },
)
class ObservabilityPipelineConfigDestinationsSumoLogic:
    def __init__(
        self,
        *,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        encoding: typing.Optional[builtins.str] = None,
        header_custom_fields: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields", typing.Dict[builtins.str, typing.Any]]]]] = None,
        header_host_name: typing.Optional[builtins.str] = None,
        header_source_category: typing.Optional[builtins.str] = None,
        header_source_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param encoding: The output encoding format. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        :param header_custom_fields: header_custom_fields block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#header_custom_fields ObservabilityPipeline#header_custom_fields}
        :param header_host_name: Optional override for the host name header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#header_host_name ObservabilityPipeline#header_host_name}
        :param header_source_category: Optional override for the source category header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#header_source_category ObservabilityPipeline#header_source_category}
        :param header_source_name: Optional override for the source name header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#header_source_name ObservabilityPipeline#header_source_name}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__906af7bdc69e88755b5cc78c950df65f0648d918b09e63270a61b0d1dc139695)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument encoding", value=encoding, expected_type=type_hints["encoding"])
            check_type(argname="argument header_custom_fields", value=header_custom_fields, expected_type=type_hints["header_custom_fields"])
            check_type(argname="argument header_host_name", value=header_host_name, expected_type=type_hints["header_host_name"])
            check_type(argname="argument header_source_category", value=header_source_category, expected_type=type_hints["header_source_category"])
            check_type(argname="argument header_source_name", value=header_source_name, expected_type=type_hints["header_source_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "inputs": inputs,
        }
        if encoding is not None:
            self._values["encoding"] = encoding
        if header_custom_fields is not None:
            self._values["header_custom_fields"] = header_custom_fields
        if header_host_name is not None:
            self._values["header_host_name"] = header_host_name
        if header_source_category is not None:
            self._values["header_source_category"] = header_source_category
        if header_source_name is not None:
            self._values["header_source_name"] = header_source_name

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def encoding(self) -> typing.Optional[builtins.str]:
        '''The output encoding format.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        '''
        result = self._values.get("encoding")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def header_custom_fields(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields"]]]:
        '''header_custom_fields block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#header_custom_fields ObservabilityPipeline#header_custom_fields}
        '''
        result = self._values.get("header_custom_fields")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields"]]], result)

    @builtins.property
    def header_host_name(self) -> typing.Optional[builtins.str]:
        '''Optional override for the host name header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#header_host_name ObservabilityPipeline#header_host_name}
        '''
        result = self._values.get("header_host_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def header_source_category(self) -> typing.Optional[builtins.str]:
        '''Optional override for the source category header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#header_source_category ObservabilityPipeline#header_source_category}
        '''
        result = self._values.get("header_source_category")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def header_source_name(self) -> typing.Optional[builtins.str]:
        '''Optional override for the source name header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#header_source_name ObservabilityPipeline#header_source_name}
        '''
        result = self._values.get("header_source_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsSumoLogic(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: The header field name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        :param value: The header field value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#value ObservabilityPipeline#value}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a02ace214114f814b6093285243b625ac8c1c76fb5eb2449d1d276261e45ad3b)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The header field name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''The header field value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#value ObservabilityPipeline#value}
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFieldsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFieldsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8429e2e2111deec89498791071656947fc378d4f2b48f361c5db55317323927)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFieldsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e108743cf0db76a7b273a99b66a0cfb0fb73da65021cd683b358ec0eb5e8c1b)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFieldsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aad9a126b4172c418f3dfca8ade0a8afbfe84ada2244872c7df42c1bec08208a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49b80d59a20fe8c85fc5e7f8278af9f1b9f3d1a7392effcdf39289c21bb9485f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed329e6c837a017f95da152d78753ec4b17298a63e8bebe324bb16cba31c6da8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed854754db1d2329ced72fa15f02bf5ae37598e96eda8bf7f42d4d9300ed37a1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFieldsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFieldsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__afccf164b88e2c934cc5232232d8dc3698d8313905aa540cb1c80ce9b2f33194)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1d48d4ec6e63767788602731c109046d3ff34bae54841c1d549ee1a138bdb22)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b419bfbafad83c2eb6e6023ded7d3d0b887c5ff6731d261ef4529040256c7288)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6cea7d5f0c155132fbcfdff13236764fb98f0cf973974b5bdff077d5975576e6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsSumoLogicList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSumoLogicList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f1401889ed6c5106961b2e08c0d1d73a825b62e385a28a31418e32e58fdb6797)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsSumoLogicOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1fc047442c975fedddb00202924a466b82e77ca9d55414251b49c4ddbb06085)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsSumoLogicOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b075fed2a31dc58f825c0d529f8d99eb377ab30dc55e1beae471604529a6fd8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b38e65987feeb37b596146fc14e7c06abf12efa9e5ac0060fe6b5e6f666610f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eaada3ab7767612ef57bf2ae17819552197889b2a92d60b533ae22fecb278af3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSumoLogic]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSumoLogic]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSumoLogic]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d29be090e677fcd0d95f0bd354999ae6af896c2a3f9c11cba94dbc5580523c4c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsSumoLogicOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSumoLogicOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c25ccd7375c6913c402316fefda8aaf84bd282033f18ea2fb2ffc84131a6f63c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putHeaderCustomFields")
    def put_header_custom_fields(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29a7d5270b2464ef90877f2cb57cb22e91559eb385e2b0eb2c6566bbc47c1d24)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putHeaderCustomFields", [value]))

    @jsii.member(jsii_name="resetEncoding")
    def reset_encoding(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEncoding", []))

    @jsii.member(jsii_name="resetHeaderCustomFields")
    def reset_header_custom_fields(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHeaderCustomFields", []))

    @jsii.member(jsii_name="resetHeaderHostName")
    def reset_header_host_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHeaderHostName", []))

    @jsii.member(jsii_name="resetHeaderSourceCategory")
    def reset_header_source_category(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHeaderSourceCategory", []))

    @jsii.member(jsii_name="resetHeaderSourceName")
    def reset_header_source_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHeaderSourceName", []))

    @builtins.property
    @jsii.member(jsii_name="headerCustomFields")
    def header_custom_fields(
        self,
    ) -> ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFieldsList:
        return typing.cast(ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFieldsList, jsii.get(self, "headerCustomFields"))

    @builtins.property
    @jsii.member(jsii_name="encodingInput")
    def encoding_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "encodingInput"))

    @builtins.property
    @jsii.member(jsii_name="headerCustomFieldsInput")
    def header_custom_fields_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields]]], jsii.get(self, "headerCustomFieldsInput"))

    @builtins.property
    @jsii.member(jsii_name="headerHostNameInput")
    def header_host_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "headerHostNameInput"))

    @builtins.property
    @jsii.member(jsii_name="headerSourceCategoryInput")
    def header_source_category_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "headerSourceCategoryInput"))

    @builtins.property
    @jsii.member(jsii_name="headerSourceNameInput")
    def header_source_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "headerSourceNameInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="encoding")
    def encoding(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "encoding"))

    @encoding.setter
    def encoding(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4cb861e82845c013e36bff018758770e8b64cb24c15b5884f6a2a226b61f9f4c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "encoding", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="headerHostName")
    def header_host_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "headerHostName"))

    @header_host_name.setter
    def header_host_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7022a2c2db8fee72c32b99dbfe9dc3c1b0f7ac4f496630695dc51001c4ec97f6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "headerHostName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="headerSourceCategory")
    def header_source_category(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "headerSourceCategory"))

    @header_source_category.setter
    def header_source_category(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f12bf55aba04b34c3b1181c224d69f585ceaa9cc3abbfc7196295761a8eeb860)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "headerSourceCategory", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="headerSourceName")
    def header_source_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "headerSourceName"))

    @header_source_name.setter
    def header_source_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d5baa1ce3c7dcce515d850d5826b59f646600fe49275fdfa6204ad8953e601d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "headerSourceName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d38c60c6fe410e609ade7e63b512dfab7d5ea6e3a2a241f9dadf2ea89d0e994f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6a7b585c67c45b88784e2bd1dc8bcec5d11c5025fedd1ee5f52fcc5081991b6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSumoLogic]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSumoLogic]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSumoLogic]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33fca38a261393836adec4a8437e6d9139fa5d8652f990ab696e0502f4632566)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSyslogNg",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "inputs": "inputs",
        "keepalive": "keepalive",
        "tls": "tls",
    },
)
class ObservabilityPipelineConfigDestinationsSyslogNg:
    def __init__(
        self,
        *,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        keepalive: typing.Optional[jsii.Number] = None,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigDestinationsSyslogNgTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param keepalive: Optional socket keepalive duration in milliseconds. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#keepalive ObservabilityPipeline#keepalive}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigDestinationsSyslogNgTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49e769a06dc80da4fb4d7ef9e6e8b0c8deff46146da8227faef806f35d3a8d9e)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument keepalive", value=keepalive, expected_type=type_hints["keepalive"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "inputs": inputs,
        }
        if keepalive is not None:
            self._values["keepalive"] = keepalive
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def keepalive(self) -> typing.Optional[jsii.Number]:
        '''Optional socket keepalive duration in milliseconds.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#keepalive ObservabilityPipeline#keepalive}
        '''
        result = self._values.get("keepalive")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tls(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigDestinationsSyslogNgTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigDestinationsSyslogNgTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsSyslogNg(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsSyslogNgList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSyslogNgList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8ae8a58515ae61d55598ae2b415d034cec79aca4054a497bb982517f4e75bb0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigDestinationsSyslogNgOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db8a2f68dd54c60160e136949099efa0d8aea9b9b028fcfbfd5380841796ad89)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigDestinationsSyslogNgOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f0ba126ffb099407c3b8fc49655c34cb1d5f2edc9ff9354be706ca25137374a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7885f53360d62e0558376404598144eebe9b3245a4869d3b5d8f83e0bc74ad2a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d25df1a9c5808e59f079d7679247f4d58d9ed34c084f355b8849ac0f779748e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSyslogNg]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSyslogNg]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSyslogNg]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3c63f0eef3cbb7ef9884c5fda1c0c782dbffab410802df193cff0ad1a496196)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigDestinationsSyslogNgOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSyslogNgOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c86c75609d1e2f5a96bb6ac9c353823c3e846318cbc0438369f3223738ca1787)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigDestinationsSyslogNgTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetKeepalive")
    def reset_keepalive(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeepalive", []))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(
        self,
    ) -> "ObservabilityPipelineConfigDestinationsSyslogNgTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigDestinationsSyslogNgTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="keepaliveInput")
    def keepalive_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "keepaliveInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinationsSyslogNgTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigDestinationsSyslogNgTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f78459bdf7f5623a3d6ad255b1478aea78e4eca9e6d611b0ef042b6eca4ed7f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64f34fd5ed36b949a18c430ee05f656d712d9618bc402829b8543add16eb9fe1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keepalive")
    def keepalive(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "keepalive"))

    @keepalive.setter
    def keepalive(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb4e7f1884cadbee8aea34eb3c434abf3153999fdf3725ae539099827b5797da)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keepalive", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSyslogNg]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSyslogNg]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSyslogNg]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1e3edbd206469dddb407f9319929fac9b1c87af1e06a1d93c0b8151cf14436e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSyslogNgTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigDestinationsSyslogNgTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b86c27f0d9b1af71760553feb2bbb4df278c351eebc1afe2d79cdafcb38ee4a1)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigDestinationsSyslogNgTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigDestinationsSyslogNgTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigDestinationsSyslogNgTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7edb85a65bc793fa3488058f002ff8c6b9e3a271b7d7925541725ffff8997cce)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__585789e73d3122e18b7111dcc57e2f8b0538fafed3882cb7ef0812b78f9fd399)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__629b6f045d46087d8998074ce7eb72e3e8fa7ff8a537223598fb1c3f832ca66d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__414a5e2fd09aea08d2092e133785070c468b6eb8be28527c3677ba4da6bd1b1a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSyslogNgTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSyslogNgTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSyslogNgTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__266d2f6412c2af5b030e1f4ce461f86e764fb4358b0e3af2c6b0cd8c6341fd68)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessors",
    jsii_struct_bases=[],
    name_mapping={
        "add_env_vars": "addEnvVars",
        "add_fields": "addFields",
        "custom_processor": "customProcessor",
        "datadog_tags": "datadogTags",
        "dedupe": "dedupe",
        "enrichment_table": "enrichmentTable",
        "filter": "filter",
        "generate_datadog_metrics": "generateDatadogMetrics",
        "ocsf_mapper": "ocsfMapper",
        "parse_grok": "parseGrok",
        "parse_json": "parseJson",
        "quota": "quota",
        "reduce": "reduce",
        "remove_fields": "removeFields",
        "rename_fields": "renameFields",
        "sample": "sample",
        "sensitive_data_scanner": "sensitiveDataScanner",
        "throttle": "throttle",
    },
)
class ObservabilityPipelineConfigProcessors:
    def __init__(
        self,
        *,
        add_env_vars: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsAddEnvVars", typing.Dict[builtins.str, typing.Any]]]]] = None,
        add_fields: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsAddFields", typing.Dict[builtins.str, typing.Any]]]]] = None,
        custom_processor: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsCustomProcessor", typing.Dict[builtins.str, typing.Any]]]]] = None,
        datadog_tags: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsDatadogTags", typing.Dict[builtins.str, typing.Any]]]]] = None,
        dedupe: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsDedupe", typing.Dict[builtins.str, typing.Any]]]]] = None,
        enrichment_table: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsEnrichmentTable", typing.Dict[builtins.str, typing.Any]]]]] = None,
        filter: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsFilter", typing.Dict[builtins.str, typing.Any]]]]] = None,
        generate_datadog_metrics: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics", typing.Dict[builtins.str, typing.Any]]]]] = None,
        ocsf_mapper: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsOcsfMapper", typing.Dict[builtins.str, typing.Any]]]]] = None,
        parse_grok: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsParseGrok", typing.Dict[builtins.str, typing.Any]]]]] = None,
        parse_json: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsParseJson", typing.Dict[builtins.str, typing.Any]]]]] = None,
        quota: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsQuota", typing.Dict[builtins.str, typing.Any]]]]] = None,
        reduce: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsReduce", typing.Dict[builtins.str, typing.Any]]]]] = None,
        remove_fields: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsRemoveFields", typing.Dict[builtins.str, typing.Any]]]]] = None,
        rename_fields: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsRenameFields", typing.Dict[builtins.str, typing.Any]]]]] = None,
        sample: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsSample", typing.Dict[builtins.str, typing.Any]]]]] = None,
        sensitive_data_scanner: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScanner", typing.Dict[builtins.str, typing.Any]]]]] = None,
        throttle: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsThrottle", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param add_env_vars: add_env_vars block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#add_env_vars ObservabilityPipeline#add_env_vars}
        :param add_fields: add_fields block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#add_fields ObservabilityPipeline#add_fields}
        :param custom_processor: custom_processor block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#custom_processor ObservabilityPipeline#custom_processor}
        :param datadog_tags: datadog_tags block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#datadog_tags ObservabilityPipeline#datadog_tags}
        :param dedupe: dedupe block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#dedupe ObservabilityPipeline#dedupe}
        :param enrichment_table: enrichment_table block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#enrichment_table ObservabilityPipeline#enrichment_table}
        :param filter: filter block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#filter ObservabilityPipeline#filter}
        :param generate_datadog_metrics: generate_datadog_metrics block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#generate_datadog_metrics ObservabilityPipeline#generate_datadog_metrics}
        :param ocsf_mapper: ocsf_mapper block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ocsf_mapper ObservabilityPipeline#ocsf_mapper}
        :param parse_grok: parse_grok block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#parse_grok ObservabilityPipeline#parse_grok}
        :param parse_json: parse_json block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#parse_json ObservabilityPipeline#parse_json}
        :param quota: quota block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#quota ObservabilityPipeline#quota}
        :param reduce: reduce block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#reduce ObservabilityPipeline#reduce}
        :param remove_fields: remove_fields block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#remove_fields ObservabilityPipeline#remove_fields}
        :param rename_fields: rename_fields block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rename_fields ObservabilityPipeline#rename_fields}
        :param sample: sample block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sample ObservabilityPipeline#sample}
        :param sensitive_data_scanner: sensitive_data_scanner block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sensitive_data_scanner ObservabilityPipeline#sensitive_data_scanner}
        :param throttle: throttle block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#throttle ObservabilityPipeline#throttle}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70735c7949657318d76c2bf80bfb931c6f4d1dda94d21c87d73dbb72b28bbd6b)
            check_type(argname="argument add_env_vars", value=add_env_vars, expected_type=type_hints["add_env_vars"])
            check_type(argname="argument add_fields", value=add_fields, expected_type=type_hints["add_fields"])
            check_type(argname="argument custom_processor", value=custom_processor, expected_type=type_hints["custom_processor"])
            check_type(argname="argument datadog_tags", value=datadog_tags, expected_type=type_hints["datadog_tags"])
            check_type(argname="argument dedupe", value=dedupe, expected_type=type_hints["dedupe"])
            check_type(argname="argument enrichment_table", value=enrichment_table, expected_type=type_hints["enrichment_table"])
            check_type(argname="argument filter", value=filter, expected_type=type_hints["filter"])
            check_type(argname="argument generate_datadog_metrics", value=generate_datadog_metrics, expected_type=type_hints["generate_datadog_metrics"])
            check_type(argname="argument ocsf_mapper", value=ocsf_mapper, expected_type=type_hints["ocsf_mapper"])
            check_type(argname="argument parse_grok", value=parse_grok, expected_type=type_hints["parse_grok"])
            check_type(argname="argument parse_json", value=parse_json, expected_type=type_hints["parse_json"])
            check_type(argname="argument quota", value=quota, expected_type=type_hints["quota"])
            check_type(argname="argument reduce", value=reduce, expected_type=type_hints["reduce"])
            check_type(argname="argument remove_fields", value=remove_fields, expected_type=type_hints["remove_fields"])
            check_type(argname="argument rename_fields", value=rename_fields, expected_type=type_hints["rename_fields"])
            check_type(argname="argument sample", value=sample, expected_type=type_hints["sample"])
            check_type(argname="argument sensitive_data_scanner", value=sensitive_data_scanner, expected_type=type_hints["sensitive_data_scanner"])
            check_type(argname="argument throttle", value=throttle, expected_type=type_hints["throttle"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if add_env_vars is not None:
            self._values["add_env_vars"] = add_env_vars
        if add_fields is not None:
            self._values["add_fields"] = add_fields
        if custom_processor is not None:
            self._values["custom_processor"] = custom_processor
        if datadog_tags is not None:
            self._values["datadog_tags"] = datadog_tags
        if dedupe is not None:
            self._values["dedupe"] = dedupe
        if enrichment_table is not None:
            self._values["enrichment_table"] = enrichment_table
        if filter is not None:
            self._values["filter"] = filter
        if generate_datadog_metrics is not None:
            self._values["generate_datadog_metrics"] = generate_datadog_metrics
        if ocsf_mapper is not None:
            self._values["ocsf_mapper"] = ocsf_mapper
        if parse_grok is not None:
            self._values["parse_grok"] = parse_grok
        if parse_json is not None:
            self._values["parse_json"] = parse_json
        if quota is not None:
            self._values["quota"] = quota
        if reduce is not None:
            self._values["reduce"] = reduce
        if remove_fields is not None:
            self._values["remove_fields"] = remove_fields
        if rename_fields is not None:
            self._values["rename_fields"] = rename_fields
        if sample is not None:
            self._values["sample"] = sample
        if sensitive_data_scanner is not None:
            self._values["sensitive_data_scanner"] = sensitive_data_scanner
        if throttle is not None:
            self._values["throttle"] = throttle

    @builtins.property
    def add_env_vars(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsAddEnvVars"]]]:
        '''add_env_vars block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#add_env_vars ObservabilityPipeline#add_env_vars}
        '''
        result = self._values.get("add_env_vars")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsAddEnvVars"]]], result)

    @builtins.property
    def add_fields(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsAddFields"]]]:
        '''add_fields block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#add_fields ObservabilityPipeline#add_fields}
        '''
        result = self._values.get("add_fields")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsAddFields"]]], result)

    @builtins.property
    def custom_processor(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsCustomProcessor"]]]:
        '''custom_processor block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#custom_processor ObservabilityPipeline#custom_processor}
        '''
        result = self._values.get("custom_processor")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsCustomProcessor"]]], result)

    @builtins.property
    def datadog_tags(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsDatadogTags"]]]:
        '''datadog_tags block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#datadog_tags ObservabilityPipeline#datadog_tags}
        '''
        result = self._values.get("datadog_tags")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsDatadogTags"]]], result)

    @builtins.property
    def dedupe(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsDedupe"]]]:
        '''dedupe block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#dedupe ObservabilityPipeline#dedupe}
        '''
        result = self._values.get("dedupe")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsDedupe"]]], result)

    @builtins.property
    def enrichment_table(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsEnrichmentTable"]]]:
        '''enrichment_table block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#enrichment_table ObservabilityPipeline#enrichment_table}
        '''
        result = self._values.get("enrichment_table")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsEnrichmentTable"]]], result)

    @builtins.property
    def filter(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsFilter"]]]:
        '''filter block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#filter ObservabilityPipeline#filter}
        '''
        result = self._values.get("filter")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsFilter"]]], result)

    @builtins.property
    def generate_datadog_metrics(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics"]]]:
        '''generate_datadog_metrics block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#generate_datadog_metrics ObservabilityPipeline#generate_datadog_metrics}
        '''
        result = self._values.get("generate_datadog_metrics")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics"]]], result)

    @builtins.property
    def ocsf_mapper(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsOcsfMapper"]]]:
        '''ocsf_mapper block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ocsf_mapper ObservabilityPipeline#ocsf_mapper}
        '''
        result = self._values.get("ocsf_mapper")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsOcsfMapper"]]], result)

    @builtins.property
    def parse_grok(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrok"]]]:
        '''parse_grok block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#parse_grok ObservabilityPipeline#parse_grok}
        '''
        result = self._values.get("parse_grok")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrok"]]], result)

    @builtins.property
    def parse_json(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseJson"]]]:
        '''parse_json block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#parse_json ObservabilityPipeline#parse_json}
        '''
        result = self._values.get("parse_json")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseJson"]]], result)

    @builtins.property
    def quota(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsQuota"]]]:
        '''quota block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#quota ObservabilityPipeline#quota}
        '''
        result = self._values.get("quota")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsQuota"]]], result)

    @builtins.property
    def reduce(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsReduce"]]]:
        '''reduce block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#reduce ObservabilityPipeline#reduce}
        '''
        result = self._values.get("reduce")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsReduce"]]], result)

    @builtins.property
    def remove_fields(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsRemoveFields"]]]:
        '''remove_fields block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#remove_fields ObservabilityPipeline#remove_fields}
        '''
        result = self._values.get("remove_fields")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsRemoveFields"]]], result)

    @builtins.property
    def rename_fields(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsRenameFields"]]]:
        '''rename_fields block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rename_fields ObservabilityPipeline#rename_fields}
        '''
        result = self._values.get("rename_fields")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsRenameFields"]]], result)

    @builtins.property
    def sample(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsSample"]]]:
        '''sample block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sample ObservabilityPipeline#sample}
        '''
        result = self._values.get("sample")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsSample"]]], result)

    @builtins.property
    def sensitive_data_scanner(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsSensitiveDataScanner"]]]:
        '''sensitive_data_scanner block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sensitive_data_scanner ObservabilityPipeline#sensitive_data_scanner}
        '''
        result = self._values.get("sensitive_data_scanner")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsSensitiveDataScanner"]]], result)

    @builtins.property
    def throttle(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsThrottle"]]]:
        '''throttle block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#throttle ObservabilityPipeline#throttle}
        '''
        result = self._values.get("throttle")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsThrottle"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessors(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsAddEnvVars",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "variables": "variables",
    },
)
class ObservabilityPipelineConfigProcessorsAddEnvVars:
    def __init__(
        self,
        *,
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        variables: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsAddEnvVarsVariables", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this processor in the pipeline. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: A list of component IDs whose output is used as the input for this processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param variables: variables block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#variables ObservabilityPipeline#variables}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2d16b2bca318be68aee0a8101e21e69f68894f37f18602518de5df260a1597d)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument variables", value=variables, expected_type=type_hints["variables"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "include": include,
            "inputs": inputs,
        }
        if variables is not None:
            self._values["variables"] = variables

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component. Used to reference this processor in the pipeline.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the input for this processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def variables(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsAddEnvVarsVariables"]]]:
        '''variables block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#variables ObservabilityPipeline#variables}
        '''
        result = self._values.get("variables")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsAddEnvVarsVariables"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsAddEnvVars(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsAddEnvVarsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsAddEnvVarsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18b21247df4af51912926691f40483910b549044435a8ddebf18de17d5c97eca)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsAddEnvVarsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e96d28aca2a9778767164d679298bde9fefc7136063cde3c4a15cd7df7fb22d)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsAddEnvVarsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a4ee7cdbc471677820c181eff0b8d3da0afd13b053dcd06d7cb9fac2e10f3b2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5abc46d2cb0bd5a46a4c1435814373f5ee2ab4310641e15ea6218e6f7b4d3e3a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__338a5c281c6d3ff77b3ff709e8a9bcc908e0ea7df2bff9a499b8b38a20c4ab8d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddEnvVars]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddEnvVars]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddEnvVars]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bdccd180495cc6ac907983e1653494db91dc126f30e283c40a678b004659ecbf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsAddEnvVarsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsAddEnvVarsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25ac1db160fbb67523c07bca378eb4f06e947f2f0e3086e9f5f9b733cf6b893e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putVariables")
    def put_variables(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsAddEnvVarsVariables", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ae2cbfba577165aa2f13ca94d13678cdf287f51791baced8da255765072f0fa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putVariables", [value]))

    @jsii.member(jsii_name="resetVariables")
    def reset_variables(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetVariables", []))

    @builtins.property
    @jsii.member(jsii_name="variables")
    def variables(
        self,
    ) -> "ObservabilityPipelineConfigProcessorsAddEnvVarsVariablesList":
        return typing.cast("ObservabilityPipelineConfigProcessorsAddEnvVarsVariablesList", jsii.get(self, "variables"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="variablesInput")
    def variables_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsAddEnvVarsVariables"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsAddEnvVarsVariables"]]], jsii.get(self, "variablesInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8bcd4cc891e12c2f315577d20c000e11c1d78fc96c91b7bc1657299d0c42540d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ea99ca567e69608f7d37b8ab0da4360bf7160c3916dbbab0313bd90e835d602)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5a7dcb928cc8b10ea218eb3c5a0665e0be5b29487547991efc5315151bbb1b6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddEnvVars]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddEnvVars]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddEnvVars]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__405b0d79afd5f45258c9bbd9e265f0673fcb15e947e5c69e4ff6656a0fd50d11)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsAddEnvVarsVariables",
    jsii_struct_bases=[],
    name_mapping={"field": "field", "name": "name"},
)
class ObservabilityPipelineConfigProcessorsAddEnvVarsVariables:
    def __init__(self, *, field: builtins.str, name: builtins.str) -> None:
        '''
        :param field: The target field in the log event. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        :param name: The name of the environment variable to read. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d26cdd5950ea1a523f905109380e1d3c7bbc32000a11abc43223ea301a46ac1f)
            check_type(argname="argument field", value=field, expected_type=type_hints["field"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "field": field,
            "name": name,
        }

    @builtins.property
    def field(self) -> builtins.str:
        '''The target field in the log event.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        '''
        result = self._values.get("field")
        assert result is not None, "Required property 'field' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the environment variable to read.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsAddEnvVarsVariables(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsAddEnvVarsVariablesList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsAddEnvVarsVariablesList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a05b9d163ef4742f7dc64e7987fc80318f6ba1e5d5ff209b4886e679c8a40796)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsAddEnvVarsVariablesOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85a0bc3a90f44556a0cff7da02a8cd01887c64eca9c8159436f969ac433128dd)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsAddEnvVarsVariablesOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25f5422d6ab724674d2b8df43fd00ec63c093aacb152fe730ea6d9b982422b09)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6aec491e6e9c85f88a7df972cc2f5c9f5add7b7f4cb1d33cd41cb5fe38dd20e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c0fb5b8f334a0e694347029b57f3528d1a12943acd2b60583b21db3e2ca4cdb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddEnvVarsVariables]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddEnvVarsVariables]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddEnvVarsVariables]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12ccb00ee242ef06687902206714c476562923e5a126b8c91f2c18d340efb686)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsAddEnvVarsVariablesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsAddEnvVarsVariablesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a3c4093fbb627e3620fa071ff71763fe71cc72ab9c3d4ea73ca6dcae836faf3)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="fieldInput")
    def field_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fieldInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="field")
    def field(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "field"))

    @field.setter
    def field(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e96093d309ccc177b88132554263abd793287faf15ad517bfd66ee7491fa191)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "field", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9bbffe6d244a97ea8b22f43247d096d9a6715390e2b3065495c8091be34d223e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddEnvVarsVariables]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddEnvVarsVariables]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddEnvVarsVariables]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2db58f54b5a076dfc57797d2991d047cff5281bef4188769dac1e35ed64b35dc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsAddFields",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "field": "field",
    },
)
class ObservabilityPipelineConfigProcessorsAddFields:
    def __init__(
        self,
        *,
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        field: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsAddFieldsField", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param id: The unique ID of the processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: The inputs for the processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param field: field block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec882221963f5a89d0b572d7a253b5286d8ec1586f34630cd95410af7b450ee7)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument field", value=field, expected_type=type_hints["field"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "include": include,
            "inputs": inputs,
        }
        if field is not None:
            self._values["field"] = field

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique ID of the processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''The inputs for the processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def field(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsAddFieldsField"]]]:
        '''field block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        '''
        result = self._values.get("field")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsAddFieldsField"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsAddFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsAddFieldsField",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class ObservabilityPipelineConfigProcessorsAddFieldsField:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: The field name to add. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        :param value: The value to assign to the field. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#value ObservabilityPipeline#value}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__600686e000790fe141c4b2e9f31a997eeb27c1ae29016a70ee2f9bb024b8882d)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''The field name to add.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''The value to assign to the field.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#value ObservabilityPipeline#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsAddFieldsField(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsAddFieldsFieldList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsAddFieldsFieldList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eea22baaaf997f47b530aedbdb77dedece5c3a72b557260a40ee672b085dbc28)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsAddFieldsFieldOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8af8989953ec21fd676976bf95d9e788028397c8f782e1924a6de55627963b8b)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsAddFieldsFieldOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d470c6b76b96c0a12e91798199cbbd58c2f0083008082465a11bc364f70c538)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d601e471588b54eb7d5fd9a807ea80df35c38138454761e0875915f7a7ed951)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac80d78daf186cc48a98a765b2a8bce657aef83bbd86c96a0775da5e9b1227f5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddFieldsField]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddFieldsField]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddFieldsField]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57a7c6fb9a248d529962220c9358b07a9e6d4cee2d8bed25ef1924ec6012798f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsAddFieldsFieldOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsAddFieldsFieldOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd514257793c6b1417da895b0f3960cbc53716d965040a6f1b2f43db13b3242b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__afe59f9d6ca21f292188709ecad6e967bbec8bd5acaaa33d75a13d1c63b5342e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__43e8a64b096d7543c1661c2731d0250a3d55dbf21635c2a5d60ff4051f6b9041)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddFieldsField]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddFieldsField]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddFieldsField]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97a5fa1e5f244b284592e39dcad7f500a8056889dd3c417ab027b2bc666d0406)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsAddFieldsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsAddFieldsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60edc1da79c657453aa92b1f92cc2eff87ff145e5776762148e9f67bee8bf13f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsAddFieldsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5f7ceea9a9dea68d928de1b7e2a0d636b7629c5b7683e3562cf72ccdbe009e5)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsAddFieldsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b51dd999badbccdc780f30205246acde53a27f6b1bde2e4d049e45de046cea47)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b14913bfe9577e3e75d3e0d8b97812b11c367ccf969572673b03d4a4565e583)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__988f6a54f1372e9637781146883441b110d24d08a293c54e364e173df88c4331)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddFields]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddFields]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddFields]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1d4713ceaa4325fb827c97b9a7166961d169c57489360f6d62a2037ab195c0e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsAddFieldsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsAddFieldsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1bef632bc294d35ecf2433c72376caf1f46b113f26a6002c09e1e040d790a29)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putField")
    def put_field(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsAddFieldsField, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f5648689dad52e943941378ef4a3922482cc7f3b03518610c80889c4f7426c9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putField", [value]))

    @jsii.member(jsii_name="resetField")
    def reset_field(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetField", []))

    @builtins.property
    @jsii.member(jsii_name="field")
    def field(self) -> ObservabilityPipelineConfigProcessorsAddFieldsFieldList:
        return typing.cast(ObservabilityPipelineConfigProcessorsAddFieldsFieldList, jsii.get(self, "field"))

    @builtins.property
    @jsii.member(jsii_name="fieldInput")
    def field_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddFieldsField]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddFieldsField]]], jsii.get(self, "fieldInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e3c89075918f33a6017690f0d2c1ca909bce75d0922263006a84ac311981a38)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6034bbf17ed8f841012253083d02e46ea4f403a8d94dcec03c750d13a8bd9c8c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__525101bf03ade027a8c8f30e3dbc6d9ee24d7b242de2b2ebc5b9b62b482dfc16)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddFields]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddFields]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddFields]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__225e0a72a38b1fba3ba7d9003ca201aa1cd68557f1f4ba940316ca7e3db107bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsCustomProcessor",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "inputs": "inputs", "remaps": "remaps"},
)
class ObservabilityPipelineConfigProcessorsCustomProcessor:
    def __init__(
        self,
        *,
        id: builtins.str,
        inputs: typing.Sequence[builtins.str],
        remaps: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsCustomProcessorRemaps", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param inputs: A list of component IDs whose output is used as the input for this processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param remaps: remaps block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#remaps ObservabilityPipeline#remaps}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__868a2fe7e9ee8a1de2eb627baeee1c0a02788729c5f759521ddfe5b5cdccc7bd)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument remaps", value=remaps, expected_type=type_hints["remaps"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "inputs": inputs,
        }
        if remaps is not None:
            self._values["remaps"] = remaps

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the input for this processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def remaps(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsCustomProcessorRemaps"]]]:
        '''remaps block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#remaps ObservabilityPipeline#remaps}
        '''
        result = self._values.get("remaps")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsCustomProcessorRemaps"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsCustomProcessor(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsCustomProcessorList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsCustomProcessorList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4d0672047f03f998b95321b23114538b254111f3f13b40f57c275512de7b6e7d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsCustomProcessorOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f8b357fc14f461f34b126437f36e754bd20caff69911c77c9130595ced3064d4)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsCustomProcessorOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71f1748a5ea1b8ac5a0cb7d9985df2cb4468a2a0669418a380dc1249436cb659)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f60dd23534aeb5e52caa87553a042651886af2d3682d507a709a1433741578b7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e0e8cc185e9de2dfd46d2710907e0ed1d79e32655013cb00f3da333c093f195)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsCustomProcessor]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsCustomProcessor]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsCustomProcessor]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2163ef740113b30e22036d0e44054505292bfe2369854304f550d03cd61d2bbe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsCustomProcessorOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsCustomProcessorOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__80e9ca34789598f8940ea564a30a5738dc164d6a22fa5b6b8f4cfc9f9704e691)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putRemaps")
    def put_remaps(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsCustomProcessorRemaps", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7718ac9ec7317147e9530edd4adefc7499ebe174f98a7d9d5eb244b7b1816583)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putRemaps", [value]))

    @jsii.member(jsii_name="resetRemaps")
    def reset_remaps(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRemaps", []))

    @builtins.property
    @jsii.member(jsii_name="remaps")
    def remaps(
        self,
    ) -> "ObservabilityPipelineConfigProcessorsCustomProcessorRemapsList":
        return typing.cast("ObservabilityPipelineConfigProcessorsCustomProcessorRemapsList", jsii.get(self, "remaps"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="remapsInput")
    def remaps_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsCustomProcessorRemaps"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsCustomProcessorRemaps"]]], jsii.get(self, "remapsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b105b42aad801d7144260611d5f5f2d14270726e589e7f5790ee358cfc4eb06f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4479f3740d132dac19ccf2ca952fc75eb61b6ac131f954317cf5ff2508cf22c1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsCustomProcessor]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsCustomProcessor]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsCustomProcessor]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f8a2831442a81cd8ee8f159ef344d341e4e789bd9149cbe7d570acc046abc7a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsCustomProcessorRemaps",
    jsii_struct_bases=[],
    name_mapping={
        "drop_on_error": "dropOnError",
        "enabled": "enabled",
        "include": "include",
        "name": "name",
        "source": "source",
    },
)
class ObservabilityPipelineConfigProcessorsCustomProcessorRemaps:
    def __init__(
        self,
        *,
        drop_on_error: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        include: builtins.str,
        name: builtins.str,
        source: builtins.str,
    ) -> None:
        '''
        :param drop_on_error: Whether to drop events that cause errors during transformation. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#drop_on_error ObservabilityPipeline#drop_on_error}
        :param enabled: Whether this remap rule is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#enabled ObservabilityPipeline#enabled}
        :param include: A Datadog search query used to filter events for this specific remap rule. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param name: A descriptive name for this remap rule. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        :param source: The VRL script source code that defines the transformation logic. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#source ObservabilityPipeline#source}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__699ed433b2280eef4833be587ff4da9a8e2886c3b0f6ea433c3cb29f4b93ae47)
            check_type(argname="argument drop_on_error", value=drop_on_error, expected_type=type_hints["drop_on_error"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "drop_on_error": drop_on_error,
            "enabled": enabled,
            "include": include,
            "name": name,
            "source": source,
        }

    @builtins.property
    def drop_on_error(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether to drop events that cause errors during transformation.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#drop_on_error ObservabilityPipeline#drop_on_error}
        '''
        result = self._values.get("drop_on_error")
        assert result is not None, "Required property 'drop_on_error' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether this remap rule is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#enabled ObservabilityPipeline#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to filter events for this specific remap rule.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''A descriptive name for this remap rule.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def source(self) -> builtins.str:
        '''The VRL script source code that defines the transformation logic.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#source ObservabilityPipeline#source}
        '''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsCustomProcessorRemaps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsCustomProcessorRemapsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsCustomProcessorRemapsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71547f691f5a6588bb11e58f713490e8f3fd84c57681c3defd1801f71d9936cf)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsCustomProcessorRemapsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06c83e1bb3f062604da333bdc640078fa0072313fb906e73be10c06b642882ba)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsCustomProcessorRemapsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0b4dda6e40cbc884052ed75509bcf8fe9e74a69f87f1a032159b44f5b171e4e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1bb87450fde4c9e3ea56be392d9b11bc89808e469869924088980aefa909d84)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed22237ed745b5e0e88178dcd063e40d2bf52a817964993c5606397fb271527c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsCustomProcessorRemaps]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsCustomProcessorRemaps]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsCustomProcessorRemaps]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7af8182d86b3535ab62afe739578fdedc6e3e6875db5dcf6de0748d165f78f57)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsCustomProcessorRemapsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsCustomProcessorRemapsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4bbdba3ec931d1747ec78b47d710af7cee61a8b231a54d43245a989b821a3426)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="dropOnErrorInput")
    def drop_on_error_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "dropOnErrorInput"))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="sourceInput")
    def source_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceInput"))

    @builtins.property
    @jsii.member(jsii_name="dropOnError")
    def drop_on_error(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "dropOnError"))

    @drop_on_error.setter
    def drop_on_error(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d87091cffee8e598e8aaa3f9c7f6650f1bf6482cc1e5d19d08230d2b3a1ecc2e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dropOnError", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7d69f95d4c17f1b6456b493dfcb9e950e471a5297033983e586cb98fe48c33c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6356758c0d3d352dc475a71be56a416bdda8b13ccf341b3d62c7e9acf5b1f626)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c698b36b30b634c227152b098feac0ff2f524066c0124d47b49ba72c8b612a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="source")
    def source(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "source"))

    @source.setter
    def source(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8327eef2b3ae9feaa134287b8b09a346c9e6c9d5b2632d7feacb61794adc55c1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "source", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsCustomProcessorRemaps]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsCustomProcessorRemaps]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsCustomProcessorRemaps]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e10b296b0945085c003fddcb9090b0cb8698517efaba82e4d7a92fd473e82ca)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsDatadogTags",
    jsii_struct_bases=[],
    name_mapping={
        "action": "action",
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "keys": "keys",
        "mode": "mode",
    },
)
class ObservabilityPipelineConfigProcessorsDatadogTags:
    def __init__(
        self,
        *,
        action: builtins.str,
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        keys: typing.Sequence[builtins.str],
        mode: builtins.str,
    ) -> None:
        '''
        :param action: Valid values are ``include``, ``exclude``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#action ObservabilityPipeline#action}
        :param id: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}. Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}.
        :param inputs: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}.
        :param keys: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#keys ObservabilityPipeline#keys}.
        :param mode: Valid values are ``filter``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mode ObservabilityPipeline#mode}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33f37bcea176ba6210de0c2b0d621860ba5d48f77a26b11c577d491e054a648c)
            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument keys", value=keys, expected_type=type_hints["keys"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "action": action,
            "id": id,
            "include": include,
            "inputs": inputs,
            "keys": keys,
            "mode": mode,
        }

    @builtins.property
    def action(self) -> builtins.str:
        '''Valid values are ``include``, ``exclude``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#action ObservabilityPipeline#action}
        '''
        result = self._values.get("action")
        assert result is not None, "Required property 'action' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def id(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}.

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}.'''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}.'''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def keys(self) -> typing.List[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#keys ObservabilityPipeline#keys}.'''
        result = self._values.get("keys")
        assert result is not None, "Required property 'keys' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def mode(self) -> builtins.str:
        '''Valid values are ``filter``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mode ObservabilityPipeline#mode}
        '''
        result = self._values.get("mode")
        assert result is not None, "Required property 'mode' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsDatadogTags(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsDatadogTagsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsDatadogTagsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__096d2a7e258740ead9657ce0b8eef207dac200918756ac7d775d4382a24c0e01)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsDatadogTagsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87ee84b6ed3a5376fb5fb325fa1b38eb8dabf78efb429e45950562760a8f44a1)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsDatadogTagsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f76a2717ebd28faf40912cfb6dac5de98a953044e1f5d2cd7fca521005434c13)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6bb2688e4f3caf6a1fd54eedc28e2890e03eead3a4cee3b268502b65e5d1231)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd4eb93a8788b9e25033d820a663e20feae134d0afe9f00d31c7b7602d75e14b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsDatadogTags]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsDatadogTags]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsDatadogTags]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95e8a0a443a53bc7ebc55bc17e1d90ff6e31e084612bdd837c645da6f5c9dfa8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsDatadogTagsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsDatadogTagsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b14008fe8679410b05ad1a75dff19ec8eeacfed17023c1c577b3e46ea0b50710)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="actionInput")
    def action_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "actionInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="keysInput")
    def keys_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "keysInput"))

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @action.setter
    def action(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe6f822a54e9d6679307b2e98bbc533097b6f8732f93ed488df5ed7cc43c9568)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "action", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d649a8cbd951bb3e25e57544fa884b7f1d1de809bc9b48da05429fb62e066ce8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4c91a0150ad8e3dd66028e6976992cccfd7bbb515e959a74fc3f7ece28e9bf4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d8c1d8d1142b95d084cbc0bd06b814324b66aa382d3983d528056dfc3d0b9ec)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keys")
    def keys(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "keys"))

    @keys.setter
    def keys(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__76272b66ce0b91dd70ed954dbc33d39d7527d2d0a776b7b51cfae84df3dd1586)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keys", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ca4e0e48aa6f64c22fb8c66bf1dc53ee28e09f961bfcae4a0e4de15a8a9cd68)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsDatadogTags]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsDatadogTags]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsDatadogTags]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5227f755c91fe7d3a5012a7e416c7bbe4a26f7cf3f0f4fd2e533ec698b5842c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsDedupe",
    jsii_struct_bases=[],
    name_mapping={
        "fields": "fields",
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "mode": "mode",
    },
)
class ObservabilityPipelineConfigProcessorsDedupe:
    def __init__(
        self,
        *,
        fields: typing.Sequence[builtins.str],
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        mode: builtins.str,
    ) -> None:
        '''
        :param fields: A list of log field paths to check for duplicates. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fields ObservabilityPipeline#fields}
        :param id: The unique identifier for this processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: A list of component IDs whose output is used as the input for this processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param mode: The deduplication mode to apply to the fields. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mode ObservabilityPipeline#mode}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f2e6e514d3bc50c2354de9fd996a7730f8fb27b9b77e7d70433e44c7854c7f9)
            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "fields": fields,
            "id": id,
            "include": include,
            "inputs": inputs,
            "mode": mode,
        }

    @builtins.property
    def fields(self) -> typing.List[builtins.str]:
        '''A list of log field paths to check for duplicates.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fields ObservabilityPipeline#fields}
        '''
        result = self._values.get("fields")
        assert result is not None, "Required property 'fields' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the input for this processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def mode(self) -> builtins.str:
        '''The deduplication mode to apply to the fields.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mode ObservabilityPipeline#mode}
        '''
        result = self._values.get("mode")
        assert result is not None, "Required property 'mode' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsDedupe(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsDedupeList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsDedupeList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea0430a7f3dbadcc288aad94f069a6a0c4f46217b45ce59fbb7664ddf550eddf)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsDedupeOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98f46dddda831ac3459ceafdac70cf59145aa00ff24f77d4dc915679f86dc461)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsDedupeOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8cfd971a8c7ef3af64bc033f20ae17fb43d1241cf43819dff3e1d7047778f419)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c375dbb452d7b6eb1619554d0105af6def2feee2f9a5be67df5ec6200b5151e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14fba9d9fab989b5e11453bb62e8960b4486a34284d1bb95583d60e12fb772c6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsDedupe]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsDedupe]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsDedupe]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__221dea916c45b1ad0f50a1d0bb4d2b112750f2ea8d3ce4157b6e72e79123f023)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsDedupeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsDedupeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ce8cd5508c1b1db8429630e8626d82171ce332ab7873e7303ceb9bd485187b7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="fieldsInput")
    def fields_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "fieldsInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="fields")
    def fields(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "fields"))

    @fields.setter
    def fields(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9132e44878e09864611410866ae58b762f978ee4012c091e1aa77fd35dc8b368)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "fields", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19482c2993c6a7cc767cafb2946f15be0826f14a7354cae5ed0f5a4d27af3d9c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__684e676d1f8bd8905b190e874e4f4a2c7e298e23310792064fc830b821edb092)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24e447831ecabb5959f418e02b67ab2feace6f10e988a5233138a94b6a50c04c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32a78c255a887e51ae981cb3a88ece35ea26555b08cc0d4b3ddcb6425c9c7fcd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsDedupe]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsDedupe]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsDedupe]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5be8c0d6a86707104116bbe9c007c8b7fea2e6f658d0c3b238065d69671a23fa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTable",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "target": "target",
        "file": "file",
        "geoip": "geoip",
    },
)
class ObservabilityPipelineConfigProcessorsEnrichmentTable:
    def __init__(
        self,
        *,
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        target: builtins.str,
        file: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsEnrichmentTableFile", typing.Dict[builtins.str, typing.Any]]] = None,
        geoip: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: A list of component IDs whose output is used as the input for this processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param target: Path where enrichment results should be stored in the log. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#target ObservabilityPipeline#target}
        :param file: file block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#file ObservabilityPipeline#file}
        :param geoip: geoip block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#geoip ObservabilityPipeline#geoip}
        '''
        if isinstance(file, dict):
            file = ObservabilityPipelineConfigProcessorsEnrichmentTableFile(**file)
        if isinstance(geoip, dict):
            geoip = ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip(**geoip)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__344433843a4e50bd2c7bb89fbb2b2665378cbe6119e473c7fc13351ab3c939c2)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
            check_type(argname="argument file", value=file, expected_type=type_hints["file"])
            check_type(argname="argument geoip", value=geoip, expected_type=type_hints["geoip"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "include": include,
            "inputs": inputs,
            "target": target,
        }
        if file is not None:
            self._values["file"] = file
        if geoip is not None:
            self._values["geoip"] = geoip

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the input for this processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Path where enrichment results should be stored in the log.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#target ObservabilityPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def file(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsEnrichmentTableFile"]:
        '''file block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#file ObservabilityPipeline#file}
        '''
        result = self._values.get("file")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsEnrichmentTableFile"], result)

    @builtins.property
    def geoip(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip"]:
        '''geoip block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#geoip ObservabilityPipeline#geoip}
        '''
        result = self._values.get("geoip")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsEnrichmentTable(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableFile",
    jsii_struct_bases=[],
    name_mapping={
        "encoding": "encoding",
        "key": "key",
        "path": "path",
        "schema": "schema",
    },
)
class ObservabilityPipelineConfigProcessorsEnrichmentTableFile:
    def __init__(
        self,
        *,
        encoding: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding", typing.Dict[builtins.str, typing.Any]]] = None,
        key: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey", typing.Dict[builtins.str, typing.Any]]]]] = None,
        path: typing.Optional[builtins.str] = None,
        schema: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param encoding: encoding block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        :param key: key block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key ObservabilityPipeline#key}
        :param path: Path to the CSV file. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#path ObservabilityPipeline#path}
        :param schema: schema block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#schema ObservabilityPipeline#schema}
        '''
        if isinstance(encoding, dict):
            encoding = ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding(**encoding)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea60331f8b4b9c2e34fdc5cea7f0901c7c5c465d159acbb80b485f5dc9403899)
            check_type(argname="argument encoding", value=encoding, expected_type=type_hints["encoding"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument schema", value=schema, expected_type=type_hints["schema"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if encoding is not None:
            self._values["encoding"] = encoding
        if key is not None:
            self._values["key"] = key
        if path is not None:
            self._values["path"] = path
        if schema is not None:
            self._values["schema"] = schema

    @builtins.property
    def encoding(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding"]:
        '''encoding block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        '''
        result = self._values.get("encoding")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding"], result)

    @builtins.property
    def key(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey"]]]:
        '''key block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key ObservabilityPipeline#key}
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey"]]], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path to the CSV file.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#path ObservabilityPipeline#path}
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def schema(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema"]]]:
        '''schema block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#schema ObservabilityPipeline#schema}
        '''
        result = self._values.get("schema")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsEnrichmentTableFile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding",
    jsii_struct_bases=[],
    name_mapping={
        "delimiter": "delimiter",
        "includes_headers": "includesHeaders",
        "type": "type",
    },
)
class ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding:
    def __init__(
        self,
        *,
        delimiter: typing.Optional[builtins.str] = None,
        includes_headers: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param delimiter: The ``encoding`` ``delimiter``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#delimiter ObservabilityPipeline#delimiter}
        :param includes_headers: The ``encoding`` ``includes_headers``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#includes_headers ObservabilityPipeline#includes_headers}
        :param type: File encoding format. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#type ObservabilityPipeline#type}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__31151945f4343c52cd2d0e2372111fbf24ae2b43885c8038b3702dff72d94bae)
            check_type(argname="argument delimiter", value=delimiter, expected_type=type_hints["delimiter"])
            check_type(argname="argument includes_headers", value=includes_headers, expected_type=type_hints["includes_headers"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if delimiter is not None:
            self._values["delimiter"] = delimiter
        if includes_headers is not None:
            self._values["includes_headers"] = includes_headers
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def delimiter(self) -> typing.Optional[builtins.str]:
        '''The ``encoding`` ``delimiter``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#delimiter ObservabilityPipeline#delimiter}
        '''
        result = self._values.get("delimiter")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def includes_headers(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''The ``encoding`` ``includes_headers``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#includes_headers ObservabilityPipeline#includes_headers}
        '''
        result = self._values.get("includes_headers")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''File encoding format.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#type ObservabilityPipeline#type}
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncodingOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncodingOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6746ae9c363fba6b343b25a7860285064a7b0d2104c3791d2b0d0eda30b19045)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetDelimiter")
    def reset_delimiter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDelimiter", []))

    @jsii.member(jsii_name="resetIncludesHeaders")
    def reset_includes_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIncludesHeaders", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @builtins.property
    @jsii.member(jsii_name="delimiterInput")
    def delimiter_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "delimiterInput"))

    @builtins.property
    @jsii.member(jsii_name="includesHeadersInput")
    def includes_headers_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "includesHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="delimiter")
    def delimiter(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "delimiter"))

    @delimiter.setter
    def delimiter(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ce72039d93003dadd88ea139bcf0846c2a5583096fa5644b09940e075e5ba87)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "delimiter", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="includesHeaders")
    def includes_headers(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "includesHeaders"))

    @includes_headers.setter
    def includes_headers(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5195364c7910053072c1733cc4aa972c6540863285337ace49aaf68949bd253d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "includesHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23e5c76e8f3c35aa57e3ff986d8704adf476da751ca5e69fa2fa0879792c1ee8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4005a8f2c77c1595ee40e79a90f3321697d4a6e0beff8061a22478b420be73d9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey",
    jsii_struct_bases=[],
    name_mapping={"column": "column", "comparison": "comparison", "field": "field"},
)
class ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey:
    def __init__(
        self,
        *,
        column: typing.Optional[builtins.str] = None,
        comparison: typing.Optional[builtins.str] = None,
        field: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param column: The ``items`` ``column``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#column ObservabilityPipeline#column}
        :param comparison: The comparison method (e.g. equals). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#comparison ObservabilityPipeline#comparison}
        :param field: The ``items`` ``field``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3bb23ac090b53f5808948006abc6ba1fc26dc980b7e1355d6a200e843398df4e)
            check_type(argname="argument column", value=column, expected_type=type_hints["column"])
            check_type(argname="argument comparison", value=comparison, expected_type=type_hints["comparison"])
            check_type(argname="argument field", value=field, expected_type=type_hints["field"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if column is not None:
            self._values["column"] = column
        if comparison is not None:
            self._values["comparison"] = comparison
        if field is not None:
            self._values["field"] = field

    @builtins.property
    def column(self) -> typing.Optional[builtins.str]:
        '''The ``items`` ``column``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#column ObservabilityPipeline#column}
        '''
        result = self._values.get("column")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison(self) -> typing.Optional[builtins.str]:
        '''The comparison method (e.g. equals).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#comparison ObservabilityPipeline#comparison}
        '''
        result = self._values.get("comparison")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def field(self) -> typing.Optional[builtins.str]:
        '''The ``items`` ``field``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        '''
        result = self._values.get("field")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsEnrichmentTableFileKeyList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableFileKeyList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94ca26e5229c9844d96c66b6e9e0e06954595b8e71ae7a6400569d6aa1bc1e55)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsEnrichmentTableFileKeyOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b888b001586e8cd78ef06055953065cf9dae2c6618462390a306d1f891417b13)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsEnrichmentTableFileKeyOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39bf6df92beeeda3e55e98dda4b0fa9696555c3d18a52ab8697271772aeaa412)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee36f90e469facb1eb8bd4ca3841e1ab38f5caaab21474531d74451c6ce5caa9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__940b120916748eab27887cac90aeacfe003ed890df080fc8056dc30278886669)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d3b06961c29827aae0777672bb5b7890efe3d3def5a3f7f1da77bd31e470b5c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsEnrichmentTableFileKeyOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableFileKeyOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8bd6df73ef7caf527d63f959903f8bae55ce69775552eb7913a9da775716354f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetColumn")
    def reset_column(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetColumn", []))

    @jsii.member(jsii_name="resetComparison")
    def reset_comparison(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetComparison", []))

    @jsii.member(jsii_name="resetField")
    def reset_field(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetField", []))

    @builtins.property
    @jsii.member(jsii_name="columnInput")
    def column_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "columnInput"))

    @builtins.property
    @jsii.member(jsii_name="comparisonInput")
    def comparison_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "comparisonInput"))

    @builtins.property
    @jsii.member(jsii_name="fieldInput")
    def field_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fieldInput"))

    @builtins.property
    @jsii.member(jsii_name="column")
    def column(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "column"))

    @column.setter
    def column(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7451b970d93c8ac58440af97ed41dbbb9289abee3d8f96ce6846e94ddf0151e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "column", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="comparison")
    def comparison(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "comparison"))

    @comparison.setter
    def comparison(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ed1568fa1dbbfd932cd2fe0ffc50ea53e13b3cb5bf8ffb9bccb719c7f2b1077)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "comparison", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="field")
    def field(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "field"))

    @field.setter
    def field(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d6c526290edad9a1a9f63d65b86644bed4a8720c2236e0ca95029c69592d925)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "field", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c4136e024ab3bca726e723a5752498d6d433978c1a772d5f40d779e523bdfdc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsEnrichmentTableFileOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableFileOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b029f2c17769be7dfe52ec562d1eb4809278e3c1a184b36aaa53d5b842137459)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putEncoding")
    def put_encoding(
        self,
        *,
        delimiter: typing.Optional[builtins.str] = None,
        includes_headers: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param delimiter: The ``encoding`` ``delimiter``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#delimiter ObservabilityPipeline#delimiter}
        :param includes_headers: The ``encoding`` ``includes_headers``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#includes_headers ObservabilityPipeline#includes_headers}
        :param type: File encoding format. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#type ObservabilityPipeline#type}
        '''
        value = ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding(
            delimiter=delimiter, includes_headers=includes_headers, type=type
        )

        return typing.cast(None, jsii.invoke(self, "putEncoding", [value]))

    @jsii.member(jsii_name="putKey")
    def put_key(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d059cfdd0f2fd14a53f031a6650ad1dd4d8e6d43adde6885ebe2432a314af8f4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putKey", [value]))

    @jsii.member(jsii_name="putSchema")
    def put_schema(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cdde45f261b772e81bd45e15b4df9de1d2fa80a7e6b8c93dbf4f7aa17b4e03da)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSchema", [value]))

    @jsii.member(jsii_name="resetEncoding")
    def reset_encoding(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEncoding", []))

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetSchema")
    def reset_schema(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSchema", []))

    @builtins.property
    @jsii.member(jsii_name="encoding")
    def encoding(
        self,
    ) -> ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncodingOutputReference:
        return typing.cast(ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncodingOutputReference, jsii.get(self, "encoding"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> ObservabilityPipelineConfigProcessorsEnrichmentTableFileKeyList:
        return typing.cast(ObservabilityPipelineConfigProcessorsEnrichmentTableFileKeyList, jsii.get(self, "key"))

    @builtins.property
    @jsii.member(jsii_name="schema")
    def schema(
        self,
    ) -> "ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchemaList":
        return typing.cast("ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchemaList", jsii.get(self, "schema"))

    @builtins.property
    @jsii.member(jsii_name="encodingInput")
    def encoding_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding]], jsii.get(self, "encodingInput"))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey]]], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="schemaInput")
    def schema_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema"]]], jsii.get(self, "schemaInput"))

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__921c0a3619cc8958264eb43d39a44e6e1f3c681f895bc0a2d3958c0e18423c1e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "path", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFile]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFile]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFile]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6781b640324a21dcfd57ec486193c5918a514d3873ecee9a5200db3236c2741f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema",
    jsii_struct_bases=[],
    name_mapping={"column": "column", "type": "type"},
)
class ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema:
    def __init__(
        self,
        *,
        column: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param column: The ``items`` ``column``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#column ObservabilityPipeline#column}
        :param type: The type of the column (e.g. string, boolean, integer, etc.). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#type ObservabilityPipeline#type}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0218e28a4ce326646028466a37e957be13168b3f9bdcfe0251c33f4002d3acac)
            check_type(argname="argument column", value=column, expected_type=type_hints["column"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if column is not None:
            self._values["column"] = column
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def column(self) -> typing.Optional[builtins.str]:
        '''The ``items`` ``column``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#column ObservabilityPipeline#column}
        '''
        result = self._values.get("column")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of the column (e.g. string, boolean, integer, etc.).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#type ObservabilityPipeline#type}
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchemaList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchemaList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd0bf80815b685cdef1d7946724c2798d55ac3c5b68f584363249da1c6c49da0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchemaOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ba9187a48e8f66289560f0731149cbb14375185b0f2924efc40ee763a8898ee)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchemaOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d9deadb901ec85760ec7bda1bf201de7fc5f3835278125ed01da71e8b1037b4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c540d9b2632b37cc9cbf1d96209b5be40768a2d39a1306cbc2b3f606058b493)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7209c031a2b6e3eff4ad05337741b0908f78e603623f85d5ef7d243b72dc1ef0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d5d46faccd02a6b75f5a07a8c37b19a6fdbd1853743d9b4c7920cf1b2121177)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchemaOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchemaOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e5f73e772e5a9303b8650ce09735433a24f8432c17635355ef4e2a99e68a9d0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetColumn")
    def reset_column(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetColumn", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @builtins.property
    @jsii.member(jsii_name="columnInput")
    def column_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "columnInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="column")
    def column(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "column"))

    @column.setter
    def column(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9e8c682b531059ed7df710eef20526b06d8da7e9c67f44164727743ee3026e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "column", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d37fef8be34e8858d10f2d35c93d2782065c87029c224cd1019061921dceb3b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__342f349fe9823b5c1a4f26bbe2f788d0ec5f6f7624f9a24a9901518d9777d11e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip",
    jsii_struct_bases=[],
    name_mapping={"key_field": "keyField", "locale": "locale", "path": "path"},
)
class ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip:
    def __init__(
        self,
        *,
        key_field: typing.Optional[builtins.str] = None,
        locale: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key_field: Path to the IP field in the log. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_field ObservabilityPipeline#key_field}
        :param locale: Locale used to resolve geographical names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#locale ObservabilityPipeline#locale}
        :param path: Path to the GeoIP database file. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#path ObservabilityPipeline#path}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0ee863a08c3ca473c2dbd8635d7e2d2b699a118da68af53a654822e04e5fa63)
            check_type(argname="argument key_field", value=key_field, expected_type=type_hints["key_field"])
            check_type(argname="argument locale", value=locale, expected_type=type_hints["locale"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key_field is not None:
            self._values["key_field"] = key_field
        if locale is not None:
            self._values["locale"] = locale
        if path is not None:
            self._values["path"] = path

    @builtins.property
    def key_field(self) -> typing.Optional[builtins.str]:
        '''Path to the IP field in the log.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_field ObservabilityPipeline#key_field}
        '''
        result = self._values.get("key_field")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def locale(self) -> typing.Optional[builtins.str]:
        '''Locale used to resolve geographical names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#locale ObservabilityPipeline#locale}
        '''
        result = self._values.get("locale")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path to the GeoIP database file.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#path ObservabilityPipeline#path}
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsEnrichmentTableGeoipOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableGeoipOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f52550f7c462a9cd1e4f0ad830e55f8fb15871e7e1f18eb2a1d86c50a7139c6)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetKeyField")
    def reset_key_field(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyField", []))

    @jsii.member(jsii_name="resetLocale")
    def reset_locale(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocale", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @builtins.property
    @jsii.member(jsii_name="keyFieldInput")
    def key_field_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFieldInput"))

    @builtins.property
    @jsii.member(jsii_name="localeInput")
    def locale_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "localeInput"))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="keyField")
    def key_field(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyField"))

    @key_field.setter
    def key_field(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__919101224b32d56e8fb1255693e9d446ecbd07f77fc4ad9d93a47446c998dfc4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyField", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="locale")
    def locale(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "locale"))

    @locale.setter
    def locale(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4db60ac426a2cbed6ef3c843c83bf608f4c19012484a4cd0b39d8f99995f4580)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "locale", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73a2d90a1a609fd343c6b9e32c8810e6bb97f9291fc29f8659740dc1c6176c1d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "path", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e488ba8944e319d07bae003b8e4ebfadf1548c5e2b99101798defc53484b7b4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsEnrichmentTableList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b86cb48a38025b051fd00b650331b21224c3d5a844cbbc8f94749d9adf2674b8)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsEnrichmentTableOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ec9a62ac0f3ceb1a3ca6954d62cf5fe39ffd0ef5800a80fbd1c5d59b3a30547)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsEnrichmentTableOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc599c6bdc2c21161b2121fb4887b0f37d25787f65fde4722d9a2b3e9fa82ae9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__645059d8107c23c427068f16b3e58f8369702ad6e88f4e9970f767a6c44392b8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f531a789c983067455a359574b188824dc883c08933d3abfea1ea3ac0eaa5fa3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTable]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTable]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTable]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9e298ca01dad1553fab2aad299a9e13943f1e0f78799e5dfde6f2f354b52393)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsEnrichmentTableOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsEnrichmentTableOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc8f91e8c9e335c10678e712503a5cd662034f8cc2029d34fdb7cc8bbc176abc)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putFile")
    def put_file(
        self,
        *,
        encoding: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding, typing.Dict[builtins.str, typing.Any]]] = None,
        key: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey, typing.Dict[builtins.str, typing.Any]]]]] = None,
        path: typing.Optional[builtins.str] = None,
        schema: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param encoding: encoding block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#encoding ObservabilityPipeline#encoding}
        :param key: key block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key ObservabilityPipeline#key}
        :param path: Path to the CSV file. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#path ObservabilityPipeline#path}
        :param schema: schema block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#schema ObservabilityPipeline#schema}
        '''
        value = ObservabilityPipelineConfigProcessorsEnrichmentTableFile(
            encoding=encoding, key=key, path=path, schema=schema
        )

        return typing.cast(None, jsii.invoke(self, "putFile", [value]))

    @jsii.member(jsii_name="putGeoip")
    def put_geoip(
        self,
        *,
        key_field: typing.Optional[builtins.str] = None,
        locale: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key_field: Path to the IP field in the log. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_field ObservabilityPipeline#key_field}
        :param locale: Locale used to resolve geographical names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#locale ObservabilityPipeline#locale}
        :param path: Path to the GeoIP database file. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#path ObservabilityPipeline#path}
        '''
        value = ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip(
            key_field=key_field, locale=locale, path=path
        )

        return typing.cast(None, jsii.invoke(self, "putGeoip", [value]))

    @jsii.member(jsii_name="resetFile")
    def reset_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFile", []))

    @jsii.member(jsii_name="resetGeoip")
    def reset_geoip(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGeoip", []))

    @builtins.property
    @jsii.member(jsii_name="file")
    def file(
        self,
    ) -> ObservabilityPipelineConfigProcessorsEnrichmentTableFileOutputReference:
        return typing.cast(ObservabilityPipelineConfigProcessorsEnrichmentTableFileOutputReference, jsii.get(self, "file"))

    @builtins.property
    @jsii.member(jsii_name="geoip")
    def geoip(
        self,
    ) -> ObservabilityPipelineConfigProcessorsEnrichmentTableGeoipOutputReference:
        return typing.cast(ObservabilityPipelineConfigProcessorsEnrichmentTableGeoipOutputReference, jsii.get(self, "geoip"))

    @builtins.property
    @jsii.member(jsii_name="fileInput")
    def file_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFile]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFile]], jsii.get(self, "fileInput"))

    @builtins.property
    @jsii.member(jsii_name="geoipInput")
    def geoip_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip]], jsii.get(self, "geoipInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="targetInput")
    def target_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "targetInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed6fb48a4cb32ef98eca7048b5ad882295d93a85d4f3a59796046d02dde750b5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b627153925c30efd39b00f94923dcb6cdd745fdf0f1b60758a0e2a87401b541a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9151940bc772aa18baeaf8850c40a3e4cecff6cbfeaf64021fab981b9083fdbc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="target")
    def target(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "target"))

    @target.setter
    def target(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__621b6dd3d2a8535db3250bdd7a4083af8e44585233bcaaac70713772b76b9e71)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "target", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTable]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTable]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a9b053dabee8d72a95e6dcad0bda21c3078ceafc5cde152aef40c316b8330dad)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsFilter",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "include": "include", "inputs": "inputs"},
)
class ObservabilityPipelineConfigProcessorsFilter:
    def __init__(
        self,
        *,
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param id: The unique ID of the processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs should pass through the filter. Logs that match this query continue to downstream components; others are dropped. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: The inputs for the processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__716f86525bbefc8f88c9c5a55769316492c07ceaa74dc3e5604319633f7d201c)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "include": include,
            "inputs": inputs,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique ID of the processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs should pass through the filter.

        Logs that match this query continue to downstream components; others are dropped.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''The inputs for the processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsFilterList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsFilterList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9db28dd4ce778ffc826e503a8e66b0031f90f7b4cf48cd70b5b4f52d0ff66fbf)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsFilterOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7b4bbfff82c91127486e710ebbf3e5d4d5c503298bdd19f68bff6bd17adcb05)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsFilterOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39456daf4e4ba765690302917a9b431fbb9d1f8525628239c0a416e39a2566ba)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c661995033e9ea205e773acbb5fde7e024b36d026cd17248a41c7843d972f455)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a92d3b6a3da5d9305233d03fb9903f5e8febc6632b8b841f9ade60919040464a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsFilter]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsFilter]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsFilter]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74836f050c984f7b655f6ed99383d318b077ecd52d90cac73dc4673bf422b608)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsFilterOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsFilterOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__311395263aa372cd2af8e732dd71d270beea9a567fdbb6dffc04f6812b3a904f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a92ccadc8b0ba1d94afecef670ae4bf9a3200fea3d9e0fcaaffe4ecc72656fe6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__384aca36e8d40d51391afc2de2a3e314892d01fa53cba446853676b4d43ea5d0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fdd7a8a540aab0b721cb730d71ce5fcce57a4ae78fe113ef35a40881a4af7fa9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsFilter]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsFilter]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsFilter]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__58afd2baecdaf1f17c50b4bb91eabb6951fe6a1c5ce253c1f9c9d1167eef1fd6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "metrics": "metrics",
    },
)
class ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics:
    def __init__(
        self,
        *,
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        metrics: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: A list of component IDs whose output is used as the ``input`` for this processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param metrics: metrics block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#metrics ObservabilityPipeline#metrics}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4592c0d9e5ecceb001fc0caa16c808f3e4a71d7a47195fd3dfb563d4f676408e)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument metrics", value=metrics, expected_type=type_hints["metrics"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "include": include,
            "inputs": inputs,
        }
        if metrics is not None:
            self._values["metrics"] = metrics

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component. Used to reference this component in other parts of the pipeline.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def metrics(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics"]]]:
        '''metrics block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#metrics ObservabilityPipeline#metrics}
        '''
        result = self._values.get("metrics")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c44904ee52f041ae4f7faca2b1d7ca8c4ece7080467f1c7b56a29eb0defa773)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__48faf781586c7e7b85afe4d99b317312d2e05afce7aaac025f2098dd1cec1e28)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0184445cf23e40e14ebdc260a0c5f0d7f35f95aaee8d85eb98bc6a6fd51d1b3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__429c70d32d2af306237af2bb36e9af3e25421b89b196850671b73e907c09193e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67b1307c9734060ffca78a32f76f17a05c513c280b50a9e0c2c641e09e09200e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a2c17d9b57c8c2ecbf652df84c9a79a445e48593167af64cc831b8599bec7cc7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics",
    jsii_struct_bases=[],
    name_mapping={
        "include": "include",
        "metric_type": "metricType",
        "name": "name",
        "group_by": "groupBy",
        "value": "value",
    },
)
class ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics:
    def __init__(
        self,
        *,
        include: builtins.str,
        metric_type: builtins.str,
        name: builtins.str,
        group_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        value: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param include: Datadog filter query to match logs for metric generation. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param metric_type: Type of metric to create. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#metric_type ObservabilityPipeline#metric_type}
        :param name: Name of the custom metric to be created. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        :param group_by: Optional fields used to group the metric series. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#group_by ObservabilityPipeline#group_by}
        :param value: value block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#value ObservabilityPipeline#value}
        '''
        if isinstance(value, dict):
            value = ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue(**value)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2f45108d3f7d333855478b255de2bf66d8afa44d744d20878f2c825ed189ff3)
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument metric_type", value=metric_type, expected_type=type_hints["metric_type"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument group_by", value=group_by, expected_type=type_hints["group_by"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "include": include,
            "metric_type": metric_type,
            "name": name,
        }
        if group_by is not None:
            self._values["group_by"] = group_by
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def include(self) -> builtins.str:
        '''Datadog filter query to match logs for metric generation.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric_type(self) -> builtins.str:
        '''Type of metric to create.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#metric_type ObservabilityPipeline#metric_type}
        '''
        result = self._values.get("metric_type")
        assert result is not None, "Required property 'metric_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the custom metric to be created.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Optional fields used to group the metric series.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#group_by ObservabilityPipeline#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def value(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue"]:
        '''value block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#value ObservabilityPipeline#value}
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da3dfe8e9b81c802163507c9ce4a94eee5fdb8faf91d104490fa7d3b598e6a59)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fef992e98dd1e90073e4da8d54bd987205dbbef872808df5d4ad3acca7ac1267)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35f1edf042e582b6a47913cb34f23173b16c44160ad8fe3669d490e3b0605788)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__430e88a2f052b8ce01cf770722fda114af5c50bb1f8c6bb7cd57cd5fb63e32f7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71e8346877eef6af5fea713c3d8a449c535514786f212c98117ce7a5463e5cb9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51343675deb614f7e36e22b7b28f3ba9179eb52c4c8af15d0512563326412bf3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44f221fd3ff9cb43a392bb53997a787da939f538d661d3055fd56a615f68bf18)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putValue")
    def put_value(
        self,
        *,
        strategy: builtins.str,
        field: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param strategy: Metric value strategy: ``increment_by_one`` or ``increment_by_field``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#strategy ObservabilityPipeline#strategy}
        :param field: Name of the log field containing the numeric value to increment the metric by (used only for ``increment_by_field``). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        '''
        value = ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue(
            strategy=strategy, field=field
        )

        return typing.cast(None, jsii.invoke(self, "putValue", [value]))

    @jsii.member(jsii_name="resetGroupBy")
    def reset_group_by(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGroupBy", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(
        self,
    ) -> "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValueOutputReference":
        return typing.cast("ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValueOutputReference", jsii.get(self, "value"))

    @builtins.property
    @jsii.member(jsii_name="groupByInput")
    def group_by_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "groupByInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="metricTypeInput")
    def metric_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "metricTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue"]], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="groupBy")
    def group_by(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "groupBy"))

    @group_by.setter
    def group_by(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a55178506487bcd5002ac2ac51256a21f7298f10570ee0fb306392482132f06a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "groupBy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9daa7ef77277d7911ee4e2508b77051c360edc6c6bab70e39bb7fa5985d5a9a1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="metricType")
    def metric_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "metricType"))

    @metric_type.setter
    def metric_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__042081c3bf734e3ff821a2564604ac7b4fea196fd43c1ce045f5526796ae8e6b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "metricType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__55bc311bb54323828188d675adb704730c0be1f536b8ab1fb9dddb9cea2ccf0a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb72439b1127a9ad0f1a2f13fa4000c8f1c24138d58ea4ec21d6bffec767135b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue",
    jsii_struct_bases=[],
    name_mapping={"strategy": "strategy", "field": "field"},
)
class ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue:
    def __init__(
        self,
        *,
        strategy: builtins.str,
        field: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param strategy: Metric value strategy: ``increment_by_one`` or ``increment_by_field``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#strategy ObservabilityPipeline#strategy}
        :param field: Name of the log field containing the numeric value to increment the metric by (used only for ``increment_by_field``). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11a946117852a5fb65e8323ba37f446c6ca04b6c5a1bec783fc72cc82953afef)
            check_type(argname="argument strategy", value=strategy, expected_type=type_hints["strategy"])
            check_type(argname="argument field", value=field, expected_type=type_hints["field"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "strategy": strategy,
        }
        if field is not None:
            self._values["field"] = field

    @builtins.property
    def strategy(self) -> builtins.str:
        '''Metric value strategy: ``increment_by_one`` or ``increment_by_field``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#strategy ObservabilityPipeline#strategy}
        '''
        result = self._values.get("strategy")
        assert result is not None, "Required property 'strategy' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def field(self) -> typing.Optional[builtins.str]:
        '''Name of the log field containing the numeric value to increment the metric by (used only for ``increment_by_field``).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        '''
        result = self._values.get("field")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValueOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValueOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__007bcd1ff85e1f52472e1674b4e5cf9316694a7237d960adc80a0022d54dfcac)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetField")
    def reset_field(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetField", []))

    @builtins.property
    @jsii.member(jsii_name="fieldInput")
    def field_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fieldInput"))

    @builtins.property
    @jsii.member(jsii_name="strategyInput")
    def strategy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "strategyInput"))

    @builtins.property
    @jsii.member(jsii_name="field")
    def field(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "field"))

    @field.setter
    def field(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70bd285d1da1cd9a64249829d83c0aaafaf0e7b1c608175ca65189165f0fcb21)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "field", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def strategy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "strategy"))

    @strategy.setter
    def strategy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1de099c4c900d5006e2648e2cbb92d75980f54e88dd90c26a1f6e91f410c012f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "strategy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03e788b57a1d63f4a4f0a5bb4fd378d11ded11ca6dbed18727b863b94537cf8b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c0cbe65b1a04f28c9ad021171d93e1997a9313c82c6f6a43c5e8188b0153c2a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putMetrics")
    def put_metrics(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23df3d269b2d56a8b65c6a0338bec906874e7fa3e9ce1d5b73f9a519c4827bbe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putMetrics", [value]))

    @jsii.member(jsii_name="resetMetrics")
    def reset_metrics(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMetrics", []))

    @builtins.property
    @jsii.member(jsii_name="metrics")
    def metrics(
        self,
    ) -> ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsList:
        return typing.cast(ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsList, jsii.get(self, "metrics"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="metricsInput")
    def metrics_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics]]], jsii.get(self, "metricsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0180246350932635ee1995b50067f04ea81f3cbbd2367c3192d8bf09201b2b58)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06ddf3a3c539f3bbcd97721214be8fd19078b7204b622d5977f8f6032ee5633a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1560d8fe635750a9296d9069087bc5e5bd4cf17bb4987e2056dddeb4d75cd432)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a48110ba7e064427ba2cbf1dbf3c5770312a3bcbf3726df4aeded10289ea309)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsOcsfMapper",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "mapping": "mapping",
    },
)
class ObservabilityPipelineConfigProcessorsOcsfMapper:
    def __init__(
        self,
        *,
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        mapping: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsOcsfMapperMapping", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: Search query to select logs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: List of component IDs whose output is used as input. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param mapping: mapping block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mapping ObservabilityPipeline#mapping}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__827c119a366285c162b71d20f68c18bea877e964a2b0dbf162a53bd0935d9135)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument mapping", value=mapping, expected_type=type_hints["mapping"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "include": include,
            "inputs": inputs,
        }
        if mapping is not None:
            self._values["mapping"] = mapping

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''Search query to select logs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''List of component IDs whose output is used as input.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def mapping(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsOcsfMapperMapping"]]]:
        '''mapping block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mapping ObservabilityPipeline#mapping}
        '''
        result = self._values.get("mapping")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsOcsfMapperMapping"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsOcsfMapper(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsOcsfMapperList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsOcsfMapperList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a14e4bd5201f21c6f89c425d1701dd8c78b346d6afa2e803e037e4a3739d9d0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsOcsfMapperOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b87a37dd11d8b00fc71506f858a7b9d784b8103b05ff5da01800a74e54decc7e)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsOcsfMapperOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a543767d07b2704dea50251244ab423c2dc28e874bf426df3ff79271fe2ed27)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb06cb276e255f162e92ef1223a4a7eda4e0fffee7f1ad0330fe7a3654070a9c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f8dd0db98fe6e2cf1f98c7a606b0851423d9acd81d2d4e55a7834ef27ad8405)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsOcsfMapper]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsOcsfMapper]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsOcsfMapper]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54617d5b9a454fac1f65e7bce6bdc9b914af8b977273100d13c07d4e96aebd90)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsOcsfMapperMapping",
    jsii_struct_bases=[],
    name_mapping={"include": "include", "library_mapping": "libraryMapping"},
)
class ObservabilityPipelineConfigProcessorsOcsfMapperMapping:
    def __init__(self, *, include: builtins.str, library_mapping: builtins.str) -> None:
        '''
        :param include: Search query for selecting which logs the mapping applies to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param library_mapping: Predefined library mapping for log transformation. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#library_mapping ObservabilityPipeline#library_mapping}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8dc86f384b6c9ec3ba3932312a56fa588c5864605092cd895c3387897bac004e)
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument library_mapping", value=library_mapping, expected_type=type_hints["library_mapping"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "include": include,
            "library_mapping": library_mapping,
        }

    @builtins.property
    def include(self) -> builtins.str:
        '''Search query for selecting which logs the mapping applies to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def library_mapping(self) -> builtins.str:
        '''Predefined library mapping for log transformation.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#library_mapping ObservabilityPipeline#library_mapping}
        '''
        result = self._values.get("library_mapping")
        assert result is not None, "Required property 'library_mapping' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsOcsfMapperMapping(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsOcsfMapperMappingList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsOcsfMapperMappingList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c30bb21079c0048601bc5ebea18a0df94084270d6cfc671b0e2920b0141c502e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsOcsfMapperMappingOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__839b7519c10397f9f57a7b6ec966600b282a0d116fd53a50a780bd3317283874)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsOcsfMapperMappingOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0224001209f1bbf35c80d3445268167f4a8b19814760ba803eed4f11d2948a1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a253cc1f3b36e1f8687be204a0d4eb1321b265272285205a8ca99b2d9111213f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8753c836f684a3802050bf285315d40dd1b922ad281f92f2f736c6807e58fc85)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsOcsfMapperMapping]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsOcsfMapperMapping]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsOcsfMapperMapping]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4125c4c59c3ca542d3abf8fe8ff8c2bc9e2c7f76bccb9cbaf42c1d638fcd786d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsOcsfMapperMappingOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsOcsfMapperMappingOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22a104ca829c05c4992c3a8f35e43306f86038018e1ff12d9d972097e196a17b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="libraryMappingInput")
    def library_mapping_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "libraryMappingInput"))

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e377f9957d818b910ef09ce52cc3ed81f75b8bd5d808543b0da949d0a829d9b2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="libraryMapping")
    def library_mapping(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "libraryMapping"))

    @library_mapping.setter
    def library_mapping(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3170b9767d5088a333af4a2f2382985f0735d854ca46d48aad2f395e98c51e44)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "libraryMapping", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsOcsfMapperMapping]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsOcsfMapperMapping]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsOcsfMapperMapping]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1c2a391e881812cc6c030a260d300ead327293fe76c3ebc17c3cbabee041a83)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsOcsfMapperOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsOcsfMapperOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8ea77a37e537edaf3f4863d7c25e26015bfb3113d58e355a4818eb9f8fe1f51)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putMapping")
    def put_mapping(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsOcsfMapperMapping, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e38025154022e0673f7f0adbd437d7dc1cd657d0dd9f6fd4b303ec6a54d5389)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putMapping", [value]))

    @jsii.member(jsii_name="resetMapping")
    def reset_mapping(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMapping", []))

    @builtins.property
    @jsii.member(jsii_name="mapping")
    def mapping(self) -> ObservabilityPipelineConfigProcessorsOcsfMapperMappingList:
        return typing.cast(ObservabilityPipelineConfigProcessorsOcsfMapperMappingList, jsii.get(self, "mapping"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="mappingInput")
    def mapping_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsOcsfMapperMapping]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsOcsfMapperMapping]]], jsii.get(self, "mappingInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28428429e684ab7f06ef116f1772c751eebe5b0c3b64ccb6aa2f17d370258a96)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8581cfcc3b04caa9c33e7a845a083882615e07df5211a15bf636d50db619338)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13ba83527c8ffa94dff955ca8476cc24549bce32a4a2af52efd2785dd6010115)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsOcsfMapper]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsOcsfMapper]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsOcsfMapper]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b76d931565cc08d73cc147f5b354877a5e7cff85559c2385dc79a77e0ce4cd56)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__764fb59c255712a769848254605538637e8209b6b325b57e12da5b9a8d4b814d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAddEnvVars")
    def put_add_env_vars(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsAddEnvVars, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__681b352359b654622eb4ce659310623638aa3bb030ebb86188baff5d3c7feee6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAddEnvVars", [value]))

    @jsii.member(jsii_name="putAddFields")
    def put_add_fields(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsAddFields, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d56a23f8572a89e7bd546299223f1f31eabe1b85e3402e8b5ece17b92f0676ec)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAddFields", [value]))

    @jsii.member(jsii_name="putCustomProcessor")
    def put_custom_processor(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsCustomProcessor, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c88218daf15abbdc930cb5422bbc024f10dade0615ee8101edfe29c3b46a9e48)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putCustomProcessor", [value]))

    @jsii.member(jsii_name="putDatadogTags")
    def put_datadog_tags(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsDatadogTags, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8379555b5312ba83979d4a34a48feddfa34421a9909f4b9dab56f7d786856b46)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putDatadogTags", [value]))

    @jsii.member(jsii_name="putDedupe")
    def put_dedupe(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsDedupe, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b61006952c410706a18a4d7ea3b8c1ecf643985db63a73fcb841c86faffd1435)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putDedupe", [value]))

    @jsii.member(jsii_name="putEnrichmentTable")
    def put_enrichment_table(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTable, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0ba29b3a7089869f7ac4fb71cc04e0ba6f0fa8da7b6a980bc7c157599ffc5f42)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putEnrichmentTable", [value]))

    @jsii.member(jsii_name="putFilter")
    def put_filter(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsFilter, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__935e60a76f6721ec781b276968bbb69fb60c2b0e769132ae156c76e3a1573268)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putFilter", [value]))

    @jsii.member(jsii_name="putGenerateDatadogMetrics")
    def put_generate_datadog_metrics(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a46db895f436d451ef9a34cb67b60db7623b4b005e2318f52d4be878a611c765)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putGenerateDatadogMetrics", [value]))

    @jsii.member(jsii_name="putOcsfMapper")
    def put_ocsf_mapper(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsOcsfMapper, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb6bf85234752fbf30be4eae3722e6a7b66db4d7c48f9934e8442ba1a4ca1110)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putOcsfMapper", [value]))

    @jsii.member(jsii_name="putParseGrok")
    def put_parse_grok(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsParseGrok", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50c9e17b86253b24a3b84e586a458b27454ca4a89cb6ed0ec382b4a6b1f7760d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putParseGrok", [value]))

    @jsii.member(jsii_name="putParseJson")
    def put_parse_json(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsParseJson", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d096df1cf9909294a39860ef7e453666a661a518837a7fb96c879a385e1e237)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putParseJson", [value]))

    @jsii.member(jsii_name="putQuota")
    def put_quota(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsQuota", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b0583498b83607284e690773effd2df58dda1650e1eb5f64239293bb024d070)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putQuota", [value]))

    @jsii.member(jsii_name="putReduce")
    def put_reduce(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsReduce", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__665d86133016ef17bcf73049145c05b20b1657188d03e866ca2b34a480c58b26)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putReduce", [value]))

    @jsii.member(jsii_name="putRemoveFields")
    def put_remove_fields(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsRemoveFields", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06e7d6aa18c55f68ebd5db49bd47461a3e385768fb2f3d6f9533fc49b949eed3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putRemoveFields", [value]))

    @jsii.member(jsii_name="putRenameFields")
    def put_rename_fields(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsRenameFields", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d90c98f21d09754878289af3f963b70bfc702a9c246e4e65d55d5f92f1e3367)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putRenameFields", [value]))

    @jsii.member(jsii_name="putSample")
    def put_sample(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsSample", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d47ba221138bf3cacb325f4617270c6d542f2925f70ff0e371368a4fd816b09a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSample", [value]))

    @jsii.member(jsii_name="putSensitiveDataScanner")
    def put_sensitive_data_scanner(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScanner", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8857743320b6567672b77fdd30d67777a1d5badb7b6c89e1307539016b5758f0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSensitiveDataScanner", [value]))

    @jsii.member(jsii_name="putThrottle")
    def put_throttle(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsThrottle", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2cc4e1d3a21b75c5e6ef77a406c292575532b222a891f59981945845c033c2cc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putThrottle", [value]))

    @jsii.member(jsii_name="resetAddEnvVars")
    def reset_add_env_vars(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAddEnvVars", []))

    @jsii.member(jsii_name="resetAddFields")
    def reset_add_fields(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAddFields", []))

    @jsii.member(jsii_name="resetCustomProcessor")
    def reset_custom_processor(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCustomProcessor", []))

    @jsii.member(jsii_name="resetDatadogTags")
    def reset_datadog_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatadogTags", []))

    @jsii.member(jsii_name="resetDedupe")
    def reset_dedupe(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDedupe", []))

    @jsii.member(jsii_name="resetEnrichmentTable")
    def reset_enrichment_table(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnrichmentTable", []))

    @jsii.member(jsii_name="resetFilter")
    def reset_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFilter", []))

    @jsii.member(jsii_name="resetGenerateDatadogMetrics")
    def reset_generate_datadog_metrics(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGenerateDatadogMetrics", []))

    @jsii.member(jsii_name="resetOcsfMapper")
    def reset_ocsf_mapper(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOcsfMapper", []))

    @jsii.member(jsii_name="resetParseGrok")
    def reset_parse_grok(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetParseGrok", []))

    @jsii.member(jsii_name="resetParseJson")
    def reset_parse_json(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetParseJson", []))

    @jsii.member(jsii_name="resetQuota")
    def reset_quota(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetQuota", []))

    @jsii.member(jsii_name="resetReduce")
    def reset_reduce(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReduce", []))

    @jsii.member(jsii_name="resetRemoveFields")
    def reset_remove_fields(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRemoveFields", []))

    @jsii.member(jsii_name="resetRenameFields")
    def reset_rename_fields(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRenameFields", []))

    @jsii.member(jsii_name="resetSample")
    def reset_sample(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSample", []))

    @jsii.member(jsii_name="resetSensitiveDataScanner")
    def reset_sensitive_data_scanner(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSensitiveDataScanner", []))

    @jsii.member(jsii_name="resetThrottle")
    def reset_throttle(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetThrottle", []))

    @builtins.property
    @jsii.member(jsii_name="addEnvVars")
    def add_env_vars(self) -> ObservabilityPipelineConfigProcessorsAddEnvVarsList:
        return typing.cast(ObservabilityPipelineConfigProcessorsAddEnvVarsList, jsii.get(self, "addEnvVars"))

    @builtins.property
    @jsii.member(jsii_name="addFields")
    def add_fields(self) -> ObservabilityPipelineConfigProcessorsAddFieldsList:
        return typing.cast(ObservabilityPipelineConfigProcessorsAddFieldsList, jsii.get(self, "addFields"))

    @builtins.property
    @jsii.member(jsii_name="customProcessor")
    def custom_processor(
        self,
    ) -> ObservabilityPipelineConfigProcessorsCustomProcessorList:
        return typing.cast(ObservabilityPipelineConfigProcessorsCustomProcessorList, jsii.get(self, "customProcessor"))

    @builtins.property
    @jsii.member(jsii_name="datadogTags")
    def datadog_tags(self) -> ObservabilityPipelineConfigProcessorsDatadogTagsList:
        return typing.cast(ObservabilityPipelineConfigProcessorsDatadogTagsList, jsii.get(self, "datadogTags"))

    @builtins.property
    @jsii.member(jsii_name="dedupe")
    def dedupe(self) -> ObservabilityPipelineConfigProcessorsDedupeList:
        return typing.cast(ObservabilityPipelineConfigProcessorsDedupeList, jsii.get(self, "dedupe"))

    @builtins.property
    @jsii.member(jsii_name="enrichmentTable")
    def enrichment_table(
        self,
    ) -> ObservabilityPipelineConfigProcessorsEnrichmentTableList:
        return typing.cast(ObservabilityPipelineConfigProcessorsEnrichmentTableList, jsii.get(self, "enrichmentTable"))

    @builtins.property
    @jsii.member(jsii_name="filter")
    def filter(self) -> ObservabilityPipelineConfigProcessorsFilterList:
        return typing.cast(ObservabilityPipelineConfigProcessorsFilterList, jsii.get(self, "filter"))

    @builtins.property
    @jsii.member(jsii_name="generateDatadogMetrics")
    def generate_datadog_metrics(
        self,
    ) -> ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsList:
        return typing.cast(ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsList, jsii.get(self, "generateDatadogMetrics"))

    @builtins.property
    @jsii.member(jsii_name="ocsfMapper")
    def ocsf_mapper(self) -> ObservabilityPipelineConfigProcessorsOcsfMapperList:
        return typing.cast(ObservabilityPipelineConfigProcessorsOcsfMapperList, jsii.get(self, "ocsfMapper"))

    @builtins.property
    @jsii.member(jsii_name="parseGrok")
    def parse_grok(self) -> "ObservabilityPipelineConfigProcessorsParseGrokList":
        return typing.cast("ObservabilityPipelineConfigProcessorsParseGrokList", jsii.get(self, "parseGrok"))

    @builtins.property
    @jsii.member(jsii_name="parseJson")
    def parse_json(self) -> "ObservabilityPipelineConfigProcessorsParseJsonList":
        return typing.cast("ObservabilityPipelineConfigProcessorsParseJsonList", jsii.get(self, "parseJson"))

    @builtins.property
    @jsii.member(jsii_name="quota")
    def quota(self) -> "ObservabilityPipelineConfigProcessorsQuotaList":
        return typing.cast("ObservabilityPipelineConfigProcessorsQuotaList", jsii.get(self, "quota"))

    @builtins.property
    @jsii.member(jsii_name="reduce")
    def reduce(self) -> "ObservabilityPipelineConfigProcessorsReduceList":
        return typing.cast("ObservabilityPipelineConfigProcessorsReduceList", jsii.get(self, "reduce"))

    @builtins.property
    @jsii.member(jsii_name="removeFields")
    def remove_fields(self) -> "ObservabilityPipelineConfigProcessorsRemoveFieldsList":
        return typing.cast("ObservabilityPipelineConfigProcessorsRemoveFieldsList", jsii.get(self, "removeFields"))

    @builtins.property
    @jsii.member(jsii_name="renameFields")
    def rename_fields(self) -> "ObservabilityPipelineConfigProcessorsRenameFieldsList":
        return typing.cast("ObservabilityPipelineConfigProcessorsRenameFieldsList", jsii.get(self, "renameFields"))

    @builtins.property
    @jsii.member(jsii_name="sample")
    def sample(self) -> "ObservabilityPipelineConfigProcessorsSampleList":
        return typing.cast("ObservabilityPipelineConfigProcessorsSampleList", jsii.get(self, "sample"))

    @builtins.property
    @jsii.member(jsii_name="sensitiveDataScanner")
    def sensitive_data_scanner(
        self,
    ) -> "ObservabilityPipelineConfigProcessorsSensitiveDataScannerList":
        return typing.cast("ObservabilityPipelineConfigProcessorsSensitiveDataScannerList", jsii.get(self, "sensitiveDataScanner"))

    @builtins.property
    @jsii.member(jsii_name="throttle")
    def throttle(self) -> "ObservabilityPipelineConfigProcessorsThrottleList":
        return typing.cast("ObservabilityPipelineConfigProcessorsThrottleList", jsii.get(self, "throttle"))

    @builtins.property
    @jsii.member(jsii_name="addEnvVarsInput")
    def add_env_vars_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddEnvVars]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddEnvVars]]], jsii.get(self, "addEnvVarsInput"))

    @builtins.property
    @jsii.member(jsii_name="addFieldsInput")
    def add_fields_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddFields]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddFields]]], jsii.get(self, "addFieldsInput"))

    @builtins.property
    @jsii.member(jsii_name="customProcessorInput")
    def custom_processor_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsCustomProcessor]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsCustomProcessor]]], jsii.get(self, "customProcessorInput"))

    @builtins.property
    @jsii.member(jsii_name="datadogTagsInput")
    def datadog_tags_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsDatadogTags]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsDatadogTags]]], jsii.get(self, "datadogTagsInput"))

    @builtins.property
    @jsii.member(jsii_name="dedupeInput")
    def dedupe_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsDedupe]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsDedupe]]], jsii.get(self, "dedupeInput"))

    @builtins.property
    @jsii.member(jsii_name="enrichmentTableInput")
    def enrichment_table_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTable]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTable]]], jsii.get(self, "enrichmentTableInput"))

    @builtins.property
    @jsii.member(jsii_name="filterInput")
    def filter_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsFilter]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsFilter]]], jsii.get(self, "filterInput"))

    @builtins.property
    @jsii.member(jsii_name="generateDatadogMetricsInput")
    def generate_datadog_metrics_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics]]], jsii.get(self, "generateDatadogMetricsInput"))

    @builtins.property
    @jsii.member(jsii_name="ocsfMapperInput")
    def ocsf_mapper_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsOcsfMapper]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsOcsfMapper]]], jsii.get(self, "ocsfMapperInput"))

    @builtins.property
    @jsii.member(jsii_name="parseGrokInput")
    def parse_grok_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrok"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrok"]]], jsii.get(self, "parseGrokInput"))

    @builtins.property
    @jsii.member(jsii_name="parseJsonInput")
    def parse_json_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseJson"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseJson"]]], jsii.get(self, "parseJsonInput"))

    @builtins.property
    @jsii.member(jsii_name="quotaInput")
    def quota_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsQuota"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsQuota"]]], jsii.get(self, "quotaInput"))

    @builtins.property
    @jsii.member(jsii_name="reduceInput")
    def reduce_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsReduce"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsReduce"]]], jsii.get(self, "reduceInput"))

    @builtins.property
    @jsii.member(jsii_name="removeFieldsInput")
    def remove_fields_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsRemoveFields"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsRemoveFields"]]], jsii.get(self, "removeFieldsInput"))

    @builtins.property
    @jsii.member(jsii_name="renameFieldsInput")
    def rename_fields_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsRenameFields"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsRenameFields"]]], jsii.get(self, "renameFieldsInput"))

    @builtins.property
    @jsii.member(jsii_name="sampleInput")
    def sample_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsSample"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsSample"]]], jsii.get(self, "sampleInput"))

    @builtins.property
    @jsii.member(jsii_name="sensitiveDataScannerInput")
    def sensitive_data_scanner_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsSensitiveDataScanner"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsSensitiveDataScanner"]]], jsii.get(self, "sensitiveDataScannerInput"))

    @builtins.property
    @jsii.member(jsii_name="throttleInput")
    def throttle_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsThrottle"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsThrottle"]]], jsii.get(self, "throttleInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessors]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessors]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessors]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__30ab56d0be6405c998d21c9f1f24cb2489c20284c3832f2b2827dcf15544669b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseGrok",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "disable_library_rules": "disableLibraryRules",
        "rules": "rules",
    },
)
class ObservabilityPipelineConfigProcessorsParseGrok:
    def __init__(
        self,
        *,
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        disable_library_rules: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        rules: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsParseGrokRules", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param id: A unique identifier for this processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param disable_library_rules: If set to ``true``, disables the default Grok rules provided by Datadog. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#disable_library_rules ObservabilityPipeline#disable_library_rules}
        :param rules: rules block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rules ObservabilityPipeline#rules}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4db72e9da594a2efd988bfbe10af415a517a031539643813a7f56dd17135a721)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument disable_library_rules", value=disable_library_rules, expected_type=type_hints["disable_library_rules"])
            check_type(argname="argument rules", value=rules, expected_type=type_hints["rules"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "include": include,
            "inputs": inputs,
        }
        if disable_library_rules is not None:
            self._values["disable_library_rules"] = disable_library_rules
        if rules is not None:
            self._values["rules"] = rules

    @builtins.property
    def id(self) -> builtins.str:
        '''A unique identifier for this processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def disable_library_rules(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''If set to ``true``, disables the default Grok rules provided by Datadog.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#disable_library_rules ObservabilityPipeline#disable_library_rules}
        '''
        result = self._values.get("disable_library_rules")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def rules(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrokRules"]]]:
        '''rules block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rules ObservabilityPipeline#rules}
        '''
        result = self._values.get("rules")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrokRules"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsParseGrok(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsParseGrokList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseGrokList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88d3be2ffd73c3e0e325680e56fae6acef05999a8e77865d307d2c64569258b7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsParseGrokOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29e7207f63d5d648daa3c8eadb266985a200e2c3b4cc1929216f56928f908b77)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsParseGrokOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20aa7a34c651138ca5486870b71251d6d1dd48764bc4880881a04213823a3a87)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39592d74512ebe1e4a58c19fa0a6d2dd4ed948184e3ae771b6b3afce1acb983b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b38641a18b01018663feae20df007a3a05831488ff4f5e7e7fac8077f82eb92d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrok]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrok]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrok]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff6c2ce998c97598998fd38723abae735a470b45acae3071f202e5e497411e23)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsParseGrokOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseGrokOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20a80e18d788cdaa40dab83a941977c8a0324041ccb536b83898123cd8180243)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putRules")
    def put_rules(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsParseGrokRules", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f9b25e3de1fa44043de5ca209eec91aec1f3198f81a46d6547308e2eb7d1366)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putRules", [value]))

    @jsii.member(jsii_name="resetDisableLibraryRules")
    def reset_disable_library_rules(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisableLibraryRules", []))

    @jsii.member(jsii_name="resetRules")
    def reset_rules(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRules", []))

    @builtins.property
    @jsii.member(jsii_name="rules")
    def rules(self) -> "ObservabilityPipelineConfigProcessorsParseGrokRulesList":
        return typing.cast("ObservabilityPipelineConfigProcessorsParseGrokRulesList", jsii.get(self, "rules"))

    @builtins.property
    @jsii.member(jsii_name="disableLibraryRulesInput")
    def disable_library_rules_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disableLibraryRulesInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="rulesInput")
    def rules_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrokRules"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrokRules"]]], jsii.get(self, "rulesInput"))

    @builtins.property
    @jsii.member(jsii_name="disableLibraryRules")
    def disable_library_rules(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disableLibraryRules"))

    @disable_library_rules.setter
    def disable_library_rules(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a121065ac6ad1cd562681abbaee7926430fd2abb3c2ae5b0a8a797c9bb4cff61)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disableLibraryRules", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f03f351ce4e022e4f59f3c199c07aa44699a91a1a83a2f80a3d644342752128)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e1e416b18fc7476374bd8d0cc59d31d9c4bcfcab8d108634b76e8d761cdc653)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a2eea2ba03b98d22bd0f9d72ef476453f358049984355f81c7e4360196a52d9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrok]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrok]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrok]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e31cb2d3668e8851fd19724e8ba291d178b3646652e02531fdd1be9acd5a60f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseGrokRules",
    jsii_struct_bases=[],
    name_mapping={
        "source": "source",
        "match_rule": "matchRule",
        "support_rule": "supportRule",
    },
)
class ObservabilityPipelineConfigProcessorsParseGrokRules:
    def __init__(
        self,
        *,
        source: builtins.str,
        match_rule: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule", typing.Dict[builtins.str, typing.Any]]]]] = None,
        support_rule: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param source: The name of the field in the log event to apply the Grok rules to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#source ObservabilityPipeline#source}
        :param match_rule: match_rule block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#match_rule ObservabilityPipeline#match_rule}
        :param support_rule: support_rule block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#support_rule ObservabilityPipeline#support_rule}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f541ea44e78bc51565ddadc5aa933700187ba0f67fe7cb5555def2df3eb861c)
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
            check_type(argname="argument match_rule", value=match_rule, expected_type=type_hints["match_rule"])
            check_type(argname="argument support_rule", value=support_rule, expected_type=type_hints["support_rule"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "source": source,
        }
        if match_rule is not None:
            self._values["match_rule"] = match_rule
        if support_rule is not None:
            self._values["support_rule"] = support_rule

    @builtins.property
    def source(self) -> builtins.str:
        '''The name of the field in the log event to apply the Grok rules to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#source ObservabilityPipeline#source}
        '''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def match_rule(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule"]]]:
        '''match_rule block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#match_rule ObservabilityPipeline#match_rule}
        '''
        result = self._values.get("match_rule")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule"]]], result)

    @builtins.property
    def support_rule(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule"]]]:
        '''support_rule block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#support_rule ObservabilityPipeline#support_rule}
        '''
        result = self._values.get("support_rule")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsParseGrokRules(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsParseGrokRulesList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseGrokRulesList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4ba7646ecf6ff4d5c508b36c5718cb7836f124cc4e3983d2d319081047e0371)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsParseGrokRulesOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__526401beed7b927c024bea0677826968b5d37873adc1f9b29cddcdfdb771a303)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsParseGrokRulesOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__746c012a379c49b5c03ae8c0a2fd3cf77afdd42567cff53731ce8bdcb24ddb33)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__870cfbe147a3cce4cd0f65391db967f3212df74e2c457cf74e0d02796e16d323)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19bf18464dbb74163555b872871e06aa4c1503df4a55c151f45b2e88bf6e0d76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRules]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRules]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRules]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b84419763b5c5c633e2b94f11ee3be9700be1fb1c90f564f93494a540567ed7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "rule": "rule"},
)
class ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule:
    def __init__(self, *, name: builtins.str, rule: builtins.str) -> None:
        '''
        :param name: The name of the rule. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        :param rule: The definition of the Grok rule. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rule ObservabilityPipeline#rule}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35b0b869aa2f717f7f06c02bdde57c75fddaed9ca4cc378959ce62665bcbb64c)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument rule", value=rule, expected_type=type_hints["rule"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "rule": rule,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the rule.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule(self) -> builtins.str:
        '''The definition of the Grok rule.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rule ObservabilityPipeline#rule}
        '''
        result = self._values.get("rule")
        assert result is not None, "Required property 'rule' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRuleList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRuleList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__698caf2744df8f6c312aca1ae1f1bb252b53c59186f0e616aa6ec8bb80ef12d9)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRuleOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73d681621ae64445c2bd133ce0aad45dfd0f0d4a16675228d17c86345f96707e)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRuleOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__65d07a7a9ce5f1b2de2108f91ffce0d9aeec706ebacb1dec3e2e373f9de3599d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__950a07332a900814144e9fd734ba95016f10438cb4ffd8ec43ec93e95082bc37)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eed232833f91e1fca6ed071d8958ce8e73497870ef919a60c1708bdc13d1cafb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3258726f76029b6a79db9642e45dcd04f7c1cec122a784f37660255fa9db953)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRuleOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRuleOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b65bef4653706fe83e31ba698d7f549dd82d44855681f600c134e85c555fbe7b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9b78df6410808f664a479c1e32733a63f63599d120ea4b9031a2d18de1b5187)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rule"))

    @rule.setter
    def rule(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9724fa73a624b3cc3bbe569504183df36b2705d40c033d1bbcc95802a41b189e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "rule", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ed0d9cde732ab3978ca6ce05005d55257e2cb029c91964f22f2ec91c29b5e40)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsParseGrokRulesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseGrokRulesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bdece0a5fcf1779b45aacbbcb8c2321d49a4eef3cf4053b252c6ecaa9c332201)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putMatchRule")
    def put_match_rule(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c560e07809a0ecce72e796c70a4f43982e90675ae12ce376377ded1bdd600ea)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putMatchRule", [value]))

    @jsii.member(jsii_name="putSupportRule")
    def put_support_rule(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0485e766948b1ba75a9ba82d91ac8db3daa94d121dd8f0e634d83f75a4e85be8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSupportRule", [value]))

    @jsii.member(jsii_name="resetMatchRule")
    def reset_match_rule(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchRule", []))

    @jsii.member(jsii_name="resetSupportRule")
    def reset_support_rule(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSupportRule", []))

    @builtins.property
    @jsii.member(jsii_name="matchRule")
    def match_rule(
        self,
    ) -> ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRuleList:
        return typing.cast(ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRuleList, jsii.get(self, "matchRule"))

    @builtins.property
    @jsii.member(jsii_name="supportRule")
    def support_rule(
        self,
    ) -> "ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRuleList":
        return typing.cast("ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRuleList", jsii.get(self, "supportRule"))

    @builtins.property
    @jsii.member(jsii_name="matchRuleInput")
    def match_rule_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule]]], jsii.get(self, "matchRuleInput"))

    @builtins.property
    @jsii.member(jsii_name="sourceInput")
    def source_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceInput"))

    @builtins.property
    @jsii.member(jsii_name="supportRuleInput")
    def support_rule_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule"]]], jsii.get(self, "supportRuleInput"))

    @builtins.property
    @jsii.member(jsii_name="source")
    def source(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "source"))

    @source.setter
    def source(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03767d5c736a66d03a84a2cf9996c259c0d6d68252914456e194057ed60de8c7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "source", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrokRules]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrokRules]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrokRules]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9dadf998be4c49d9d8578dcc90192512326afdfc4dc6187814dd1ce649d9300)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "rule": "rule"},
)
class ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule:
    def __init__(self, *, name: builtins.str, rule: builtins.str) -> None:
        '''
        :param name: The name of the helper Grok rule. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        :param rule: The definition of the helper Grok rule. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rule ObservabilityPipeline#rule}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e8e8262d6a58f87710b13a112691dc775add40890751d6dda35758240bdeed2)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument rule", value=rule, expected_type=type_hints["rule"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "rule": rule,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the helper Grok rule.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule(self) -> builtins.str:
        '''The definition of the helper Grok rule.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rule ObservabilityPipeline#rule}
        '''
        result = self._values.get("rule")
        assert result is not None, "Required property 'rule' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRuleList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRuleList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47ee6b1a1aad95b586ab00fa5539f4f98e55546c641cc444a5d96a7c8530038d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRuleOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f963f548b57963e0bba348dadcfe3342041122b84083304aea53c4fb48a2dbc)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRuleOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2acd9dff3a339352384e02040d69e3e3abf199a9ddbd99521f1f1f5336ce0ff)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0204591ff7e87ecae16a423d55bb9118793ff8fc9a6f10e01fb8fce9f2f8ba33)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__79a7cc3686acdb4c06d34237027c5f1a288438d8e31044869685fd7053e6afae)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4b1006e24d98c6880739d062ca1541f8b854c06e14898801bc2bf69c4f565b5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRuleOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRuleOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5082406bf85b56cb7a260bf97a3147471957a11a7b8aa533bff9c7cf8cba2bb)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__453d237e5758343778a7769fc0a5b37b326a98a1e10987499b8a1705c2915688)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rule"))

    @rule.setter
    def rule(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2791b35a5c628b9a83de2d562119b71f2b6a72066e89ae772ef43c68ce4f869e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "rule", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff536a958104a184f313c9d42b10761c619aee22215b6a5b06f99cc6388c6645)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseJson",
    jsii_struct_bases=[],
    name_mapping={
        "field": "field",
        "id": "id",
        "include": "include",
        "inputs": "inputs",
    },
)
class ObservabilityPipelineConfigProcessorsParseJson:
    def __init__(
        self,
        *,
        field: builtins.str,
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param field: The field to parse. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        :param id: The unique ID of the processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: The inputs for the processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__30b5bc2e45530f50f7e6155fbbd9e717db91020a4adb16ac25236468d4cbe4bf)
            check_type(argname="argument field", value=field, expected_type=type_hints["field"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "field": field,
            "id": id,
            "include": include,
            "inputs": inputs,
        }

    @builtins.property
    def field(self) -> builtins.str:
        '''The field to parse.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        '''
        result = self._values.get("field")
        assert result is not None, "Required property 'field' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique ID of the processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''The inputs for the processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsParseJson(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsParseJsonList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseJsonList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__186e719237e98dd9468fc5f3d396555198539835ba69a9c6043a19aafda567cf)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsParseJsonOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39f49e661318c65408ace7ab0d86aea4d75ce268204e8d754cdff8f2b982cd40)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsParseJsonOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf19396bd18249b8d42f2f7fe96056d11fbeb384c6a7ab25ea6790c17c6fcfd4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af8982381b59af24b78359d20ab7e621c195d358f513d8dd7cc885c94f8f39bb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c959e8b9ec85f404ec9662dcff5bde0a5196de6eb199dc17c3098f094462c89b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseJson]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseJson]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseJson]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8326003255892efeb15bfad9892bc9bb2df9811bca845747682d1ad9b493bb9d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsParseJsonOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsParseJsonOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc2dc5f3ee617c5cd8eb41fee9899d47e1d20f3166605bd7f4a9571a4641958f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="fieldInput")
    def field_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fieldInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="field")
    def field(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "field"))

    @field.setter
    def field(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4749f4d338e8014b81b7da4e9e429bd8cb3f7dae67dcdbc5d186366e08306b5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "field", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d77213b62a62efbc39d9909a3b941244fd3faf2083807ea4eeb610c52d5d863)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__149aab8c1754e41da61a42bb2c0788e747291caeaec6c4785a1e2353a60b923a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a718e93ecc18b14dfbf01826d8253feff99d031b13e3927e46f2ec78322d20d4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseJson]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseJson]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseJson]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7eef630e85c044ebe4a31feb444c3bc43c6292f05150d01562e8229402d0196d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsQuota",
    jsii_struct_bases=[],
    name_mapping={
        "drop_events": "dropEvents",
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "limit": "limit",
        "name": "name",
        "ignore_when_missing_partitions": "ignoreWhenMissingPartitions",
        "overflow_action": "overflowAction",
        "overrides": "overrides",
        "partition_fields": "partitionFields",
    },
)
class ObservabilityPipelineConfigProcessorsQuota:
    def __init__(
        self,
        *,
        drop_events: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        limit: typing.Union["ObservabilityPipelineConfigProcessorsQuotaLimit", typing.Dict[builtins.str, typing.Any]],
        name: builtins.str,
        ignore_when_missing_partitions: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        overflow_action: typing.Optional[builtins.str] = None,
        overrides: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsQuotaOverrides", typing.Dict[builtins.str, typing.Any]]]]] = None,
        partition_fields: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param drop_events: Whether to drop events exceeding the limit. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#drop_events ObservabilityPipeline#drop_events}
        :param id: The unique ID of the processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: The inputs for the processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param limit: limit block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#limit ObservabilityPipeline#limit}
        :param name: The name of the quota. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        :param ignore_when_missing_partitions: Whether to ignore when partition fields are missing. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ignore_when_missing_partitions ObservabilityPipeline#ignore_when_missing_partitions}
        :param overflow_action: The action to take when the quota is exceeded: ``drop``, ``no_action``, or ``overflow_routing``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#overflow_action ObservabilityPipeline#overflow_action}
        :param overrides: overrides block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#overrides ObservabilityPipeline#overrides}
        :param partition_fields: List of partition fields. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#partition_fields ObservabilityPipeline#partition_fields}
        '''
        if isinstance(limit, dict):
            limit = ObservabilityPipelineConfigProcessorsQuotaLimit(**limit)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96c9aa4b8a81ac275740889575040a3ca73ea4d9de7785542bdccb4245941bb4)
            check_type(argname="argument drop_events", value=drop_events, expected_type=type_hints["drop_events"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument limit", value=limit, expected_type=type_hints["limit"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument ignore_when_missing_partitions", value=ignore_when_missing_partitions, expected_type=type_hints["ignore_when_missing_partitions"])
            check_type(argname="argument overflow_action", value=overflow_action, expected_type=type_hints["overflow_action"])
            check_type(argname="argument overrides", value=overrides, expected_type=type_hints["overrides"])
            check_type(argname="argument partition_fields", value=partition_fields, expected_type=type_hints["partition_fields"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "drop_events": drop_events,
            "id": id,
            "include": include,
            "inputs": inputs,
            "limit": limit,
            "name": name,
        }
        if ignore_when_missing_partitions is not None:
            self._values["ignore_when_missing_partitions"] = ignore_when_missing_partitions
        if overflow_action is not None:
            self._values["overflow_action"] = overflow_action
        if overrides is not None:
            self._values["overrides"] = overrides
        if partition_fields is not None:
            self._values["partition_fields"] = partition_fields

    @builtins.property
    def drop_events(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether to drop events exceeding the limit.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#drop_events ObservabilityPipeline#drop_events}
        '''
        result = self._values.get("drop_events")
        assert result is not None, "Required property 'drop_events' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique ID of the processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''The inputs for the processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def limit(self) -> "ObservabilityPipelineConfigProcessorsQuotaLimit":
        '''limit block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#limit ObservabilityPipeline#limit}
        '''
        result = self._values.get("limit")
        assert result is not None, "Required property 'limit' is missing"
        return typing.cast("ObservabilityPipelineConfigProcessorsQuotaLimit", result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the quota.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ignore_when_missing_partitions(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to ignore when partition fields are missing.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ignore_when_missing_partitions ObservabilityPipeline#ignore_when_missing_partitions}
        '''
        result = self._values.get("ignore_when_missing_partitions")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def overflow_action(self) -> typing.Optional[builtins.str]:
        '''The action to take when the quota is exceeded: ``drop``, ``no_action``, or ``overflow_routing``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#overflow_action ObservabilityPipeline#overflow_action}
        '''
        result = self._values.get("overflow_action")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def overrides(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsQuotaOverrides"]]]:
        '''overrides block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#overrides ObservabilityPipeline#overrides}
        '''
        result = self._values.get("overrides")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsQuotaOverrides"]]], result)

    @builtins.property
    def partition_fields(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of partition fields.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#partition_fields ObservabilityPipeline#partition_fields}
        '''
        result = self._values.get("partition_fields")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsQuota(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsQuotaLimit",
    jsii_struct_bases=[],
    name_mapping={"enforce": "enforce", "limit": "limit"},
)
class ObservabilityPipelineConfigProcessorsQuotaLimit:
    def __init__(self, *, enforce: builtins.str, limit: jsii.Number) -> None:
        '''
        :param enforce: Whether to enforce by 'bytes' or 'events'. Valid values are ``bytes``, ``events``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#enforce ObservabilityPipeline#enforce}
        :param limit: The daily quota limit. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#limit ObservabilityPipeline#limit}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4dee7801dfff0c689049c646a00b943dacfc5f5d1cf0d25fd8171ea137e5a92c)
            check_type(argname="argument enforce", value=enforce, expected_type=type_hints["enforce"])
            check_type(argname="argument limit", value=limit, expected_type=type_hints["limit"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enforce": enforce,
            "limit": limit,
        }

    @builtins.property
    def enforce(self) -> builtins.str:
        '''Whether to enforce by 'bytes' or 'events'. Valid values are ``bytes``, ``events``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#enforce ObservabilityPipeline#enforce}
        '''
        result = self._values.get("enforce")
        assert result is not None, "Required property 'enforce' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def limit(self) -> jsii.Number:
        '''The daily quota limit.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#limit ObservabilityPipeline#limit}
        '''
        result = self._values.get("limit")
        assert result is not None, "Required property 'limit' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsQuotaLimit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsQuotaLimitOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsQuotaLimitOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5b17504720e9a9aba6b5ffd55377336d8f9b8466f35881ccc4ac9fda6026afb)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enforceInput")
    def enforce_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "enforceInput"))

    @builtins.property
    @jsii.member(jsii_name="limitInput")
    def limit_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "limitInput"))

    @builtins.property
    @jsii.member(jsii_name="enforce")
    def enforce(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "enforce"))

    @enforce.setter
    def enforce(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3201f014125c53391931a31ce35962fd6c1c97d90607df04a7bf5e1b6d5af07)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enforce", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="limit")
    def limit(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "limit"))

    @limit.setter
    def limit(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94e1b1d63df48e410e445e20cb36d291c7d7c7a5dcb335d3b5c6a98e4fcf7e38)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "limit", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaLimit]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaLimit]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaLimit]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4621719119831a28bb2aa47948aa5f88f15611b4c7b6ffcffe890911bf41d5c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsQuotaList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsQuotaList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4d17f65ac9ee3ca300af5239532466d9db1d850d671ebbd8e41bda2786ae076)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsQuotaOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bbe2b944137feaace52bf3be20be8798915d780df121c1543eef5dd295f42d7)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsQuotaOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__101b1ce1e9839098a07300bc2ce7bebfe5a7240f16e2a00b03622c7edbe96246)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ef6464a2f099cacf91198b45d1b00fad70027cec877c5f4a201aff3090f747f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25d39c88b34c3eb33f39ae01cb2d1a8e363d02b63a27a74417a7c0a177fd4ada)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuota]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuota]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuota]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__905c6ef0338a922a29fc2d8a98b25863a9b0a593ab4d189e346f096246539436)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsQuotaOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsQuotaOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__65278396386c1d0e5d0de8ce2458c95887618e89ac7df63fbe77f500bd0f68e9)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putLimit")
    def put_limit(self, *, enforce: builtins.str, limit: jsii.Number) -> None:
        '''
        :param enforce: Whether to enforce by 'bytes' or 'events'. Valid values are ``bytes``, ``events``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#enforce ObservabilityPipeline#enforce}
        :param limit: The daily quota limit. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#limit ObservabilityPipeline#limit}
        '''
        value = ObservabilityPipelineConfigProcessorsQuotaLimit(
            enforce=enforce, limit=limit
        )

        return typing.cast(None, jsii.invoke(self, "putLimit", [value]))

    @jsii.member(jsii_name="putOverrides")
    def put_overrides(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsQuotaOverrides", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aaaa55c57f073a063c5b01815a6cef741559309c132ad4b7da6c494f7c5dce2e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putOverrides", [value]))

    @jsii.member(jsii_name="resetIgnoreWhenMissingPartitions")
    def reset_ignore_when_missing_partitions(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIgnoreWhenMissingPartitions", []))

    @jsii.member(jsii_name="resetOverflowAction")
    def reset_overflow_action(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOverflowAction", []))

    @jsii.member(jsii_name="resetOverrides")
    def reset_overrides(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOverrides", []))

    @jsii.member(jsii_name="resetPartitionFields")
    def reset_partition_fields(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPartitionFields", []))

    @builtins.property
    @jsii.member(jsii_name="limit")
    def limit(self) -> ObservabilityPipelineConfigProcessorsQuotaLimitOutputReference:
        return typing.cast(ObservabilityPipelineConfigProcessorsQuotaLimitOutputReference, jsii.get(self, "limit"))

    @builtins.property
    @jsii.member(jsii_name="overrides")
    def overrides(self) -> "ObservabilityPipelineConfigProcessorsQuotaOverridesList":
        return typing.cast("ObservabilityPipelineConfigProcessorsQuotaOverridesList", jsii.get(self, "overrides"))

    @builtins.property
    @jsii.member(jsii_name="dropEventsInput")
    def drop_events_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "dropEventsInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="ignoreWhenMissingPartitionsInput")
    def ignore_when_missing_partitions_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "ignoreWhenMissingPartitionsInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="limitInput")
    def limit_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaLimit]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaLimit]], jsii.get(self, "limitInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="overflowActionInput")
    def overflow_action_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "overflowActionInput"))

    @builtins.property
    @jsii.member(jsii_name="overridesInput")
    def overrides_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsQuotaOverrides"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsQuotaOverrides"]]], jsii.get(self, "overridesInput"))

    @builtins.property
    @jsii.member(jsii_name="partitionFieldsInput")
    def partition_fields_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "partitionFieldsInput"))

    @builtins.property
    @jsii.member(jsii_name="dropEvents")
    def drop_events(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "dropEvents"))

    @drop_events.setter
    def drop_events(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f856a1481decc7a1050ad61befa2c93c277a9f60068ba391e668b0d89127b4e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dropEvents", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5b45e3c5574ac8a83d9a1c66a08b80f9a562a79337cb2774c47f198065d4c76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="ignoreWhenMissingPartitions")
    def ignore_when_missing_partitions(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "ignoreWhenMissingPartitions"))

    @ignore_when_missing_partitions.setter
    def ignore_when_missing_partitions(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06f9ac205755d2ae845760a7a14ca154e2cccb2f2a7caaa93b824e9a3332e17b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ignoreWhenMissingPartitions", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d02040b0dc50e72121535dcc166552255db592c14e3180a9e8d1b60721d6aca5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41936c9125ec0231dc429630f3a9fd556ae9f9ea26b396df6b4b1b5f99a7f81a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a7f3582625d30e926c8810d38e4d3581c22ff753ca004764a67d4858f7bfe7f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="overflowAction")
    def overflow_action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "overflowAction"))

    @overflow_action.setter
    def overflow_action(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d998c911bdb8f887eed7cb90221957255f490a25e45ce97e0b90ed92a3c8d1d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "overflowAction", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="partitionFields")
    def partition_fields(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "partitionFields"))

    @partition_fields.setter
    def partition_fields(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__671fc1c9f0fad990ce74cf7b33b7d9a0d88f36234713306168c89ed3556c4a2f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "partitionFields", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuota]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuota]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuota]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aff3305ed3d6c1803c4760aa51654f59ed5896702f613e86e182df31d8264c4b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsQuotaOverrides",
    jsii_struct_bases=[],
    name_mapping={"limit": "limit", "field": "field"},
)
class ObservabilityPipelineConfigProcessorsQuotaOverrides:
    def __init__(
        self,
        *,
        limit: typing.Union["ObservabilityPipelineConfigProcessorsQuotaOverridesLimit", typing.Dict[builtins.str, typing.Any]],
        field: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsQuotaOverridesField", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param limit: limit block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#limit ObservabilityPipeline#limit}
        :param field: field block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        '''
        if isinstance(limit, dict):
            limit = ObservabilityPipelineConfigProcessorsQuotaOverridesLimit(**limit)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f355cc996fc24ac0f70943d038cd16164e8776d83c4df7c8490f4b7cfa55dbd)
            check_type(argname="argument limit", value=limit, expected_type=type_hints["limit"])
            check_type(argname="argument field", value=field, expected_type=type_hints["field"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "limit": limit,
        }
        if field is not None:
            self._values["field"] = field

    @builtins.property
    def limit(self) -> "ObservabilityPipelineConfigProcessorsQuotaOverridesLimit":
        '''limit block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#limit ObservabilityPipeline#limit}
        '''
        result = self._values.get("limit")
        assert result is not None, "Required property 'limit' is missing"
        return typing.cast("ObservabilityPipelineConfigProcessorsQuotaOverridesLimit", result)

    @builtins.property
    def field(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsQuotaOverridesField"]]]:
        '''field block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        '''
        result = self._values.get("field")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsQuotaOverridesField"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsQuotaOverrides(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsQuotaOverridesField",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class ObservabilityPipelineConfigProcessorsQuotaOverridesField:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: The field name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        :param value: The field value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#value ObservabilityPipeline#value}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61af1950a287739bfec7ec9421099d1bbc57cdef0e3c27c130c0a7a74fd65445)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''The field name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''The field value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#value ObservabilityPipeline#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsQuotaOverridesField(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsQuotaOverridesFieldList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsQuotaOverridesFieldList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4f51342eb87a9e4827f8b019528d3f6a8827da5012805de5303ca8cf27f06d2)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsQuotaOverridesFieldOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f27647872608485317446c5739734da21bb451fd11d0329a118bc86cbbb6ebee)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsQuotaOverridesFieldOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6b30fced8be5916b435880ba13b6ee2cc9c52d016954b3e070bed031a061e5f8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a4d81c28d339208b5d5d536fd559e117876d8d1aebbcc0ef0490f8ac7ef0304)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0b8f1938e2b00e9e6a77fc265b4b2c29f9026109383a5465f8fcab02bcf1721)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuotaOverridesField]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuotaOverridesField]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuotaOverridesField]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__054ca0043f4cd4b80791b26e44442a1fcc3e134e48c8c95e6bcd662819e73f57)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsQuotaOverridesFieldOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsQuotaOverridesFieldOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0d270a7dbd38bade2e82948257ebe1e533608b04624718e3321fb5899b11f3c9)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3fc6cf54d93d2bca2ff30853ff466e3ff2c497c3d060f62411b9347d22b4ccdf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f6c2541a7d9e4166f1c0b10708999ae1cd6b1515be8fe1a29658fd061aece745)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverridesField]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverridesField]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverridesField]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c61c388fd54d61cfa357e682b66b11a7ba6da2cfa3b25155bf425aa8106982e5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsQuotaOverridesLimit",
    jsii_struct_bases=[],
    name_mapping={"enforce": "enforce", "limit": "limit"},
)
class ObservabilityPipelineConfigProcessorsQuotaOverridesLimit:
    def __init__(self, *, enforce: builtins.str, limit: jsii.Number) -> None:
        '''
        :param enforce: Whether to enforce by 'bytes' or 'events'. Valid values are ``bytes``, ``events``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#enforce ObservabilityPipeline#enforce}
        :param limit: The daily quota limit. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#limit ObservabilityPipeline#limit}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db902c552d2bb6c42a48a64cc7557124218afbe8c1029eed7d25000136534b5a)
            check_type(argname="argument enforce", value=enforce, expected_type=type_hints["enforce"])
            check_type(argname="argument limit", value=limit, expected_type=type_hints["limit"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enforce": enforce,
            "limit": limit,
        }

    @builtins.property
    def enforce(self) -> builtins.str:
        '''Whether to enforce by 'bytes' or 'events'. Valid values are ``bytes``, ``events``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#enforce ObservabilityPipeline#enforce}
        '''
        result = self._values.get("enforce")
        assert result is not None, "Required property 'enforce' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def limit(self) -> jsii.Number:
        '''The daily quota limit.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#limit ObservabilityPipeline#limit}
        '''
        result = self._values.get("limit")
        assert result is not None, "Required property 'limit' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsQuotaOverridesLimit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsQuotaOverridesLimitOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsQuotaOverridesLimitOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cdfef76d784d00db4e3119037c0502459a82ec9f52e19e47eb8c27852027cafa)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enforceInput")
    def enforce_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "enforceInput"))

    @builtins.property
    @jsii.member(jsii_name="limitInput")
    def limit_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "limitInput"))

    @builtins.property
    @jsii.member(jsii_name="enforce")
    def enforce(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "enforce"))

    @enforce.setter
    def enforce(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14912c8194113e79c47573f65d75953a679c0a5b7b94988b767dba8676f4ee98)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enforce", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="limit")
    def limit(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "limit"))

    @limit.setter
    def limit(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbd539f8dd64bf8219e2d64702fbc7c388f087038f6aeb3cd4f65eee181fe64f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "limit", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverridesLimit]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverridesLimit]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverridesLimit]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c6aa3362248080f4f1632035003759e899a175cbd9db87e89553ea9d9af5e75)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsQuotaOverridesList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsQuotaOverridesList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a446a772f8343643efac3f7195c111a4f49d922bd14a05eb5393244f26d68891)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsQuotaOverridesOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c18915bda1c7a71a74d1c81c0a2b97d1a35098b3645be1d155a708e3025de4da)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsQuotaOverridesOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__192c5871f4a8dbcb2b8fac1841a041d7035e8222d19564222628518e5fa185d0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e6a8a01548a5b26af9de1bb871fbc04b64c4e4e5b52fd4901d4db76b9ee944f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__112cc713991a24aaf2158c6965a522d5710d8ca4f0975cdb363e90a85c6bc3c8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuotaOverrides]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuotaOverrides]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuotaOverrides]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1964890f3bd2ad429c73e8406634a886b155ec5f8d594e2dc334ad8786a44925)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsQuotaOverridesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsQuotaOverridesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fbaf9a09e95886f06779c71b9306242b7a5e36d8dbf6b8ebae10bba60a7d7090)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putField")
    def put_field(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsQuotaOverridesField, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9d68a821dadde6c38c7c1199d162a1e928d08c3a567be15e96fa74284664778)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putField", [value]))

    @jsii.member(jsii_name="putLimit")
    def put_limit(self, *, enforce: builtins.str, limit: jsii.Number) -> None:
        '''
        :param enforce: Whether to enforce by 'bytes' or 'events'. Valid values are ``bytes``, ``events``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#enforce ObservabilityPipeline#enforce}
        :param limit: The daily quota limit. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#limit ObservabilityPipeline#limit}
        '''
        value = ObservabilityPipelineConfigProcessorsQuotaOverridesLimit(
            enforce=enforce, limit=limit
        )

        return typing.cast(None, jsii.invoke(self, "putLimit", [value]))

    @jsii.member(jsii_name="resetField")
    def reset_field(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetField", []))

    @builtins.property
    @jsii.member(jsii_name="field")
    def field(self) -> ObservabilityPipelineConfigProcessorsQuotaOverridesFieldList:
        return typing.cast(ObservabilityPipelineConfigProcessorsQuotaOverridesFieldList, jsii.get(self, "field"))

    @builtins.property
    @jsii.member(jsii_name="limit")
    def limit(
        self,
    ) -> ObservabilityPipelineConfigProcessorsQuotaOverridesLimitOutputReference:
        return typing.cast(ObservabilityPipelineConfigProcessorsQuotaOverridesLimitOutputReference, jsii.get(self, "limit"))

    @builtins.property
    @jsii.member(jsii_name="fieldInput")
    def field_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuotaOverridesField]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuotaOverridesField]]], jsii.get(self, "fieldInput"))

    @builtins.property
    @jsii.member(jsii_name="limitInput")
    def limit_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverridesLimit]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverridesLimit]], jsii.get(self, "limitInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverrides]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverrides]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverrides]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e37887fc23e3b304e78591dc2f7db64c3a1cde339f54511478bb8385ffca07a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsReduce",
    jsii_struct_bases=[],
    name_mapping={
        "group_by": "groupBy",
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "merge_strategies": "mergeStrategies",
    },
)
class ObservabilityPipelineConfigProcessorsReduce:
    def __init__(
        self,
        *,
        group_by: typing.Sequence[builtins.str],
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        merge_strategies: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsReduceMergeStrategies", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param group_by: A list of fields used to group log events for merging. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#group_by ObservabilityPipeline#group_by}
        :param id: The unique identifier for this processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: A list of component IDs whose output is used as the input for this processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param merge_strategies: merge_strategies block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#merge_strategies ObservabilityPipeline#merge_strategies}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d548294b48662fe7eb9a256753fb8b147d19c4eb1ca60fb3eb5c10eb88b05a81)
            check_type(argname="argument group_by", value=group_by, expected_type=type_hints["group_by"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument merge_strategies", value=merge_strategies, expected_type=type_hints["merge_strategies"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "group_by": group_by,
            "id": id,
            "include": include,
            "inputs": inputs,
        }
        if merge_strategies is not None:
            self._values["merge_strategies"] = merge_strategies

    @builtins.property
    def group_by(self) -> typing.List[builtins.str]:
        '''A list of fields used to group log events for merging.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#group_by ObservabilityPipeline#group_by}
        '''
        result = self._values.get("group_by")
        assert result is not None, "Required property 'group_by' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the input for this processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def merge_strategies(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsReduceMergeStrategies"]]]:
        '''merge_strategies block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#merge_strategies ObservabilityPipeline#merge_strategies}
        '''
        result = self._values.get("merge_strategies")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsReduceMergeStrategies"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsReduce(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsReduceList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsReduceList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97e22af6fe92079dc2f51cdad37742e06b9e426cdee0a835cf1ac92132f3933a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsReduceOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2cc28cfa5ac4b9e7f63f280cd6c5f6260dfb23b333cf4e9fb3feba2ccfb4768c)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsReduceOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97c9cca6df26b31fa6cc5a6c25365305036c41a85e483bb799367ecc5a1c2e08)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__003155d363318c7f4c2a4996344fed2c7464f50ee7d66f81382b2418b146417d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8bf3f4a1eb5c8dd64f5a3847cc803b68e7b114233613fe115f7f509b9a3cc99)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsReduce]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsReduce]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsReduce]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45a5921ada25b692bbea4e39064297d03901bbb6343ae82be8185c4eb8873833)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsReduceMergeStrategies",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "strategy": "strategy"},
)
class ObservabilityPipelineConfigProcessorsReduceMergeStrategies:
    def __init__(self, *, path: builtins.str, strategy: builtins.str) -> None:
        '''
        :param path: The field path in the log event. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#path ObservabilityPipeline#path}
        :param strategy: The merge strategy to apply. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#strategy ObservabilityPipeline#strategy}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__56be14925a8573b25db3bcc64ba1f8cf8e80ec52914d801e089be4c49b15c4dd)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument strategy", value=strategy, expected_type=type_hints["strategy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "strategy": strategy,
        }

    @builtins.property
    def path(self) -> builtins.str:
        '''The field path in the log event.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#path ObservabilityPipeline#path}
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def strategy(self) -> builtins.str:
        '''The merge strategy to apply.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#strategy ObservabilityPipeline#strategy}
        '''
        result = self._values.get("strategy")
        assert result is not None, "Required property 'strategy' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsReduceMergeStrategies(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsReduceMergeStrategiesList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsReduceMergeStrategiesList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f801179ebf2b28746a65158a561a55c0232014f4dd74b435eb54095ac3d03ad)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsReduceMergeStrategiesOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__76a8ed9987509fb1ac0a324a9aafc08a274f4913fd877c06b25d5a45703a2fba)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsReduceMergeStrategiesOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6de03841d1a5ddfa0a39cfc4d51c048ae300069311cee3c976e0397202cc3f94)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__451498f1f529506e0d15f0ef0a7c39570accbfb684b3935fdd0e9e419f41934a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__405c95b55cdc3067b479f7188fedf119a29660bc529bb01c175f0945cb3bfe29)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsReduceMergeStrategies]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsReduceMergeStrategies]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsReduceMergeStrategies]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce06f180833be082f72e5855acfd2275953fbd57a9eb98f8686d0423af66b3f1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsReduceMergeStrategiesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsReduceMergeStrategiesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3a774aebcc6cbbc99ffb8d08ee48597b8c455983293d3a4b734d73292eef000)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="strategyInput")
    def strategy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "strategyInput"))

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20874e73504a8f9d1ff61ce1406d835d0c0058def6d0c68b3c0a371fefdbc3f5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "path", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def strategy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "strategy"))

    @strategy.setter
    def strategy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f5b63ce90be8b80dab89537ffde01dd97be504130e327c98ece6aaa9a30598a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "strategy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsReduceMergeStrategies]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsReduceMergeStrategies]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsReduceMergeStrategies]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__31d5870d27377b5e06663fcbb157e8397a65f7a92de6512147410a84cef5aeb0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsReduceOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsReduceOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c56210c3a985837e58860f7084802ad6ae2745406c983e4de404579f655cc1c5)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putMergeStrategies")
    def put_merge_strategies(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsReduceMergeStrategies, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__55c5bac94dedeea10cd35d810f8f905ee5a9fdbda925a1523298e53407f4cf82)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putMergeStrategies", [value]))

    @jsii.member(jsii_name="resetMergeStrategies")
    def reset_merge_strategies(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMergeStrategies", []))

    @builtins.property
    @jsii.member(jsii_name="mergeStrategies")
    def merge_strategies(
        self,
    ) -> ObservabilityPipelineConfigProcessorsReduceMergeStrategiesList:
        return typing.cast(ObservabilityPipelineConfigProcessorsReduceMergeStrategiesList, jsii.get(self, "mergeStrategies"))

    @builtins.property
    @jsii.member(jsii_name="groupByInput")
    def group_by_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "groupByInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="mergeStrategiesInput")
    def merge_strategies_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsReduceMergeStrategies]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsReduceMergeStrategies]]], jsii.get(self, "mergeStrategiesInput"))

    @builtins.property
    @jsii.member(jsii_name="groupBy")
    def group_by(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "groupBy"))

    @group_by.setter
    def group_by(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e219ff4bfc7f4aba00e563805a47efc4c0056218171cc0bb3d685d776a52ae2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "groupBy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7d7f817ef5f1eb137c6272f3ceec0e8b9e51b613bad8aaf6f2fbfd02335b416)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b846a44c7591cacf09ebe9012dab762c8166dea83430daba81b8f6ef82e979d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6fb8e38adb6cced3e4672e8fa0bf2f1fddaa33f5a9c1b7051ea6b70ae56a700e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsReduce]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsReduce]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsReduce]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be41ba998fb981def1e0778fc8b5f0039ed7bc35ecf60ec70fc0a4f1fd3d9a35)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsRemoveFields",
    jsii_struct_bases=[],
    name_mapping={
        "fields": "fields",
        "id": "id",
        "include": "include",
        "inputs": "inputs",
    },
)
class ObservabilityPipelineConfigProcessorsRemoveFields:
    def __init__(
        self,
        *,
        fields: typing.Sequence[builtins.str],
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param fields: List of fields to remove from the events. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fields ObservabilityPipeline#fields}
        :param id: The unique ID of the processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: The inputs for the processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06ad0615220b708f5abd61c8dab0dd9d0cdfb6e0874ae9521118b49a257692b2)
            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "fields": fields,
            "id": id,
            "include": include,
            "inputs": inputs,
        }

    @builtins.property
    def fields(self) -> typing.List[builtins.str]:
        '''List of fields to remove from the events.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fields ObservabilityPipeline#fields}
        '''
        result = self._values.get("fields")
        assert result is not None, "Required property 'fields' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique ID of the processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''The inputs for the processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsRemoveFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsRemoveFieldsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsRemoveFieldsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c9c809131c784a41ae29a2d766ebda16c163c0b7feb171eba5c97cc12121766)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsRemoveFieldsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9149b01001eb8fe263e4df9315582a9dfcf0df249eeeccf18cee0de5252d23e0)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsRemoveFieldsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__abe77409dc99b706a81cbac3d4ed98c698f65156c8efa21af48f75587707bccb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__324126a382f2f00328955a132b1fe2b0c3daf599a4c43162f2ad44e628ed45e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__979329cb1543b875992406ffdd426a21ca8cc88d89455dc877aea05cdcc5af52)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRemoveFields]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRemoveFields]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRemoveFields]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cd3955f8117db0a8794a05752120835d2e9cc2703d70e0992234ca43ef819d07)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsRemoveFieldsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsRemoveFieldsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a9453a2b8752cb825e8b31f5efd74958ab3ee731e8b7bdb8a3271c0bb457c77)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="fieldsInput")
    def fields_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "fieldsInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="fields")
    def fields(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "fields"))

    @fields.setter
    def fields(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7fb29adbddcd093bfec79a72d38771fe2434fbd3264564cd3fa4e76d7ca9d1e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "fields", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51a0a016fe05a3a01691e1a37dd24e28feb798e1b7a102d82c0e359cd9f4738d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fcba0db3dd4c734e744e26dc27fa70580933bcf7c6b505c8c932f77b58acbf25)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d9b0bf65b46fdaa8b15f47d643b1e5366af4f8d44af9bf1683ad9cd45da59ac)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsRemoveFields]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsRemoveFields]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsRemoveFields]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf9c33a4bd1916d0cdab24f0fe988152237f66152841a3f13dfc125795983844)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsRenameFields",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "field": "field",
    },
)
class ObservabilityPipelineConfigProcessorsRenameFields:
    def __init__(
        self,
        *,
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        field: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsRenameFieldsField", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param id: The unique ID of the processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: The inputs for the processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param field: field block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__849fb1f97819bfd610bcc90a4fa3cfbf8c464ffe831b9a07fcd7438516b944b1)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument field", value=field, expected_type=type_hints["field"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "include": include,
            "inputs": inputs,
        }
        if field is not None:
            self._values["field"] = field

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique ID of the processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''The inputs for the processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def field(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsRenameFieldsField"]]]:
        '''field block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#field ObservabilityPipeline#field}
        '''
        result = self._values.get("field")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsRenameFieldsField"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsRenameFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsRenameFieldsField",
    jsii_struct_bases=[],
    name_mapping={
        "destination": "destination",
        "preserve_source": "preserveSource",
        "source": "source",
    },
)
class ObservabilityPipelineConfigProcessorsRenameFieldsField:
    def __init__(
        self,
        *,
        destination: builtins.str,
        preserve_source: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        source: builtins.str,
    ) -> None:
        '''
        :param destination: Destination field name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#destination ObservabilityPipeline#destination}
        :param preserve_source: Whether to keep the original field. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#preserve_source ObservabilityPipeline#preserve_source}
        :param source: Source field to rename. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#source ObservabilityPipeline#source}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec911e68d925c617fd922cac083783e7833f677602ebb88e4c94bd7456820924)
            check_type(argname="argument destination", value=destination, expected_type=type_hints["destination"])
            check_type(argname="argument preserve_source", value=preserve_source, expected_type=type_hints["preserve_source"])
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "destination": destination,
            "preserve_source": preserve_source,
            "source": source,
        }

    @builtins.property
    def destination(self) -> builtins.str:
        '''Destination field name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#destination ObservabilityPipeline#destination}
        '''
        result = self._values.get("destination")
        assert result is not None, "Required property 'destination' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def preserve_source(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether to keep the original field.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#preserve_source ObservabilityPipeline#preserve_source}
        '''
        result = self._values.get("preserve_source")
        assert result is not None, "Required property 'preserve_source' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def source(self) -> builtins.str:
        '''Source field to rename.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#source ObservabilityPipeline#source}
        '''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsRenameFieldsField(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsRenameFieldsFieldList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsRenameFieldsFieldList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f15a43aca17468511a91f7c39e21032e56e79c6d30dda0e206d7aff61143181c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsRenameFieldsFieldOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__431847aad0aefd13c0b38390d4ad971c3560f522579ab98cc3b930d20b3ccf34)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsRenameFieldsFieldOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__09c4018382829499e17e0992b70b9ccd4008da22fe564b97ddbd12b5c88a5462)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__444d0b6aca6078ecfd9bb23385d581289243fd1c04ef7b0b159377f9227c9885)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__53d57fb6f2a3439cbfeff088df8fcfa6faed091d21f77060c6f12d6081df94b1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRenameFieldsField]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRenameFieldsField]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRenameFieldsField]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7984c0f51418aea142e787b5d5b72c7c4d094d389d6463b6c6c3c97b9f061b7a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsRenameFieldsFieldOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsRenameFieldsFieldOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe2bb864112d4f75fb9c5f8d23d1fd4fe94b46d118b72387dcc1aed6ff2a3eed)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="destinationInput")
    def destination_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "destinationInput"))

    @builtins.property
    @jsii.member(jsii_name="preserveSourceInput")
    def preserve_source_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "preserveSourceInput"))

    @builtins.property
    @jsii.member(jsii_name="sourceInput")
    def source_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceInput"))

    @builtins.property
    @jsii.member(jsii_name="destination")
    def destination(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "destination"))

    @destination.setter
    def destination(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b11f18a0d13e6d6e72364b0a20d6a92cba117f5804c1b24bb65867bb0d13630f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "destination", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="preserveSource")
    def preserve_source(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "preserveSource"))

    @preserve_source.setter
    def preserve_source(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c91df38a150972186b05915d4cbd99f279d37fb5d744c53231d3a1ca7350f6f5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "preserveSource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="source")
    def source(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "source"))

    @source.setter
    def source(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1c4b56ca879139b1345e317a4445b72f804c699f63c6efcd01138988887c2dd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "source", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsRenameFieldsField]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsRenameFieldsField]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsRenameFieldsField]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85975616e971682b360160bd6e110e9fa12333cb2d27540dfd91b1e0e3184099)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsRenameFieldsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsRenameFieldsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6672b12f2f5f04ed1ca63131aea669371ee240d74cd979a337a832c5272a152)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsRenameFieldsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94d356b9b6ca82fd1bf51bf9ece912c324be80ea8b302a800878dd345707bbd9)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsRenameFieldsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e39459a1c3d47277662c879c209ffaa31cac044c28ced771478783eb9db5408e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a84fa510e4257af026383cf992cd13cc365488a6b418e348b2c4669614786e2d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52d9a68e33e2b04cc594f6a34e998c5c77581d41f87cf072182b48582b42c480)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRenameFields]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRenameFields]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRenameFields]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6432e01b8081b3bbea81e403e201b33d00fb9ad2096cdad7d375410ba1f3376b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsRenameFieldsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsRenameFieldsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45aa7c1efbb0e78d154b976ce58edea1332ca80237a6ea736fcf9a57b9f55de8)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putField")
    def put_field(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsRenameFieldsField, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1fe62e2a071ceafd68f4a36aab2f942636673b3cc7e39c430b7b26f564a9021)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putField", [value]))

    @jsii.member(jsii_name="resetField")
    def reset_field(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetField", []))

    @builtins.property
    @jsii.member(jsii_name="field")
    def field(self) -> ObservabilityPipelineConfigProcessorsRenameFieldsFieldList:
        return typing.cast(ObservabilityPipelineConfigProcessorsRenameFieldsFieldList, jsii.get(self, "field"))

    @builtins.property
    @jsii.member(jsii_name="fieldInput")
    def field_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRenameFieldsField]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRenameFieldsField]]], jsii.get(self, "fieldInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__615f64cb9c2152ec249b81444b6a638c302a8a17016bdba5b2757fe2ba1189b0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__58476176361adeafef7afba54f462ddb1281e79233dbc5ea35f6bb795e9c3053)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b48fbf7f172310e68c602a7aaef870db514d47e0a9eee6401dc6b5a0d843801d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsRenameFields]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsRenameFields]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsRenameFields]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5e08dae1e73188f72f20016a6682a8ef48c65d986bccc30f8b0a5a269f0faa4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSample",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "percentage": "percentage",
        "rate": "rate",
    },
)
class ObservabilityPipelineConfigProcessorsSample:
    def __init__(
        self,
        *,
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        percentage: typing.Optional[jsii.Number] = None,
        rate: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (for example, as the ``input`` to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param percentage: The percentage of logs to sample. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#percentage ObservabilityPipeline#percentage}
        :param rate: Number of events to sample (1 in N). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rate ObservabilityPipeline#rate}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e47bfcb2b2ad30217375e55a95ed0be92f4887628a09813a7ef1034c49661870)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument percentage", value=percentage, expected_type=type_hints["percentage"])
            check_type(argname="argument rate", value=rate, expected_type=type_hints["rate"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "include": include,
            "inputs": inputs,
        }
        if percentage is not None:
            self._values["percentage"] = percentage
        if rate is not None:
            self._values["rate"] = rate

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (for example, as the ``input`` to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def percentage(self) -> typing.Optional[jsii.Number]:
        '''The percentage of logs to sample.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#percentage ObservabilityPipeline#percentage}
        '''
        result = self._values.get("percentage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def rate(self) -> typing.Optional[jsii.Number]:
        '''Number of events to sample (1 in N).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rate ObservabilityPipeline#rate}
        '''
        result = self._values.get("rate")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSample(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsSampleList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSampleList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b81392cc42bf0211a3affff5c9fe8d06c0f0b0b9ec1a83d39528c63e131e039a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsSampleOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f4e87bb47afd7f492a99813add8ea6b8b12a8f718bc762145b8d7f6af13fdcf)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsSampleOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a2e10edae8edbc721bee3ab26b350db31c1c0332c9a21c9033ebed832647d2c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e769294d49c414867d97dbaa99a011b94a1bb04ebc239836054ad5acc5b148fe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d943360ebb1dc86319b983d7b3676f8d4fa8c128207e50434cfa54e6266257c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsSample]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsSample]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsSample]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e7abe6fe2e45af9f2dc7846154becd11a2c301cf540f233f2d7941d21d5be2b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsSampleOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSampleOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50609ff18a20eaf9fcfe2c7c21dbf2cf7ce743fe08be1de8db9a5a2bc3997b82)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetPercentage")
    def reset_percentage(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPercentage", []))

    @jsii.member(jsii_name="resetRate")
    def reset_rate(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRate", []))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="percentageInput")
    def percentage_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "percentageInput"))

    @builtins.property
    @jsii.member(jsii_name="rateInput")
    def rate_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "rateInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33fd9391c07dc71ca3b37d709862aee9a192fa7ac9c2663dc0fd7fd0c8bd065b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1a9a20e2407fb94278471e3067d3478275f897a82540839e8d7475265662e96)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44b5d50c4ac24d6b1380fd7a02495de8873d23c4aaef59753eb906e03523b705)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="percentage")
    def percentage(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "percentage"))

    @percentage.setter
    def percentage(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1425f61925621ea8c6793dc82bf676347cc2ae7c20ba093328cd64254bdd289)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "percentage", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="rate")
    def rate(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "rate"))

    @rate.setter
    def rate(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9a7947575c582beeba993c0ef9f60b0717204515e916d7b572e08ba3ab31d79)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "rate", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSample]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSample]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSample]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__edf1f5bb1d7d83b4e4a227c4a2cde9ef6307b02bde8765ce02c6af84f10c7754)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScanner",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "rules": "rules",
    },
)
class ObservabilityPipelineConfigProcessorsSensitiveDataScanner:
    def __init__(
        self,
        *,
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        rules: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (e.g., as input to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: A list of component IDs whose output is used as the ``input`` for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param rules: rules block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rules ObservabilityPipeline#rules}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d45b8b23acdb8b7a6cc62ab6b9f0c12f05ba831f0c6296f56332444a4fb3699d)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument rules", value=rules, expected_type=type_hints["rules"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "include": include,
            "inputs": inputs,
        }
        if rules is not None:
            self._values["rules"] = rules

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (e.g., as input to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the ``input`` for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def rules(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules"]]]:
        '''rules block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rules ObservabilityPipeline#rules}
        '''
        result = self._values.get("rules")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSensitiveDataScanner(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08b968c47fc1e321c06a72ff604b38a3965334bfe74e8f637dd91bf27ca52cb4)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsSensitiveDataScannerOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87e7b813bba84a34a431a0ec8a57879995dbf041706fdbe4aafb69ddb3638803)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsSensitiveDataScannerOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d752732aa562f4f9c2de0ab032d312961d078c97892e3572ed89ca300712fcff)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c2f31a1ae0a1e6500b092ab7b9a46ea3f75f833e59f3118409535d41a4a5ee2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d9fd8afc32fa5d6ba0ed00fe2a3266f7a141f45a08ef1c413af4ba612181db5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsSensitiveDataScanner]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsSensitiveDataScanner]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsSensitiveDataScanner]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f00b7678f7837de433d01cfb8e57d0dac917f5c534c0ee86885a534b717b8d1b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05b5b7bdabefe9ee2e54cea3e9ead640a1d3800dc81d23c8c68bfd0628f02b5c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putRules")
    def put_rules(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41f9999e5422d1b570688f8203726674557194d9c066156c6d38282a59ad6b21)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putRules", [value]))

    @jsii.member(jsii_name="resetRules")
    def reset_rules(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRules", []))

    @builtins.property
    @jsii.member(jsii_name="rules")
    def rules(
        self,
    ) -> "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesList":
        return typing.cast("ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesList", jsii.get(self, "rules"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="rulesInput")
    def rules_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules"]]], jsii.get(self, "rulesInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dfe707d802883d77e6dd319a4639951e4f6fcb07eb05b5a392241fff1735d1f4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3168311236b95374c99ca27a10183c0c39ada353bde286ced9c29c1737b2d054)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f269588a9f9550fc50b65d7733855ed90ccba82844dc24dfddfd7724b1638e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScanner]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScanner]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScanner]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed152f6a8070c6bf4f4f6526a0c847c4c33bca163d5818fc6225a26d03c7f14f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules",
    jsii_struct_bases=[],
    name_mapping={
        "keyword_options": "keywordOptions",
        "name": "name",
        "on_match": "onMatch",
        "pattern": "pattern",
        "scope": "scope",
        "tags": "tags",
    },
)
class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules:
    def __init__(
        self,
        *,
        keyword_options: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions", typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        on_match: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch", typing.Dict[builtins.str, typing.Any]]] = None,
        pattern: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern", typing.Dict[builtins.str, typing.Any]]] = None,
        scope: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope", typing.Dict[builtins.str, typing.Any]]] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param keyword_options: keyword_options block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#keyword_options ObservabilityPipeline#keyword_options}
        :param name: A name identifying the rule. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        :param on_match: on_match block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#on_match ObservabilityPipeline#on_match}
        :param pattern: pattern block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#pattern ObservabilityPipeline#pattern}
        :param scope: scope block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#scope ObservabilityPipeline#scope}
        :param tags: Tags assigned to this rule for filtering and classification. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tags ObservabilityPipeline#tags}
        '''
        if isinstance(keyword_options, dict):
            keyword_options = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions(**keyword_options)
        if isinstance(on_match, dict):
            on_match = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch(**on_match)
        if isinstance(pattern, dict):
            pattern = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern(**pattern)
        if isinstance(scope, dict):
            scope = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope(**scope)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab30b1591e168a1b4cadbb33861d1efa228d55d8f8377015c2a825b1cb0d3217)
            check_type(argname="argument keyword_options", value=keyword_options, expected_type=type_hints["keyword_options"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument on_match", value=on_match, expected_type=type_hints["on_match"])
            check_type(argname="argument pattern", value=pattern, expected_type=type_hints["pattern"])
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if keyword_options is not None:
            self._values["keyword_options"] = keyword_options
        if name is not None:
            self._values["name"] = name
        if on_match is not None:
            self._values["on_match"] = on_match
        if pattern is not None:
            self._values["pattern"] = pattern
        if scope is not None:
            self._values["scope"] = scope
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def keyword_options(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions"]:
        '''keyword_options block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#keyword_options ObservabilityPipeline#keyword_options}
        '''
        result = self._values.get("keyword_options")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions"], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''A name identifying the rule.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def on_match(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch"]:
        '''on_match block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#on_match ObservabilityPipeline#on_match}
        '''
        result = self._values.get("on_match")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch"], result)

    @builtins.property
    def pattern(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern"]:
        '''pattern block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#pattern ObservabilityPipeline#pattern}
        '''
        result = self._values.get("pattern")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern"], result)

    @builtins.property
    def scope(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope"]:
        '''scope block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#scope ObservabilityPipeline#scope}
        '''
        result = self._values.get("scope")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope"], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Tags assigned to this rule for filtering and classification.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tags ObservabilityPipeline#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions",
    jsii_struct_bases=[],
    name_mapping={"keywords": "keywords", "proximity": "proximity"},
)
class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions:
    def __init__(
        self,
        *,
        keywords: typing.Optional[typing.Sequence[builtins.str]] = None,
        proximity: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param keywords: A list of keywords to match near the sensitive pattern. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#keywords ObservabilityPipeline#keywords}
        :param proximity: Maximum number of tokens between a keyword and a sensitive value match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#proximity ObservabilityPipeline#proximity}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__abe24d056ca29c36e100e2e15143c9358ec34bf6b024769a30b306b0eaaaa467)
            check_type(argname="argument keywords", value=keywords, expected_type=type_hints["keywords"])
            check_type(argname="argument proximity", value=proximity, expected_type=type_hints["proximity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if keywords is not None:
            self._values["keywords"] = keywords
        if proximity is not None:
            self._values["proximity"] = proximity

    @builtins.property
    def keywords(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of keywords to match near the sensitive pattern.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#keywords ObservabilityPipeline#keywords}
        '''
        result = self._values.get("keywords")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def proximity(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of tokens between a keyword and a sensitive value match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#proximity ObservabilityPipeline#proximity}
        '''
        result = self._values.get("proximity")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__942c0173ef1cb852e34db26880744b74adec4a58c4eb4486b5e8f17e849160d4)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetKeywords")
    def reset_keywords(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeywords", []))

    @jsii.member(jsii_name="resetProximity")
    def reset_proximity(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProximity", []))

    @builtins.property
    @jsii.member(jsii_name="keywordsInput")
    def keywords_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "keywordsInput"))

    @builtins.property
    @jsii.member(jsii_name="proximityInput")
    def proximity_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "proximityInput"))

    @builtins.property
    @jsii.member(jsii_name="keywords")
    def keywords(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "keywords"))

    @keywords.setter
    def keywords(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7183e458565fe2a3c7a04474c06d9ad46ca1faade43b857c26e1b72d32ceb3c1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keywords", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="proximity")
    def proximity(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "proximity"))

    @proximity.setter
    def proximity(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7cec22abc39603aad7b9a552c7f7c3265ff03ff1bfba6fc2f7fbbf1d0e41634)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "proximity", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__07d94108c670770b163485d030733d40ca8d5b7e1cbe385943bd6ff924c79378)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9259e53bb6041549096ee9420ca976b86f7cc3e825de83f4fef8ebc044fc53d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f8f52970aebf4b1b330f6d993dde3639b27fbf77972799ef467256d8ffeb9248)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d818fe436cb1c08eac2db07d1a71becd12b7e07106543aa36abcd082f68fb40)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e6dc42c747416e4646d4b300bacff58c384bd24fdeda907ea7448aafe11bfad)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c26f552bb1c208c10c59ce53041c459a925ed5939b12dfd6ddc1bbe8f0f6e1c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61f6f2a637bd07674c0e0d441d658fb6e860a506ef2c90baf3f62298da20a781)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch",
    jsii_struct_bases=[],
    name_mapping={
        "hash": "hash",
        "partial_redact": "partialRedact",
        "redact": "redact",
    },
)
class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch:
    def __init__(
        self,
        *,
        hash: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash", typing.Dict[builtins.str, typing.Any]]] = None,
        partial_redact: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact", typing.Dict[builtins.str, typing.Any]]] = None,
        redact: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param hash: hash block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#hash ObservabilityPipeline#hash}
        :param partial_redact: partial_redact block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#partial_redact ObservabilityPipeline#partial_redact}
        :param redact: redact block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#redact ObservabilityPipeline#redact}
        '''
        if isinstance(hash, dict):
            hash = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash(**hash)
        if isinstance(partial_redact, dict):
            partial_redact = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact(**partial_redact)
        if isinstance(redact, dict):
            redact = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact(**redact)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__750e4314819aa924957f686f8a121c8011416b84e71466a82d256ba48f8e45bb)
            check_type(argname="argument hash", value=hash, expected_type=type_hints["hash"])
            check_type(argname="argument partial_redact", value=partial_redact, expected_type=type_hints["partial_redact"])
            check_type(argname="argument redact", value=redact, expected_type=type_hints["redact"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if hash is not None:
            self._values["hash"] = hash
        if partial_redact is not None:
            self._values["partial_redact"] = partial_redact
        if redact is not None:
            self._values["redact"] = redact

    @builtins.property
    def hash(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash"]:
        '''hash block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#hash ObservabilityPipeline#hash}
        '''
        result = self._values.get("hash")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash"], result)

    @builtins.property
    def partial_redact(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact"]:
        '''partial_redact block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#partial_redact ObservabilityPipeline#partial_redact}
        '''
        result = self._values.get("partial_redact")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact"], result)

    @builtins.property
    def redact(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact"]:
        '''redact block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#redact ObservabilityPipeline#redact}
        '''
        result = self._values.get("redact")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash",
    jsii_struct_bases=[],
    name_mapping={},
)
class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash:
    def __init__(self) -> None:
        self._values: typing.Dict[builtins.str, typing.Any] = {}

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHashOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHashOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e24b267c5a7f169aad2a70896dd39ec877d0834b1fda87f09eb199729d820301)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2feda08d85142e14600a06e5a4e8841771ade7e38896fa0ad73425750a41f015)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a21a9e4591790308b3e7b314789d905601d8ab7ee3c25b7813bf7bfb88d37b98)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putHash")
    def put_hash(self) -> None:
        value = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash()

        return typing.cast(None, jsii.invoke(self, "putHash", [value]))

    @jsii.member(jsii_name="putPartialRedact")
    def put_partial_redact(
        self,
        *,
        characters: typing.Optional[jsii.Number] = None,
        direction: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param characters: Number of characters to keep. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#characters ObservabilityPipeline#characters}
        :param direction: Direction from which to keep characters: ``first`` or ``last``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#direction ObservabilityPipeline#direction}
        '''
        value = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact(
            characters=characters, direction=direction
        )

        return typing.cast(None, jsii.invoke(self, "putPartialRedact", [value]))

    @jsii.member(jsii_name="putRedact")
    def put_redact(self, *, replace: typing.Optional[builtins.str] = None) -> None:
        '''
        :param replace: Replacement string for redacted values (e.g., ``***``). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#replace ObservabilityPipeline#replace}
        '''
        value = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact(
            replace=replace
        )

        return typing.cast(None, jsii.invoke(self, "putRedact", [value]))

    @jsii.member(jsii_name="resetPartialRedact")
    def reset_partial_redact(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPartialRedact", []))

    @jsii.member(jsii_name="resetRedact")
    def reset_redact(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRedact", []))

    @builtins.property
    @jsii.member(jsii_name="hash")
    def hash(
        self,
    ) -> ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHashOutputReference:
        return typing.cast(ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHashOutputReference, jsii.get(self, "hash"))

    @builtins.property
    @jsii.member(jsii_name="partialRedact")
    def partial_redact(
        self,
    ) -> "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedactOutputReference":
        return typing.cast("ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedactOutputReference", jsii.get(self, "partialRedact"))

    @builtins.property
    @jsii.member(jsii_name="redact")
    def redact(
        self,
    ) -> "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedactOutputReference":
        return typing.cast("ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedactOutputReference", jsii.get(self, "redact"))

    @builtins.property
    @jsii.member(jsii_name="hashInput")
    def hash_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash]], jsii.get(self, "hashInput"))

    @builtins.property
    @jsii.member(jsii_name="partialRedactInput")
    def partial_redact_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact"]], jsii.get(self, "partialRedactInput"))

    @builtins.property
    @jsii.member(jsii_name="redactInput")
    def redact_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact"]], jsii.get(self, "redactInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12308e13a1eb5aa71c31fb000ea5ea74eee62913c2fa27905c8afd55f2a74cd7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact",
    jsii_struct_bases=[],
    name_mapping={"characters": "characters", "direction": "direction"},
)
class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact:
    def __init__(
        self,
        *,
        characters: typing.Optional[jsii.Number] = None,
        direction: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param characters: Number of characters to keep. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#characters ObservabilityPipeline#characters}
        :param direction: Direction from which to keep characters: ``first`` or ``last``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#direction ObservabilityPipeline#direction}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82b384e22b8a6b2bf44b5a452351e3293df5af9ccf706068e070fe4126f6f30a)
            check_type(argname="argument characters", value=characters, expected_type=type_hints["characters"])
            check_type(argname="argument direction", value=direction, expected_type=type_hints["direction"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if characters is not None:
            self._values["characters"] = characters
        if direction is not None:
            self._values["direction"] = direction

    @builtins.property
    def characters(self) -> typing.Optional[jsii.Number]:
        '''Number of characters to keep.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#characters ObservabilityPipeline#characters}
        '''
        result = self._values.get("characters")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def direction(self) -> typing.Optional[builtins.str]:
        '''Direction from which to keep characters: ``first`` or ``last``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#direction ObservabilityPipeline#direction}
        '''
        result = self._values.get("direction")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedactOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedactOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06fc5043f97a5d97abe4e7dfe62b60098abd31718e3652450c8f8ff97c39e649)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCharacters")
    def reset_characters(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCharacters", []))

    @jsii.member(jsii_name="resetDirection")
    def reset_direction(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDirection", []))

    @builtins.property
    @jsii.member(jsii_name="charactersInput")
    def characters_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "charactersInput"))

    @builtins.property
    @jsii.member(jsii_name="directionInput")
    def direction_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "directionInput"))

    @builtins.property
    @jsii.member(jsii_name="characters")
    def characters(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "characters"))

    @characters.setter
    def characters(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f7dfa49ed1f27402d4351e05e6bf11155546f1238bd7a5825518171bb215412)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "characters", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="direction")
    def direction(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "direction"))

    @direction.setter
    def direction(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5116c0c688cc5bb8e2572402f9513d8d42dad3f032beb777c54bc46a7cf8223)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "direction", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c65f45f93dc3eeea75b0018dfbc7996eb1d3bb7d4e312f33230c8bf540a790b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact",
    jsii_struct_bases=[],
    name_mapping={"replace": "replace"},
)
class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact:
    def __init__(self, *, replace: typing.Optional[builtins.str] = None) -> None:
        '''
        :param replace: Replacement string for redacted values (e.g., ``***``). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#replace ObservabilityPipeline#replace}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05d8ff8b83e62e856bb38e0e013940a840451172478850dbd650c953dc8a81aa)
            check_type(argname="argument replace", value=replace, expected_type=type_hints["replace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if replace is not None:
            self._values["replace"] = replace

    @builtins.property
    def replace(self) -> typing.Optional[builtins.str]:
        '''Replacement string for redacted values (e.g., ``***``).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#replace ObservabilityPipeline#replace}
        '''
        result = self._values.get("replace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedactOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedactOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85f60d5dc17ffe0cd6871d01d0f2a3a832830c6d0053da7c529ca1f11963849c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetReplace")
    def reset_replace(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReplace", []))

    @builtins.property
    @jsii.member(jsii_name="replaceInput")
    def replace_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "replaceInput"))

    @builtins.property
    @jsii.member(jsii_name="replace")
    def replace(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "replace"))

    @replace.setter
    def replace(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b9f986d344b20e74df2abb05d7c35dc084f1781148ce2ccaa9be215d9f2fc91f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "replace", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eddf070b0190bb6dc7705b164bfee3c01dd77d8453e0c9c9b1d041091149a086)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b5b1dd8fd60daa6e610287943d57ffaaacff42a6e38fccbbb792b2725bb932e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putKeywordOptions")
    def put_keyword_options(
        self,
        *,
        keywords: typing.Optional[typing.Sequence[builtins.str]] = None,
        proximity: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param keywords: A list of keywords to match near the sensitive pattern. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#keywords ObservabilityPipeline#keywords}
        :param proximity: Maximum number of tokens between a keyword and a sensitive value match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#proximity ObservabilityPipeline#proximity}
        '''
        value = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions(
            keywords=keywords, proximity=proximity
        )

        return typing.cast(None, jsii.invoke(self, "putKeywordOptions", [value]))

    @jsii.member(jsii_name="putOnMatch")
    def put_on_match(
        self,
        *,
        hash: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash, typing.Dict[builtins.str, typing.Any]]] = None,
        partial_redact: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact, typing.Dict[builtins.str, typing.Any]]] = None,
        redact: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param hash: hash block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#hash ObservabilityPipeline#hash}
        :param partial_redact: partial_redact block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#partial_redact ObservabilityPipeline#partial_redact}
        :param redact: redact block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#redact ObservabilityPipeline#redact}
        '''
        value = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch(
            hash=hash, partial_redact=partial_redact, redact=redact
        )

        return typing.cast(None, jsii.invoke(self, "putOnMatch", [value]))

    @jsii.member(jsii_name="putPattern")
    def put_pattern(
        self,
        *,
        custom: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom", typing.Dict[builtins.str, typing.Any]]] = None,
        library: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param custom: custom block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#custom ObservabilityPipeline#custom}
        :param library: library block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#library ObservabilityPipeline#library}
        '''
        value = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern(
            custom=custom, library=library
        )

        return typing.cast(None, jsii.invoke(self, "putPattern", [value]))

    @jsii.member(jsii_name="putScope")
    def put_scope(
        self,
        *,
        all: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        exclude: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude", typing.Dict[builtins.str, typing.Any]]] = None,
        include: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param all: Scan all fields. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#all ObservabilityPipeline#all}
        :param exclude: exclude block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#exclude ObservabilityPipeline#exclude}
        :param include: include block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        value = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope(
            all=all, exclude=exclude, include=include
        )

        return typing.cast(None, jsii.invoke(self, "putScope", [value]))

    @jsii.member(jsii_name="resetKeywordOptions")
    def reset_keyword_options(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeywordOptions", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetOnMatch")
    def reset_on_match(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOnMatch", []))

    @jsii.member(jsii_name="resetPattern")
    def reset_pattern(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPattern", []))

    @jsii.member(jsii_name="resetScope")
    def reset_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScope", []))

    @jsii.member(jsii_name="resetTags")
    def reset_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTags", []))

    @builtins.property
    @jsii.member(jsii_name="keywordOptions")
    def keyword_options(
        self,
    ) -> ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptionsOutputReference:
        return typing.cast(ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptionsOutputReference, jsii.get(self, "keywordOptions"))

    @builtins.property
    @jsii.member(jsii_name="onMatch")
    def on_match(
        self,
    ) -> ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchOutputReference:
        return typing.cast(ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchOutputReference, jsii.get(self, "onMatch"))

    @builtins.property
    @jsii.member(jsii_name="pattern")
    def pattern(
        self,
    ) -> "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternOutputReference":
        return typing.cast("ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternOutputReference", jsii.get(self, "pattern"))

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(
        self,
    ) -> "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeOutputReference":
        return typing.cast("ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeOutputReference", jsii.get(self, "scope"))

    @builtins.property
    @jsii.member(jsii_name="keywordOptionsInput")
    def keyword_options_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions]], jsii.get(self, "keywordOptionsInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="onMatchInput")
    def on_match_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch]], jsii.get(self, "onMatchInput"))

    @builtins.property
    @jsii.member(jsii_name="patternInput")
    def pattern_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern"]], jsii.get(self, "patternInput"))

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope"]], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="tagsInput")
    def tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "tagsInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0c337a4c74e0978791193dc0071559c9b68a716319bbf4f7a75958c83803cd1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tags"))

    @tags.setter
    def tags(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ced9c1e1b980f083a99eed950a335545dda24a5388e71105808e4a5f0fd4b42d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13781f6260033b8be238e8d85734de111de7cfb553ebd0573b3ccc3e7b97c699)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern",
    jsii_struct_bases=[],
    name_mapping={"custom": "custom", "library": "library"},
)
class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern:
    def __init__(
        self,
        *,
        custom: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom", typing.Dict[builtins.str, typing.Any]]] = None,
        library: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param custom: custom block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#custom ObservabilityPipeline#custom}
        :param library: library block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#library ObservabilityPipeline#library}
        '''
        if isinstance(custom, dict):
            custom = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom(**custom)
        if isinstance(library, dict):
            library = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary(**library)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2fbd21d010640e75b18728a769c1116ad458447607c1334440d2f8a195f64bce)
            check_type(argname="argument custom", value=custom, expected_type=type_hints["custom"])
            check_type(argname="argument library", value=library, expected_type=type_hints["library"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if custom is not None:
            self._values["custom"] = custom
        if library is not None:
            self._values["library"] = library

    @builtins.property
    def custom(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom"]:
        '''custom block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#custom ObservabilityPipeline#custom}
        '''
        result = self._values.get("custom")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom"], result)

    @builtins.property
    def library(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary"]:
        '''library block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#library ObservabilityPipeline#library}
        '''
        result = self._values.get("library")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom",
    jsii_struct_bases=[],
    name_mapping={"rule": "rule"},
)
class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom:
    def __init__(self, *, rule: typing.Optional[builtins.str] = None) -> None:
        '''
        :param rule: A regular expression used to detect sensitive values. Must be a valid regex. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rule ObservabilityPipeline#rule}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9d366d92c943ba53a27ab99b98e9c3575cec845917a68c12333d234afaa3cb3)
            check_type(argname="argument rule", value=rule, expected_type=type_hints["rule"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if rule is not None:
            self._values["rule"] = rule

    @builtins.property
    def rule(self) -> typing.Optional[builtins.str]:
        '''A regular expression used to detect sensitive values. Must be a valid regex.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rule ObservabilityPipeline#rule}
        '''
        result = self._values.get("rule")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustomOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustomOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__791dfc5342d7c6843aaf94790780abbde07e429fc324cd0b643dae6b56014c12)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetRule")
    def reset_rule(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRule", []))

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rule"))

    @rule.setter
    def rule(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb1fb3528813d453f68b27fe9cfc828e439d45fe4b071248f2a242dcdc62214a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "rule", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__75199fe1daa3abf1be653cfae6a5c93133f435828cf70e9e2fb6a1b3c196b74a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "use_recommended_keywords": "useRecommendedKeywords"},
)
class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary:
    def __init__(
        self,
        *,
        id: typing.Optional[builtins.str] = None,
        use_recommended_keywords: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param id: Identifier for a predefined pattern from the sensitive data scanner pattern library. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param use_recommended_keywords: Whether to augment the pattern with recommended keywords (optional). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#use_recommended_keywords ObservabilityPipeline#use_recommended_keywords}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6f0fc366d4159343213a171c644e74ee98d1350a39f7ef614abe8dd9723d070)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument use_recommended_keywords", value=use_recommended_keywords, expected_type=type_hints["use_recommended_keywords"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if id is not None:
            self._values["id"] = id
        if use_recommended_keywords is not None:
            self._values["use_recommended_keywords"] = use_recommended_keywords

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        '''Identifier for a predefined pattern from the sensitive data scanner pattern library.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def use_recommended_keywords(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to augment the pattern with recommended keywords (optional).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#use_recommended_keywords ObservabilityPipeline#use_recommended_keywords}
        '''
        result = self._values.get("use_recommended_keywords")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibraryOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibraryOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__014ceefeabbc9968967a88a541c0258e23b799c4c4ae03a0f761df2eea5bfddd)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetId")
    def reset_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetId", []))

    @jsii.member(jsii_name="resetUseRecommendedKeywords")
    def reset_use_recommended_keywords(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUseRecommendedKeywords", []))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="useRecommendedKeywordsInput")
    def use_recommended_keywords_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "useRecommendedKeywordsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e01415679eddf0febeeadeef9ea3acc27e2c780d724688ea8b3aef52ba47e9e8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="useRecommendedKeywords")
    def use_recommended_keywords(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "useRecommendedKeywords"))

    @use_recommended_keywords.setter
    def use_recommended_keywords(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8657435aeb22175637ea49ebf40d65a163f89441e1db7c13b53a2b7118818f20)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "useRecommendedKeywords", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73328366ea97490ba035096470a6f4657db9206aa3f316fe6883b721b663d98b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bbe8ee578357bd41b004ca420a645d2b7c8e0612fe30ec621af31587cef6f174)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putCustom")
    def put_custom(self, *, rule: typing.Optional[builtins.str] = None) -> None:
        '''
        :param rule: A regular expression used to detect sensitive values. Must be a valid regex. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rule ObservabilityPipeline#rule}
        '''
        value = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom(
            rule=rule
        )

        return typing.cast(None, jsii.invoke(self, "putCustom", [value]))

    @jsii.member(jsii_name="putLibrary")
    def put_library(
        self,
        *,
        id: typing.Optional[builtins.str] = None,
        use_recommended_keywords: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param id: Identifier for a predefined pattern from the sensitive data scanner pattern library. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param use_recommended_keywords: Whether to augment the pattern with recommended keywords (optional). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#use_recommended_keywords ObservabilityPipeline#use_recommended_keywords}
        '''
        value = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary(
            id=id, use_recommended_keywords=use_recommended_keywords
        )

        return typing.cast(None, jsii.invoke(self, "putLibrary", [value]))

    @jsii.member(jsii_name="resetCustom")
    def reset_custom(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCustom", []))

    @jsii.member(jsii_name="resetLibrary")
    def reset_library(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLibrary", []))

    @builtins.property
    @jsii.member(jsii_name="custom")
    def custom(
        self,
    ) -> ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustomOutputReference:
        return typing.cast(ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustomOutputReference, jsii.get(self, "custom"))

    @builtins.property
    @jsii.member(jsii_name="library")
    def library(
        self,
    ) -> ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibraryOutputReference:
        return typing.cast(ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibraryOutputReference, jsii.get(self, "library"))

    @builtins.property
    @jsii.member(jsii_name="customInput")
    def custom_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom]], jsii.get(self, "customInput"))

    @builtins.property
    @jsii.member(jsii_name="libraryInput")
    def library_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary]], jsii.get(self, "libraryInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__80102ff0d0eb052c83ceee8ad475c4fa0d705f3c4f4446d1652da0f01b150a0d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope",
    jsii_struct_bases=[],
    name_mapping={"all": "all", "exclude": "exclude", "include": "include"},
)
class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope:
    def __init__(
        self,
        *,
        all: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        exclude: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude", typing.Dict[builtins.str, typing.Any]]] = None,
        include: typing.Optional[typing.Union["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param all: Scan all fields. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#all ObservabilityPipeline#all}
        :param exclude: exclude block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#exclude ObservabilityPipeline#exclude}
        :param include: include block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        if isinstance(exclude, dict):
            exclude = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude(**exclude)
        if isinstance(include, dict):
            include = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude(**include)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fab926fa0838f4740e932e97c795c218a5f3d795d028bab2a9920de3b42aea90)
            check_type(argname="argument all", value=all, expected_type=type_hints["all"])
            check_type(argname="argument exclude", value=exclude, expected_type=type_hints["exclude"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if all is not None:
            self._values["all"] = all
        if exclude is not None:
            self._values["exclude"] = exclude
        if include is not None:
            self._values["include"] = include

    @builtins.property
    def all(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Scan all fields.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#all ObservabilityPipeline#all}
        '''
        result = self._values.get("all")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def exclude(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude"]:
        '''exclude block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#exclude ObservabilityPipeline#exclude}
        '''
        result = self._values.get("exclude")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude"], result)

    @builtins.property
    def include(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude"]:
        '''include block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude",
    jsii_struct_bases=[],
    name_mapping={"fields": "fields"},
)
class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude:
    def __init__(
        self,
        *,
        fields: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param fields: The fields to exclude from scanning. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fields ObservabilityPipeline#fields}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39ec9e9397165267a7dfae1cbb1e2165dfcf2c41889b35d31530daa43ba02e6b)
            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if fields is not None:
            self._values["fields"] = fields

    @builtins.property
    def fields(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The fields to exclude from scanning.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fields ObservabilityPipeline#fields}
        '''
        result = self._values.get("fields")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExcludeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExcludeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1473ecbf9a4f6cd7e01f7e4b8535195d8b9ebf140093a0904666fb51c5da509a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetFields")
    def reset_fields(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFields", []))

    @builtins.property
    @jsii.member(jsii_name="fieldsInput")
    def fields_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "fieldsInput"))

    @builtins.property
    @jsii.member(jsii_name="fields")
    def fields(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "fields"))

    @fields.setter
    def fields(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39449c051b8b7a5622009d3af621210de6a61f8f36d37ceda4d3f004509c19aa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "fields", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__30ae5e434ae57aa01830973612f80d69f817c43edd4b62d194a3f0be56d9eb37)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude",
    jsii_struct_bases=[],
    name_mapping={"fields": "fields"},
)
class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude:
    def __init__(
        self,
        *,
        fields: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param fields: The fields to include in scanning. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fields ObservabilityPipeline#fields}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f3d9ea90c2be40cada1f5f027673802ecb672ca1fd34ca233fc3a66503293a3)
            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if fields is not None:
            self._values["fields"] = fields

    @builtins.property
    def fields(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The fields to include in scanning.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fields ObservabilityPipeline#fields}
        '''
        result = self._values.get("fields")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeIncludeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeIncludeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd16d288e2e489505e96a24408f25b2b40a87451737f7cab6b64275b02d41a54)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetFields")
    def reset_fields(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFields", []))

    @builtins.property
    @jsii.member(jsii_name="fieldsInput")
    def fields_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "fieldsInput"))

    @builtins.property
    @jsii.member(jsii_name="fields")
    def fields(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "fields"))

    @fields.setter
    def fields(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7283014cd70a395b20d300469e2bc866a652a673192ab33dd739410873e8283)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "fields", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__705e62dc25ad60e0fc8badb18421c31f3500c2603cc053b6b8ffaffc4d858763)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__941dd9a80b7c5b91573d02117270eb21a0bed7c517ee2ad2158fe16ed56bac99)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putExclude")
    def put_exclude(
        self,
        *,
        fields: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param fields: The fields to exclude from scanning. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fields ObservabilityPipeline#fields}
        '''
        value = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude(
            fields=fields
        )

        return typing.cast(None, jsii.invoke(self, "putExclude", [value]))

    @jsii.member(jsii_name="putInclude")
    def put_include(
        self,
        *,
        fields: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param fields: The fields to include in scanning. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fields ObservabilityPipeline#fields}
        '''
        value = ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude(
            fields=fields
        )

        return typing.cast(None, jsii.invoke(self, "putInclude", [value]))

    @jsii.member(jsii_name="resetAll")
    def reset_all(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAll", []))

    @jsii.member(jsii_name="resetExclude")
    def reset_exclude(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExclude", []))

    @jsii.member(jsii_name="resetInclude")
    def reset_include(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInclude", []))

    @builtins.property
    @jsii.member(jsii_name="exclude")
    def exclude(
        self,
    ) -> ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExcludeOutputReference:
        return typing.cast(ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExcludeOutputReference, jsii.get(self, "exclude"))

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(
        self,
    ) -> ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeIncludeOutputReference:
        return typing.cast(ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeIncludeOutputReference, jsii.get(self, "include"))

    @builtins.property
    @jsii.member(jsii_name="allInput")
    def all_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "allInput"))

    @builtins.property
    @jsii.member(jsii_name="excludeInput")
    def exclude_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude]], jsii.get(self, "excludeInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude]], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="all")
    def all(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "all"))

    @all.setter
    def all(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eacfc8b58d835bb6dbd11691c5d555a97755d527d92b7480abd9743056f4ecd5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "all", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c2837d69523ac0707b618c2917de590a066a4ef6d08663fa128a760cebc8364)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsThrottle",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "include": "include",
        "inputs": "inputs",
        "threshold": "threshold",
        "window": "window",
        "group_by": "groupBy",
    },
)
class ObservabilityPipelineConfigProcessorsThrottle:
    def __init__(
        self,
        *,
        id: builtins.str,
        include: builtins.str,
        inputs: typing.Sequence[builtins.str],
        threshold: jsii.Number,
        window: jsii.Number,
        group_by: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param include: A Datadog search query used to determine which logs this processor targets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        :param inputs: A list of component IDs whose output is used as the input for this processor. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        :param threshold: The number of events to allow before throttling is applied. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#threshold ObservabilityPipeline#threshold}
        :param window: The time window in seconds over which the threshold applies. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#window ObservabilityPipeline#window}
        :param group_by: Optional list of fields used to group events before applying throttling. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#group_by ObservabilityPipeline#group_by}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9221cfcfe79ad75010cc2319471701747db19ac85475580c2d8e0e3b64a7dec1)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument include", value=include, expected_type=type_hints["include"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument window", value=window, expected_type=type_hints["window"])
            check_type(argname="argument group_by", value=group_by, expected_type=type_hints["group_by"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "include": include,
            "inputs": inputs,
            "threshold": threshold,
            "window": window,
        }
        if group_by is not None:
            self._values["group_by"] = group_by

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def include(self) -> builtins.str:
        '''A Datadog search query used to determine which logs this processor targets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#include ObservabilityPipeline#include}
        '''
        result = self._values.get("include")
        assert result is not None, "Required property 'include' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def inputs(self) -> typing.List[builtins.str]:
        '''A list of component IDs whose output is used as the input for this processor.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#inputs ObservabilityPipeline#inputs}
        '''
        result = self._values.get("inputs")
        assert result is not None, "Required property 'inputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The number of events to allow before throttling is applied.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#threshold ObservabilityPipeline#threshold}
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def window(self) -> jsii.Number:
        '''The time window in seconds over which the threshold applies.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#window ObservabilityPipeline#window}
        '''
        result = self._values.get("window")
        assert result is not None, "Required property 'window' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def group_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Optional list of fields used to group events before applying throttling.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#group_by ObservabilityPipeline#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigProcessorsThrottle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigProcessorsThrottleList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsThrottleList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b0fb4da87d3f92c820e3e798e2f0314cd7be3cbbe31a1c171789b7a64629d7e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigProcessorsThrottleOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__029bc261c795e350b5c8a33c00dfa7563dc7e8815659a778dfd075578da11b27)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigProcessorsThrottleOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd58544d69d5c5487e7f4210b7b5b6a7a0c018e5e9a7d899598005caae76fa67)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f4a6297a7f2b8c8b010eda59b00d780db8bb0200fff506c31d0efae8da0b286e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9d29bc30b8b1872572d874e4d726da2fce21957cf4f79341151b291dde8b5bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsThrottle]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsThrottle]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsThrottle]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f6728cce86d5d42cdb77a6329401a9b20697de94fb44c248f688a4b963e261e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigProcessorsThrottleOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigProcessorsThrottleOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c53579cf940efbdd93f8a09277947a75240d47100234ddad1f0ba83c24c51e2e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetGroupBy")
    def reset_group_by(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGroupBy", []))

    @builtins.property
    @jsii.member(jsii_name="groupByInput")
    def group_by_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "groupByInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="includeInput")
    def include_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "includeInput"))

    @builtins.property
    @jsii.member(jsii_name="inputsInput")
    def inputs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "inputsInput"))

    @builtins.property
    @jsii.member(jsii_name="thresholdInput")
    def threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "thresholdInput"))

    @builtins.property
    @jsii.member(jsii_name="windowInput")
    def window_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "windowInput"))

    @builtins.property
    @jsii.member(jsii_name="groupBy")
    def group_by(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "groupBy"))

    @group_by.setter
    def group_by(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__871b68c9c958b060a97c483c559a633aa1ad9b13cf45888b29535c90f9574226)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "groupBy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cd362e9bc0c8d8fafd4eb651b3f348f2d73767e77a5c432bc8724f97fcf7c06e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="include")
    def include(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "include"))

    @include.setter
    def include(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4de3db0453c2325676df9b3b20f841671f4b4d5408d8f319b78713308f56de3a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "include", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "inputs"))

    @inputs.setter
    def inputs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6cded671082888b6ce6f6157b8103caaaf5e9d81fe371724fc4f827150c03d16)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inputs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="threshold")
    def threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "threshold"))

    @threshold.setter
    def threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e254521e2408bd6629ae9a2bbe428448f92b9cb77d9d17ac78eb822bc82abe29)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "threshold", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="window")
    def window(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "window"))

    @window.setter
    def window(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17a3d79e06223bf51704061300cf82a666ff2e002ac1da8b5149535a725f482f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "window", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsThrottle]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsThrottle]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsThrottle]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__42c5b3333b81c445e498cebb9ffb12d459a145dcc3e76684bada5c71f53ca4ad)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSources",
    jsii_struct_bases=[],
    name_mapping={
        "amazon_data_firehose": "amazonDataFirehose",
        "amazon_s3": "amazonS3",
        "datadog_agent": "datadogAgent",
        "fluent_bit": "fluentBit",
        "fluentd": "fluentd",
        "google_pubsub": "googlePubsub",
        "http_client": "httpClient",
        "http_server": "httpServer",
        "kafka": "kafka",
        "logstash": "logstash",
        "rsyslog": "rsyslog",
        "socket": "socket",
        "splunk_hec": "splunkHec",
        "splunk_tcp": "splunkTcp",
        "sumo_logic": "sumoLogic",
        "syslog_ng": "syslogNg",
    },
)
class ObservabilityPipelineConfigSources:
    def __init__(
        self,
        *,
        amazon_data_firehose: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesAmazonDataFirehose", typing.Dict[builtins.str, typing.Any]]]]] = None,
        amazon_s3: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesAmazonS3", typing.Dict[builtins.str, typing.Any]]]]] = None,
        datadog_agent: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesDatadogAgent", typing.Dict[builtins.str, typing.Any]]]]] = None,
        fluent_bit: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesFluentBit", typing.Dict[builtins.str, typing.Any]]]]] = None,
        fluentd: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesFluentd", typing.Dict[builtins.str, typing.Any]]]]] = None,
        google_pubsub: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesGooglePubsub", typing.Dict[builtins.str, typing.Any]]]]] = None,
        http_client: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesHttpClient", typing.Dict[builtins.str, typing.Any]]]]] = None,
        http_server: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesHttpServer", typing.Dict[builtins.str, typing.Any]]]]] = None,
        kafka: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesKafka", typing.Dict[builtins.str, typing.Any]]]]] = None,
        logstash: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesLogstash", typing.Dict[builtins.str, typing.Any]]]]] = None,
        rsyslog: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesRsyslog", typing.Dict[builtins.str, typing.Any]]]]] = None,
        socket: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSocket", typing.Dict[builtins.str, typing.Any]]]]] = None,
        splunk_hec: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSplunkHec", typing.Dict[builtins.str, typing.Any]]]]] = None,
        splunk_tcp: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSplunkTcp", typing.Dict[builtins.str, typing.Any]]]]] = None,
        sumo_logic: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSumoLogic", typing.Dict[builtins.str, typing.Any]]]]] = None,
        syslog_ng: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSyslogNg", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param amazon_data_firehose: amazon_data_firehose block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_data_firehose ObservabilityPipeline#amazon_data_firehose}
        :param amazon_s3: amazon_s3 block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_s3 ObservabilityPipeline#amazon_s3}
        :param datadog_agent: datadog_agent block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#datadog_agent ObservabilityPipeline#datadog_agent}
        :param fluent_bit: fluent_bit block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fluent_bit ObservabilityPipeline#fluent_bit}
        :param fluentd: fluentd block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fluentd ObservabilityPipeline#fluentd}
        :param google_pubsub: google_pubsub block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#google_pubsub ObservabilityPipeline#google_pubsub}
        :param http_client: http_client block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#http_client ObservabilityPipeline#http_client}
        :param http_server: http_server block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#http_server ObservabilityPipeline#http_server}
        :param kafka: kafka block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#kafka ObservabilityPipeline#kafka}
        :param logstash: logstash block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#logstash ObservabilityPipeline#logstash}
        :param rsyslog: rsyslog block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rsyslog ObservabilityPipeline#rsyslog}
        :param socket: socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#socket ObservabilityPipeline#socket}
        :param splunk_hec: splunk_hec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#splunk_hec ObservabilityPipeline#splunk_hec}
        :param splunk_tcp: splunk_tcp block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#splunk_tcp ObservabilityPipeline#splunk_tcp}
        :param sumo_logic: sumo_logic block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sumo_logic ObservabilityPipeline#sumo_logic}
        :param syslog_ng: syslog_ng block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#syslog_ng ObservabilityPipeline#syslog_ng}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49015850ddc7b28aa0df549fd07e8652551f233acd25899cb805b635a0122141)
            check_type(argname="argument amazon_data_firehose", value=amazon_data_firehose, expected_type=type_hints["amazon_data_firehose"])
            check_type(argname="argument amazon_s3", value=amazon_s3, expected_type=type_hints["amazon_s3"])
            check_type(argname="argument datadog_agent", value=datadog_agent, expected_type=type_hints["datadog_agent"])
            check_type(argname="argument fluent_bit", value=fluent_bit, expected_type=type_hints["fluent_bit"])
            check_type(argname="argument fluentd", value=fluentd, expected_type=type_hints["fluentd"])
            check_type(argname="argument google_pubsub", value=google_pubsub, expected_type=type_hints["google_pubsub"])
            check_type(argname="argument http_client", value=http_client, expected_type=type_hints["http_client"])
            check_type(argname="argument http_server", value=http_server, expected_type=type_hints["http_server"])
            check_type(argname="argument kafka", value=kafka, expected_type=type_hints["kafka"])
            check_type(argname="argument logstash", value=logstash, expected_type=type_hints["logstash"])
            check_type(argname="argument rsyslog", value=rsyslog, expected_type=type_hints["rsyslog"])
            check_type(argname="argument socket", value=socket, expected_type=type_hints["socket"])
            check_type(argname="argument splunk_hec", value=splunk_hec, expected_type=type_hints["splunk_hec"])
            check_type(argname="argument splunk_tcp", value=splunk_tcp, expected_type=type_hints["splunk_tcp"])
            check_type(argname="argument sumo_logic", value=sumo_logic, expected_type=type_hints["sumo_logic"])
            check_type(argname="argument syslog_ng", value=syslog_ng, expected_type=type_hints["syslog_ng"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if amazon_data_firehose is not None:
            self._values["amazon_data_firehose"] = amazon_data_firehose
        if amazon_s3 is not None:
            self._values["amazon_s3"] = amazon_s3
        if datadog_agent is not None:
            self._values["datadog_agent"] = datadog_agent
        if fluent_bit is not None:
            self._values["fluent_bit"] = fluent_bit
        if fluentd is not None:
            self._values["fluentd"] = fluentd
        if google_pubsub is not None:
            self._values["google_pubsub"] = google_pubsub
        if http_client is not None:
            self._values["http_client"] = http_client
        if http_server is not None:
            self._values["http_server"] = http_server
        if kafka is not None:
            self._values["kafka"] = kafka
        if logstash is not None:
            self._values["logstash"] = logstash
        if rsyslog is not None:
            self._values["rsyslog"] = rsyslog
        if socket is not None:
            self._values["socket"] = socket
        if splunk_hec is not None:
            self._values["splunk_hec"] = splunk_hec
        if splunk_tcp is not None:
            self._values["splunk_tcp"] = splunk_tcp
        if sumo_logic is not None:
            self._values["sumo_logic"] = sumo_logic
        if syslog_ng is not None:
            self._values["syslog_ng"] = syslog_ng

    @builtins.property
    def amazon_data_firehose(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesAmazonDataFirehose"]]]:
        '''amazon_data_firehose block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_data_firehose ObservabilityPipeline#amazon_data_firehose}
        '''
        result = self._values.get("amazon_data_firehose")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesAmazonDataFirehose"]]], result)

    @builtins.property
    def amazon_s3(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesAmazonS3"]]]:
        '''amazon_s3 block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#amazon_s3 ObservabilityPipeline#amazon_s3}
        '''
        result = self._values.get("amazon_s3")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesAmazonS3"]]], result)

    @builtins.property
    def datadog_agent(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesDatadogAgent"]]]:
        '''datadog_agent block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#datadog_agent ObservabilityPipeline#datadog_agent}
        '''
        result = self._values.get("datadog_agent")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesDatadogAgent"]]], result)

    @builtins.property
    def fluent_bit(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesFluentBit"]]]:
        '''fluent_bit block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fluent_bit ObservabilityPipeline#fluent_bit}
        '''
        result = self._values.get("fluent_bit")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesFluentBit"]]], result)

    @builtins.property
    def fluentd(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesFluentd"]]]:
        '''fluentd block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#fluentd ObservabilityPipeline#fluentd}
        '''
        result = self._values.get("fluentd")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesFluentd"]]], result)

    @builtins.property
    def google_pubsub(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesGooglePubsub"]]]:
        '''google_pubsub block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#google_pubsub ObservabilityPipeline#google_pubsub}
        '''
        result = self._values.get("google_pubsub")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesGooglePubsub"]]], result)

    @builtins.property
    def http_client(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesHttpClient"]]]:
        '''http_client block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#http_client ObservabilityPipeline#http_client}
        '''
        result = self._values.get("http_client")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesHttpClient"]]], result)

    @builtins.property
    def http_server(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesHttpServer"]]]:
        '''http_server block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#http_server ObservabilityPipeline#http_server}
        '''
        result = self._values.get("http_server")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesHttpServer"]]], result)

    @builtins.property
    def kafka(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesKafka"]]]:
        '''kafka block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#kafka ObservabilityPipeline#kafka}
        '''
        result = self._values.get("kafka")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesKafka"]]], result)

    @builtins.property
    def logstash(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesLogstash"]]]:
        '''logstash block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#logstash ObservabilityPipeline#logstash}
        '''
        result = self._values.get("logstash")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesLogstash"]]], result)

    @builtins.property
    def rsyslog(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesRsyslog"]]]:
        '''rsyslog block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#rsyslog ObservabilityPipeline#rsyslog}
        '''
        result = self._values.get("rsyslog")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesRsyslog"]]], result)

    @builtins.property
    def socket(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSocket"]]]:
        '''socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#socket ObservabilityPipeline#socket}
        '''
        result = self._values.get("socket")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSocket"]]], result)

    @builtins.property
    def splunk_hec(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSplunkHec"]]]:
        '''splunk_hec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#splunk_hec ObservabilityPipeline#splunk_hec}
        '''
        result = self._values.get("splunk_hec")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSplunkHec"]]], result)

    @builtins.property
    def splunk_tcp(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSplunkTcp"]]]:
        '''splunk_tcp block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#splunk_tcp ObservabilityPipeline#splunk_tcp}
        '''
        result = self._values.get("splunk_tcp")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSplunkTcp"]]], result)

    @builtins.property
    def sumo_logic(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSumoLogic"]]]:
        '''sumo_logic block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sumo_logic ObservabilityPipeline#sumo_logic}
        '''
        result = self._values.get("sumo_logic")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSumoLogic"]]], result)

    @builtins.property
    def syslog_ng(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSyslogNg"]]]:
        '''syslog_ng block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#syslog_ng ObservabilityPipeline#syslog_ng}
        '''
        result = self._values.get("syslog_ng")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSyslogNg"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonDataFirehose",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "auth": "auth", "tls": "tls"},
)
class ObservabilityPipelineConfigSourcesAmazonDataFirehose:
    def __init__(
        self,
        *,
        id: builtins.str,
        auth: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (e.g., as input to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param auth: auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(auth, dict):
            auth = ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth(**auth)
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__814557b96fbb60a0584b97b52bf00c335255ec5471ece858276e01d58a003ec5)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }
        if auth is not None:
            self._values["auth"] = auth
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (e.g., as input to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth"]:
        '''auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth"], result)

    @builtins.property
    def tls(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesAmazonDataFirehose(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth",
    jsii_struct_bases=[],
    name_mapping={
        "assume_role": "assumeRole",
        "external_id": "externalId",
        "session_name": "sessionName",
    },
)
class ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth:
    def __init__(
        self,
        *,
        assume_role: typing.Optional[builtins.str] = None,
        external_id: typing.Optional[builtins.str] = None,
        session_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param assume_role: The Amazon Resource Name (ARN) of the role to assume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        :param external_id: A unique identifier for cross-account role assumption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        :param session_name: A session identifier used for logging and tracing the assumed role session. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86c0c4e4dfa61eb6ceca3b49c24240e9beee8307853199101101f20df5e4f621)
            check_type(argname="argument assume_role", value=assume_role, expected_type=type_hints["assume_role"])
            check_type(argname="argument external_id", value=external_id, expected_type=type_hints["external_id"])
            check_type(argname="argument session_name", value=session_name, expected_type=type_hints["session_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if assume_role is not None:
            self._values["assume_role"] = assume_role
        if external_id is not None:
            self._values["external_id"] = external_id
        if session_name is not None:
            self._values["session_name"] = session_name

    @builtins.property
    def assume_role(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the role to assume.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        '''
        result = self._values.get("assume_role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def external_id(self) -> typing.Optional[builtins.str]:
        '''A unique identifier for cross-account role assumption.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        '''
        result = self._values.get("external_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def session_name(self) -> typing.Optional[builtins.str]:
        '''A session identifier used for logging and tracing the assumed role session.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        result = self._values.get("session_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06749e4eb0cde7c68205803ba48a151828b4aeedf58047d011cc4555225dcbcd)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAssumeRole")
    def reset_assume_role(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAssumeRole", []))

    @jsii.member(jsii_name="resetExternalId")
    def reset_external_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExternalId", []))

    @jsii.member(jsii_name="resetSessionName")
    def reset_session_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSessionName", []))

    @builtins.property
    @jsii.member(jsii_name="assumeRoleInput")
    def assume_role_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "assumeRoleInput"))

    @builtins.property
    @jsii.member(jsii_name="externalIdInput")
    def external_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "externalIdInput"))

    @builtins.property
    @jsii.member(jsii_name="sessionNameInput")
    def session_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sessionNameInput"))

    @builtins.property
    @jsii.member(jsii_name="assumeRole")
    def assume_role(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "assumeRole"))

    @assume_role.setter
    def assume_role(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__43ee397eec7b26087562ab1b6e95094c5d30482ffa4d972bd21340010e4438c1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "assumeRole", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="externalId")
    def external_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "externalId"))

    @external_id.setter
    def external_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ffb3ab0ffc8486fec0e43bae7ad4e3f1f994473f77f7c85ea3eaa2bdbe1da0f2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "externalId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sessionName")
    def session_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sessionName"))

    @session_name.setter
    def session_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__135dee6a31f146da9e7fb10815c16f3bee8b73ea26c7c3dd32378a09fc2874c6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sessionName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7ca4f876035ae6e3107da82f55b9b40824839a724b6c19547fbcd34a07cc608)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesAmazonDataFirehoseList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonDataFirehoseList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90eb7783604e99f91230d1f4e59dd528bfd361fc6e16e567dbdf76467810d316)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesAmazonDataFirehoseOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e0c05c9b34cceb115c5234461763afe0f0a1c7350d56c2c04d32c2dba839192f)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesAmazonDataFirehoseOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2dc6b2c73c9ea1832da8f3c17497cae1b8e33228cf9d0ccd678feac9e4d3bce2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__42fb89495f9d99ae6a99d76efc3fe57cebbda0234b078fffd7401a49c048c9a3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__191311178d5c9957516d5abe2bb2d674274904e8c5a270ecc0eb65dea3e25a01)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesAmazonDataFirehose]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesAmazonDataFirehose]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesAmazonDataFirehose]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f507bb9b38eeb6d3ab713b9948b7bbd217341d7df208ce84de1fa3229e7ae77)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesAmazonDataFirehoseOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonDataFirehoseOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce497cb22e32b7179f2e31a2f404fe83d0d3d35d77b2efcc4f41ccc57d36adb7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAuth")
    def put_auth(
        self,
        *,
        assume_role: typing.Optional[builtins.str] = None,
        external_id: typing.Optional[builtins.str] = None,
        session_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param assume_role: The Amazon Resource Name (ARN) of the role to assume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        :param external_id: A unique identifier for cross-account role assumption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        :param session_name: A session identifier used for logging and tracing the assumed role session. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        value = ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth(
            assume_role=assume_role, external_id=external_id, session_name=session_name
        )

        return typing.cast(None, jsii.invoke(self, "putAuth", [value]))

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetAuth")
    def reset_auth(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAuth", []))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="auth")
    def auth(
        self,
    ) -> ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuthOutputReference:
        return typing.cast(ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuthOutputReference, jsii.get(self, "auth"))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(
        self,
    ) -> "ObservabilityPipelineConfigSourcesAmazonDataFirehoseTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesAmazonDataFirehoseTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="authInput")
    def auth_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth]], jsii.get(self, "authInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af4d444aef66fe7ab2c2c43e33573ad786f748e967d8fd9f7d58db6c26f385b5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehose]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehose]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehose]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7ea6d883b8c65e0c5bab192facc4b32d2dc99eab900c758a504cc13a1a4464b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af38c4f5cb8f99768fcbc5421422d2571aa6bf43d3009721051a63d6f84edb09)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesAmazonDataFirehoseTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonDataFirehoseTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__46c4be08b7fccba7ac11df0345956a6872377631b0a1826e5d0ee6761693d41a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20569db3672c2dd6d0c2786e81a5eb1dd625be2cbc13134c91f5379540aa3a49)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2bd9f6796c9e4d3f23cd36d5aacecef223375b188f855738b7c67acee9d73892)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__30f95c130b4d2048cdf6307898e54b9383e66ef17b6122e867a98a510bee2245)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dccc29b028e36cbc738f230c518e00c7591abe8fe78a6b4a201c3a2294a2fef7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonS3",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "region": "region", "auth": "auth", "tls": "tls"},
)
class ObservabilityPipelineConfigSourcesAmazonS3:
    def __init__(
        self,
        *,
        id: builtins.str,
        region: builtins.str,
        auth: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesAmazonS3Auth", typing.Dict[builtins.str, typing.Any]]] = None,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesAmazonS3Tls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (e.g., as input to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param region: AWS region where the S3 bucket resides. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#region ObservabilityPipeline#region}
        :param auth: auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(auth, dict):
            auth = ObservabilityPipelineConfigSourcesAmazonS3Auth(**auth)
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesAmazonS3Tls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ccf5b1c96cca4aac37aac29c8526778799456b1da77fba54985399c871fe312)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "region": region,
        }
        if auth is not None:
            self._values["auth"] = auth
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (e.g., as input to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def region(self) -> builtins.str:
        '''AWS region where the S3 bucket resides.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#region ObservabilityPipeline#region}
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(self) -> typing.Optional["ObservabilityPipelineConfigSourcesAmazonS3Auth"]:
        '''auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesAmazonS3Auth"], result)

    @builtins.property
    def tls(self) -> typing.Optional["ObservabilityPipelineConfigSourcesAmazonS3Tls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesAmazonS3Tls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesAmazonS3(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonS3Auth",
    jsii_struct_bases=[],
    name_mapping={
        "assume_role": "assumeRole",
        "external_id": "externalId",
        "session_name": "sessionName",
    },
)
class ObservabilityPipelineConfigSourcesAmazonS3Auth:
    def __init__(
        self,
        *,
        assume_role: typing.Optional[builtins.str] = None,
        external_id: typing.Optional[builtins.str] = None,
        session_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param assume_role: The Amazon Resource Name (ARN) of the role to assume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        :param external_id: A unique identifier for cross-account role assumption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        :param session_name: A session identifier used for logging and tracing the assumed role session. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0642464453bcd3c7af976a86fcf10d64875e4ea7e5aa97f8a5073b23cc00b1a)
            check_type(argname="argument assume_role", value=assume_role, expected_type=type_hints["assume_role"])
            check_type(argname="argument external_id", value=external_id, expected_type=type_hints["external_id"])
            check_type(argname="argument session_name", value=session_name, expected_type=type_hints["session_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if assume_role is not None:
            self._values["assume_role"] = assume_role
        if external_id is not None:
            self._values["external_id"] = external_id
        if session_name is not None:
            self._values["session_name"] = session_name

    @builtins.property
    def assume_role(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the role to assume.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        '''
        result = self._values.get("assume_role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def external_id(self) -> typing.Optional[builtins.str]:
        '''A unique identifier for cross-account role assumption.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        '''
        result = self._values.get("external_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def session_name(self) -> typing.Optional[builtins.str]:
        '''A session identifier used for logging and tracing the assumed role session.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        result = self._values.get("session_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesAmazonS3Auth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesAmazonS3AuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonS3AuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f475c3812ef934eda4251e6c8ffa734170499b6301a59f07b37cb6bbcf451a3)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAssumeRole")
    def reset_assume_role(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAssumeRole", []))

    @jsii.member(jsii_name="resetExternalId")
    def reset_external_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExternalId", []))

    @jsii.member(jsii_name="resetSessionName")
    def reset_session_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSessionName", []))

    @builtins.property
    @jsii.member(jsii_name="assumeRoleInput")
    def assume_role_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "assumeRoleInput"))

    @builtins.property
    @jsii.member(jsii_name="externalIdInput")
    def external_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "externalIdInput"))

    @builtins.property
    @jsii.member(jsii_name="sessionNameInput")
    def session_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sessionNameInput"))

    @builtins.property
    @jsii.member(jsii_name="assumeRole")
    def assume_role(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "assumeRole"))

    @assume_role.setter
    def assume_role(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61890ab6f55e38c7faeedadc9ce8862f635aa9feb9cf31d24aac59fa0f8b3967)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "assumeRole", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="externalId")
    def external_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "externalId"))

    @external_id.setter
    def external_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e5a657dfa9862f883d647c313d4198b72ec1c7845403f5ffbf9ec4a444937ad)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "externalId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sessionName")
    def session_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sessionName"))

    @session_name.setter
    def session_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e187702d85c94d30d83f878f9c311f68d89cab8af3f79b12b39db4b5a917d3b2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sessionName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3Auth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3Auth]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3Auth]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a23d06d5750cd00f4b2964bd3b2af2784ec6e2cf05107f34f66f7c00058ba2f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesAmazonS3List(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonS3List",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b4fba9502ed63a3eb395e3c3a3731a89d5a48fb8bad6c0fcee73ec2bdeb82ea)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesAmazonS3OutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7db43fc07a40ba72823c43d1a87d3ea7e1d4d2b543f70aa5703d1a7ee7b30a26)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesAmazonS3OutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ae710f525609a123941eb88d4f9932fb0398253a411ccb67f653bd2120fd092)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33d14cb62609d8f270faa129502a417559896cf6765ad00bbb88d96e18a057c9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f19fe6f5cf713ba6e3c8e4d7eb2dcdc4e8a13039b89187308cd53b99a5e2fff2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesAmazonS3]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesAmazonS3]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesAmazonS3]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d6a3b516557e8483edff6e2ceaa7f5d0230cc8bd233c0a4ee1e8a130515665d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesAmazonS3OutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonS3OutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__776c5d32da34aa1288dd3dd290b80f8811127418b8dbc8a6948b7afdec714df7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAuth")
    def put_auth(
        self,
        *,
        assume_role: typing.Optional[builtins.str] = None,
        external_id: typing.Optional[builtins.str] = None,
        session_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param assume_role: The Amazon Resource Name (ARN) of the role to assume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#assume_role ObservabilityPipeline#assume_role}
        :param external_id: A unique identifier for cross-account role assumption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#external_id ObservabilityPipeline#external_id}
        :param session_name: A session identifier used for logging and tracing the assumed role session. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#session_name ObservabilityPipeline#session_name}
        '''
        value = ObservabilityPipelineConfigSourcesAmazonS3Auth(
            assume_role=assume_role, external_id=external_id, session_name=session_name
        )

        return typing.cast(None, jsii.invoke(self, "putAuth", [value]))

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesAmazonS3Tls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetAuth")
    def reset_auth(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAuth", []))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="auth")
    def auth(self) -> ObservabilityPipelineConfigSourcesAmazonS3AuthOutputReference:
        return typing.cast(ObservabilityPipelineConfigSourcesAmazonS3AuthOutputReference, jsii.get(self, "auth"))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesAmazonS3TlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesAmazonS3TlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="authInput")
    def auth_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3Auth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3Auth]], jsii.get(self, "authInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="regionInput")
    def region_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regionInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesAmazonS3Tls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesAmazonS3Tls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9144cd8293ad2d7e1967bdbf5a1cd2751c3f9332754c554e47352d4d64e5751a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="region")
    def region(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "region"))

    @region.setter
    def region(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__07fc5e7127a78477a0938b0ca95178458e9869f08fe4a35a0ecd8635987ab0a7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "region", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__40122e961a36c88d87f518c274abdca6a7f808555d057858a272864c2b47540b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonS3Tls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesAmazonS3Tls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__80d9d0dcf5f68b29d1c50f72d2f198a33331ea65c95b392f2228ec4c7205142b)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesAmazonS3Tls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesAmazonS3TlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesAmazonS3TlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9f368c6b2c532e8081d1c11e59b7abbb75fbed5c86be2e0f0f12b53a9c90526)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c75bbe446916c27a3b2a3aa448a346fd7e317f39f72fcdb74664e5c3b2455a92)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c7bd8e7395f34d805030cf1e0eb1257a7cc740ac263caae68c26b99785c5dba)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7cdc2db527b0da9a535bf15e07635a353dd53b3a8ed3cc548ef92f60325f9171)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3Tls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3Tls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3Tls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5f88e9c6c57ad13da7c7f58155ff31be0fd1db7527ea10a7de521ab2013b526)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesDatadogAgent",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "tls": "tls"},
)
class ObservabilityPipelineConfigSourcesDatadogAgent:
    def __init__(
        self,
        *,
        id: builtins.str,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesDatadogAgentTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique ID of the source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesDatadogAgentTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__40201c60390f36fa192eeac8d0af2513cf89c03af6641e65c0f35add37d87ebe)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique ID of the source.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tls(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigSourcesDatadogAgentTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesDatadogAgentTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesDatadogAgent(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesDatadogAgentList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesDatadogAgentList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7cb4d298dccfbae1a99f65381f3c298ed79508c6b35c88c90a6c352dff1ac84c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesDatadogAgentOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1445b660cfe5960d6e6a6811c74ecff20a88d14b6ae3430099c92d0b9c4cda9d)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesDatadogAgentOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a92151ad31d93f6e95c11400ceb4d7370170773ed92b7161676add8d88bd557e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22258c5e1a53822dbda8a82930c51bb5fb3dba2f2b02c77ac988ca5799002a70)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dac69d6abd36ca22b48c6b2b504f2f465048bb3ee2e0da90803a74d8a55c0e8d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesDatadogAgent]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesDatadogAgent]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesDatadogAgent]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c3c3cb4e6bc2164419addf08f2f631e5ada486ed221af5dcb3c4ebb0d61cd72)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesDatadogAgentOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesDatadogAgentOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__405f98baa0b8eba74e390c222687507c5ef0ddb82f7a807a62be6e3de9e3b97a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesDatadogAgentTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesDatadogAgentTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesDatadogAgentTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesDatadogAgentTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesDatadogAgentTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f5dfb5a7b5ce97d2cfc53b6fc85a61b693bd6dc19eece711917b5723d4554b5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesDatadogAgent]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesDatadogAgent]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesDatadogAgent]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17b5f01fc2a67116df0634133c082a48b04e533c19090f3c0806f9e442696735)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesDatadogAgentTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesDatadogAgentTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e1248ce1386d6f6612f15a5abcbbc84d0bb2700663daff7defe11323c2b3baf)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesDatadogAgentTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesDatadogAgentTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesDatadogAgentTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ecc3e40a7e2dfa553b85abdb00d6d8c8a8f2a76e6bb9eacce5beb39f96147cd1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e28492516ef7eaf0ab27516fdc5c328f418ca63e4424193c8061015d58c9c4ac)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e96fc24db2aa2d2b693c1a1a605564a7f5ff08a092fc4e3d30aa9dfe39b45f77)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5cfa784008904a2745ef31dcaae41ba3d484c2f272c399c9091c6b896226ae86)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesDatadogAgentTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesDatadogAgentTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesDatadogAgentTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b3b6172ee837de4bef4f6409a499b47dc989333cccaee51c0584ba943ab43c3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesFluentBit",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "tls": "tls"},
)
class ObservabilityPipelineConfigSourcesFluentBit:
    def __init__(
        self,
        *,
        id: builtins.str,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesFluentBitTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (for example, as the ``input`` to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesFluentBitTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2cd25eae20d2dad8351a1af1ce72dfc705b3e41186a3d76edf76cdb64409916b)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (for example, as the ``input`` to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tls(self) -> typing.Optional["ObservabilityPipelineConfigSourcesFluentBitTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesFluentBitTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesFluentBit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesFluentBitList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesFluentBitList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__393add17a7da4a090ce2467ab2b4abc33583c26af57f57276e26aaac29dea589)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesFluentBitOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2311abf9bf4a8c3519c20be559b9155b7ecb9d19ee5e76bd4f074c8a120b9046)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesFluentBitOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__800bcb5c130334fcba80fb64016e6c6c3c98c2eea1f4f66b9a7ccaaa79a95b03)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87f6940e80fe131edc59c612ced48437ec01227d39e2cbc7cc2e37de44bcdd96)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c21202673c5409286c5f4c0df2c84824ebe5ef79a85a728be0704939bfb96b70)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesFluentBit]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesFluentBit]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesFluentBit]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__590aadf9287b04e678800e2279d591dc8f7910bc5f85a3d30cfd8e805a949163)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesFluentBitOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesFluentBitOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0ca29f7e574a8f9089ddfb6541a52f83d3152ef0db3472e8e942004ce0bc1353)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesFluentBitTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesFluentBitTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesFluentBitTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesFluentBitTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesFluentBitTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbcbb6c60ddda45de9d7624cdc91e1cf4afbde2c27ac0d26b0c04e91b36ec698)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentBit]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentBit]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentBit]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb82d4d3a9ee3d3e54cd75d7680996a41aa6f12bf126999afa8c53d1c9115321)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesFluentBitTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesFluentBitTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a5f9f5bf5a8fd3d8cdd3b695e2766a81d4c1a4cb87a423d82e161c31b44cba8)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesFluentBitTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesFluentBitTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesFluentBitTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb6680abca0eb9c08dcfc644945ca754c238b502e2fe08b0e928b9b85f0bd614)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__46aeb70d6c9a9d22a2845abac1f1e83be7e8e72353bd4ed81154d0b89a529777)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f1b0b33a6e4cb0b3bb9fcb008deac4b7ca5ae7b09a1e569a96c60ab2040839e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0f38584acdd429598005b6d6f0634e35afdfb909112e8cae971c073e53d91b1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentBitTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentBitTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentBitTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82cfbe1143a737ccadb5c8f3ca9b2124c749103163f035fdaad99a14d8989eb1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesFluentd",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "tls": "tls"},
)
class ObservabilityPipelineConfigSourcesFluentd:
    def __init__(
        self,
        *,
        id: builtins.str,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesFluentdTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (for example, as the ``input`` to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesFluentdTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__449f5b3360770c32f6b1327d19442dfa5ab3501bb13792c3c1de3699ae5e0311)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (for example, as the ``input`` to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tls(self) -> typing.Optional["ObservabilityPipelineConfigSourcesFluentdTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesFluentdTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesFluentd(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesFluentdList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesFluentdList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__16a96912448a39d3d09a4456c841b628edc88ca7d9b5cf46c6f6af8032e7f4e0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesFluentdOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25cd8cb57b7ac1cf25ce856f42103054baef3965bb7ef59231e3b582516a3377)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesFluentdOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d31da2353841d1b394475aec359144d30eeb84897603c3631b6d9daa54aa83d3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1373e71dfa99e181e0ae6b2c075ac9660110c274da5d11375c939d336e551d68)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1125a7eb9a5bf0d4fd0614f9d04045457241c1778a28958e2227d4985932454)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesFluentd]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesFluentd]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesFluentd]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ffedb5d90f25fc3953e90f87fdfd6b162cd44a31a2808069a0a6d958ec2c0c90)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesFluentdOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesFluentdOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b271862879197b2066f620820d4d12d99f71967577e95b6c89f857780be19378)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesFluentdTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesFluentdTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesFluentdTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesFluentdTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesFluentdTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__43cab42fe008ae310d66d43634bf6deb54b7ae28ce98b2d56c435b2ef8855390)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentd]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentd]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentd]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2155f4df9ce6b42765394c2d0f7ff19397c007b19b146e99ace513ea72765d3e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesFluentdTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesFluentdTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a6d051675a96143ec0c5dba73c446e357c16d3a648b4bbbd4688b74e0d2a61b)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesFluentdTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesFluentdTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesFluentdTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7239af4dd1b81378ad2fd7b175076ec6fbe12e1868b1bf8cdda8bf84fa3ff539)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83e0942492667c26681ae433b7e1e47ffa6d6d06659fdd03a1bb811a747f1f76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__598b9bfe95a2bc72059f68a4c138b531887c87dc35425baf4200bfaadabae58b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c64dfdb06fa0b58fee6a809461a1031809a611cb981653bd6d5256e5b4b868c6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentdTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentdTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentdTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf9af381ec42eaf327fa4f0830c76fbf6c120cbf7e0a095a310b5ae596755f15)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesGooglePubsub",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "decoding": "decoding",
        "id": "id",
        "project": "project",
        "subscription": "subscription",
        "tls": "tls",
    },
)
class ObservabilityPipelineConfigSourcesGooglePubsub:
    def __init__(
        self,
        *,
        auth: typing.Union["ObservabilityPipelineConfigSourcesGooglePubsubAuth", typing.Dict[builtins.str, typing.Any]],
        decoding: builtins.str,
        id: builtins.str,
        project: builtins.str,
        subscription: builtins.str,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesGooglePubsubTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param auth: auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        :param decoding: The decoding format used to interpret incoming logs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#decoding ObservabilityPipeline#decoding}
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (e.g., as input to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param project: The GCP project ID that owns the Pub/Sub subscription. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#project ObservabilityPipeline#project}
        :param subscription: The Pub/Sub subscription name from which messages are consumed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#subscription ObservabilityPipeline#subscription}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(auth, dict):
            auth = ObservabilityPipelineConfigSourcesGooglePubsubAuth(**auth)
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesGooglePubsubTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5fba159cc0fc5ed5bb5f4104e26f34303a8a4909efe2121aa39de21a497a4b23)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument decoding", value=decoding, expected_type=type_hints["decoding"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
            check_type(argname="argument subscription", value=subscription, expected_type=type_hints["subscription"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "decoding": decoding,
            "id": id,
            "project": project,
            "subscription": subscription,
        }
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def auth(self) -> "ObservabilityPipelineConfigSourcesGooglePubsubAuth":
        '''auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth ObservabilityPipeline#auth}
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ObservabilityPipelineConfigSourcesGooglePubsubAuth", result)

    @builtins.property
    def decoding(self) -> builtins.str:
        '''The decoding format used to interpret incoming logs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#decoding ObservabilityPipeline#decoding}
        '''
        result = self._values.get("decoding")
        assert result is not None, "Required property 'decoding' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (e.g., as input to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def project(self) -> builtins.str:
        '''The GCP project ID that owns the Pub/Sub subscription.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#project ObservabilityPipeline#project}
        '''
        result = self._values.get("project")
        assert result is not None, "Required property 'project' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subscription(self) -> builtins.str:
        '''The Pub/Sub subscription name from which messages are consumed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#subscription ObservabilityPipeline#subscription}
        '''
        result = self._values.get("subscription")
        assert result is not None, "Required property 'subscription' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tls(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigSourcesGooglePubsubTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesGooglePubsubTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesGooglePubsub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesGooglePubsubAuth",
    jsii_struct_bases=[],
    name_mapping={"credentials_file": "credentialsFile"},
)
class ObservabilityPipelineConfigSourcesGooglePubsubAuth:
    def __init__(self, *, credentials_file: builtins.str) -> None:
        '''
        :param credentials_file: Path to the GCP service account key file. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#credentials_file ObservabilityPipeline#credentials_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a46a87201ca7886b435b4693cb195cc2ac759dac41350991a2ebe4c52ffc3fd)
            check_type(argname="argument credentials_file", value=credentials_file, expected_type=type_hints["credentials_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "credentials_file": credentials_file,
        }

    @builtins.property
    def credentials_file(self) -> builtins.str:
        '''Path to the GCP service account key file.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#credentials_file ObservabilityPipeline#credentials_file}
        '''
        result = self._values.get("credentials_file")
        assert result is not None, "Required property 'credentials_file' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesGooglePubsubAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesGooglePubsubAuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesGooglePubsubAuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5f08f2a06d563674f4bdcd3cabd563cef70364c2f13dbd7b4f17620d94596e1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="credentialsFileInput")
    def credentials_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "credentialsFileInput"))

    @builtins.property
    @jsii.member(jsii_name="credentialsFile")
    def credentials_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "credentialsFile"))

    @credentials_file.setter
    def credentials_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82a69a46991aa50a5da0dd443710cafc018be274a46331b93214fbe16046290f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "credentialsFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsubAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsubAuth]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsubAuth]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e58e785a7c53a2d2aca876822254e2d2a97135fe338dd1be4ff4bc3dd5850dca)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesGooglePubsubList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesGooglePubsubList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a3420f48293852d0ce4f41807bcab330e7fe0851dfef17be8eb16df02000886)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesGooglePubsubOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ae4903ca1cea458150cd2b593eabb6a77cef8bd7eb2feeeb5d3514e94ed0a69)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesGooglePubsubOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd13f55fb7ac356a2ddd13b8d75c918e9d7d312af96c450d54f484af033bc0d5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a557a61e42294caa1313cee6832b422095ba460d57890508ca53beba5766a3f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5586bf7503c7a45dde71e81b5b583ce28c57baad8db9bf7b9c048fdfd7dcf448)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesGooglePubsub]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesGooglePubsub]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesGooglePubsub]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c76146663e8392d4a47f489b98e54e7df19aad199b2fc82aae37d8ae31228020)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesGooglePubsubOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesGooglePubsubOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4de0d9475ee44bff6b5feae78eb4871558048f4bc7345a00dbd5a7ea792b1eee)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAuth")
    def put_auth(self, *, credentials_file: builtins.str) -> None:
        '''
        :param credentials_file: Path to the GCP service account key file. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#credentials_file ObservabilityPipeline#credentials_file}
        '''
        value = ObservabilityPipelineConfigSourcesGooglePubsubAuth(
            credentials_file=credentials_file
        )

        return typing.cast(None, jsii.invoke(self, "putAuth", [value]))

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesGooglePubsubTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="auth")
    def auth(self) -> ObservabilityPipelineConfigSourcesGooglePubsubAuthOutputReference:
        return typing.cast(ObservabilityPipelineConfigSourcesGooglePubsubAuthOutputReference, jsii.get(self, "auth"))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesGooglePubsubTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesGooglePubsubTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="authInput")
    def auth_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsubAuth]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsubAuth]], jsii.get(self, "authInput"))

    @builtins.property
    @jsii.member(jsii_name="decodingInput")
    def decoding_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "decodingInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="projectInput")
    def project_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "projectInput"))

    @builtins.property
    @jsii.member(jsii_name="subscriptionInput")
    def subscription_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "subscriptionInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesGooglePubsubTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesGooglePubsubTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="decoding")
    def decoding(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "decoding"))

    @decoding.setter
    def decoding(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c3eaea323893f35f1069b12208dea8d53caf7098897f3791ee4f5f8d4b36173)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "decoding", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2dc8e93cbfb95031f31e013a26ba4832ad7718e3179aea5cfe7eef18243da98d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="project")
    def project(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "project"))

    @project.setter
    def project(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__09b7d5b20eea66b74c2c3d9bf6e79087d3f21f960c781630f383061e58cdb5e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "project", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="subscription")
    def subscription(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subscription"))

    @subscription.setter
    def subscription(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73c92f37326364b6a47c027b4c33be8f06e25aee2b886f6f5bc1216c7b4c12d5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "subscription", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsub]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsub]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsub]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3963949ab3e718a3d4e7274982be4480d7df2d398ce53b5926f2bdee27cbcc82)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesGooglePubsubTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesGooglePubsubTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__308996af2623d83413cf11eb5359a424349a4d213b4b3d55ca24c63b3bdb638f)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesGooglePubsubTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesGooglePubsubTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesGooglePubsubTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a642671dee803811040423d6d91c0a3e8385d4ff371a0d3e6e5ec5cf4b33e52)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed2c939177282424d7aa4446aa6481ffe686c80a6dc85f58a0cbe1d4d5c52fd2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70be470027162e35f917efce474c2af0efc2f0d2d5be7a204f03267df5a78ab6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5967f2371bde3c4388725f5595a09e6dfbf21c88c46e47a11a411036b2c2f116)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsubTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsubTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsubTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b27ea97b03c179a07af36f8923ff69bc6cd19906726b728e1b6554ef502d8a1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesHttpClient",
    jsii_struct_bases=[],
    name_mapping={
        "decoding": "decoding",
        "id": "id",
        "auth_strategy": "authStrategy",
        "scrape_interval_secs": "scrapeIntervalSecs",
        "scrape_timeout_secs": "scrapeTimeoutSecs",
        "tls": "tls",
    },
)
class ObservabilityPipelineConfigSourcesHttpClient:
    def __init__(
        self,
        *,
        decoding: builtins.str,
        id: builtins.str,
        auth_strategy: typing.Optional[builtins.str] = None,
        scrape_interval_secs: typing.Optional[jsii.Number] = None,
        scrape_timeout_secs: typing.Optional[jsii.Number] = None,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesHttpClientTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param decoding: The decoding format used to interpret incoming logs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#decoding ObservabilityPipeline#decoding}
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (e.g., as input to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param auth_strategy: Optional authentication strategy for HTTP requests. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth_strategy ObservabilityPipeline#auth_strategy}
        :param scrape_interval_secs: The interval (in seconds) between HTTP scrape requests. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#scrape_interval_secs ObservabilityPipeline#scrape_interval_secs}
        :param scrape_timeout_secs: The timeout (in seconds) for each scrape request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#scrape_timeout_secs ObservabilityPipeline#scrape_timeout_secs}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesHttpClientTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e3e191518b28cdac54de1021e53567c07c8e5c90a15f5dfb5047af119a293be)
            check_type(argname="argument decoding", value=decoding, expected_type=type_hints["decoding"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument auth_strategy", value=auth_strategy, expected_type=type_hints["auth_strategy"])
            check_type(argname="argument scrape_interval_secs", value=scrape_interval_secs, expected_type=type_hints["scrape_interval_secs"])
            check_type(argname="argument scrape_timeout_secs", value=scrape_timeout_secs, expected_type=type_hints["scrape_timeout_secs"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "decoding": decoding,
            "id": id,
        }
        if auth_strategy is not None:
            self._values["auth_strategy"] = auth_strategy
        if scrape_interval_secs is not None:
            self._values["scrape_interval_secs"] = scrape_interval_secs
        if scrape_timeout_secs is not None:
            self._values["scrape_timeout_secs"] = scrape_timeout_secs
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def decoding(self) -> builtins.str:
        '''The decoding format used to interpret incoming logs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#decoding ObservabilityPipeline#decoding}
        '''
        result = self._values.get("decoding")
        assert result is not None, "Required property 'decoding' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (e.g., as input to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_strategy(self) -> typing.Optional[builtins.str]:
        '''Optional authentication strategy for HTTP requests.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth_strategy ObservabilityPipeline#auth_strategy}
        '''
        result = self._values.get("auth_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scrape_interval_secs(self) -> typing.Optional[jsii.Number]:
        '''The interval (in seconds) between HTTP scrape requests.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#scrape_interval_secs ObservabilityPipeline#scrape_interval_secs}
        '''
        result = self._values.get("scrape_interval_secs")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def scrape_timeout_secs(self) -> typing.Optional[jsii.Number]:
        '''The timeout (in seconds) for each scrape request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#scrape_timeout_secs ObservabilityPipeline#scrape_timeout_secs}
        '''
        result = self._values.get("scrape_timeout_secs")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tls(self) -> typing.Optional["ObservabilityPipelineConfigSourcesHttpClientTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesHttpClientTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesHttpClient(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesHttpClientList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesHttpClientList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__950d5cf2301754679d0d69b7d1efc1d8417fb1eb63cdf7e1febbbc950eb3c36b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesHttpClientOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8dd812aa4df778af515e30c0e6528ba61d3105c01f1aa5558f7e9f09cff2835b)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesHttpClientOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2c3a5a1a80971ba9e02d2eff39c6ff4b8d80d81a7f63cc4d0623b9b8298bf03)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a252003456b37cd5505bcdb41299bfddbd3c31798bfa7b1efc4f87b208aea682)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f2478ce9860abdb419d950951b9f83ee755037df8dc415ed5d6dcdbd12b75e9e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesHttpClient]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesHttpClient]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesHttpClient]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7a1d548e4797f03dffea03d38819438a0c0be282c2c64a334fa5d97b9dc3cb9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesHttpClientOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesHttpClientOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5bc1459d53ac55e91da6497811c3b0a8dabee8e47c2396daf70ece8424e96dcf)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesHttpClientTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetAuthStrategy")
    def reset_auth_strategy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAuthStrategy", []))

    @jsii.member(jsii_name="resetScrapeIntervalSecs")
    def reset_scrape_interval_secs(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScrapeIntervalSecs", []))

    @jsii.member(jsii_name="resetScrapeTimeoutSecs")
    def reset_scrape_timeout_secs(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScrapeTimeoutSecs", []))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesHttpClientTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesHttpClientTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="authStrategyInput")
    def auth_strategy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "authStrategyInput"))

    @builtins.property
    @jsii.member(jsii_name="decodingInput")
    def decoding_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "decodingInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="scrapeIntervalSecsInput")
    def scrape_interval_secs_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "scrapeIntervalSecsInput"))

    @builtins.property
    @jsii.member(jsii_name="scrapeTimeoutSecsInput")
    def scrape_timeout_secs_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "scrapeTimeoutSecsInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesHttpClientTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesHttpClientTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="authStrategy")
    def auth_strategy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "authStrategy"))

    @auth_strategy.setter
    def auth_strategy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__510081de4363b287a8185b64d182e4999a303444e0f0c30ce3ef659c2459d910)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "authStrategy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="decoding")
    def decoding(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "decoding"))

    @decoding.setter
    def decoding(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e27d513f4958fed881429584c9e12421468e6b7c5fa6bfd4c0e8e15ec63cb2f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "decoding", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a6c00175f3c176cc0e296ddaba656b76df99c1ef2c91ca19901402967013dc93)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="scrapeIntervalSecs")
    def scrape_interval_secs(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "scrapeIntervalSecs"))

    @scrape_interval_secs.setter
    def scrape_interval_secs(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64301dd656aaf21b039aa5dbe8bd4b33780c8e1edcf1cdf9a7bae946c30a9b44)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scrapeIntervalSecs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="scrapeTimeoutSecs")
    def scrape_timeout_secs(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "scrapeTimeoutSecs"))

    @scrape_timeout_secs.setter
    def scrape_timeout_secs(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd7ec85a24e8d2378e763b55d6129e6821e07a0b2edcd1d6a8d4ae23984b8dc1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scrapeTimeoutSecs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpClient]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpClient]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpClient]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__abea684c5db6cd559df3ec4f5aaeae194eab882f291313707247193f4c496a0e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesHttpClientTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesHttpClientTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__313fd0e30de8607003720758b782400b814694adb83c71423ba699d590280605)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesHttpClientTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesHttpClientTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesHttpClientTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88ee6cc3bb8a0bb678d607adc01cc45756d4c43991655eb00696cc88e153a0e3)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__edaa1bfe9d7bf6ecb903822cdd4a51d82d212849ca84003646f806efa7e31e34)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc60176bab0da635df1e93502672213ac369bc991780e045c0763a61d8c0e504)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7e1fe430f0855e6c9db9fb579508dc54a0a7df7250bc96d9d0e503c0e2559dd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpClientTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpClientTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpClientTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__685e92cca8ae24e33c1e4268b43a481311e5439998c96cc51df320e3898d92f8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesHttpServer",
    jsii_struct_bases=[],
    name_mapping={
        "auth_strategy": "authStrategy",
        "decoding": "decoding",
        "id": "id",
        "tls": "tls",
    },
)
class ObservabilityPipelineConfigSourcesHttpServer:
    def __init__(
        self,
        *,
        auth_strategy: builtins.str,
        decoding: builtins.str,
        id: builtins.str,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesHttpServerTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param auth_strategy: HTTP authentication method. Valid values are ``none``, ``plain``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth_strategy ObservabilityPipeline#auth_strategy}
        :param decoding: The decoding format used to interpret incoming logs. Valid values are ``json``, ``gelf``, ``syslog``, ``bytes``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#decoding ObservabilityPipeline#decoding}
        :param id: Unique ID for the HTTP server source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesHttpServerTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70796920b01305b6365d4d9974a54258b82a67c2d45c78ece475a808ba25a608)
            check_type(argname="argument auth_strategy", value=auth_strategy, expected_type=type_hints["auth_strategy"])
            check_type(argname="argument decoding", value=decoding, expected_type=type_hints["decoding"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth_strategy": auth_strategy,
            "decoding": decoding,
            "id": id,
        }
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def auth_strategy(self) -> builtins.str:
        '''HTTP authentication method. Valid values are ``none``, ``plain``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#auth_strategy ObservabilityPipeline#auth_strategy}
        '''
        result = self._values.get("auth_strategy")
        assert result is not None, "Required property 'auth_strategy' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def decoding(self) -> builtins.str:
        '''The decoding format used to interpret incoming logs. Valid values are ``json``, ``gelf``, ``syslog``, ``bytes``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#decoding ObservabilityPipeline#decoding}
        '''
        result = self._values.get("decoding")
        assert result is not None, "Required property 'decoding' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def id(self) -> builtins.str:
        '''Unique ID for the HTTP server source.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tls(self) -> typing.Optional["ObservabilityPipelineConfigSourcesHttpServerTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesHttpServerTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesHttpServer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesHttpServerList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesHttpServerList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d941524be1eb8a3ad3c28349a70177dbcb9a7a200bd1f310834bdb63f77307b8)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesHttpServerOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70964a498552b40e6bd8d4cefe7b710eebc0f772b550cf11420e9a98b696e412)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesHttpServerOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cef9cad1b0e1bf503c3d471bfbc291b9dfb6453fd9d6daa0c186d6764f6825b5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__58ed91954147a94f640c4ca1c9e10c6f0667d00fa231c9d9b0c807ec90423a33)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a242407ff5fe0fd9e948e55f4159b386ed7840586932dc0e3a0b6368f7185a1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesHttpServer]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesHttpServer]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesHttpServer]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb7c23f8991f00adfb33c75f6df14143b6d6d4274c4a3c96d50a97de91a30faf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesHttpServerOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesHttpServerOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14de3e68bfa2e696201926c73d76122f973e53e084dd0f99f76e36412d07e3e1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesHttpServerTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesHttpServerTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesHttpServerTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="authStrategyInput")
    def auth_strategy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "authStrategyInput"))

    @builtins.property
    @jsii.member(jsii_name="decodingInput")
    def decoding_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "decodingInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesHttpServerTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesHttpServerTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="authStrategy")
    def auth_strategy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "authStrategy"))

    @auth_strategy.setter
    def auth_strategy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89518dd4b4986238588b04f0be1e23517027b40001821ac4a7e00891a22af62f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "authStrategy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="decoding")
    def decoding(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "decoding"))

    @decoding.setter
    def decoding(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d727e7c9a5800d5ab8a804edad8daf868f034998649c97207b82a80b810ffd73)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "decoding", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__990e1da786e1187de393d69f8a769fd57ef2ddb78885cf258ca9b31404b8a4eb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpServer]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpServer]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpServer]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef0820a16353cb157648b6f7ed7ba1f0b7ee803a297fa8892cfdf9e6aef33771)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesHttpServerTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesHttpServerTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5171086ddf38d5a55da2a6bbf3604c620b7b2fa83c2ef49363b157e011bcbc7)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesHttpServerTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesHttpServerTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesHttpServerTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee76d9f27547e44ad03b82a306a17845d7116c9e22002735aaa15a86451bb8c4)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d80ee1166bb7921f611a650a62daf3f9eeef0ff2b99d685bc3db296d5586fe8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d446afca6638b4333b096acd7df512b9cec201c0cb9501b0b3a4384983d29186)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1cd054d6c25b917ecf93c62a8a827b6d9ce806e399bb86891cd8d10b1480df0a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpServerTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpServerTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpServerTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b788813a793699d1aa8a7a9c6500817ebf41f7eb20d2a68337b2bde17b392f26)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesKafka",
    jsii_struct_bases=[],
    name_mapping={
        "group_id": "groupId",
        "id": "id",
        "topics": "topics",
        "librdkafka_option": "librdkafkaOption",
        "sasl": "sasl",
        "tls": "tls",
    },
)
class ObservabilityPipelineConfigSourcesKafka:
    def __init__(
        self,
        *,
        group_id: builtins.str,
        id: builtins.str,
        topics: typing.Sequence[builtins.str],
        librdkafka_option: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption", typing.Dict[builtins.str, typing.Any]]]]] = None,
        sasl: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesKafkaSasl", typing.Dict[builtins.str, typing.Any]]] = None,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesKafkaTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param group_id: The Kafka consumer group ID. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#group_id ObservabilityPipeline#group_id}
        :param id: The unique ID of the source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param topics: A list of Kafka topic names to subscribe to. The source ingests messages from each topic specified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#topics ObservabilityPipeline#topics}
        :param librdkafka_option: librdkafka_option block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#librdkafka_option ObservabilityPipeline#librdkafka_option}
        :param sasl: sasl block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sasl ObservabilityPipeline#sasl}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(sasl, dict):
            sasl = ObservabilityPipelineConfigSourcesKafkaSasl(**sasl)
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesKafkaTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0bd79b2cf7c0464e23f9c8e94f48bce0ce006e782fa5311b6373760317e8d27)
            check_type(argname="argument group_id", value=group_id, expected_type=type_hints["group_id"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument topics", value=topics, expected_type=type_hints["topics"])
            check_type(argname="argument librdkafka_option", value=librdkafka_option, expected_type=type_hints["librdkafka_option"])
            check_type(argname="argument sasl", value=sasl, expected_type=type_hints["sasl"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "group_id": group_id,
            "id": id,
            "topics": topics,
        }
        if librdkafka_option is not None:
            self._values["librdkafka_option"] = librdkafka_option
        if sasl is not None:
            self._values["sasl"] = sasl
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def group_id(self) -> builtins.str:
        '''The Kafka consumer group ID.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#group_id ObservabilityPipeline#group_id}
        '''
        result = self._values.get("group_id")
        assert result is not None, "Required property 'group_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique ID of the source.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def topics(self) -> typing.List[builtins.str]:
        '''A list of Kafka topic names to subscribe to. The source ingests messages from each topic specified.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#topics ObservabilityPipeline#topics}
        '''
        result = self._values.get("topics")
        assert result is not None, "Required property 'topics' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def librdkafka_option(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption"]]]:
        '''librdkafka_option block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#librdkafka_option ObservabilityPipeline#librdkafka_option}
        '''
        result = self._values.get("librdkafka_option")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption"]]], result)

    @builtins.property
    def sasl(self) -> typing.Optional["ObservabilityPipelineConfigSourcesKafkaSasl"]:
        '''sasl block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#sasl ObservabilityPipeline#sasl}
        '''
        result = self._values.get("sasl")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesKafkaSasl"], result)

    @builtins.property
    def tls(self) -> typing.Optional["ObservabilityPipelineConfigSourcesKafkaTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesKafkaTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesKafka(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: The name of the librdkafka option. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        :param value: The value of the librdkafka option. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#value ObservabilityPipeline#value}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c5d0624a80c6c222871d6ebe171e184204118a3006ab0b82d2142b3b692e472)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the librdkafka option.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#name ObservabilityPipeline#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''The value of the librdkafka option.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#value ObservabilityPipeline#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOptionList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOptionList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__815877146f7eeb8059be1007d48c068cedbf6d686e14e473539c943c97d7449a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOptionOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e90ed0f87e8b5272e82305d5464228e6088083a2a4a60062971eed7963f750c)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOptionOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25d5d1eeae8368f66982cb98f462bb6de75c6845e73266cb003d46c3c7d58660)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__139ed0e40d7546603ce1debbe13e8e10d74f967ea0630b765466578391c762d1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9568500e1b3b049446159d7d2b785919f84e9fc68b528263b5ee54e32ce38c64)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df9a850b4ee7e351ee8265e5db14f076b67dad75411ee00a2d075cdcad2bbf63)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOptionOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOptionOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__deb6cf15ad8e2384d1a3a62d175c405052c1fceda6fc565812ac6ff17da9abb7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d931536ed43a98a1d09cfddf6699b3c98dd0d9a6cf4741b8c6572a8fd07783c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6513f9dcb7f3b77aa3528e1a027158360e02e185b997dbdb7a164c5b0cd6019e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd31d6ee4bfb4f838ef0fbb863aca389c7a22eaa2ea77bb5027c5fcb746f21ab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesKafkaList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesKafkaList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1e360c55060f7aad4d70cb3f9f4d9d6b4d376e13a44a89b842beee0c44d3912)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesKafkaOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b199d24e78b213791c133e169c79090ca4a4f2dfe6d8fe53c0ec7e4a3c24e6d)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesKafkaOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3216732c27083019e24476f70e8fd1f25323408442320f635402ec59203cc7c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc099ed115eee72db525ca2256d4a145d37e9da7e1a22dd94ebb8ee3577d30cb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8416d0b954c5f7cca370f6eab77bf27d5be7e1e1d5b068d6513f284462530798)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesKafka]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesKafka]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesKafka]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83a094957d0e77752b407fcf2f7822652e81f538f8c36440cba328efc207efb6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesKafkaOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesKafkaOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5b5b34319f083966581dc59835a0f8cac9bfedd865462f47f492a03a386da30)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putLibrdkafkaOption")
    def put_librdkafka_option(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6948e6a338aa5a7846330e81694d07385095660a4b6d9924621a5f504cb053d7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putLibrdkafkaOption", [value]))

    @jsii.member(jsii_name="putSasl")
    def put_sasl(self, *, mechanism: typing.Optional[builtins.str] = None) -> None:
        '''
        :param mechanism: SASL mechanism to use (e.g., PLAIN, SCRAM-SHA-256, SCRAM-SHA-512). Valid values are ``PLAIN``, ``SCRAM-SHA-256``, ``SCRAM-SHA-512``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mechanism ObservabilityPipeline#mechanism}
        '''
        value = ObservabilityPipelineConfigSourcesKafkaSasl(mechanism=mechanism)

        return typing.cast(None, jsii.invoke(self, "putSasl", [value]))

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesKafkaTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetLibrdkafkaOption")
    def reset_librdkafka_option(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLibrdkafkaOption", []))

    @jsii.member(jsii_name="resetSasl")
    def reset_sasl(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSasl", []))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="librdkafkaOption")
    def librdkafka_option(
        self,
    ) -> ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOptionList:
        return typing.cast(ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOptionList, jsii.get(self, "librdkafkaOption"))

    @builtins.property
    @jsii.member(jsii_name="sasl")
    def sasl(self) -> "ObservabilityPipelineConfigSourcesKafkaSaslOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesKafkaSaslOutputReference", jsii.get(self, "sasl"))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesKafkaTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesKafkaTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="groupIdInput")
    def group_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "groupIdInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="librdkafkaOptionInput")
    def librdkafka_option_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption]]], jsii.get(self, "librdkafkaOptionInput"))

    @builtins.property
    @jsii.member(jsii_name="saslInput")
    def sasl_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesKafkaSasl"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesKafkaSasl"]], jsii.get(self, "saslInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesKafkaTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesKafkaTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="topicsInput")
    def topics_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "topicsInput"))

    @builtins.property
    @jsii.member(jsii_name="groupId")
    def group_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "groupId"))

    @group_id.setter
    def group_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__622359c6ffe3a4b3cdf81953983c0654ce8cf870588bfe923ad91b54dabece41)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "groupId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84892662b215c640845022678839bf4f94e724876627d34cee3513d2ef93095b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="topics")
    def topics(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "topics"))

    @topics.setter
    def topics(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9dfc515f7cade04b03f03c06623e6542a4066f9716d398c0948c9b6b30b4e1d7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "topics", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafka]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafka]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafka]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a8b183bb4fb95dfbbf0c35f44a7253b1c239e0562e6047b9db48fa1969e7d10)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesKafkaSasl",
    jsii_struct_bases=[],
    name_mapping={"mechanism": "mechanism"},
)
class ObservabilityPipelineConfigSourcesKafkaSasl:
    def __init__(self, *, mechanism: typing.Optional[builtins.str] = None) -> None:
        '''
        :param mechanism: SASL mechanism to use (e.g., PLAIN, SCRAM-SHA-256, SCRAM-SHA-512). Valid values are ``PLAIN``, ``SCRAM-SHA-256``, ``SCRAM-SHA-512``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mechanism ObservabilityPipeline#mechanism}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b6e38ce744df0cb92bf762198c4adc184d3b7f046d504de1c3685045cf9735e)
            check_type(argname="argument mechanism", value=mechanism, expected_type=type_hints["mechanism"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if mechanism is not None:
            self._values["mechanism"] = mechanism

    @builtins.property
    def mechanism(self) -> typing.Optional[builtins.str]:
        '''SASL mechanism to use (e.g., PLAIN, SCRAM-SHA-256, SCRAM-SHA-512). Valid values are ``PLAIN``, ``SCRAM-SHA-256``, ``SCRAM-SHA-512``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mechanism ObservabilityPipeline#mechanism}
        '''
        result = self._values.get("mechanism")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesKafkaSasl(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesKafkaSaslOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesKafkaSaslOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6b878721355138368deecd0a1da77a1aa730833afd1439ef23ce898f8740ff10)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetMechanism")
    def reset_mechanism(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMechanism", []))

    @builtins.property
    @jsii.member(jsii_name="mechanismInput")
    def mechanism_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "mechanismInput"))

    @builtins.property
    @jsii.member(jsii_name="mechanism")
    def mechanism(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mechanism"))

    @mechanism.setter
    def mechanism(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7bbf0f299715faef85571286f43dca85bf3d454bacbb9d8bea2fe4dd521242cb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mechanism", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafkaSasl]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafkaSasl]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafkaSasl]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1db8d1a12cd7c6f6d25049a627cff5006490281ad1b101949eb8dfb106275111)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesKafkaTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesKafkaTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94d6c7bbbd7f2b61906e176457cf1a945c1143eb7863214425d60b683a1c10f5)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesKafkaTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesKafkaTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesKafkaTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__000a52ce188d0410331c08333ed1ea695f7bd5d94181007456c5386772c41f83)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1020ee2daca202835bb81ae76cb11ab4c7c736dd047dec6ee1c5774188162218)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d9e79803cfd9e8e2b214f874bde22baea57ac0242f3c236b5618cb3fd093385)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04250b0879c2d4d54cf4ad0d3e29d8a6d1f5e45a70a47240abe5cd84d46d4fb8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafkaTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafkaTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafkaTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cce2a5a64b073f774d5aa097a3952fed90604f78b678a80e15d859f530f3ee54)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesLogstash",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "tls": "tls"},
)
class ObservabilityPipelineConfigSourcesLogstash:
    def __init__(
        self,
        *,
        id: builtins.str,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesLogstashTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (e.g., as input to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesLogstashTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00632662e2ae3748896ebdd76cd48ec33ddf96422f123ec28e3d34fab2ff26b9)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (e.g., as input to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tls(self) -> typing.Optional["ObservabilityPipelineConfigSourcesLogstashTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesLogstashTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesLogstash(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesLogstashList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesLogstashList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1880f10d144a4c4edf67c565de3dbaf45b5be17b2916e32663d4479be8761960)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesLogstashOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d6c2605b08f1e69ce12d4306458304d6d57854387a8d06f58198f11c17a3413)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesLogstashOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c8c1c3f2ca4995fe12d5c81210bd32728bdd6c96a43e67c6fa80261db6b92dce)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b04dd46fa76f9f620cca4fc4e7143c90b91fabd350101ce5cec7516d9abf5ad)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e1c78da85fffb0625f178303af26932d5855cbc86cd0750c3dca8a994dc6487)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesLogstash]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesLogstash]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesLogstash]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b21bec8a0c75a12be21ca182470f08bd831758d237afd171780c30d0f0d4f0c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesLogstashOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesLogstashOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e768cc9b4e0aab458cf987d857d40f9c9faacdc33860a1ce1f1f65809c5d6f2c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesLogstashTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesLogstashTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesLogstashTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesLogstashTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesLogstashTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f21497ca96e3545c1717669ecfaf6cbe91ed528fbcbde330c6abe3efc2a2a504)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesLogstash]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesLogstash]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesLogstash]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a6034e710e6901d3da07e94d5515b90b7fd0428d4b8e941d55946e1f56ebcd4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesLogstashTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesLogstashTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f3a19080c3ff74695ebca98c671327bcb468dc7e296fcb9e7fd1a04b5a6f3ab4)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesLogstashTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesLogstashTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesLogstashTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f7fba8efbbf6754dbbc90dc82f7d10a022034a659ee4749c6231635a31f436e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af1dd35dffd2dc67edc261090a0ccb9fe75b4be2991da39f2cb8ff13bc01e21c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe43d5472cfeae03929d3e2a85c9e7d6baa827b1be58c13f0a26a74bc120b729)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c0da2b364999a4e3dd2b323bd2b4744e7f89cddd284daf2b48252b61dc3b8a9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesLogstashTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesLogstashTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesLogstashTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1be112c672886cd886650f1d91b844cad51a159aedd7739a0b5d9624dc7251bf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b48de712acdfad9d5d2f7e9f51bf90cfa89a1103c4dbf1922bfaa8590b7dcce)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAmazonDataFirehose")
    def put_amazon_data_firehose(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesAmazonDataFirehose, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11adbeab3cccfefe5e9fb704888f517a3d9449c82aff154632abe031620bb0ed)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAmazonDataFirehose", [value]))

    @jsii.member(jsii_name="putAmazonS3")
    def put_amazon_s3(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesAmazonS3, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__92140c26ef63a2e0b6a9298a1d63759f13978278ed8f2e9ae9fff8b4a8e9c881)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAmazonS3", [value]))

    @jsii.member(jsii_name="putDatadogAgent")
    def put_datadog_agent(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesDatadogAgent, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c1a4612504dc0bc02164c43e0fb103a0984d6fe5dc39443dd949f6cb4e2093d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putDatadogAgent", [value]))

    @jsii.member(jsii_name="putFluentBit")
    def put_fluent_bit(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesFluentBit, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49d4b1050700ee86e4ecf16a395ca4f7d5c3bd4a1ed362d62bb21d87d74ed225)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putFluentBit", [value]))

    @jsii.member(jsii_name="putFluentd")
    def put_fluentd(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesFluentd, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2159e0d7f672df042a71e79acdef2dbdc664cf0d3385553e48abecde4fdfab0a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putFluentd", [value]))

    @jsii.member(jsii_name="putGooglePubsub")
    def put_google_pubsub(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesGooglePubsub, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4d55e7cf6df20373e570ae98ebe023c1eed18d1bfdce87e8725cf6073f5b1381)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putGooglePubsub", [value]))

    @jsii.member(jsii_name="putHttpClient")
    def put_http_client(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesHttpClient, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__860bba32e929a6c931f2d425bf09c187dc8d9bb55a372942c5c706655764145f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putHttpClient", [value]))

    @jsii.member(jsii_name="putHttpServer")
    def put_http_server(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesHttpServer, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0aa995d00830bc9702cc312103d9c7185f498ec03b1f677e191f4467e888de12)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putHttpServer", [value]))

    @jsii.member(jsii_name="putKafka")
    def put_kafka(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesKafka, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0afd50a302db25761c4c4735ab30449ba0ba4769957bd601ed8b9bfbae9d6e63)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putKafka", [value]))

    @jsii.member(jsii_name="putLogstash")
    def put_logstash(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesLogstash, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c8f907ad20d7563f028fd8e644bd785258ad4846a804c65b84071890aeb512c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putLogstash", [value]))

    @jsii.member(jsii_name="putRsyslog")
    def put_rsyslog(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesRsyslog", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf6a3bcb0e08e4fad0f94d014f33d7a877ee460cb7810e1203a5a5720189d941)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putRsyslog", [value]))

    @jsii.member(jsii_name="putSocket")
    def put_socket(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSocket", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eed231a0b55ab8220cf84c9cfcffb2933588119862020794073d5d27749355a2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSocket", [value]))

    @jsii.member(jsii_name="putSplunkHec")
    def put_splunk_hec(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSplunkHec", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__031aa6a7c56a1824e5dc35c76230fd29b1219f253856d4ad16932f33486f0454)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSplunkHec", [value]))

    @jsii.member(jsii_name="putSplunkTcp")
    def put_splunk_tcp(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSplunkTcp", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5985b2f8187374b7830ef0eaf6e4744abc0cba319a4c7d801a1d27dc36551f08)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSplunkTcp", [value]))

    @jsii.member(jsii_name="putSumoLogic")
    def put_sumo_logic(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSumoLogic", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da0c0e45cc07b8c35f7ea34df4b5a0224ee9d1415621a96ecdaa284317cf1b8f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSumoLogic", [value]))

    @jsii.member(jsii_name="putSyslogNg")
    def put_syslog_ng(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ObservabilityPipelineConfigSourcesSyslogNg", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a004f92a182e3a6b416e2d5bf73ea09a1a9b49404581b8490decae644221c699)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSyslogNg", [value]))

    @jsii.member(jsii_name="resetAmazonDataFirehose")
    def reset_amazon_data_firehose(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAmazonDataFirehose", []))

    @jsii.member(jsii_name="resetAmazonS3")
    def reset_amazon_s3(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAmazonS3", []))

    @jsii.member(jsii_name="resetDatadogAgent")
    def reset_datadog_agent(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatadogAgent", []))

    @jsii.member(jsii_name="resetFluentBit")
    def reset_fluent_bit(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFluentBit", []))

    @jsii.member(jsii_name="resetFluentd")
    def reset_fluentd(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFluentd", []))

    @jsii.member(jsii_name="resetGooglePubsub")
    def reset_google_pubsub(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGooglePubsub", []))

    @jsii.member(jsii_name="resetHttpClient")
    def reset_http_client(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpClient", []))

    @jsii.member(jsii_name="resetHttpServer")
    def reset_http_server(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpServer", []))

    @jsii.member(jsii_name="resetKafka")
    def reset_kafka(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKafka", []))

    @jsii.member(jsii_name="resetLogstash")
    def reset_logstash(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogstash", []))

    @jsii.member(jsii_name="resetRsyslog")
    def reset_rsyslog(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRsyslog", []))

    @jsii.member(jsii_name="resetSocket")
    def reset_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSocket", []))

    @jsii.member(jsii_name="resetSplunkHec")
    def reset_splunk_hec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSplunkHec", []))

    @jsii.member(jsii_name="resetSplunkTcp")
    def reset_splunk_tcp(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSplunkTcp", []))

    @jsii.member(jsii_name="resetSumoLogic")
    def reset_sumo_logic(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSumoLogic", []))

    @jsii.member(jsii_name="resetSyslogNg")
    def reset_syslog_ng(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSyslogNg", []))

    @builtins.property
    @jsii.member(jsii_name="amazonDataFirehose")
    def amazon_data_firehose(
        self,
    ) -> ObservabilityPipelineConfigSourcesAmazonDataFirehoseList:
        return typing.cast(ObservabilityPipelineConfigSourcesAmazonDataFirehoseList, jsii.get(self, "amazonDataFirehose"))

    @builtins.property
    @jsii.member(jsii_name="amazonS3")
    def amazon_s3(self) -> ObservabilityPipelineConfigSourcesAmazonS3List:
        return typing.cast(ObservabilityPipelineConfigSourcesAmazonS3List, jsii.get(self, "amazonS3"))

    @builtins.property
    @jsii.member(jsii_name="datadogAgent")
    def datadog_agent(self) -> ObservabilityPipelineConfigSourcesDatadogAgentList:
        return typing.cast(ObservabilityPipelineConfigSourcesDatadogAgentList, jsii.get(self, "datadogAgent"))

    @builtins.property
    @jsii.member(jsii_name="fluentBit")
    def fluent_bit(self) -> ObservabilityPipelineConfigSourcesFluentBitList:
        return typing.cast(ObservabilityPipelineConfigSourcesFluentBitList, jsii.get(self, "fluentBit"))

    @builtins.property
    @jsii.member(jsii_name="fluentd")
    def fluentd(self) -> ObservabilityPipelineConfigSourcesFluentdList:
        return typing.cast(ObservabilityPipelineConfigSourcesFluentdList, jsii.get(self, "fluentd"))

    @builtins.property
    @jsii.member(jsii_name="googlePubsub")
    def google_pubsub(self) -> ObservabilityPipelineConfigSourcesGooglePubsubList:
        return typing.cast(ObservabilityPipelineConfigSourcesGooglePubsubList, jsii.get(self, "googlePubsub"))

    @builtins.property
    @jsii.member(jsii_name="httpClient")
    def http_client(self) -> ObservabilityPipelineConfigSourcesHttpClientList:
        return typing.cast(ObservabilityPipelineConfigSourcesHttpClientList, jsii.get(self, "httpClient"))

    @builtins.property
    @jsii.member(jsii_name="httpServer")
    def http_server(self) -> ObservabilityPipelineConfigSourcesHttpServerList:
        return typing.cast(ObservabilityPipelineConfigSourcesHttpServerList, jsii.get(self, "httpServer"))

    @builtins.property
    @jsii.member(jsii_name="kafka")
    def kafka(self) -> ObservabilityPipelineConfigSourcesKafkaList:
        return typing.cast(ObservabilityPipelineConfigSourcesKafkaList, jsii.get(self, "kafka"))

    @builtins.property
    @jsii.member(jsii_name="logstash")
    def logstash(self) -> ObservabilityPipelineConfigSourcesLogstashList:
        return typing.cast(ObservabilityPipelineConfigSourcesLogstashList, jsii.get(self, "logstash"))

    @builtins.property
    @jsii.member(jsii_name="rsyslog")
    def rsyslog(self) -> "ObservabilityPipelineConfigSourcesRsyslogList":
        return typing.cast("ObservabilityPipelineConfigSourcesRsyslogList", jsii.get(self, "rsyslog"))

    @builtins.property
    @jsii.member(jsii_name="socket")
    def socket(self) -> "ObservabilityPipelineConfigSourcesSocketList":
        return typing.cast("ObservabilityPipelineConfigSourcesSocketList", jsii.get(self, "socket"))

    @builtins.property
    @jsii.member(jsii_name="splunkHec")
    def splunk_hec(self) -> "ObservabilityPipelineConfigSourcesSplunkHecList":
        return typing.cast("ObservabilityPipelineConfigSourcesSplunkHecList", jsii.get(self, "splunkHec"))

    @builtins.property
    @jsii.member(jsii_name="splunkTcp")
    def splunk_tcp(self) -> "ObservabilityPipelineConfigSourcesSplunkTcpList":
        return typing.cast("ObservabilityPipelineConfigSourcesSplunkTcpList", jsii.get(self, "splunkTcp"))

    @builtins.property
    @jsii.member(jsii_name="sumoLogic")
    def sumo_logic(self) -> "ObservabilityPipelineConfigSourcesSumoLogicList":
        return typing.cast("ObservabilityPipelineConfigSourcesSumoLogicList", jsii.get(self, "sumoLogic"))

    @builtins.property
    @jsii.member(jsii_name="syslogNg")
    def syslog_ng(self) -> "ObservabilityPipelineConfigSourcesSyslogNgList":
        return typing.cast("ObservabilityPipelineConfigSourcesSyslogNgList", jsii.get(self, "syslogNg"))

    @builtins.property
    @jsii.member(jsii_name="amazonDataFirehoseInput")
    def amazon_data_firehose_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesAmazonDataFirehose]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesAmazonDataFirehose]]], jsii.get(self, "amazonDataFirehoseInput"))

    @builtins.property
    @jsii.member(jsii_name="amazonS3Input")
    def amazon_s3_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesAmazonS3]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesAmazonS3]]], jsii.get(self, "amazonS3Input"))

    @builtins.property
    @jsii.member(jsii_name="datadogAgentInput")
    def datadog_agent_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesDatadogAgent]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesDatadogAgent]]], jsii.get(self, "datadogAgentInput"))

    @builtins.property
    @jsii.member(jsii_name="fluentBitInput")
    def fluent_bit_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesFluentBit]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesFluentBit]]], jsii.get(self, "fluentBitInput"))

    @builtins.property
    @jsii.member(jsii_name="fluentdInput")
    def fluentd_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesFluentd]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesFluentd]]], jsii.get(self, "fluentdInput"))

    @builtins.property
    @jsii.member(jsii_name="googlePubsubInput")
    def google_pubsub_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesGooglePubsub]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesGooglePubsub]]], jsii.get(self, "googlePubsubInput"))

    @builtins.property
    @jsii.member(jsii_name="httpClientInput")
    def http_client_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesHttpClient]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesHttpClient]]], jsii.get(self, "httpClientInput"))

    @builtins.property
    @jsii.member(jsii_name="httpServerInput")
    def http_server_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesHttpServer]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesHttpServer]]], jsii.get(self, "httpServerInput"))

    @builtins.property
    @jsii.member(jsii_name="kafkaInput")
    def kafka_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesKafka]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesKafka]]], jsii.get(self, "kafkaInput"))

    @builtins.property
    @jsii.member(jsii_name="logstashInput")
    def logstash_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesLogstash]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesLogstash]]], jsii.get(self, "logstashInput"))

    @builtins.property
    @jsii.member(jsii_name="rsyslogInput")
    def rsyslog_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesRsyslog"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesRsyslog"]]], jsii.get(self, "rsyslogInput"))

    @builtins.property
    @jsii.member(jsii_name="socketInput")
    def socket_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSocket"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSocket"]]], jsii.get(self, "socketInput"))

    @builtins.property
    @jsii.member(jsii_name="splunkHecInput")
    def splunk_hec_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSplunkHec"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSplunkHec"]]], jsii.get(self, "splunkHecInput"))

    @builtins.property
    @jsii.member(jsii_name="splunkTcpInput")
    def splunk_tcp_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSplunkTcp"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSplunkTcp"]]], jsii.get(self, "splunkTcpInput"))

    @builtins.property
    @jsii.member(jsii_name="sumoLogicInput")
    def sumo_logic_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSumoLogic"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSumoLogic"]]], jsii.get(self, "sumoLogicInput"))

    @builtins.property
    @jsii.member(jsii_name="syslogNgInput")
    def syslog_ng_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSyslogNg"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ObservabilityPipelineConfigSourcesSyslogNg"]]], jsii.get(self, "syslogNgInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSources]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSources]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSources]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b515a1ba47e4634acb7fe55d0b955434b2dc901b54e5b829571084232f32cbd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesRsyslog",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "mode": "mode", "tls": "tls"},
)
class ObservabilityPipelineConfigSourcesRsyslog:
    def __init__(
        self,
        *,
        id: builtins.str,
        mode: typing.Optional[builtins.str] = None,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesRsyslogTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (e.g., as input to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param mode: Protocol used by the syslog source to receive messages. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mode ObservabilityPipeline#mode}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesRsyslogTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__333cfc949924460ce41d52496a76fb0aa416339cb9c3334b5b4e22f9ec603bb2)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }
        if mode is not None:
            self._values["mode"] = mode
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (e.g., as input to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        '''Protocol used by the syslog source to receive messages.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mode ObservabilityPipeline#mode}
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tls(self) -> typing.Optional["ObservabilityPipelineConfigSourcesRsyslogTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesRsyslogTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesRsyslog(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesRsyslogList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesRsyslogList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__375ab1abafe8d96c5e249635cce2422ed4a266bfd559c5d0ab8fb54fc620ddba)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesRsyslogOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49ac59f1f27563aa321c588dc3bfd6f35001e5d810ebde9455ffec4e3d697604)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesRsyslogOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04ee6d31e44b9a55e14ac2a1947b1bb45b38c73b10478f764a61625790b61aab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28809b7cef21be86b6c12043bbab96e4cf578d50b417c750e462e15532e72be6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__758978785b032aaf8ebdd1ab6a53135bf72fbffe26e649b3a40a359da0612c00)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesRsyslog]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesRsyslog]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesRsyslog]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b733bdc496cf27ca33ead91ab19a4a97fb9cdf95af061c43905f2f72f2ce4b7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesRsyslogOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesRsyslogOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6c31494c248d7281df1c12945fddd8bdcde67442268d0423709f32a74e87bed)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesRsyslogTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetMode")
    def reset_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMode", []))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesRsyslogTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesRsyslogTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesRsyslogTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesRsyslogTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef6cbe3481c997bd8fd91b08eafa382051a06943ddc9903a9b9542798df70ae8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51202d3309586b0485550b44fdc7d732159a5829d7398bed7b114ab11c98d777)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesRsyslog]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesRsyslog]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesRsyslog]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0be279cc96ac206c62e9c2618d0208e5ba136a0eaf936cb6e3f869eb422965c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesRsyslogTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesRsyslogTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d96dde02487308407e161cccaf6f08fd6ff86a5a0ecaef96107c75ee1e58f50e)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesRsyslogTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesRsyslogTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesRsyslogTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff7e989c1d2207ac54529824b807aef78d8f6932ed43926fdfb027eee68c2d5f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3090394baebed16adfd9274286d1966b1fdb748bdef708c7362896d09d8757f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0fdae11f6af7417d183df302ba55e09cc4c2f82f7e2aaa67d11c5ed5ecb6f404)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__16d82dd59f6bbe8404397f65b9a4b153eb9d3cc5151a13917ad526e3ed01b86a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesRsyslogTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesRsyslogTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesRsyslogTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f889d8dbbb849ff07889b07118d2ae090450037dd2048aa8a396aa60393ca27)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSocket",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "mode": "mode", "framing": "framing", "tls": "tls"},
)
class ObservabilityPipelineConfigSourcesSocket:
    def __init__(
        self,
        *,
        id: builtins.str,
        mode: builtins.str,
        framing: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesSocketFraming", typing.Dict[builtins.str, typing.Any]]] = None,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesSocketTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param mode: The protocol used to receive logs. Valid values are ``tcp``, ``udp``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mode ObservabilityPipeline#mode}
        :param framing: framing block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#framing ObservabilityPipeline#framing}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(framing, dict):
            framing = ObservabilityPipelineConfigSourcesSocketFraming(**framing)
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesSocketTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5dd3a661781ee69470ecef4b441002eef7c450fc8a7fd8260c704081266b9e39)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument framing", value=framing, expected_type=type_hints["framing"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
            "mode": mode,
        }
        if framing is not None:
            self._values["framing"] = framing
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> builtins.str:
        '''The protocol used to receive logs. Valid values are ``tcp``, ``udp``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mode ObservabilityPipeline#mode}
        '''
        result = self._values.get("mode")
        assert result is not None, "Required property 'mode' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def framing(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigSourcesSocketFraming"]:
        '''framing block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#framing ObservabilityPipeline#framing}
        '''
        result = self._values.get("framing")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesSocketFraming"], result)

    @builtins.property
    def tls(self) -> typing.Optional["ObservabilityPipelineConfigSourcesSocketTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesSocketTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSocketFraming",
    jsii_struct_bases=[],
    name_mapping={"character_delimited": "characterDelimited", "method": "method"},
)
class ObservabilityPipelineConfigSourcesSocketFraming:
    def __init__(
        self,
        *,
        character_delimited: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited", typing.Dict[builtins.str, typing.Any]]] = None,
        method: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param character_delimited: character_delimited block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#character_delimited ObservabilityPipeline#character_delimited}
        :param method: The framing method. Valid values are ``newline_delimited``, ``bytes``, ``character_delimited``, ``octet_counting``, ``chunked_gelf``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#method ObservabilityPipeline#method}
        '''
        if isinstance(character_delimited, dict):
            character_delimited = ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited(**character_delimited)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b7a9a67dfe0bf0b3609a737dd85f9c803d3efeea628e77f88a61bdeb837f9c7)
            check_type(argname="argument character_delimited", value=character_delimited, expected_type=type_hints["character_delimited"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if character_delimited is not None:
            self._values["character_delimited"] = character_delimited
        if method is not None:
            self._values["method"] = method

    @builtins.property
    def character_delimited(
        self,
    ) -> typing.Optional["ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited"]:
        '''character_delimited block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#character_delimited ObservabilityPipeline#character_delimited}
        '''
        result = self._values.get("character_delimited")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited"], result)

    @builtins.property
    def method(self) -> typing.Optional[builtins.str]:
        '''The framing method. Valid values are ``newline_delimited``, ``bytes``, ``character_delimited``, ``octet_counting``, ``chunked_gelf``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#method ObservabilityPipeline#method}
        '''
        result = self._values.get("method")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesSocketFraming(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited",
    jsii_struct_bases=[],
    name_mapping={"delimiter": "delimiter"},
)
class ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited:
    def __init__(self, *, delimiter: typing.Optional[builtins.str] = None) -> None:
        '''
        :param delimiter: A single ASCII character used as a delimiter. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#delimiter ObservabilityPipeline#delimiter}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7fb125bc9dd6847f936ed83559e7ebd35acc651dca19ca149735e79a14f75fa1)
            check_type(argname="argument delimiter", value=delimiter, expected_type=type_hints["delimiter"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if delimiter is not None:
            self._values["delimiter"] = delimiter

    @builtins.property
    def delimiter(self) -> typing.Optional[builtins.str]:
        '''A single ASCII character used as a delimiter.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#delimiter ObservabilityPipeline#delimiter}
        '''
        result = self._values.get("delimiter")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimitedOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimitedOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74eaf563e46430334524dce78a34eeee10940cd76c50ada377898bc6232a0001)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetDelimiter")
    def reset_delimiter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDelimiter", []))

    @builtins.property
    @jsii.member(jsii_name="delimiterInput")
    def delimiter_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "delimiterInput"))

    @builtins.property
    @jsii.member(jsii_name="delimiter")
    def delimiter(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "delimiter"))

    @delimiter.setter
    def delimiter(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7aebe4af325ba1779ee9e4796057a0a96f114adc7b6fd663018ae01b61623a2c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "delimiter", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13bb98ea128c6389a3c523f8c73ee4d89b255feaea8d5e64593553ab087b5651)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesSocketFramingOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSocketFramingOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d225c5f8bb0b73fb9297f446c2e1ec675dc0be1e77a33e4a3dc45ca3ba2c8de1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putCharacterDelimited")
    def put_character_delimited(
        self,
        *,
        delimiter: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param delimiter: A single ASCII character used as a delimiter. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#delimiter ObservabilityPipeline#delimiter}
        '''
        value = ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited(
            delimiter=delimiter
        )

        return typing.cast(None, jsii.invoke(self, "putCharacterDelimited", [value]))

    @jsii.member(jsii_name="resetCharacterDelimited")
    def reset_character_delimited(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCharacterDelimited", []))

    @jsii.member(jsii_name="resetMethod")
    def reset_method(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMethod", []))

    @builtins.property
    @jsii.member(jsii_name="characterDelimited")
    def character_delimited(
        self,
    ) -> ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimitedOutputReference:
        return typing.cast(ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimitedOutputReference, jsii.get(self, "characterDelimited"))

    @builtins.property
    @jsii.member(jsii_name="characterDelimitedInput")
    def character_delimited_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited]], jsii.get(self, "characterDelimitedInput"))

    @builtins.property
    @jsii.member(jsii_name="methodInput")
    def method_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "methodInput"))

    @builtins.property
    @jsii.member(jsii_name="method")
    def method(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "method"))

    @method.setter
    def method(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18ae1684a014220674220842cf81d7b3d7ef2eeee1ffdb75efe4107ab6e7b157)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "method", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketFraming]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketFraming]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketFraming]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c02ffb3b1831c78328c9170f665c49b012749d2e14c016672c9c0bfeb17bf60c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesSocketList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSocketList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20cda3e271400486a7ae9820f3bf0a743ba5a3581a49a000ea86e5c29519d320)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesSocketOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5fcbb88538c4c42fa8c4016c11da66afa3109bed3b8578cff1c9e16a431cd865)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesSocketOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a9e7375bd4ed32934c79c234c0341d473bfaad1b20882557ee5c54a337c0cbb0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f38258f468ced89a122a3d8e7fab9ac7bd2a19eae5629499cb4835908ab17679)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1429493dbf926d40f34a447a0355b87bddb762399184e6b753c99dd9da9ede16)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSocket]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSocket]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSocket]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b2f03bf24419e920e970bbb2b4e0205aa8167b6743df2dc220827f73d69d858)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4416435eceeb10e9b6eb93738b7655fd80aeb99be33fabe43df95ddbb3f6bda3)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putFraming")
    def put_framing(
        self,
        *,
        character_delimited: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited, typing.Dict[builtins.str, typing.Any]]] = None,
        method: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param character_delimited: character_delimited block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#character_delimited ObservabilityPipeline#character_delimited}
        :param method: The framing method. Valid values are ``newline_delimited``, ``bytes``, ``character_delimited``, ``octet_counting``, ``chunked_gelf``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#method ObservabilityPipeline#method}
        '''
        value = ObservabilityPipelineConfigSourcesSocketFraming(
            character_delimited=character_delimited, method=method
        )

        return typing.cast(None, jsii.invoke(self, "putFraming", [value]))

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesSocketTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetFraming")
    def reset_framing(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFraming", []))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="framing")
    def framing(self) -> ObservabilityPipelineConfigSourcesSocketFramingOutputReference:
        return typing.cast(ObservabilityPipelineConfigSourcesSocketFramingOutputReference, jsii.get(self, "framing"))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesSocketTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesSocketTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="framingInput")
    def framing_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketFraming]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketFraming]], jsii.get(self, "framingInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesSocketTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesSocketTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef8b7270251f8d812fb81ab7e856a371e7290d1d3de90dcf4793a8ae96857349)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b2c96fc5b8a0277a8c7f38b2bddd4c93618f21b3f91bd3d0a23eb8266b43951)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocket]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocket]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocket]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a46c2f2b563bec3f049f805a5dad577c1ac1a3a4e117033c81885ab9c29ba14e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSocketTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesSocketTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36afa286ae273d16baf77e834d6bcb476fec7b15f18b1ba29a8296b97b899380)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesSocketTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesSocketTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSocketTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f31039e3b8afcc25f5fcb6a3a0e51865e1d3f4682f7715888aee011e03183fd)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac62490dd7180c047a710a72209d7b135a533dc73019535648ee1a01936db4cd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a8796b892b48f9ee1d4c3583562a079296affb27bebd7c80728a05c378d7db9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9dd3e15a93ea8d8a48189a82b69ac47206d6055b6e4dc32992f5de91e2c6b9f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ea6f20bac48dbfef8b067e2251e569d1194699df93d8c2b9d68af78b0297228)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSplunkHec",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "tls": "tls"},
)
class ObservabilityPipelineConfigSourcesSplunkHec:
    def __init__(
        self,
        *,
        id: builtins.str,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesSplunkHecTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (e.g., as input to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesSplunkHecTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f341a0d9122e1dd3fb48de65ddb364316413f84d08f646438c6d23029d20b6b)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (e.g., as input to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tls(self) -> typing.Optional["ObservabilityPipelineConfigSourcesSplunkHecTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesSplunkHecTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesSplunkHec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesSplunkHecList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSplunkHecList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0fe57b5393b2ed0e252dbcd907b418eb06881cbbf0797d7653270e5d6359e0d0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesSplunkHecOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__958727286e4594e4946116c1e4d7123e5f8264c11d69b5e427046625f087af48)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesSplunkHecOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac1e1c746be707c3dd89389d92dc14b3cbcafdc18772c88e4be0203777df8e91)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__762f90407201b4ac6f6b72e57218fc2d811415cbbb0d364977763fa4a6a357bd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__315caf67c21fc39d5861da75d93dd38cd452d7962204a0957254426adcfc621f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSplunkHec]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSplunkHec]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSplunkHec]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b587f31a75b2d112042f94757864d4b3a189cb938123435c905075e609376f4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesSplunkHecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSplunkHecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d38aae60116982095370f3068aeded1c51331e57799a8895bec8b6ae13dd6c9)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesSplunkHecTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesSplunkHecTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesSplunkHecTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesSplunkHecTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesSplunkHecTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__93a9ddd405dd0ba8788b23ab94896457f5e2ef22eb06c9fdee46171bce35ed26)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkHec]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkHec]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkHec]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5b2cc3adb9ef8349ad4aee27921ab010ccbdea736e19c1a42389c70843354fd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSplunkHecTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesSplunkHecTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1bb980c38e14b804ec27b4b9a41cbab3d114c59cb54f0cd8cc9c84e8238a4767)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesSplunkHecTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesSplunkHecTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSplunkHecTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f21bfdd3b5ffc571424b32f96682533dd746fa667364d78495dae6df4c0e4ed)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cbaa10f8d8893e3573efbb1bdd8bf5ff4cfe249e74f64210b994e1faef3c4aad)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1b4e3aa10edf3434d0105318c561c34288ad0bcbbdab70a989dc45ab0a4cc71)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d97320ade901ed6270240907cafffea014ee619b98344e584b4aae00814807fd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkHecTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkHecTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkHecTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__443dbb6f1376cb3c29c1b4c354fb5e1c102afc5e8e400ffacbaf5bfaa28b6f10)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSplunkTcp",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "tls": "tls"},
)
class ObservabilityPipelineConfigSourcesSplunkTcp:
    def __init__(
        self,
        *,
        id: builtins.str,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesSplunkTcpTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (e.g., as input to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesSplunkTcpTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1780475ca2aea03c289c4a01e71307ef06fcda76e1db222c979690baa4a092b)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (e.g., as input to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tls(self) -> typing.Optional["ObservabilityPipelineConfigSourcesSplunkTcpTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesSplunkTcpTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesSplunkTcp(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesSplunkTcpList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSplunkTcpList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d3af8cff99bb73b99d64182512f3550cbd884a8118a43115bef3a8842ce9507)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesSplunkTcpOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e57b1de6a49433c62c3dfea2ba82edcb9a1d1097d0d1d5300f2d9700b1362789)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesSplunkTcpOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c23891b6ab75880f9ec304af1d084565c3c6ba96047c8f2536e6af83612f4fe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99b4af3e08ebf7bfcf0f4f63f0a9a57722b4ea6cd6150bc3b6f5d789f9341be2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__167c939fee5205855469b62d6dd26284c2b36efa8ed07df2dcd0109d52f888ce)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSplunkTcp]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSplunkTcp]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSplunkTcp]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a34db31d434bf1f831f1d8042c4ac3fb8676719efc7258ee28eb0b36a82f84f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesSplunkTcpOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSplunkTcpOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27a1c402d671ffda3af8f8220471cefbd502c69b8d10601bab0d975aa0dcc9da)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesSplunkTcpTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesSplunkTcpTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesSplunkTcpTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesSplunkTcpTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesSplunkTcpTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45dc6d2274f9feac1203a158d455c9072b57b1448d759ac900060845047645ce)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkTcp]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkTcp]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkTcp]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73a3aaac9062b441306b3261fd53728ef2675bca3cbc15b6c91e1b6c75251060)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSplunkTcpTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesSplunkTcpTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__77caedc7b1bfa3d34ad9a15f91187d408ea80ab5d4b755f5540ebcd05728af6c)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesSplunkTcpTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesSplunkTcpTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSplunkTcpTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__275f0e17ff0bb5de820a76753f96f399bafb2f23607c8fcc7fb2337824e6eb86)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73e4f4293245e3165f276c3cfcac3ddb713d6c63ea7169a08678e0c1f7b7463b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c940747f9a0d61d6d699195a6658799c035abcb485c5b2e3f6df7ce45397634)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c602fc443606c72bfb07d46c7d55a63edb7a3f2a26885639bc1fae5fb76c3a01)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkTcpTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkTcpTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkTcpTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb46a1d3b5e46b4bd4d2e5d69a8acdfa2e513649fe42bec9314fefe4ffef11e7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSumoLogic",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class ObservabilityPipelineConfigSourcesSumoLogic:
    def __init__(self, *, id: builtins.str) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (e.g., as input to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b0ff3a38f052df98ff009bcd0b9140e6dde3ad1530371d2c77a7cdb2ab045eb)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (e.g., as input to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesSumoLogic(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesSumoLogicList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSumoLogicList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71b917066f1980b229fa3860f7597e7de0fd640eef38a3edb1f0114de7178c0d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesSumoLogicOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6be1940a4049fb7f49f8ceeb6b40853934f93ba491196f5720b02ef092577118)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesSumoLogicOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f26b722c7a8e4b4c60a1e8fe6a8b7a21bdab28ed80789091b288d3d92c56531)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c661c63758c97f5695d140e94825caab980e37d1a8cd3c5ab6710e3997f94b98)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__321ad901cc3fdaac5780275a3cde2dcc6aa1e77236ed24607a9c5363df9fe734)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSumoLogic]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSumoLogic]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSumoLogic]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06e9b43e272671e285250aec3705313b176a74e857edbbbeec9f944326cb1ea3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesSumoLogicOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSumoLogicOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee2517c57fc4274be22e6561a02869ef78a912e77f6d3d40e1b4ce6ccc7bbf15)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eaad48e223ed645c28810a8d0c6348d9a2fc249aa030be8b04899b959554e5d1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSumoLogic]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSumoLogic]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSumoLogic]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9725041f45570baa3ed0c5b88db130a41064ba63b3416be28b61c017cd8a5114)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSyslogNg",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "mode": "mode", "tls": "tls"},
)
class ObservabilityPipelineConfigSourcesSyslogNg:
    def __init__(
        self,
        *,
        id: builtins.str,
        mode: typing.Optional[builtins.str] = None,
        tls: typing.Optional[typing.Union["ObservabilityPipelineConfigSourcesSyslogNgTls", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param id: The unique identifier for this component. Used to reference this component in other parts of the pipeline (e.g., as input to downstream components). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param mode: Protocol used by the syslog source to receive messages. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mode ObservabilityPipeline#mode}
        :param tls: tls block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        if isinstance(tls, dict):
            tls = ObservabilityPipelineConfigSourcesSyslogNgTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34002abd46dce6eac9a0480ebf11f2badadb447654d142dbad08138e4f59f95b)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }
        if mode is not None:
            self._values["mode"] = mode
        if tls is not None:
            self._values["tls"] = tls

    @builtins.property
    def id(self) -> builtins.str:
        '''The unique identifier for this component.

        Used to reference this component in other parts of the pipeline (e.g., as input to downstream components).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#id ObservabilityPipeline#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        '''Protocol used by the syslog source to receive messages.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#mode ObservabilityPipeline#mode}
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tls(self) -> typing.Optional["ObservabilityPipelineConfigSourcesSyslogNgTls"]:
        '''tls block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#tls ObservabilityPipeline#tls}
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ObservabilityPipelineConfigSourcesSyslogNgTls"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesSyslogNg(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesSyslogNgList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSyslogNgList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c55619f2dd5e536c17ab96a5e8f80c9c8e096f2806cca9e65e3019ae36387acc)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ObservabilityPipelineConfigSourcesSyslogNgOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b31f8c3597105fd4a6db5216516d959c96493685fdf52797f037a147ed82ab2c)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ObservabilityPipelineConfigSourcesSyslogNgOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2d47b030cd310393717403d94821c9b7ac02814574c090fba8164c3b772c136)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__436839e88ba74c54965530667f17056b6de4cea653f5c94830e761fa0741f24a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__31e3d7e4132840d56451dc06e6efb3644bf17b845a475931178ae59a48ecc321)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSyslogNg]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSyslogNg]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSyslogNg]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3822ebfb0d62d3e16521d9e857ac9f9120159a9577f710e9921804772287458d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ObservabilityPipelineConfigSourcesSyslogNgOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSyslogNgOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2b441f833d15d7c20acd26fd40078f4ecdd6b6030f13cb1fdeee2a8f131b409)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putTls")
    def put_tls(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        value = ObservabilityPipelineConfigSourcesSyslogNgTls(
            ca_file=ca_file, crt_file=crt_file, key_file=key_file
        )

        return typing.cast(None, jsii.invoke(self, "putTls", [value]))

    @jsii.member(jsii_name="resetMode")
    def reset_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMode", []))

    @jsii.member(jsii_name="resetTls")
    def reset_tls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTls", []))

    @builtins.property
    @jsii.member(jsii_name="tls")
    def tls(self) -> "ObservabilityPipelineConfigSourcesSyslogNgTlsOutputReference":
        return typing.cast("ObservabilityPipelineConfigSourcesSyslogNgTlsOutputReference", jsii.get(self, "tls"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="tlsInput")
    def tls_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesSyslogNgTls"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ObservabilityPipelineConfigSourcesSyslogNgTls"]], jsii.get(self, "tlsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b67248204f24d2ecafdaba33477a0081f6d47ea982962643333575cd0a8a5b1c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1aa29287d5c9bc1320b9ea50721d66218e485c32c592e03c6f7191a5e9e4399c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSyslogNg]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSyslogNg]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSyslogNg]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00d8a9a143d3706eeea4aedd391ed86deaf9c8612d71868b865547cf5cd1b854)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSyslogNgTls",
    jsii_struct_bases=[],
    name_mapping={"ca_file": "caFile", "crt_file": "crtFile", "key_file": "keyFile"},
)
class ObservabilityPipelineConfigSourcesSyslogNgTls:
    def __init__(
        self,
        *,
        ca_file: typing.Optional[builtins.str] = None,
        crt_file: typing.Optional[builtins.str] = None,
        key_file: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ca_file: Path to the Certificate Authority (CA) file used to validate the server's TLS certificate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        :param crt_file: Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        :param key_file: Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a14ae29c24727e6d0b2c0e4b3126642380ff301d9cf9941d7671f5a490cc0b5)
            check_type(argname="argument ca_file", value=ca_file, expected_type=type_hints["ca_file"])
            check_type(argname="argument crt_file", value=crt_file, expected_type=type_hints["crt_file"])
            check_type(argname="argument key_file", value=key_file, expected_type=type_hints["key_file"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_file is not None:
            self._values["ca_file"] = ca_file
        if crt_file is not None:
            self._values["crt_file"] = crt_file
        if key_file is not None:
            self._values["key_file"] = key_file

    @builtins.property
    def ca_file(self) -> typing.Optional[builtins.str]:
        '''Path to the Certificate Authority (CA) file used to validate the server's TLS certificate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#ca_file ObservabilityPipeline#ca_file}
        '''
        result = self._values.get("ca_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def crt_file(self) -> typing.Optional[builtins.str]:
        '''Path to the TLS client certificate file used to authenticate the pipeline component with upstream or downstream services.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#crt_file ObservabilityPipeline#crt_file}
        '''
        result = self._values.get("crt_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_file(self) -> typing.Optional[builtins.str]:
        '''Path to the private key file associated with the TLS client certificate. Used for mutual TLS authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/datadog/datadog/3.77.0/docs/resources/observability_pipeline#key_file ObservabilityPipeline#key_file}
        '''
        result = self._values.get("key_file")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObservabilityPipelineConfigSourcesSyslogNgTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ObservabilityPipelineConfigSourcesSyslogNgTlsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.observabilityPipeline.ObservabilityPipelineConfigSourcesSyslogNgTlsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fa64acbecfb5495641266bd8fc22f1ac001ebcfbd2bef98ecc1db2e641ec5abc)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCaFile")
    def reset_ca_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCaFile", []))

    @jsii.member(jsii_name="resetCrtFile")
    def reset_crt_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCrtFile", []))

    @jsii.member(jsii_name="resetKeyFile")
    def reset_key_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyFile", []))

    @builtins.property
    @jsii.member(jsii_name="caFileInput")
    def ca_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caFileInput"))

    @builtins.property
    @jsii.member(jsii_name="crtFileInput")
    def crt_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "crtFileInput"))

    @builtins.property
    @jsii.member(jsii_name="keyFileInput")
    def key_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyFileInput"))

    @builtins.property
    @jsii.member(jsii_name="caFile")
    def ca_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "caFile"))

    @ca_file.setter
    def ca_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a978e81625750fe3bd28b51d769a4dcd7c46700d9f436b0df5c1259f7e51b7f4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="crtFile")
    def crt_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "crtFile"))

    @crt_file.setter
    def crt_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__005b46f9c5963154edf8385e687f0d6725b49db29f0d78e3cf50be26e35eb6b8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "crtFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="keyFile")
    def key_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyFile"))

    @key_file.setter
    def key_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe01f3f75082a2cf8a096adb30feaa0e47edae5c77a49345c8b8140977b2bb08)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyFile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSyslogNgTls]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSyslogNgTls]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSyslogNgTls]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__434988332d85616272ab347b8649c76324fbdddb2d987a9d3c9427232421ee95)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


__all__ = [
    "ObservabilityPipeline",
    "ObservabilityPipelineConfig",
    "ObservabilityPipelineConfigA",
    "ObservabilityPipelineConfigAOutputReference",
    "ObservabilityPipelineConfigDestinations",
    "ObservabilityPipelineConfigDestinationsAmazonOpensearch",
    "ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth",
    "ObservabilityPipelineConfigDestinationsAmazonOpensearchAuthOutputReference",
    "ObservabilityPipelineConfigDestinationsAmazonOpensearchList",
    "ObservabilityPipelineConfigDestinationsAmazonOpensearchOutputReference",
    "ObservabilityPipelineConfigDestinationsAmazonS3",
    "ObservabilityPipelineConfigDestinationsAmazonS3Auth",
    "ObservabilityPipelineConfigDestinationsAmazonS3AuthOutputReference",
    "ObservabilityPipelineConfigDestinationsAmazonS3List",
    "ObservabilityPipelineConfigDestinationsAmazonS3OutputReference",
    "ObservabilityPipelineConfigDestinationsAmazonSecurityLake",
    "ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth",
    "ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuthOutputReference",
    "ObservabilityPipelineConfigDestinationsAmazonSecurityLakeList",
    "ObservabilityPipelineConfigDestinationsAmazonSecurityLakeOutputReference",
    "ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls",
    "ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTlsOutputReference",
    "ObservabilityPipelineConfigDestinationsAzureStorage",
    "ObservabilityPipelineConfigDestinationsAzureStorageList",
    "ObservabilityPipelineConfigDestinationsAzureStorageOutputReference",
    "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem",
    "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression",
    "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompressionOutputReference",
    "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemList",
    "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemOutputReference",
    "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls",
    "ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTlsOutputReference",
    "ObservabilityPipelineConfigDestinationsDatadogLogs",
    "ObservabilityPipelineConfigDestinationsDatadogLogsList",
    "ObservabilityPipelineConfigDestinationsDatadogLogsOutputReference",
    "ObservabilityPipelineConfigDestinationsElasticsearch",
    "ObservabilityPipelineConfigDestinationsElasticsearchList",
    "ObservabilityPipelineConfigDestinationsElasticsearchOutputReference",
    "ObservabilityPipelineConfigDestinationsGoogleChronicle",
    "ObservabilityPipelineConfigDestinationsGoogleChronicleAuth",
    "ObservabilityPipelineConfigDestinationsGoogleChronicleAuthOutputReference",
    "ObservabilityPipelineConfigDestinationsGoogleChronicleList",
    "ObservabilityPipelineConfigDestinationsGoogleChronicleOutputReference",
    "ObservabilityPipelineConfigDestinationsGoogleCloudStorage",
    "ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth",
    "ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuthOutputReference",
    "ObservabilityPipelineConfigDestinationsGoogleCloudStorageList",
    "ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata",
    "ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadataList",
    "ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadataOutputReference",
    "ObservabilityPipelineConfigDestinationsGoogleCloudStorageOutputReference",
    "ObservabilityPipelineConfigDestinationsGooglePubsub",
    "ObservabilityPipelineConfigDestinationsGooglePubsubAuth",
    "ObservabilityPipelineConfigDestinationsGooglePubsubAuthOutputReference",
    "ObservabilityPipelineConfigDestinationsGooglePubsubList",
    "ObservabilityPipelineConfigDestinationsGooglePubsubOutputReference",
    "ObservabilityPipelineConfigDestinationsGooglePubsubTls",
    "ObservabilityPipelineConfigDestinationsGooglePubsubTlsOutputReference",
    "ObservabilityPipelineConfigDestinationsMicrosoftSentinel",
    "ObservabilityPipelineConfigDestinationsMicrosoftSentinelList",
    "ObservabilityPipelineConfigDestinationsMicrosoftSentinelOutputReference",
    "ObservabilityPipelineConfigDestinationsNewRelic",
    "ObservabilityPipelineConfigDestinationsNewRelicList",
    "ObservabilityPipelineConfigDestinationsNewRelicOutputReference",
    "ObservabilityPipelineConfigDestinationsOpensearch",
    "ObservabilityPipelineConfigDestinationsOpensearchList",
    "ObservabilityPipelineConfigDestinationsOpensearchOutputReference",
    "ObservabilityPipelineConfigDestinationsOutputReference",
    "ObservabilityPipelineConfigDestinationsRsyslog",
    "ObservabilityPipelineConfigDestinationsRsyslogList",
    "ObservabilityPipelineConfigDestinationsRsyslogOutputReference",
    "ObservabilityPipelineConfigDestinationsRsyslogTls",
    "ObservabilityPipelineConfigDestinationsRsyslogTlsOutputReference",
    "ObservabilityPipelineConfigDestinationsSentinelOne",
    "ObservabilityPipelineConfigDestinationsSentinelOneList",
    "ObservabilityPipelineConfigDestinationsSentinelOneOutputReference",
    "ObservabilityPipelineConfigDestinationsSocket",
    "ObservabilityPipelineConfigDestinationsSocketFraming",
    "ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited",
    "ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimitedOutputReference",
    "ObservabilityPipelineConfigDestinationsSocketFramingOutputReference",
    "ObservabilityPipelineConfigDestinationsSocketList",
    "ObservabilityPipelineConfigDestinationsSocketOutputReference",
    "ObservabilityPipelineConfigDestinationsSocketTls",
    "ObservabilityPipelineConfigDestinationsSocketTlsOutputReference",
    "ObservabilityPipelineConfigDestinationsSplunkHec",
    "ObservabilityPipelineConfigDestinationsSplunkHecList",
    "ObservabilityPipelineConfigDestinationsSplunkHecOutputReference",
    "ObservabilityPipelineConfigDestinationsSumoLogic",
    "ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields",
    "ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFieldsList",
    "ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFieldsOutputReference",
    "ObservabilityPipelineConfigDestinationsSumoLogicList",
    "ObservabilityPipelineConfigDestinationsSumoLogicOutputReference",
    "ObservabilityPipelineConfigDestinationsSyslogNg",
    "ObservabilityPipelineConfigDestinationsSyslogNgList",
    "ObservabilityPipelineConfigDestinationsSyslogNgOutputReference",
    "ObservabilityPipelineConfigDestinationsSyslogNgTls",
    "ObservabilityPipelineConfigDestinationsSyslogNgTlsOutputReference",
    "ObservabilityPipelineConfigProcessors",
    "ObservabilityPipelineConfigProcessorsAddEnvVars",
    "ObservabilityPipelineConfigProcessorsAddEnvVarsList",
    "ObservabilityPipelineConfigProcessorsAddEnvVarsOutputReference",
    "ObservabilityPipelineConfigProcessorsAddEnvVarsVariables",
    "ObservabilityPipelineConfigProcessorsAddEnvVarsVariablesList",
    "ObservabilityPipelineConfigProcessorsAddEnvVarsVariablesOutputReference",
    "ObservabilityPipelineConfigProcessorsAddFields",
    "ObservabilityPipelineConfigProcessorsAddFieldsField",
    "ObservabilityPipelineConfigProcessorsAddFieldsFieldList",
    "ObservabilityPipelineConfigProcessorsAddFieldsFieldOutputReference",
    "ObservabilityPipelineConfigProcessorsAddFieldsList",
    "ObservabilityPipelineConfigProcessorsAddFieldsOutputReference",
    "ObservabilityPipelineConfigProcessorsCustomProcessor",
    "ObservabilityPipelineConfigProcessorsCustomProcessorList",
    "ObservabilityPipelineConfigProcessorsCustomProcessorOutputReference",
    "ObservabilityPipelineConfigProcessorsCustomProcessorRemaps",
    "ObservabilityPipelineConfigProcessorsCustomProcessorRemapsList",
    "ObservabilityPipelineConfigProcessorsCustomProcessorRemapsOutputReference",
    "ObservabilityPipelineConfigProcessorsDatadogTags",
    "ObservabilityPipelineConfigProcessorsDatadogTagsList",
    "ObservabilityPipelineConfigProcessorsDatadogTagsOutputReference",
    "ObservabilityPipelineConfigProcessorsDedupe",
    "ObservabilityPipelineConfigProcessorsDedupeList",
    "ObservabilityPipelineConfigProcessorsDedupeOutputReference",
    "ObservabilityPipelineConfigProcessorsEnrichmentTable",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableFile",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncodingOutputReference",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableFileKeyList",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableFileKeyOutputReference",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableFileOutputReference",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchemaList",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchemaOutputReference",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableGeoipOutputReference",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableList",
    "ObservabilityPipelineConfigProcessorsEnrichmentTableOutputReference",
    "ObservabilityPipelineConfigProcessorsFilter",
    "ObservabilityPipelineConfigProcessorsFilterList",
    "ObservabilityPipelineConfigProcessorsFilterOutputReference",
    "ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics",
    "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsList",
    "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics",
    "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsList",
    "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsOutputReference",
    "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue",
    "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValueOutputReference",
    "ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsOutputReference",
    "ObservabilityPipelineConfigProcessorsOcsfMapper",
    "ObservabilityPipelineConfigProcessorsOcsfMapperList",
    "ObservabilityPipelineConfigProcessorsOcsfMapperMapping",
    "ObservabilityPipelineConfigProcessorsOcsfMapperMappingList",
    "ObservabilityPipelineConfigProcessorsOcsfMapperMappingOutputReference",
    "ObservabilityPipelineConfigProcessorsOcsfMapperOutputReference",
    "ObservabilityPipelineConfigProcessorsOutputReference",
    "ObservabilityPipelineConfigProcessorsParseGrok",
    "ObservabilityPipelineConfigProcessorsParseGrokList",
    "ObservabilityPipelineConfigProcessorsParseGrokOutputReference",
    "ObservabilityPipelineConfigProcessorsParseGrokRules",
    "ObservabilityPipelineConfigProcessorsParseGrokRulesList",
    "ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule",
    "ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRuleList",
    "ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRuleOutputReference",
    "ObservabilityPipelineConfigProcessorsParseGrokRulesOutputReference",
    "ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule",
    "ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRuleList",
    "ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRuleOutputReference",
    "ObservabilityPipelineConfigProcessorsParseJson",
    "ObservabilityPipelineConfigProcessorsParseJsonList",
    "ObservabilityPipelineConfigProcessorsParseJsonOutputReference",
    "ObservabilityPipelineConfigProcessorsQuota",
    "ObservabilityPipelineConfigProcessorsQuotaLimit",
    "ObservabilityPipelineConfigProcessorsQuotaLimitOutputReference",
    "ObservabilityPipelineConfigProcessorsQuotaList",
    "ObservabilityPipelineConfigProcessorsQuotaOutputReference",
    "ObservabilityPipelineConfigProcessorsQuotaOverrides",
    "ObservabilityPipelineConfigProcessorsQuotaOverridesField",
    "ObservabilityPipelineConfigProcessorsQuotaOverridesFieldList",
    "ObservabilityPipelineConfigProcessorsQuotaOverridesFieldOutputReference",
    "ObservabilityPipelineConfigProcessorsQuotaOverridesLimit",
    "ObservabilityPipelineConfigProcessorsQuotaOverridesLimitOutputReference",
    "ObservabilityPipelineConfigProcessorsQuotaOverridesList",
    "ObservabilityPipelineConfigProcessorsQuotaOverridesOutputReference",
    "ObservabilityPipelineConfigProcessorsReduce",
    "ObservabilityPipelineConfigProcessorsReduceList",
    "ObservabilityPipelineConfigProcessorsReduceMergeStrategies",
    "ObservabilityPipelineConfigProcessorsReduceMergeStrategiesList",
    "ObservabilityPipelineConfigProcessorsReduceMergeStrategiesOutputReference",
    "ObservabilityPipelineConfigProcessorsReduceOutputReference",
    "ObservabilityPipelineConfigProcessorsRemoveFields",
    "ObservabilityPipelineConfigProcessorsRemoveFieldsList",
    "ObservabilityPipelineConfigProcessorsRemoveFieldsOutputReference",
    "ObservabilityPipelineConfigProcessorsRenameFields",
    "ObservabilityPipelineConfigProcessorsRenameFieldsField",
    "ObservabilityPipelineConfigProcessorsRenameFieldsFieldList",
    "ObservabilityPipelineConfigProcessorsRenameFieldsFieldOutputReference",
    "ObservabilityPipelineConfigProcessorsRenameFieldsList",
    "ObservabilityPipelineConfigProcessorsRenameFieldsOutputReference",
    "ObservabilityPipelineConfigProcessorsSample",
    "ObservabilityPipelineConfigProcessorsSampleList",
    "ObservabilityPipelineConfigProcessorsSampleOutputReference",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScanner",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerList",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerOutputReference",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptionsOutputReference",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesList",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHashOutputReference",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchOutputReference",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedactOutputReference",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedactOutputReference",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOutputReference",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustomOutputReference",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibraryOutputReference",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternOutputReference",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExcludeOutputReference",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeIncludeOutputReference",
    "ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeOutputReference",
    "ObservabilityPipelineConfigProcessorsThrottle",
    "ObservabilityPipelineConfigProcessorsThrottleList",
    "ObservabilityPipelineConfigProcessorsThrottleOutputReference",
    "ObservabilityPipelineConfigSources",
    "ObservabilityPipelineConfigSourcesAmazonDataFirehose",
    "ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth",
    "ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuthOutputReference",
    "ObservabilityPipelineConfigSourcesAmazonDataFirehoseList",
    "ObservabilityPipelineConfigSourcesAmazonDataFirehoseOutputReference",
    "ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls",
    "ObservabilityPipelineConfigSourcesAmazonDataFirehoseTlsOutputReference",
    "ObservabilityPipelineConfigSourcesAmazonS3",
    "ObservabilityPipelineConfigSourcesAmazonS3Auth",
    "ObservabilityPipelineConfigSourcesAmazonS3AuthOutputReference",
    "ObservabilityPipelineConfigSourcesAmazonS3List",
    "ObservabilityPipelineConfigSourcesAmazonS3OutputReference",
    "ObservabilityPipelineConfigSourcesAmazonS3Tls",
    "ObservabilityPipelineConfigSourcesAmazonS3TlsOutputReference",
    "ObservabilityPipelineConfigSourcesDatadogAgent",
    "ObservabilityPipelineConfigSourcesDatadogAgentList",
    "ObservabilityPipelineConfigSourcesDatadogAgentOutputReference",
    "ObservabilityPipelineConfigSourcesDatadogAgentTls",
    "ObservabilityPipelineConfigSourcesDatadogAgentTlsOutputReference",
    "ObservabilityPipelineConfigSourcesFluentBit",
    "ObservabilityPipelineConfigSourcesFluentBitList",
    "ObservabilityPipelineConfigSourcesFluentBitOutputReference",
    "ObservabilityPipelineConfigSourcesFluentBitTls",
    "ObservabilityPipelineConfigSourcesFluentBitTlsOutputReference",
    "ObservabilityPipelineConfigSourcesFluentd",
    "ObservabilityPipelineConfigSourcesFluentdList",
    "ObservabilityPipelineConfigSourcesFluentdOutputReference",
    "ObservabilityPipelineConfigSourcesFluentdTls",
    "ObservabilityPipelineConfigSourcesFluentdTlsOutputReference",
    "ObservabilityPipelineConfigSourcesGooglePubsub",
    "ObservabilityPipelineConfigSourcesGooglePubsubAuth",
    "ObservabilityPipelineConfigSourcesGooglePubsubAuthOutputReference",
    "ObservabilityPipelineConfigSourcesGooglePubsubList",
    "ObservabilityPipelineConfigSourcesGooglePubsubOutputReference",
    "ObservabilityPipelineConfigSourcesGooglePubsubTls",
    "ObservabilityPipelineConfigSourcesGooglePubsubTlsOutputReference",
    "ObservabilityPipelineConfigSourcesHttpClient",
    "ObservabilityPipelineConfigSourcesHttpClientList",
    "ObservabilityPipelineConfigSourcesHttpClientOutputReference",
    "ObservabilityPipelineConfigSourcesHttpClientTls",
    "ObservabilityPipelineConfigSourcesHttpClientTlsOutputReference",
    "ObservabilityPipelineConfigSourcesHttpServer",
    "ObservabilityPipelineConfigSourcesHttpServerList",
    "ObservabilityPipelineConfigSourcesHttpServerOutputReference",
    "ObservabilityPipelineConfigSourcesHttpServerTls",
    "ObservabilityPipelineConfigSourcesHttpServerTlsOutputReference",
    "ObservabilityPipelineConfigSourcesKafka",
    "ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption",
    "ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOptionList",
    "ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOptionOutputReference",
    "ObservabilityPipelineConfigSourcesKafkaList",
    "ObservabilityPipelineConfigSourcesKafkaOutputReference",
    "ObservabilityPipelineConfigSourcesKafkaSasl",
    "ObservabilityPipelineConfigSourcesKafkaSaslOutputReference",
    "ObservabilityPipelineConfigSourcesKafkaTls",
    "ObservabilityPipelineConfigSourcesKafkaTlsOutputReference",
    "ObservabilityPipelineConfigSourcesLogstash",
    "ObservabilityPipelineConfigSourcesLogstashList",
    "ObservabilityPipelineConfigSourcesLogstashOutputReference",
    "ObservabilityPipelineConfigSourcesLogstashTls",
    "ObservabilityPipelineConfigSourcesLogstashTlsOutputReference",
    "ObservabilityPipelineConfigSourcesOutputReference",
    "ObservabilityPipelineConfigSourcesRsyslog",
    "ObservabilityPipelineConfigSourcesRsyslogList",
    "ObservabilityPipelineConfigSourcesRsyslogOutputReference",
    "ObservabilityPipelineConfigSourcesRsyslogTls",
    "ObservabilityPipelineConfigSourcesRsyslogTlsOutputReference",
    "ObservabilityPipelineConfigSourcesSocket",
    "ObservabilityPipelineConfigSourcesSocketFraming",
    "ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited",
    "ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimitedOutputReference",
    "ObservabilityPipelineConfigSourcesSocketFramingOutputReference",
    "ObservabilityPipelineConfigSourcesSocketList",
    "ObservabilityPipelineConfigSourcesSocketOutputReference",
    "ObservabilityPipelineConfigSourcesSocketTls",
    "ObservabilityPipelineConfigSourcesSocketTlsOutputReference",
    "ObservabilityPipelineConfigSourcesSplunkHec",
    "ObservabilityPipelineConfigSourcesSplunkHecList",
    "ObservabilityPipelineConfigSourcesSplunkHecOutputReference",
    "ObservabilityPipelineConfigSourcesSplunkHecTls",
    "ObservabilityPipelineConfigSourcesSplunkHecTlsOutputReference",
    "ObservabilityPipelineConfigSourcesSplunkTcp",
    "ObservabilityPipelineConfigSourcesSplunkTcpList",
    "ObservabilityPipelineConfigSourcesSplunkTcpOutputReference",
    "ObservabilityPipelineConfigSourcesSplunkTcpTls",
    "ObservabilityPipelineConfigSourcesSplunkTcpTlsOutputReference",
    "ObservabilityPipelineConfigSourcesSumoLogic",
    "ObservabilityPipelineConfigSourcesSumoLogicList",
    "ObservabilityPipelineConfigSourcesSumoLogicOutputReference",
    "ObservabilityPipelineConfigSourcesSyslogNg",
    "ObservabilityPipelineConfigSourcesSyslogNgList",
    "ObservabilityPipelineConfigSourcesSyslogNgOutputReference",
    "ObservabilityPipelineConfigSourcesSyslogNgTls",
    "ObservabilityPipelineConfigSourcesSyslogNgTlsOutputReference",
]

publication.publish()

def _typecheckingstub__2ee9d464e582ae9a75da04cd684e5ea244fdbe899fe3071650dd3238886db306(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    name: builtins.str,
    config: typing.Optional[typing.Union[ObservabilityPipelineConfigA, typing.Dict[builtins.str, typing.Any]]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae63d30a4c57c3e8916b0bb55a37a0fe3c1c3b757f634d9aec4d4709eb51e2ad(
    scope: _constructs_77d1e7e8.Construct,
    import_to_id: builtins.str,
    import_from_id: builtins.str,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0d6e8aebcb558877887e4a1468bf5aaf290dffa6ecf66e6dcf4439bd42041f6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13b4c775c68f141781e3ef51e8999fecb62f12088f93e8e34e670cb2d92e51a4(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    name: builtins.str,
    config: typing.Optional[typing.Union[ObservabilityPipelineConfigA, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b66e7fb77d4a0ebfd34c20f92abdd7c2d541fe8acfad45ad868ed671d5351f48(
    *,
    destinations: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinations, typing.Dict[builtins.str, typing.Any]]] = None,
    processors: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessors, typing.Dict[builtins.str, typing.Any]]] = None,
    sources: typing.Optional[typing.Union[ObservabilityPipelineConfigSources, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e50c091225c9c55921a02474d1e20134231e0a986b3c223fd7b8d6fabfc37359(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4eb701a3b55e459a4155b0cbce02ff5a2701688f282605ac8e14cf3599cff4cd(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigA]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ade6b9ae46e12b43fc9b2b75670b6fa0834fe8bd3c5a5c300bd8a93f9a303c6(
    *,
    amazon_opensearch: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsAmazonOpensearch, typing.Dict[builtins.str, typing.Any]]]]] = None,
    amazon_s3: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsAmazonS3, typing.Dict[builtins.str, typing.Any]]]]] = None,
    amazon_security_lake: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsAmazonSecurityLake, typing.Dict[builtins.str, typing.Any]]]]] = None,
    azure_storage: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsAzureStorage, typing.Dict[builtins.str, typing.Any]]]]] = None,
    crowdstrike_next_gen_siem: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem, typing.Dict[builtins.str, typing.Any]]]]] = None,
    datadog_logs: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsDatadogLogs, typing.Dict[builtins.str, typing.Any]]]]] = None,
    elasticsearch: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsElasticsearch, typing.Dict[builtins.str, typing.Any]]]]] = None,
    google_chronicle: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsGoogleChronicle, typing.Dict[builtins.str, typing.Any]]]]] = None,
    google_cloud_storage: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsGoogleCloudStorage, typing.Dict[builtins.str, typing.Any]]]]] = None,
    google_pubsub: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsGooglePubsub, typing.Dict[builtins.str, typing.Any]]]]] = None,
    microsoft_sentinel: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsMicrosoftSentinel, typing.Dict[builtins.str, typing.Any]]]]] = None,
    new_relic: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsNewRelic, typing.Dict[builtins.str, typing.Any]]]]] = None,
    opensearch: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsOpensearch, typing.Dict[builtins.str, typing.Any]]]]] = None,
    rsyslog: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsRsyslog, typing.Dict[builtins.str, typing.Any]]]]] = None,
    sentinel_one: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsSentinelOne, typing.Dict[builtins.str, typing.Any]]]]] = None,
    socket: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsSocket, typing.Dict[builtins.str, typing.Any]]]]] = None,
    splunk_hec: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsSplunkHec, typing.Dict[builtins.str, typing.Any]]]]] = None,
    sumo_logic: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsSumoLogic, typing.Dict[builtins.str, typing.Any]]]]] = None,
    syslog_ng: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsSyslogNg, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__731b51b4d2b1c245486d7a6bad980519cee1e501c059072a810efd89e869e50c(
    *,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    auth: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    bulk_index: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__525775622076f1fadbc96e729027b66eb9a1a64a423aa37cc7ca28f3d998098d(
    *,
    strategy: builtins.str,
    assume_role: typing.Optional[builtins.str] = None,
    aws_region: typing.Optional[builtins.str] = None,
    external_id: typing.Optional[builtins.str] = None,
    session_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e8fbbafa0997f22b3431b57b18f21994d7f58357f402799464d73aaf3ed7b8c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__222ee7391e4f044b4a016d3c21ef5cb0739338247b8acb31e307554f6da7eaf2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca9cfc04c60633b7910ce7fdb9502d265950f3baa1444d2e7cc49de8fc91c002(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0874e34b844e6258e81bde3895f31a5ec8a6388eb78a7571b5428296ac36f9e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ed9f963036a71a44b2dbdb61729a0c7375ad82f75d214ad5216c76ad6dfc3d9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__500b6804db40092c287ffb1f95729a0d86658ec87187553a8984e7bf393aac77(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62986e70dac77787513d1e1994b144e61e7b9ba8977191d4dfd99ef0a89dcb1a(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonOpensearchAuth]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e40a2332b9b271a2df10f22f323015ac9c8b14cfca5b546861160acbfcaf6e3f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74c21e8f0c499869f3b7346cfad43bd5a24b5c897a7cebaf0525434c776fb122(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53ae92cabf273b2c5622d3e60943a8a59445dd7f6658ec1f7db2986658f1f8f2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__903ee2901ade7dd16751cadd2efd639105281793d34d43fb9eabb2751f90d1be(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5e7ed93bdfa3175211cbf103f20547510321095b41f26d632b4139761404b69(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05864d49f955d29943823eb304f8e30289b4e2bf0666be1f5a1a7794e20aadcc(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonOpensearch]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__547d34c7d13eba851325251e2f3a356896c7cb30cd010ca00c911379632c59a5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9a35372cde4ae9344f918e9b5aff7ee6d89d6e8dc599b1979a86f418a6d41ee(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1916dc863dd1fed5f49676b5e4b39ca58b3a56fa09ccab8684e13e2d05fb4080(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f3e891927ba929c2e08d5e8acceec5ebf5dd8b1cac213337e23666a18b930bc(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39154b2e1e47183c4fd78b895acf8aa0890faaedb6e987d54a824ceef828795f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonOpensearch]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc023ea1e9736f885f9c2c3af69f7738179b74d22274d1fb1a89a00e49a5d74a(
    *,
    bucket: builtins.str,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    key_prefix: builtins.str,
    region: builtins.str,
    storage_class: builtins.str,
    auth: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsAmazonS3Auth, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c459d41c7e8165ea1346bc4490a16e8a60a2a4af49deeb63e53211bc0c55a41(
    *,
    assume_role: typing.Optional[builtins.str] = None,
    external_id: typing.Optional[builtins.str] = None,
    session_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3058b65ec20fd2feb340c05008b150ef2b671025884698d8ffb3945b77b64755(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d357410bfe350b18f5e59538b1edf76314794d8fcd75c96a575739825b331b9f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b08c9764e59b4e26f9e56ed46192e150171c5e237faebd8253d86f13d8736046(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b22a6e59c4e46038f73de7fac7605ebec83ea00be25f67c0419c3098935b5b29(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd90c994d1d916a7dbc7593c84b518e6663e93b8688eb0a08e5c1d4896b95730(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonS3Auth]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__128736745372392bd85317b441e62eb738e795e1b5723cd309ba4d59aca2778d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b22d2940cd382dd76943916787634fae27e1972394bb2c6246d01e2e5e54476c(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28cb865e7292c459519c081688285714c8112175ee770535b3c4b973a8d3e2f4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8aae0aaf83f26177109d6feac63defa290110382ad05c2c412456bf51f516263(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4198730b81c92ea779597df1fb7d03a2ffc089516b0c6e56c9de2836c5b2db13(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7afababc0224be2af91e0df7824f243a2f7d6e0b0120b7bc7d39745a0f6240af(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonS3]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fca199665e41e4706d02dfb3b3b64b69cf8996084b3d06dcf99e803f3ef03cd2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6bc7d8c6a0ffe14df5be6731483af539c67909e294061eb1aaecce312482a8db(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e320eaecb548345b89ffec2722a0cb1c9970817ee537cdbd01d0da1d771f35e0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9daef04b1651d718711baf5e3243edf3df88bf42a9719a061466959e96d7afbd(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3adc47c1c7408723ab4b37c736847309d2440139eaa4d4edea295cbf4417f101(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fab9879e42ee9fd6f6463c0da21edf999562a79246665f351ea5591230700d36(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0dd8b2564c326776caea50f7f024c69bce8dd856c00607be3a0dc59d7207fc72(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__43c04465411bf1252b3a0946e2cb7f4e982c6ff95ed2fc9f98034ddbdb1d72e8(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonS3]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0f1e415a2d6412e0342623ad0f7a1fdc69f58b352b361c556aaa67e3f6f002d(
    *,
    bucket: builtins.str,
    custom_source_name: builtins.str,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    region: builtins.str,
    auth: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01e2e22c88c7c632b6ec106b16733acedf840d80970a9cdb8237117b83286a68(
    *,
    assume_role: typing.Optional[builtins.str] = None,
    external_id: typing.Optional[builtins.str] = None,
    session_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9b5c64ce1b640b55c0113ec7b3ff50ee4bff13125b86512e241e547008ae3fa(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ebb436e3535e0c181d0fd676fc74f71ff21ccc1e4c88c02a8d8692e23a27b4e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68b20ada9871b4ab372bb7397afcade4b505872c0026566c674f13cd5931b9a9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d93671de028c5fce6840d90d14b05494501098e13b4cdf31ac3d8eb4fa66971e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69d51796777f20e52919eee4f1e154c7205590cff724b11c66f8ae1910f67258(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLakeAuth]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6df5714e88606c4e5a3e904ffa638809ca3a53d647ea6c28b7a4add9a065656f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f2ecfd67be50f77e93dfe9b452b5fb4aed77fa44deece8e14dc564da58006332(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bae8890e40071e3527a34d71eeb85017255ba95530b6e8d786f768496b608c58(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9007747358d381af563093eede59effe1aa4d93e20d20549564beb7463ab7d7a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c64d535e5ee0bf5e5d5b9ddccaeaccfa4ea47458a389988e733c0475802688c2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17474d47ff2a97352d9ba25327c0c50f498902c434979f29c86c8a0a1cd8b712(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAmazonSecurityLake]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8425de9d4d73ee7ccaa67f7b162f8dbb9e7e0b9e61761e785c1ceacb4939bfc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7071ed51fcbfd6d36274d22287700a2982c5a6371ffe84576d085647c70c934d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9900ba4b0c7e6e85c2cc3aea1110bc0ce7007151290b02026f3bb0c3bfb486e9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57ef4b9862654cfda85b3aa0c027e629314031e03791121e023aff4fc07a4f9d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8fe244d20230c44216c13c21d3e7a5772a733bb8230a16151507b290a368d4bf(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5fab996d7a4d6b817cce21f28149eb234fa9ddc83f8b85160f314e53b207d7e3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2735877a8e658bbbc0ac268593938d33328d3607f411c549edde85c8ef4676c2(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLake]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6c60e583ccc68cf9a353b7155c827e6b6b04594880ca4e8dc22ff64ba1c9318(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dfe51498573493fe8b3cabee454eaba99d12cb2be8c11f6cf0d5d0d4f6f1c0bd(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c73daf819fae19e63f19f187efc30e94ecf80406456225c6e7d900b1465ddc40(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89ac377deba321a0b3abc6c994306cf54c7d25785140bc8c47755dd35ea46b39(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d6a9b9bdf43173d8f6e98744cee031aa3e23cae9e31ac801fed2b1d65ec3784(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fdadc7b240b092f95505ceb1370c67cf0d2bbd24057d23ad1d4c60c617ca3009(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAmazonSecurityLakeTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fdff26cda860ca33f7c2aa3e2de604c221ae52ad173232764abc5bc2fd67ea96(
    *,
    container_name: builtins.str,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    blob_prefix: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5734f10a1684173a4966cfd33916e08f53518ad191fa71dfe3193f050cc55910(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a669c4ff3b69e689b3fc213ae253a3b82d004566ee524ca2fbe4a99071bc785(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__014249dd672dadead4134c58256a34c0e9026d89c51a55878e3886468e565244(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b9e719cccd30341cc77e3bf501d1ef67ae778b801a9daf55f2ce074fdd7b21fc(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14a51f00f147efd1b56c90e66c9d3a3baad6e40f5ca562b600c00470d55cd341(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d3174effc279baae4980f16ce53fffb22cd7910a587200abfdda506e5dfe422c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsAzureStorage]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df6cf2a63bc0daf9c0167b9dabd0e07651c549ca84c9bcd7c47c739132834eec(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f68e6d7809d9a71fcd94948449d760b5053d691d4aee7219888dc3f52842f43d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec2b5ec3a98c85574896875ac1a3b8f58766251a9f5e6820a22cd70822351e82(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f43edc9de124e47a189c417f513878088220f83aa7bf88a3ed71c44a127fd69b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2653dcea9231e6abc6230ea6ab227ab61fee27c7b63ae7d2f03ee4b8870fc9c8(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd483bc6fc17d177c79f5fac71e1116b726a1767d74ed9e1baa894fdf1babbc3(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsAzureStorage]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__48991e904ebd3292529afd2230975cb5d73edc28c142a36df03b3f5b4ddd364b(
    *,
    encoding: builtins.str,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    compression: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression, typing.Dict[builtins.str, typing.Any]]] = None,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c3723e779f374c8ffc3f69a50d23ba1c3edd50378e609839091025cc07553a4(
    *,
    algorithm: typing.Optional[builtins.str] = None,
    level: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__156ad62c481da5ecf275a79e95a001e213568c9a6952d8448521c95262ac41f5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b49b17b14c359e0899c935262842796685c126d693c12110b0aebcf39841992(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9026eae6fdb6675aeab565913967da900e690970657c9676ddda4573d72494a(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d8a14a38e73efb8c19d6a7ccbab7baddbd1b2b04b57cd9a530c074ebcd1cd67(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemCompression]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9506647104068b6e97642118a8830318f295049b4d2a26713bf3c5417d0156a2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f13cc1aca198b0571263ece63691a67de39a84142773ac803285c447f0deaf4e(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2397744c92358f1fac973645c0efc02dfe7dfc0855ba67fde0ae57baa002681e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e94b63ae600e2b0c90b494d96f9f943ea16d9a5060b7af9cb5996c5fc1afe4d6(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19cc633943ad8e67952b50f09be5e171917ec4787b0d2bc4e5f998180ab19abf(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5752c6e5cb8bff2443e6dd5bdd8e52d59cb98f3280db62213005d495cae8f14(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__013492682ba0a6553fed67a0b98113d3e55fb85e260d1cb4f42a742a2f58d884(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbf11639e363efd1472817f8feb962f0d278f323fc5f01735670a76dc23aca56(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ef30b10c95cda4d9d1dcb057fc0eb6ba7f14c83ebe6c96eb631d1bea23d082e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1ece930e991f4a5c9a74b5c6a3dc9961f03c24d7417453cd8fb89acca35e198(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb55fe901f44e0daa6ca0afb535aaaca98fb7d79aedb7264464e4facea6db5d0(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e7d9a78330966d8db12e2c7dde1c1068f6a177ba78ad8d4b85136a593b4c675(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b93e45da63cb5c3db8e29227155e178128826bc0b8e36f6fcce2f599db0a42eb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c4078ffa140a7b901466f98e6d66b061272c1fb12e42f03204ea6d52d7c6777(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89f1c3d77ba2c15a31bbec39a49e517eaf081792da125dbb09b487b39e2e5a34(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24122b854ebfa6ad0601d8734082aba4fc484aa6a530483b3df24da12e36535e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e9cdcd97a0f632aa553f44910f172284f71b21482dd7f432c928a24e41f8be8(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiemTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ac7dd044594db6b267b5b808b4b6d3114fd6b446568da2576017b50d75475a7(
    *,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5aabd92b775f32011ac2e7c257e22adbcd8f1cc95689369e1bc39040d06b101(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7730a2c775288521ccf5fe9a4bf19fbe0208607b7721f4e02690fdaec0813e71(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c80e697f29b37aa467228bf645facf5643366f52d772a5b26ab343ce57431a98(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b37d312314900c4ee7072fe40ad009230acc902afa1f1c79afe052e78176b518(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__02d3ae4b31ed8c50bc5f045efbb15e93a74afe9af5d85caf73e21ef7e8f71195(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35a7af2a4bc4915faa207bf9d70e66986d25038f3950fde7a83fb1bb05d427c7(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsDatadogLogs]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a59e02a3d3fd3807823df3b953ee8ce8489fc4dd14463c24a91ea8304691f9b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2412e932c2485a20cb00476081bb7c21bd62c57159657dbfce7459ae074e7447(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__030a941fbd0ab1862c8f1031d29b9bd12dfc521fbad9065c9db6caa73d110383(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d59598cc5cfe643183aead5dba514126bc63c910e89924c6b3bb39969841463(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsDatadogLogs]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29df4ece8f2b3bb42fa2f2347fb7f7f89f8e8032060c23d6f7bf97d3d8cd67c4(
    *,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    api_version: typing.Optional[builtins.str] = None,
    bulk_index: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86b6b4057038bd264a80e5f04878990d00d9a3777125aa7fd8c5c5bab670aa9e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cda7688bdebfde07f0b5c5e31fb18b01df7c29c5b7a446a173e6a83c8c13b441(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c246a4a942f9feffbb30a8dce89ac5b55da7cbf253498bd6478350ac71217b3e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f5236f0f1d96d7ea448a67517a90d85b02eb4873963ddae30a19252fe3869c5(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e99345a2881a1a840abda8b2a32e8c5eb821bf5256c182a7413942c04407a493(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aaa83750bb1a3e8486d93d357cb2a41e6012a6a94901a0855fffc7de8e0ff030(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsElasticsearch]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f4d8ad045e721ce3d9360b0e4aa8132ef0d6bca800390f214b7a8f62d0b4f83(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb30d6c1892ce64be241e4ca78ecb58e926a6872efa0187e65915fcb88ff3fd9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9be7d09411f53a39501b1e974386f7d2700eaa05739049e14511ac755aeee137(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e977949e7c267fba18d9a3b78ab7a4b6960f79682514cfef58abc5b8a9f592a3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9faa573887c077aaee6a094d93dc6512b8561c9d4fa4a27ea587a74a93bebf32(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03dc57c8e26aac73c98fcbd0728733bcbdb5c76a8e297ee32072a337cf2d3bd8(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsElasticsearch]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71ac06731aba28b0ea70956e64fc45683a79b5c73df71da414b1dfd9d1f317ef(
    *,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    auth: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsGoogleChronicleAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    customer_id: typing.Optional[builtins.str] = None,
    encoding: typing.Optional[builtins.str] = None,
    log_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5be395439c532bdbb290e7c9d2e28c95627b1dd534f903bfbfc182d9e64091b3(
    *,
    credentials_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e7aba2f587509591d30b88f1053635ae9f9f6cecb4faf8ff7456c79a2421bdc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b21c339b44d85637cd3cbbc9107170c18cfe61aadc0e406e4fde9d2c8f9d333(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a80d5b3dce05587d2a702828e17c12d7e251c8e0af1a48a340081ab66dc8a64c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleChronicleAuth]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1527a7f65c834406856b24132e5683418d8f4b5a7263b1e51656f04e3341e84(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__caa115d8d7b99e207039d620fe742786834fea22a6f357946342c3202228e742(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c49944d185fa500d138764b4b8a8923e1772ba3f988fc12c93fa9740a044ef14(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2bcb25e3d1359f9baf009e8c12a0558a73addb6b60f67e52fd4ea3ee4f0b5c5(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ade585fa653e60c9e697726fb0eea6c3da3011846fd4dd2ec9bfb62ee564d9c9(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be8dc30cf9c0817989c8ea8c7e0d8a6006b0343a1627b7656c2fd500b34e402e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleChronicle]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3495e8a465f69e6b647a2143d4472f794ab4f48c5006a197c3cad95ab8cc5d78(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af158b8dff960333f548da2a42afd6431fe66108cfd8294dab775121a2f210e1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d13b508da21650f8ceab9d80b0d3d578adae2640ff81fd519ab10b6eacae634a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36dc43a2e8c24d063715f1dfc25867feede2bca533954c4bfad3a370e8f1c39f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84e4322714fd521597e9a315c46e1fd7f378c3bf325c2e89353c784b439a8a1a(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb0648e8f23dd4ab9c702a0fea8242ca3a00a62e5d00468a770ec6f9334caa7f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00b1e0d4e84f3a87765464afccd34ded16e61bbeb9b235724bdb81efb836dccc(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleChronicle]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__617f80393aa7b57c49eec1771181ad2762d3ce9009e0a4af68d4e1191b7a7016(
    *,
    acl: builtins.str,
    auth: typing.Union[ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth, typing.Dict[builtins.str, typing.Any]],
    bucket: builtins.str,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    storage_class: builtins.str,
    key_prefix: typing.Optional[builtins.str] = None,
    metadata: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ffe2f18e27788651e759fae90358a23c5fdf1ca18fbd6df56f2105d7ffc60589(
    *,
    credentials_file: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e4cce83c2cafa1e9364191995d0e991f13a83e777d2e14cef3a48f38e00b7f4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea8bf59e9d24eb10631c148eb448d82331c707ca020132ee7557cf5b9f456e81(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c269eca8543ba49134cc68c79cfbb4b7cdd49965b50d93eccecdd37247970bea(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorageAuth]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f86cd0eafc824fbaab60918cb68a5cbda5dc7ae98deff6cda37851cbb895a14a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3ce691a634283aa00c1f53762b716f7439152472af7daa6ca3973cbee797747(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5aa3c020d6e3ab1cf70528c25f31207c009bba942b1022bad4b2d441278adb63(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81c58edd0fe665d173f3e10775a031a766536163b2c0c53571503bfea1d1610c(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8dc44364a991187b975196261bd5881f15e17bd323a1185fab0df47986bfe24d(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b22388714a8b3464443ecc90605e31aa46a392327bebb2c31c22fba2ae9a043(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleCloudStorage]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c92e2586a228070ed58a447abaf69d4c53ebf7b1fe1d7020fb44fa29cbd33303(
    *,
    name: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__831fa85735bca62f8bc558d6a689e770e6d392115f6d3bee28870b99213aef98(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c58183bbf878fecc5c0d76a2de23f2f52bd3cd44dcd934abccbf0832a3746876(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__109a0bc3aeafeaad2dc3443933b7194d645e088557e3f61d3bacfb923987b5da(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47992d4837c60c0fcab464d6e6a1209aa8f9db32158d376df61688359846107b(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a1014a4ebf4ec8c302b2da5bb9dfd0d61087a1017b64211ce35a4addaf51345(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__466e2defe5fb4519d3897a3eb1d13e350044ee5ac42453844fbc46dbb1a781e2(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fcf9ff353ff7a21fd19bfa0c0e2a10d22221ea3a24ce7496bd1531e8cf1dd942(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f446f4a0464765c911c227e3a4192e1dc85eee9705ef21340888ec422c7a2935(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bb4a817ffd8db8b4314366406e363c6bdda56d4b9fbbc1dabf2cc1206b03d80(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19b389abf44b8964736be1966f4ed7f49639a0acc1b95b85dbaf876889a0db3f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f38fe7793defeda8d79accdce705937ab72abb78e13052ef95e8b3ec217bf5c8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__955ac1c2dcfc4e027632c7f92efe1125f207b9d1367d924db991d5caa4f945c2(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsGoogleCloudStorageMetadata, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d916fc2496ce19908ff4cffcbb64f546e582b2466f52b22e12bc52ace20ac20(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__955de0bc14457d5ff099224f9fc78f37b95f01a741c0b8c809800b49129e36ed(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20c07dc2f28522421c4bde9fbb79832fd4b8e527ed3861ac2e70f1b2c2a9657f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57af8f596fdc500719f0df919b6d18a4b07de499d02dd9b01d8d0d5365d71046(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__245577b79cc6a8740fda66e438062157a2c142999491202ba54975b06099fd23(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2afa504a250fe5ef5bb50479381e92d503af2aface9cdd653b9aeb319169ad28(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa0a40cbaeca85067f5c65368d40eac937cf034a43c5ebce005bc067e4ee5685(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGoogleCloudStorage]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5663f7927e25cec417d7911eac06c0c550a05b8f90c9e1d1e0312cf6e4d488c(
    *,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    project: builtins.str,
    topic: builtins.str,
    auth: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsGooglePubsubAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    encoding: typing.Optional[builtins.str] = None,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsGooglePubsubTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89f3272a88770be098030aac1db0c339273d4ea19c5839af5611a4484e00864f(
    *,
    credentials_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8da459416fea9a3ac0e965f1a25e855598a1609b8e6252adb957fad46e7c08ac(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c41cf30e708e455f7919037e010efc9a39e557c4dd4d4f061ada2afcc70c7073(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__911aea1a14df5874c7f6929d6a1fd9e9359c4cc7d113c1c8517d9270741f41ee(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsubAuth]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85952b0831b97fadc0505d308426b91f6e235d117826ee7fbfdcd2ce18c918df(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4673749ec791f1516a2bf22fe2165e4b85742ccd340dd89179e63764677780aa(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b36cca813ddde7b293422374f5f4979bdeeb64ed63d636a6966e2591af1a402(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11b5cb245a4de370a622cbf7a2569f85000d60527cb0033978063002525fd7c4(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14fba43bc4504f5efb535d59d1498be0fcb51722c235f34d8974f1d5c9dffcf8(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ebe54e3dc1c25644bc3cfb12a7d7e0320b5515cea4f8a6425b5a326648a813cb(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsGooglePubsub]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae5b453188d8b24c98829187df067b711cbcc8baefc4c8b919c32c1f2f8b4ebc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e5261413718c26ba68dbf0210300240792e1965945dc5700bc149667ef05d0c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__afae61bddbbb09cbf94d054a05df93b319c34c0dacb9d561862a4cf96a0ec8ad(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73bd5b80d008dfd4ba6898685720717a87d1217a178ab88655f5f4ec6a286949(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__343888629adcfaab8d591bbc6fa02a6a97038efbdb727c45be71224d9e5c761e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0f373335ff526e06f32e57df4590094fc87de73fe52f4edee09a10a75d6d922(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__247bde76cac79ce1b21451e1d8ace72bdfa2a5d267b7623732b5a1dc6a0e96e1(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsub]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e1eb16582f09399bf10219487c6436fe91e1a38c6eab9c0936e4022f8318f60f(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__589bc80d1d55ac211e294e73a67d6a9898b43fe18093493e3cb1871df8d36d65(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__834b9e4397d2c58750b0ecd7f43cfc8b7b4437ff5af7c613e113219c097a6af9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d59d994244536694a4065a0f630b97bc61f562f2c492559be6f0595e7fe18d2f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b4fa8413d71f5b122e104623b18501a7465da153131a924b2e2b813feb466aa(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e11c91cbb594e907c0125461f2fbfda24c674523f057f5efb9add288af3829d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsGooglePubsubTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5d1333b2b22a045717582ca114e95a2acdf71ec74041d3ac5f44f0d1b818530(
    *,
    client_id: builtins.str,
    dcr_immutable_id: builtins.str,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    table: builtins.str,
    tenant_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0fef03f1dcfe55a6632c4176141fdb4c3597e9e709178e868dd08d3768bd3a1f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__264e0273b8d7efcb6ae2c3a27c6b5202261edb458b23540a8df0858c5f255667(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c98045f03fbd2e0ea59020b91e96f820c390094fe1883a01f8ccce2dcef0e00(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1011a14e8e3a4d8f433e57170fe5ed87e3107ec8a3e03c903c030499fcd7dc2(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1926546ddea0465dffbd0a2dabc8daa2f6632d8e0b7abd8e8afcda062aa8bba9(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c2d9d8f9f89f4b2de7069f3ebc27fb620107b97d47a8c8ce192b13ce33f2200(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsMicrosoftSentinel]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b8c51267cf0c34d1fb3d7d9deaacb44b6e92cfd6f10f315fa3cdf0e04546d2eb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b307a9c94c4e81eef9a3738ce9d0ba2bab0e8efe4271d196a87f375308d8afa7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98b1b7ac6013b94742d3d75d4ce75dd213ba7588dc26ccd40bf8a2ad925c39a9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25fb1af54bd5af9d93d3b1af0bf584e5888c664e7ed885fce854e4deede27921(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45e1032ef107b32f76bb00125b398cde20533951e327aea090e7790c895cb336(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64da05376fff1d1c394c42d98b5bbfff970add241ea1721480fd4a32a526b2a3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f69edf98792808a4f185b9e60b3ae3e13d367a0452cadf4657114134b64bb651(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18ab9a1d98fd54fd4b609680a75ee0c44ac31881d0ee6c56a91e9ad3dbf81c0e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsMicrosoftSentinel]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3590405e36a649991fc80cbac18c2ee354021483fccd4479f7a70643e5ead550(
    *,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    region: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e5ff049961aa40e01ab9511b49c82922e81f9fd2fa2c1548dd2e51061a0bbc9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2751707ff977f4b35268f6e66d830894e780b36d0f2ae948ee673ef852e34494(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5413c6984436a9066102374a5a0be5656dd4ac79157414379a23de97784a099f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f933ec2bba687ffbf82b42d13eb246074ac5c15e61375bcc3b3c985f6e25bc2(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__322f1cc1ba55f0b3049e696b90e4b646f456a1c4d5756c198c69c8a3e4e284be(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08fb1c620214b8c0596428c967df6e16ba4f2ef4999ce4ccf7231fd69d3980db(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsNewRelic]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__352d6984388ffadf28687b15a583606237f0a8a96bff5e51f03b86863177d0f4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__721d70e026a63f4e74c141f1b587018ccc3f34f6b4b248493e328956cbca2878(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51265eb6d303db74aa71215fff927a373f84bfc6a89aeb27dbfc51e90e15687d(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61e1b39d255c4f2c782865e8fff773ca165210f224e09daf2dccb8216fda07c5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e5c33cd156afc80451b25cfcb466096e5dea0c2ddf24f64e10146d8747ffc7c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsNewRelic]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25b464225c6c1920c39e9a11f9c5d4fb745177c225df7f30d7d93d2e2920de2e(
    *,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    bulk_index: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4016ec5a099990053727cf5b299dc22598fc4e4c9bd8b40c7e53cf32a5adb2a1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4701684eedb36bf91f17dacf10d6abef2362f40495d43073f51ea0d8a1da86d(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__421045375dfdef1a0df9680b238882f58d48bb3e078c4592c31abcabde055da9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45e5f7e88202c2bfda1ed0f3c0ee22a58186d9bbc7fbedee6382bdb04b40953d(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__414a93bc0e5a00ccd836886590c4b77b5b68757dfc3812ff7e9cffb5b38c4c0f(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62dbf696c9009d4cd23d294bcf40986f831c9db3478076d7d4446c2d307cf1d8(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsOpensearch]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64fd5f98a19116c23c53dcb718f540b052c482e58aae23aa7b7016c7954d6a83(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__717f66962bd50102ae7e1e76d1da7ac5a89bef16caaa587c58a67e7485a68aa6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6ef0f4f18bed6e3b7c8db6f7b8584e3bea1d3e0e0cd4901c9005d6d89349cd2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c5bc92e4e94cab914d95e4863def628d7e2719a1758092eed9e45b30c8533c7(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d172ab5261f25b0c9f5348f4499190e7b82fba5f70e519bd14534561459ee6c3(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsOpensearch]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d550d7a34086fead61f237cd33a839da16994ae1ae0a6e1ed11052f0f4a0d72d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13162cfba8de22b94c689f178573fe9bdbb6efcc48487f1ef48f28341ca22f59(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsAmazonOpensearch, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__593c94a76c6821ad44f9a5e1fb3db5b2f34c33eedfa5fcbe0dedbc3713113a95(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsAmazonS3, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__edaa2883c9ff92c224fb648b41cb64c5af897b82a9a1b13356d4d1b90cd1bc73(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsAmazonSecurityLake, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2dd5baf36e811e4d5630d063f341216bc8fa3bbda9a18b233da53b1d2fa8d598(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsAzureStorage, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__510b526328f2bd0f301f241d44a4f74ea24e4633fa794495fd30afd7b6632e35(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsCrowdstrikeNextGenSiem, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5293fc9e077a0355ad40233c6c1dc7cb838d8410b7c8d36324e07285acd173f7(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsDatadogLogs, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e74f057d4cfe16b24eff0667c419a5cc345b8248d9c1cef7b5bba16162d44999(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsElasticsearch, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c50eacc408bfd0acd506cee8a56ccdbf17f106923033839111afea4fdfa25cf(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsGoogleChronicle, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25ef8ff59886f45b35a599c5f6b1b5ad2431024fd61481666fa47cb7770eeaba(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsGoogleCloudStorage, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1de6122d98d3866a7743394e5fd7f803b143c510b1035242d4918b9dab2eeedc(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsGooglePubsub, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11e195ee81e8b513c8e7d781fc58f22377a83106da537f915d2bd8d166a788fe(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsMicrosoftSentinel, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a88bb08a022f596729113055edd424affc46c8b12930c29830b8288a2a8ef6bb(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsNewRelic, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__72b114996a928ee45dffb878e09e2d5578954e2599bb224845443be1a2184c32(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsOpensearch, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5e064f511339f4e9d5c2b3e2d81bfd247e0029308ad00461f276cbe579610a6(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsRsyslog, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d1819704cc85ee8e8f09622774fe60cb3435845586c9d69aa6a9188ffc42a16(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsSentinelOne, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b87045b8550a30e099b9b46aa148aec7fc670def572179381eaac862fb4966b(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsSocket, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ef44b77c657cd001906a4f5a068feec3dd54a287bfeadad728d215d823a7760(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsSplunkHec, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f6b60e811ebf4cc51efc225942698e1d8807675843215b486e2043bff697f107(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsSumoLogic, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6303fa9e519bd9b189cfd04be5710a86114accd8b9f82be7c15294c12d60fe38(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsSyslogNg, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ea7d9c6e23b6786f3a83833e91aeaf27174d080a81114a4ce9ca569d4ebc754(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinations]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7142ccdf3ecc4b5e0dfb6d2012494aaa78c723090e8fe66526fdfefb3acae49d(
    *,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    keepalive: typing.Optional[jsii.Number] = None,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsRsyslogTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8babfbc54e4dadbede0307ff2c0d279992d3fce9630fceb753599343ed6d8ecc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__63bd0529e5084ac62f0c6a9769bce980f4e3c3fae20142fbe78ee7393be817f3(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71b014c0773f882c465573ef8008c5694539c4236b79ec4794edd4425d02db75(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3750ca8fbe3ae8f4ea65523e59411403ed32faeaab9e2d382231d6b3140cfa21(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf1b9aa1a62f936b6ef88666e8ec1a64f8ee17bbe5af9f0c603789d4c26dc8a5(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__579d8a5722cdd33020ea5338324af8e0828b4f6eab1a0a3fb4d7d766438ac86c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsRsyslog]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5dea350c19f57f31615402a3b58ee72b7f923ed6183760f357e8c9793fe1cbd4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fed19faf61572dd0f9ea3599c10be1319db40b2d35ade4ce6e08417e846ffb2a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2565ca5eff166cdfc95808ad94a00c917fb6201b90aa0508212c434717375c2(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b072bbd09230156c35dc0cc93d53e6fc4cf9e0b584f68bd137f19751d9d0431f(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__427d449a61f0196d8626c86d5fa3c3c24a140e7f2ac6a0fb3d8334679cd0d419(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsRsyslog]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d853470c496bba4a13e2eb385a952ae7aefd1576219f535b02da200e1d8e755(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__070fce992a0f7063525e15af6cbfcecba2494c7991d35dc8660255a2c71a611c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3656cd55c3cce57bd8c7f055bacc163e67be6a6d889eeedad4685af7e712ca83(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f18778b2d1240d7954e29169f8f8f2860dad4e4ef34da861fe068a5e576e8b1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3fa63070c8be1147a7e38efe4d54724a02c3e487e33e7e21478a7c7561c07db3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d5f5363e0ac058b70ae96b26e26759a36025a241dfdf8fa4cc9a12e127bde73(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsRsyslogTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a27ffd202ea09a0f3185a85650fd99806b242c6d5508da90ee95766050e0f87(
    *,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    region: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__feefb8391524a5553d69706df192e65262a2d2136c48e41219198d33ced8fa25(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05d391702b5f8c984d6495fb65e554a5252800c69a0bd01f27be21a5d43f2b7c(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__445cbe616ca73bdff9ce033016db18f0083e3f4d023e40c667fdb97949b4e35a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f346b2940c9f1aab2df004b11241379f8615a3a5926bb8c9e115e4855a41a02a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4cf2f54dd26475ba442e20f0eecdfb50774a69e927fc1866a2a7559db8fc3dd0(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7730a7280959d6dd706e5e99fa991d59940a1c5d9510e1ad7c6c9138583449f8(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSentinelOne]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0530b5844196e066d0d3f0be2249fd7b4e16f4d1ca8a72b0eb580ec2be6e4fab(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4332b829b5fe2d2737210992d42b3e0c128b5042bf3289521b06e4f6a4c06168(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ce73926b7affccbc0e8764df912690121f90084cf12fb87451b29d90ab49b33(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9793c2c76d802c940ed39940f96f5e97a94737823b8876419e9a8227256b5a72(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50ec37300e8542dbee37661f56f5cac7112d10d5dbe9ea94590ceb7e2cc9895a(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSentinelOne]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37107c617c953206850e31d89777c69eb036168de971ad9a63ebc9b5c8db552e(
    *,
    encoding: builtins.str,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    mode: builtins.str,
    framing: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsSocketFraming, typing.Dict[builtins.str, typing.Any]]] = None,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsSocketTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53da89384831835df78c3388f3c94044dce9393516625420ce1a7f15b62ef0fc(
    *,
    method: builtins.str,
    character_delimited: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07d8da17501f9167f80786e6c08fb3fc7ecae59ef2bdc9eb070c1e8b04222fb9(
    *,
    delimiter: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d961eea5dd547ef83593053af6bcc25a31275ceaeabf8df873474cee7049b058(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9aabffa321676f262a02486561c92dad8eac1029b6fd79ad0d36c0c5ef607d1f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__356f6248af0d99e7635e691b3383fc5cd2a1518b577bbc8a9635b4a507bc0450(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketFramingCharacterDelimited]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__612960d0a8ace394cfce4329d6d41de04e87d513e8ee6598787fd0934e8b0b67(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96a12c5d85657f84e38f5d62d4ec7e9f312b6e7d78a1372ed123f33b2843b146(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b90e974b55d0e73159db922152750ec207e9c4e5cd65ea93877869a454f0c8e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketFraming]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9cad02a2ca67d9ab7260624b83a1fea2c561c6d36f2841b863e3f1fc42eae8d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57bf402e0ebc3a49b76dce06cd32fb8978b6b5a00e8110b9b77ee1f91830089c(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c99f5eb9cda46fb8ba805257f7b288663cdf42533a847ec5474f158fcfef9e36(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5c5512a773aed42b9a5f373f8a32267a8ec1581a51dfba4c2df59284c1e7524(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2fd59deb86f4b9e17e69e8fed9bdb5122d279778cdd218c4286f5d063da99e7c(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8953425fc849a88473dcd6561574f14d41a0c0efe899b3753076076e42d6067(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSocket]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3de4a6efc5376e1c1b83f9f6dd1d867fdf1639383ac74eee824f7fe08c68d67(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f60050755b3b7dd5c0d4bc0f57be366f430ba1689cd5d12a2c3379baa28d503b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89dc4fbd861e423b1616446175ef789b4e8998e5e34c25d96048600236ca12c8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbb6b53f991d6649f98c02389fec8af1d417965806cc4b05aa6b670d7c3775e3(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b90e94b3d142abf090e74c8eabfc91d78e782fdd77f462dd56a852cbfe5821bc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da7c85ece859912aea322f15291883ad2c5ee874b39ac9b5973c366905767b36(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocket]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32df6246bb369d86e627e636ca37d577978318831121c879a612d7a5aba48eec(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4b7d5a05a851898c64b87ac76845bf87c058bfffb600485f767a6dd9602d59c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad0bbe36b691a05166bffb31c8c1a0c1954c86d28231bc50220768bf381ac221(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5e789722965deefdc5754f43ecb7d9c122f8aab942a8aef31898025cedbe040(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10d212d3c4006675f09d7ee1d6273123744dc8a81c437e7125e15e2e9856a01b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e779506aa05ae68094cc018663c65a4e393e3d0a122f3525d504a352a5318450(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSocketTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a56eb75721f7d1a494fd219c4e2d05edc81273d7beca6c8190f72b21bbf6154(
    *,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    auto_extract_timestamp: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    encoding: typing.Optional[builtins.str] = None,
    index: typing.Optional[builtins.str] = None,
    sourcetype: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2177f6145adcf515cb5437fa8e525ed227a2ee31b8887c6d78691a53bf013704(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12b4215c61190efb840f9c57b77bf804a569d697c04579cdeffe24c1838f9611(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5930d757f75101330915919b14da97c6970592e4b9cd3ac12351d7bedec44eb9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32b30953c7f6152ae78f2a92514976896c6776a075c7dc11d130ae45c63f87a7(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25d6087c8f9efd317e0d08f3c160d9d063958d100ed846b11e63bd4842e991f6(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28fd5180b2ed19cff642be29e1b679ac3d421618c8bc2ffda3c674accd5a4ed2(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSplunkHec]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fc5eb4958d73b70391e4aea0ae7758678450d9b7460a77155afa6e9633967b7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60f1439c3d8ae7ec1d137b7796061019be8bc04a145a2f8d3aa6d23cb02f7eee(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a84fd61289db017e65cadd011cd4bdea9b941f6452b5f46fdc6f4a0f6a5ec56(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f80a47aee23f000ef3fe31b0b19000194afae8f0b4d0055c393e5d2c2dfea4a5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23e0404bd36ad51ca05007dc330d08d0b4fde49e2d82934cc2db0dc2edd31caa(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7a250a03aef39c99028f9960fbdac6747e38c9db7221cd536245f6c674a3218(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__939d931d406dddb8c8cebe878dd84ccb850850efa022f9b9a9320446e61f5567(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__daea4c0fdbea36699bd732e7a58010109cd7743fded3f9d8f6e381bd462a4837(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSplunkHec]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__906af7bdc69e88755b5cc78c950df65f0648d918b09e63270a61b0d1dc139695(
    *,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    encoding: typing.Optional[builtins.str] = None,
    header_custom_fields: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields, typing.Dict[builtins.str, typing.Any]]]]] = None,
    header_host_name: typing.Optional[builtins.str] = None,
    header_source_category: typing.Optional[builtins.str] = None,
    header_source_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a02ace214114f814b6093285243b625ac8c1c76fb5eb2449d1d276261e45ad3b(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8429e2e2111deec89498791071656947fc378d4f2b48f361c5db55317323927(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e108743cf0db76a7b273a99b66a0cfb0fb73da65021cd683b358ec0eb5e8c1b(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aad9a126b4172c418f3dfca8ade0a8afbfe84ada2244872c7df42c1bec08208a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49b80d59a20fe8c85fc5e7f8278af9f1b9f3d1a7392effcdf39289c21bb9485f(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed329e6c837a017f95da152d78753ec4b17298a63e8bebe324bb16cba31c6da8(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed854754db1d2329ced72fa15f02bf5ae37598e96eda8bf7f42d4d9300ed37a1(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__afccf164b88e2c934cc5232232d8dc3698d8313905aa540cb1c80ce9b2f33194(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1d48d4ec6e63767788602731c109046d3ff34bae54841c1d549ee1a138bdb22(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b419bfbafad83c2eb6e6023ded7d3d0b887c5ff6731d261ef4529040256c7288(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6cea7d5f0c155132fbcfdff13236764fb98f0cf973974b5bdff077d5975576e6(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f1401889ed6c5106961b2e08c0d1d73a825b62e385a28a31418e32e58fdb6797(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1fc047442c975fedddb00202924a466b82e77ca9d55414251b49c4ddbb06085(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b075fed2a31dc58f825c0d529f8d99eb377ab30dc55e1beae471604529a6fd8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b38e65987feeb37b596146fc14e7c06abf12efa9e5ac0060fe6b5e6f666610f(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eaada3ab7767612ef57bf2ae17819552197889b2a92d60b533ae22fecb278af3(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d29be090e677fcd0d95f0bd354999ae6af896c2a3f9c11cba94dbc5580523c4c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSumoLogic]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c25ccd7375c6913c402316fefda8aaf84bd282033f18ea2fb2ffc84131a6f63c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29a7d5270b2464ef90877f2cb57cb22e91559eb385e2b0eb2c6566bbc47c1d24(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigDestinationsSumoLogicHeaderCustomFields, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4cb861e82845c013e36bff018758770e8b64cb24c15b5884f6a2a226b61f9f4c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7022a2c2db8fee72c32b99dbfe9dc3c1b0f7ac4f496630695dc51001c4ec97f6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f12bf55aba04b34c3b1181c224d69f585ceaa9cc3abbfc7196295761a8eeb860(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d5baa1ce3c7dcce515d850d5826b59f646600fe49275fdfa6204ad8953e601d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d38c60c6fe410e609ade7e63b512dfab7d5ea6e3a2a241f9dadf2ea89d0e994f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6a7b585c67c45b88784e2bd1dc8bcec5d11c5025fedd1ee5f52fcc5081991b6(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33fca38a261393836adec4a8437e6d9139fa5d8652f990ab696e0502f4632566(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSumoLogic]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49e769a06dc80da4fb4d7ef9e6e8b0c8deff46146da8227faef806f35d3a8d9e(
    *,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    keepalive: typing.Optional[jsii.Number] = None,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigDestinationsSyslogNgTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8ae8a58515ae61d55598ae2b415d034cec79aca4054a497bb982517f4e75bb0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db8a2f68dd54c60160e136949099efa0d8aea9b9b028fcfbfd5380841796ad89(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f0ba126ffb099407c3b8fc49655c34cb1d5f2edc9ff9354be706ca25137374a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7885f53360d62e0558376404598144eebe9b3245a4869d3b5d8f83e0bc74ad2a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d25df1a9c5808e59f079d7679247f4d58d9ed34c084f355b8849ac0f779748e9(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3c63f0eef3cbb7ef9884c5fda1c0c782dbffab410802df193cff0ad1a496196(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigDestinationsSyslogNg]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c86c75609d1e2f5a96bb6ac9c353823c3e846318cbc0438369f3223738ca1787(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f78459bdf7f5623a3d6ad255b1478aea78e4eca9e6d611b0ef042b6eca4ed7f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64f34fd5ed36b949a18c430ee05f656d712d9618bc402829b8543add16eb9fe1(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb4e7f1884cadbee8aea34eb3c434abf3153999fdf3725ae539099827b5797da(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1e3edbd206469dddb407f9319929fac9b1c87af1e06a1d93c0b8151cf14436e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSyslogNg]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b86c27f0d9b1af71760553feb2bbb4df278c351eebc1afe2d79cdafcb38ee4a1(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7edb85a65bc793fa3488058f002ff8c6b9e3a271b7d7925541725ffff8997cce(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__585789e73d3122e18b7111dcc57e2f8b0538fafed3882cb7ef0812b78f9fd399(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__629b6f045d46087d8998074ce7eb72e3e8fa7ff8a537223598fb1c3f832ca66d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__414a5e2fd09aea08d2092e133785070c468b6eb8be28527c3677ba4da6bd1b1a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__266d2f6412c2af5b030e1f4ce461f86e764fb4358b0e3af2c6b0cd8c6341fd68(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigDestinationsSyslogNgTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70735c7949657318d76c2bf80bfb931c6f4d1dda94d21c87d73dbb72b28bbd6b(
    *,
    add_env_vars: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsAddEnvVars, typing.Dict[builtins.str, typing.Any]]]]] = None,
    add_fields: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsAddFields, typing.Dict[builtins.str, typing.Any]]]]] = None,
    custom_processor: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsCustomProcessor, typing.Dict[builtins.str, typing.Any]]]]] = None,
    datadog_tags: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsDatadogTags, typing.Dict[builtins.str, typing.Any]]]]] = None,
    dedupe: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsDedupe, typing.Dict[builtins.str, typing.Any]]]]] = None,
    enrichment_table: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTable, typing.Dict[builtins.str, typing.Any]]]]] = None,
    filter: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsFilter, typing.Dict[builtins.str, typing.Any]]]]] = None,
    generate_datadog_metrics: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ocsf_mapper: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsOcsfMapper, typing.Dict[builtins.str, typing.Any]]]]] = None,
    parse_grok: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsParseGrok, typing.Dict[builtins.str, typing.Any]]]]] = None,
    parse_json: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsParseJson, typing.Dict[builtins.str, typing.Any]]]]] = None,
    quota: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsQuota, typing.Dict[builtins.str, typing.Any]]]]] = None,
    reduce: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsReduce, typing.Dict[builtins.str, typing.Any]]]]] = None,
    remove_fields: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsRemoveFields, typing.Dict[builtins.str, typing.Any]]]]] = None,
    rename_fields: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsRenameFields, typing.Dict[builtins.str, typing.Any]]]]] = None,
    sample: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsSample, typing.Dict[builtins.str, typing.Any]]]]] = None,
    sensitive_data_scanner: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScanner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    throttle: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsThrottle, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2d16b2bca318be68aee0a8101e21e69f68894f37f18602518de5df260a1597d(
    *,
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    variables: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsAddEnvVarsVariables, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18b21247df4af51912926691f40483910b549044435a8ddebf18de17d5c97eca(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e96d28aca2a9778767164d679298bde9fefc7136063cde3c4a15cd7df7fb22d(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a4ee7cdbc471677820c181eff0b8d3da0afd13b053dcd06d7cb9fac2e10f3b2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5abc46d2cb0bd5a46a4c1435814373f5ee2ab4310641e15ea6218e6f7b4d3e3a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__338a5c281c6d3ff77b3ff709e8a9bcc908e0ea7df2bff9a499b8b38a20c4ab8d(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bdccd180495cc6ac907983e1653494db91dc126f30e283c40a678b004659ecbf(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddEnvVars]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25ac1db160fbb67523c07bca378eb4f06e947f2f0e3086e9f5f9b733cf6b893e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ae2cbfba577165aa2f13ca94d13678cdf287f51791baced8da255765072f0fa(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsAddEnvVarsVariables, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8bcd4cc891e12c2f315577d20c000e11c1d78fc96c91b7bc1657299d0c42540d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ea99ca567e69608f7d37b8ab0da4360bf7160c3916dbbab0313bd90e835d602(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5a7dcb928cc8b10ea218eb3c5a0665e0be5b29487547991efc5315151bbb1b6(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__405b0d79afd5f45258c9bbd9e265f0673fcb15e947e5c69e4ff6656a0fd50d11(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddEnvVars]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d26cdd5950ea1a523f905109380e1d3c7bbc32000a11abc43223ea301a46ac1f(
    *,
    field: builtins.str,
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a05b9d163ef4742f7dc64e7987fc80318f6ba1e5d5ff209b4886e679c8a40796(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85a0bc3a90f44556a0cff7da02a8cd01887c64eca9c8159436f969ac433128dd(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25f5422d6ab724674d2b8df43fd00ec63c093aacb152fe730ea6d9b982422b09(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6aec491e6e9c85f88a7df972cc2f5c9f5add7b7f4cb1d33cd41cb5fe38dd20e4(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c0fb5b8f334a0e694347029b57f3528d1a12943acd2b60583b21db3e2ca4cdb(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12ccb00ee242ef06687902206714c476562923e5a126b8c91f2c18d340efb686(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddEnvVarsVariables]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a3c4093fbb627e3620fa071ff71763fe71cc72ab9c3d4ea73ca6dcae836faf3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e96093d309ccc177b88132554263abd793287faf15ad517bfd66ee7491fa191(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9bbffe6d244a97ea8b22f43247d096d9a6715390e2b3065495c8091be34d223e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2db58f54b5a076dfc57797d2991d047cff5281bef4188769dac1e35ed64b35dc(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddEnvVarsVariables]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec882221963f5a89d0b572d7a253b5286d8ec1586f34630cd95410af7b450ee7(
    *,
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    field: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsAddFieldsField, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__600686e000790fe141c4b2e9f31a997eeb27c1ae29016a70ee2f9bb024b8882d(
    *,
    name: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eea22baaaf997f47b530aedbdb77dedece5c3a72b557260a40ee672b085dbc28(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8af8989953ec21fd676976bf95d9e788028397c8f782e1924a6de55627963b8b(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d470c6b76b96c0a12e91798199cbbd58c2f0083008082465a11bc364f70c538(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d601e471588b54eb7d5fd9a807ea80df35c38138454761e0875915f7a7ed951(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac80d78daf186cc48a98a765b2a8bce657aef83bbd86c96a0775da5e9b1227f5(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57a7c6fb9a248d529962220c9358b07a9e6d4cee2d8bed25ef1924ec6012798f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddFieldsField]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd514257793c6b1417da895b0f3960cbc53716d965040a6f1b2f43db13b3242b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__afe59f9d6ca21f292188709ecad6e967bbec8bd5acaaa33d75a13d1c63b5342e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__43e8a64b096d7543c1661c2731d0250a3d55dbf21635c2a5d60ff4051f6b9041(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97a5fa1e5f244b284592e39dcad7f500a8056889dd3c417ab027b2bc666d0406(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddFieldsField]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60edc1da79c657453aa92b1f92cc2eff87ff145e5776762148e9f67bee8bf13f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5f7ceea9a9dea68d928de1b7e2a0d636b7629c5b7683e3562cf72ccdbe009e5(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b51dd999badbccdc780f30205246acde53a27f6b1bde2e4d049e45de046cea47(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b14913bfe9577e3e75d3e0d8b97812b11c367ccf969572673b03d4a4565e583(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__988f6a54f1372e9637781146883441b110d24d08a293c54e364e173df88c4331(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1d4713ceaa4325fb827c97b9a7166961d169c57489360f6d62a2037ab195c0e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsAddFields]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1bef632bc294d35ecf2433c72376caf1f46b113f26a6002c09e1e040d790a29(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f5648689dad52e943941378ef4a3922482cc7f3b03518610c80889c4f7426c9(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsAddFieldsField, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e3c89075918f33a6017690f0d2c1ca909bce75d0922263006a84ac311981a38(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6034bbf17ed8f841012253083d02e46ea4f403a8d94dcec03c750d13a8bd9c8c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__525101bf03ade027a8c8f30e3dbc6d9ee24d7b242de2b2ebc5b9b62b482dfc16(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__225e0a72a38b1fba3ba7d9003ca201aa1cd68557f1f4ba940316ca7e3db107bc(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsAddFields]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__868a2fe7e9ee8a1de2eb627baeee1c0a02788729c5f759521ddfe5b5cdccc7bd(
    *,
    id: builtins.str,
    inputs: typing.Sequence[builtins.str],
    remaps: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsCustomProcessorRemaps, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d0672047f03f998b95321b23114538b254111f3f13b40f57c275512de7b6e7d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8b357fc14f461f34b126437f36e754bd20caff69911c77c9130595ced3064d4(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71f1748a5ea1b8ac5a0cb7d9985df2cb4468a2a0669418a380dc1249436cb659(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f60dd23534aeb5e52caa87553a042651886af2d3682d507a709a1433741578b7(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e0e8cc185e9de2dfd46d2710907e0ed1d79e32655013cb00f3da333c093f195(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2163ef740113b30e22036d0e44054505292bfe2369854304f550d03cd61d2bbe(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsCustomProcessor]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80e9ca34789598f8940ea564a30a5738dc164d6a22fa5b6b8f4cfc9f9704e691(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7718ac9ec7317147e9530edd4adefc7499ebe174f98a7d9d5eb244b7b1816583(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsCustomProcessorRemaps, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b105b42aad801d7144260611d5f5f2d14270726e589e7f5790ee358cfc4eb06f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4479f3740d132dac19ccf2ca952fc75eb61b6ac131f954317cf5ff2508cf22c1(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f8a2831442a81cd8ee8f159ef344d341e4e789bd9149cbe7d570acc046abc7a(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsCustomProcessor]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__699ed433b2280eef4833be587ff4da9a8e2886c3b0f6ea433c3cb29f4b93ae47(
    *,
    drop_on_error: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    include: builtins.str,
    name: builtins.str,
    source: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71547f691f5a6588bb11e58f713490e8f3fd84c57681c3defd1801f71d9936cf(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06c83e1bb3f062604da333bdc640078fa0072313fb906e73be10c06b642882ba(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0b4dda6e40cbc884052ed75509bcf8fe9e74a69f87f1a032159b44f5b171e4e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1bb87450fde4c9e3ea56be392d9b11bc89808e469869924088980aefa909d84(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed22237ed745b5e0e88178dcd063e40d2bf52a817964993c5606397fb271527c(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7af8182d86b3535ab62afe739578fdedc6e3e6875db5dcf6de0748d165f78f57(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsCustomProcessorRemaps]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4bbdba3ec931d1747ec78b47d710af7cee61a8b231a54d43245a989b821a3426(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d87091cffee8e598e8aaa3f9c7f6650f1bf6482cc1e5d19d08230d2b3a1ecc2e(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7d69f95d4c17f1b6456b493dfcb9e950e471a5297033983e586cb98fe48c33c(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6356758c0d3d352dc475a71be56a416bdda8b13ccf341b3d62c7e9acf5b1f626(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c698b36b30b634c227152b098feac0ff2f524066c0124d47b49ba72c8b612a5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8327eef2b3ae9feaa134287b8b09a346c9e6c9d5b2632d7feacb61794adc55c1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e10b296b0945085c003fddcb9090b0cb8698517efaba82e4d7a92fd473e82ca(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsCustomProcessorRemaps]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33f37bcea176ba6210de0c2b0d621860ba5d48f77a26b11c577d491e054a648c(
    *,
    action: builtins.str,
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    keys: typing.Sequence[builtins.str],
    mode: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__096d2a7e258740ead9657ce0b8eef207dac200918756ac7d775d4382a24c0e01(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87ee84b6ed3a5376fb5fb325fa1b38eb8dabf78efb429e45950562760a8f44a1(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f76a2717ebd28faf40912cfb6dac5de98a953044e1f5d2cd7fca521005434c13(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6bb2688e4f3caf6a1fd54eedc28e2890e03eead3a4cee3b268502b65e5d1231(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd4eb93a8788b9e25033d820a663e20feae134d0afe9f00d31c7b7602d75e14b(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95e8a0a443a53bc7ebc55bc17e1d90ff6e31e084612bdd837c645da6f5c9dfa8(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsDatadogTags]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b14008fe8679410b05ad1a75dff19ec8eeacfed17023c1c577b3e46ea0b50710(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe6f822a54e9d6679307b2e98bbc533097b6f8732f93ed488df5ed7cc43c9568(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d649a8cbd951bb3e25e57544fa884b7f1d1de809bc9b48da05429fb62e066ce8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4c91a0150ad8e3dd66028e6976992cccfd7bbb515e959a74fc3f7ece28e9bf4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d8c1d8d1142b95d084cbc0bd06b814324b66aa382d3983d528056dfc3d0b9ec(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__76272b66ce0b91dd70ed954dbc33d39d7527d2d0a776b7b51cfae84df3dd1586(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ca4e0e48aa6f64c22fb8c66bf1dc53ee28e09f961bfcae4a0e4de15a8a9cd68(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5227f755c91fe7d3a5012a7e416c7bbe4a26f7cf3f0f4fd2e533ec698b5842c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsDatadogTags]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f2e6e514d3bc50c2354de9fd996a7730f8fb27b9b77e7d70433e44c7854c7f9(
    *,
    fields: typing.Sequence[builtins.str],
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    mode: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea0430a7f3dbadcc288aad94f069a6a0c4f46217b45ce59fbb7664ddf550eddf(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98f46dddda831ac3459ceafdac70cf59145aa00ff24f77d4dc915679f86dc461(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8cfd971a8c7ef3af64bc033f20ae17fb43d1241cf43819dff3e1d7047778f419(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c375dbb452d7b6eb1619554d0105af6def2feee2f9a5be67df5ec6200b5151e4(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14fba9d9fab989b5e11453bb62e8960b4486a34284d1bb95583d60e12fb772c6(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__221dea916c45b1ad0f50a1d0bb4d2b112750f2ea8d3ce4157b6e72e79123f023(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsDedupe]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ce8cd5508c1b1db8429630e8626d82171ce332ab7873e7303ceb9bd485187b7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9132e44878e09864611410866ae58b762f978ee4012c091e1aa77fd35dc8b368(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19482c2993c6a7cc767cafb2946f15be0826f14a7354cae5ed0f5a4d27af3d9c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__684e676d1f8bd8905b190e874e4f4a2c7e298e23310792064fc830b821edb092(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24e447831ecabb5959f418e02b67ab2feace6f10e988a5233138a94b6a50c04c(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32a78c255a887e51ae981cb3a88ece35ea26555b08cc0d4b3ddcb6425c9c7fcd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5be8c0d6a86707104116bbe9c007c8b7fea2e6f658d0c3b238065d69671a23fa(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsDedupe]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__344433843a4e50bd2c7bb89fbb2b2665378cbe6119e473c7fc13351ab3c939c2(
    *,
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    target: builtins.str,
    file: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTableFile, typing.Dict[builtins.str, typing.Any]]] = None,
    geoip: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea60331f8b4b9c2e34fdc5cea7f0901c7c5c465d159acbb80b485f5dc9403899(
    *,
    encoding: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding, typing.Dict[builtins.str, typing.Any]]] = None,
    key: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey, typing.Dict[builtins.str, typing.Any]]]]] = None,
    path: typing.Optional[builtins.str] = None,
    schema: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31151945f4343c52cd2d0e2372111fbf24ae2b43885c8038b3702dff72d94bae(
    *,
    delimiter: typing.Optional[builtins.str] = None,
    includes_headers: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6746ae9c363fba6b343b25a7860285064a7b0d2104c3791d2b0d0eda30b19045(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ce72039d93003dadd88ea139bcf0846c2a5583096fa5644b09940e075e5ba87(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5195364c7910053072c1733cc4aa972c6540863285337ace49aaf68949bd253d(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23e5c76e8f3c35aa57e3ff986d8704adf476da751ca5e69fa2fa0879792c1ee8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4005a8f2c77c1595ee40e79a90f3321697d4a6e0beff8061a22478b420be73d9(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileEncoding]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3bb23ac090b53f5808948006abc6ba1fc26dc980b7e1355d6a200e843398df4e(
    *,
    column: typing.Optional[builtins.str] = None,
    comparison: typing.Optional[builtins.str] = None,
    field: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94ca26e5229c9844d96c66b6e9e0e06954595b8e71ae7a6400569d6aa1bc1e55(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b888b001586e8cd78ef06055953065cf9dae2c6618462390a306d1f891417b13(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39bf6df92beeeda3e55e98dda4b0fa9696555c3d18a52ab8697271772aeaa412(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee36f90e469facb1eb8bd4ca3841e1ab38f5caaab21474531d74451c6ce5caa9(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__940b120916748eab27887cac90aeacfe003ed890df080fc8056dc30278886669(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d3b06961c29827aae0777672bb5b7890efe3d3def5a3f7f1da77bd31e470b5c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8bd6df73ef7caf527d63f959903f8bae55ce69775552eb7913a9da775716354f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7451b970d93c8ac58440af97ed41dbbb9289abee3d8f96ce6846e94ddf0151e9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ed1568fa1dbbfd932cd2fe0ffc50ea53e13b3cb5bf8ffb9bccb719c7f2b1077(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d6c526290edad9a1a9f63d65b86644bed4a8720c2236e0ca95029c69592d925(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c4136e024ab3bca726e723a5752498d6d433978c1a772d5f40d779e523bdfdc(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b029f2c17769be7dfe52ec562d1eb4809278e3c1a184b36aaa53d5b842137459(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d059cfdd0f2fd14a53f031a6650ad1dd4d8e6d43adde6885ebe2432a314af8f4(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTableFileKey, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cdde45f261b772e81bd45e15b4df9de1d2fa80a7e6b8c93dbf4f7aa17b4e03da(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__921c0a3619cc8958264eb43d39a44e6e1f3c681f895bc0a2d3958c0e18423c1e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6781b640324a21dcfd57ec486193c5918a514d3873ecee9a5200db3236c2741f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFile]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0218e28a4ce326646028466a37e957be13168b3f9bdcfe0251c33f4002d3acac(
    *,
    column: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd0bf80815b685cdef1d7946724c2798d55ac3c5b68f584363249da1c6c49da0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ba9187a48e8f66289560f0731149cbb14375185b0f2924efc40ee763a8898ee(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d9deadb901ec85760ec7bda1bf201de7fc5f3835278125ed01da71e8b1037b4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c540d9b2632b37cc9cbf1d96209b5be40768a2d39a1306cbc2b3f606058b493(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7209c031a2b6e3eff4ad05337741b0908f78e603623f85d5ef7d243b72dc1ef0(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d5d46faccd02a6b75f5a07a8c37b19a6fdbd1853743d9b4c7920cf1b2121177(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e5f73e772e5a9303b8650ce09735433a24f8432c17635355ef4e2a99e68a9d0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9e8c682b531059ed7df710eef20526b06d8da7e9c67f44164727743ee3026e4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d37fef8be34e8858d10f2d35c93d2782065c87029c224cd1019061921dceb3b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__342f349fe9823b5c1a4f26bbe2f788d0ec5f6f7624f9a24a9901518d9777d11e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableFileSchema]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0ee863a08c3ca473c2dbd8635d7e2d2b699a118da68af53a654822e04e5fa63(
    *,
    key_field: typing.Optional[builtins.str] = None,
    locale: typing.Optional[builtins.str] = None,
    path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f52550f7c462a9cd1e4f0ad830e55f8fb15871e7e1f18eb2a1d86c50a7139c6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__919101224b32d56e8fb1255693e9d446ecbd07f77fc4ad9d93a47446c998dfc4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4db60ac426a2cbed6ef3c843c83bf608f4c19012484a4cd0b39d8f99995f4580(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73a2d90a1a609fd343c6b9e32c8810e6bb97f9291fc29f8659740dc1c6176c1d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e488ba8944e319d07bae003b8e4ebfadf1548c5e2b99101798defc53484b7b4(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTableGeoip]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b86cb48a38025b051fd00b650331b21224c3d5a844cbbc8f94749d9adf2674b8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ec9a62ac0f3ceb1a3ca6954d62cf5fe39ffd0ef5800a80fbd1c5d59b3a30547(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc599c6bdc2c21161b2121fb4887b0f37d25787f65fde4722d9a2b3e9fa82ae9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__645059d8107c23c427068f16b3e58f8369702ad6e88f4e9970f767a6c44392b8(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f531a789c983067455a359574b188824dc883c08933d3abfea1ea3ac0eaa5fa3(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9e298ca01dad1553fab2aad299a9e13943f1e0f78799e5dfde6f2f354b52393(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsEnrichmentTable]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc8f91e8c9e335c10678e712503a5cd662034f8cc2029d34fdb7cc8bbc176abc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed6fb48a4cb32ef98eca7048b5ad882295d93a85d4f3a59796046d02dde750b5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b627153925c30efd39b00f94923dcb6cdd745fdf0f1b60758a0e2a87401b541a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9151940bc772aa18baeaf8850c40a3e4cecff6cbfeaf64021fab981b9083fdbc(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__621b6dd3d2a8535db3250bdd7a4083af8e44585233bcaaac70713772b76b9e71(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a9b053dabee8d72a95e6dcad0bda21c3078ceafc5cde152aef40c316b8330dad(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsEnrichmentTable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__716f86525bbefc8f88c9c5a55769316492c07ceaa74dc3e5604319633f7d201c(
    *,
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9db28dd4ce778ffc826e503a8e66b0031f90f7b4cf48cd70b5b4f52d0ff66fbf(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7b4bbfff82c91127486e710ebbf3e5d4d5c503298bdd19f68bff6bd17adcb05(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39456daf4e4ba765690302917a9b431fbb9d1f8525628239c0a416e39a2566ba(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c661995033e9ea205e773acbb5fde7e024b36d026cd17248a41c7843d972f455(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a92d3b6a3da5d9305233d03fb9903f5e8febc6632b8b841f9ade60919040464a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74836f050c984f7b655f6ed99383d318b077ecd52d90cac73dc4673bf422b608(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsFilter]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__311395263aa372cd2af8e732dd71d270beea9a567fdbb6dffc04f6812b3a904f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a92ccadc8b0ba1d94afecef670ae4bf9a3200fea3d9e0fcaaffe4ecc72656fe6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__384aca36e8d40d51391afc2de2a3e314892d01fa53cba446853676b4d43ea5d0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fdd7a8a540aab0b721cb730d71ce5fcce57a4ae78fe113ef35a40881a4af7fa9(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__58afd2baecdaf1f17c50b4bb91eabb6951fe6a1c5ce253c1f9c9d1167eef1fd6(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsFilter]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4592c0d9e5ecceb001fc0caa16c808f3e4a71d7a47195fd3dfb563d4f676408e(
    *,
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    metrics: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c44904ee52f041ae4f7faca2b1d7ca8c4ece7080467f1c7b56a29eb0defa773(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__48faf781586c7e7b85afe4d99b317312d2e05afce7aaac025f2098dd1cec1e28(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0184445cf23e40e14ebdc260a0c5f0d7f35f95aaee8d85eb98bc6a6fd51d1b3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__429c70d32d2af306237af2bb36e9af3e25421b89b196850671b73e907c09193e(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67b1307c9734060ffca78a32f76f17a05c513c280b50a9e0c2c641e09e09200e(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a2c17d9b57c8c2ecbf652df84c9a79a445e48593167af64cc831b8599bec7cc7(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2f45108d3f7d333855478b255de2bf66d8afa44d744d20878f2c825ed189ff3(
    *,
    include: builtins.str,
    metric_type: builtins.str,
    name: builtins.str,
    group_by: typing.Optional[typing.Sequence[builtins.str]] = None,
    value: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da3dfe8e9b81c802163507c9ce4a94eee5fdb8faf91d104490fa7d3b598e6a59(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fef992e98dd1e90073e4da8d54bd987205dbbef872808df5d4ad3acca7ac1267(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35f1edf042e582b6a47913cb34f23173b16c44160ad8fe3669d490e3b0605788(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__430e88a2f052b8ce01cf770722fda114af5c50bb1f8c6bb7cd57cd5fb63e32f7(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71e8346877eef6af5fea713c3d8a449c535514786f212c98117ce7a5463e5cb9(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51343675deb614f7e36e22b7b28f3ba9179eb52c4c8af15d0512563326412bf3(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44f221fd3ff9cb43a392bb53997a787da939f538d661d3055fd56a615f68bf18(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a55178506487bcd5002ac2ac51256a21f7298f10570ee0fb306392482132f06a(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9daa7ef77277d7911ee4e2508b77051c360edc6c6bab70e39bb7fa5985d5a9a1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__042081c3bf734e3ff821a2564604ac7b4fea196fd43c1ce045f5526796ae8e6b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__55bc311bb54323828188d675adb704730c0be1f536b8ab1fb9dddb9cea2ccf0a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb72439b1127a9ad0f1a2f13fa4000c8f1c24138d58ea4ec21d6bffec767135b(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11a946117852a5fb65e8323ba37f446c6ca04b6c5a1bec783fc72cc82953afef(
    *,
    strategy: builtins.str,
    field: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__007bcd1ff85e1f52472e1674b4e5cf9316694a7237d960adc80a0022d54dfcac(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70bd285d1da1cd9a64249829d83c0aaafaf0e7b1c608175ca65189165f0fcb21(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1de099c4c900d5006e2648e2cbb92d75980f54e88dd90c26a1f6e91f410c012f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03e788b57a1d63f4a4f0a5bb4fd378d11ded11ca6dbed18727b863b94537cf8b(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetricsValue]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c0cbe65b1a04f28c9ad021171d93e1997a9313c82c6f6a43c5e8188b0153c2a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23df3d269b2d56a8b65c6a0338bec906874e7fa3e9ce1d5b73f9a519c4827bbe(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsGenerateDatadogMetricsMetrics, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0180246350932635ee1995b50067f04ea81f3cbbd2367c3192d8bf09201b2b58(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06ddf3a3c539f3bbcd97721214be8fd19078b7204b622d5977f8f6032ee5633a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1560d8fe635750a9296d9069087bc5e5bd4cf17bb4987e2056dddeb4d75cd432(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a48110ba7e064427ba2cbf1dbf3c5770312a3bcbf3726df4aeded10289ea309(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__827c119a366285c162b71d20f68c18bea877e964a2b0dbf162a53bd0935d9135(
    *,
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    mapping: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsOcsfMapperMapping, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a14e4bd5201f21c6f89c425d1701dd8c78b346d6afa2e803e037e4a3739d9d0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b87a37dd11d8b00fc71506f858a7b9d784b8103b05ff5da01800a74e54decc7e(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a543767d07b2704dea50251244ab423c2dc28e874bf426df3ff79271fe2ed27(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb06cb276e255f162e92ef1223a4a7eda4e0fffee7f1ad0330fe7a3654070a9c(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f8dd0db98fe6e2cf1f98c7a606b0851423d9acd81d2d4e55a7834ef27ad8405(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54617d5b9a454fac1f65e7bce6bdc9b914af8b977273100d13c07d4e96aebd90(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsOcsfMapper]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8dc86f384b6c9ec3ba3932312a56fa588c5864605092cd895c3387897bac004e(
    *,
    include: builtins.str,
    library_mapping: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c30bb21079c0048601bc5ebea18a0df94084270d6cfc671b0e2920b0141c502e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__839b7519c10397f9f57a7b6ec966600b282a0d116fd53a50a780bd3317283874(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0224001209f1bbf35c80d3445268167f4a8b19814760ba803eed4f11d2948a1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a253cc1f3b36e1f8687be204a0d4eb1321b265272285205a8ca99b2d9111213f(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8753c836f684a3802050bf285315d40dd1b922ad281f92f2f736c6807e58fc85(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4125c4c59c3ca542d3abf8fe8ff8c2bc9e2c7f76bccb9cbaf42c1d638fcd786d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsOcsfMapperMapping]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22a104ca829c05c4992c3a8f35e43306f86038018e1ff12d9d972097e196a17b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e377f9957d818b910ef09ce52cc3ed81f75b8bd5d808543b0da949d0a829d9b2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3170b9767d5088a333af4a2f2382985f0735d854ca46d48aad2f395e98c51e44(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1c2a391e881812cc6c030a260d300ead327293fe76c3ebc17c3cbabee041a83(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsOcsfMapperMapping]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8ea77a37e537edaf3f4863d7c25e26015bfb3113d58e355a4818eb9f8fe1f51(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e38025154022e0673f7f0adbd437d7dc1cd657d0dd9f6fd4b303ec6a54d5389(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsOcsfMapperMapping, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28428429e684ab7f06ef116f1772c751eebe5b0c3b64ccb6aa2f17d370258a96(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8581cfcc3b04caa9c33e7a845a083882615e07df5211a15bf636d50db619338(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13ba83527c8ffa94dff955ca8476cc24549bce32a4a2af52efd2785dd6010115(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b76d931565cc08d73cc147f5b354877a5e7cff85559c2385dc79a77e0ce4cd56(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsOcsfMapper]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__764fb59c255712a769848254605538637e8209b6b325b57e12da5b9a8d4b814d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__681b352359b654622eb4ce659310623638aa3bb030ebb86188baff5d3c7feee6(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsAddEnvVars, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d56a23f8572a89e7bd546299223f1f31eabe1b85e3402e8b5ece17b92f0676ec(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsAddFields, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c88218daf15abbdc930cb5422bbc024f10dade0615ee8101edfe29c3b46a9e48(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsCustomProcessor, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8379555b5312ba83979d4a34a48feddfa34421a9909f4b9dab56f7d786856b46(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsDatadogTags, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b61006952c410706a18a4d7ea3b8c1ecf643985db63a73fcb841c86faffd1435(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsDedupe, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0ba29b3a7089869f7ac4fb71cc04e0ba6f0fa8da7b6a980bc7c157599ffc5f42(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsEnrichmentTable, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__935e60a76f6721ec781b276968bbb69fb60c2b0e769132ae156c76e3a1573268(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsFilter, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a46db895f436d451ef9a34cb67b60db7623b4b005e2318f52d4be878a611c765(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsGenerateDatadogMetrics, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb6bf85234752fbf30be4eae3722e6a7b66db4d7c48f9934e8442ba1a4ca1110(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsOcsfMapper, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50c9e17b86253b24a3b84e586a458b27454ca4a89cb6ed0ec382b4a6b1f7760d(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsParseGrok, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d096df1cf9909294a39860ef7e453666a661a518837a7fb96c879a385e1e237(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsParseJson, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b0583498b83607284e690773effd2df58dda1650e1eb5f64239293bb024d070(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsQuota, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__665d86133016ef17bcf73049145c05b20b1657188d03e866ca2b34a480c58b26(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsReduce, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06e7d6aa18c55f68ebd5db49bd47461a3e385768fb2f3d6f9533fc49b949eed3(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsRemoveFields, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d90c98f21d09754878289af3f963b70bfc702a9c246e4e65d55d5f92f1e3367(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsRenameFields, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d47ba221138bf3cacb325f4617270c6d542f2925f70ff0e371368a4fd816b09a(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsSample, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8857743320b6567672b77fdd30d67777a1d5badb7b6c89e1307539016b5758f0(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScanner, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2cc4e1d3a21b75c5e6ef77a406c292575532b222a891f59981945845c033c2cc(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsThrottle, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__30ab56d0be6405c998d21c9f1f24cb2489c20284c3832f2b2827dcf15544669b(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessors]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4db72e9da594a2efd988bfbe10af415a517a031539643813a7f56dd17135a721(
    *,
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    disable_library_rules: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    rules: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsParseGrokRules, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88d3be2ffd73c3e0e325680e56fae6acef05999a8e77865d307d2c64569258b7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29e7207f63d5d648daa3c8eadb266985a200e2c3b4cc1929216f56928f908b77(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20aa7a34c651138ca5486870b71251d6d1dd48764bc4880881a04213823a3a87(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39592d74512ebe1e4a58c19fa0a6d2dd4ed948184e3ae771b6b3afce1acb983b(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b38641a18b01018663feae20df007a3a05831488ff4f5e7e7fac8077f82eb92d(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff6c2ce998c97598998fd38723abae735a470b45acae3071f202e5e497411e23(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrok]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20a80e18d788cdaa40dab83a941977c8a0324041ccb536b83898123cd8180243(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f9b25e3de1fa44043de5ca209eec91aec1f3198f81a46d6547308e2eb7d1366(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsParseGrokRules, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a121065ac6ad1cd562681abbaee7926430fd2abb3c2ae5b0a8a797c9bb4cff61(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f03f351ce4e022e4f59f3c199c07aa44699a91a1a83a2f80a3d644342752128(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e1e416b18fc7476374bd8d0cc59d31d9c4bcfcab8d108634b76e8d761cdc653(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a2eea2ba03b98d22bd0f9d72ef476453f358049984355f81c7e4360196a52d9(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e31cb2d3668e8851fd19724e8ba291d178b3646652e02531fdd1be9acd5a60f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrok]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f541ea44e78bc51565ddadc5aa933700187ba0f67fe7cb5555def2df3eb861c(
    *,
    source: builtins.str,
    match_rule: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule, typing.Dict[builtins.str, typing.Any]]]]] = None,
    support_rule: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4ba7646ecf6ff4d5c508b36c5718cb7836f124cc4e3983d2d319081047e0371(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__526401beed7b927c024bea0677826968b5d37873adc1f9b29cddcdfdb771a303(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__746c012a379c49b5c03ae8c0a2fd3cf77afdd42567cff53731ce8bdcb24ddb33(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__870cfbe147a3cce4cd0f65391db967f3212df74e2c457cf74e0d02796e16d323(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19bf18464dbb74163555b872871e06aa4c1503df4a55c151f45b2e88bf6e0d76(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b84419763b5c5c633e2b94f11ee3be9700be1fb1c90f564f93494a540567ed7(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRules]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35b0b869aa2f717f7f06c02bdde57c75fddaed9ca4cc378959ce62665bcbb64c(
    *,
    name: builtins.str,
    rule: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__698caf2744df8f6c312aca1ae1f1bb252b53c59186f0e616aa6ec8bb80ef12d9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73d681621ae64445c2bd133ce0aad45dfd0f0d4a16675228d17c86345f96707e(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__65d07a7a9ce5f1b2de2108f91ffce0d9aeec706ebacb1dec3e2e373f9de3599d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__950a07332a900814144e9fd734ba95016f10438cb4ffd8ec43ec93e95082bc37(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eed232833f91e1fca6ed071d8958ce8e73497870ef919a60c1708bdc13d1cafb(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3258726f76029b6a79db9642e45dcd04f7c1cec122a784f37660255fa9db953(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b65bef4653706fe83e31ba698d7f549dd82d44855681f600c134e85c555fbe7b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9b78df6410808f664a479c1e32733a63f63599d120ea4b9031a2d18de1b5187(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9724fa73a624b3cc3bbe569504183df36b2705d40c033d1bbcc95802a41b189e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ed0d9cde732ab3978ca6ce05005d55257e2cb029c91964f22f2ec91c29b5e40(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bdece0a5fcf1779b45aacbbcb8c2321d49a4eef3cf4053b252c6ecaa9c332201(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c560e07809a0ecce72e796c70a4f43982e90675ae12ce376377ded1bdd600ea(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsParseGrokRulesMatchRule, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0485e766948b1ba75a9ba82d91ac8db3daa94d121dd8f0e634d83f75a4e85be8(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03767d5c736a66d03a84a2cf9996c259c0d6d68252914456e194057ed60de8c7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9dadf998be4c49d9d8578dcc90192512326afdfc4dc6187814dd1ce649d9300(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrokRules]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e8e8262d6a58f87710b13a112691dc775add40890751d6dda35758240bdeed2(
    *,
    name: builtins.str,
    rule: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47ee6b1a1aad95b586ab00fa5539f4f98e55546c641cc444a5d96a7c8530038d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f963f548b57963e0bba348dadcfe3342041122b84083304aea53c4fb48a2dbc(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2acd9dff3a339352384e02040d69e3e3abf199a9ddbd99521f1f1f5336ce0ff(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0204591ff7e87ecae16a423d55bb9118793ff8fc9a6f10e01fb8fce9f2f8ba33(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__79a7cc3686acdb4c06d34237027c5f1a288438d8e31044869685fd7053e6afae(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4b1006e24d98c6880739d062ca1541f8b854c06e14898801bc2bf69c4f565b5(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5082406bf85b56cb7a260bf97a3147471957a11a7b8aa533bff9c7cf8cba2bb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__453d237e5758343778a7769fc0a5b37b326a98a1e10987499b8a1705c2915688(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2791b35a5c628b9a83de2d562119b71f2b6a72066e89ae772ef43c68ce4f869e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff536a958104a184f313c9d42b10761c619aee22215b6a5b06f99cc6388c6645(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseGrokRulesSupportRule]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__30b5bc2e45530f50f7e6155fbbd9e717db91020a4adb16ac25236468d4cbe4bf(
    *,
    field: builtins.str,
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__186e719237e98dd9468fc5f3d396555198539835ba69a9c6043a19aafda567cf(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39f49e661318c65408ace7ab0d86aea4d75ce268204e8d754cdff8f2b982cd40(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf19396bd18249b8d42f2f7fe96056d11fbeb384c6a7ab25ea6790c17c6fcfd4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af8982381b59af24b78359d20ab7e621c195d358f513d8dd7cc885c94f8f39bb(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c959e8b9ec85f404ec9662dcff5bde0a5196de6eb199dc17c3098f094462c89b(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8326003255892efeb15bfad9892bc9bb2df9811bca845747682d1ad9b493bb9d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsParseJson]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc2dc5f3ee617c5cd8eb41fee9899d47e1d20f3166605bd7f4a9571a4641958f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4749f4d338e8014b81b7da4e9e429bd8cb3f7dae67dcdbc5d186366e08306b5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d77213b62a62efbc39d9909a3b941244fd3faf2083807ea4eeb610c52d5d863(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__149aab8c1754e41da61a42bb2c0788e747291caeaec6c4785a1e2353a60b923a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a718e93ecc18b14dfbf01826d8253feff99d031b13e3927e46f2ec78322d20d4(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7eef630e85c044ebe4a31feb444c3bc43c6292f05150d01562e8229402d0196d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsParseJson]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96c9aa4b8a81ac275740889575040a3ca73ea4d9de7785542bdccb4245941bb4(
    *,
    drop_events: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    limit: typing.Union[ObservabilityPipelineConfigProcessorsQuotaLimit, typing.Dict[builtins.str, typing.Any]],
    name: builtins.str,
    ignore_when_missing_partitions: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    overflow_action: typing.Optional[builtins.str] = None,
    overrides: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsQuotaOverrides, typing.Dict[builtins.str, typing.Any]]]]] = None,
    partition_fields: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4dee7801dfff0c689049c646a00b943dacfc5f5d1cf0d25fd8171ea137e5a92c(
    *,
    enforce: builtins.str,
    limit: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5b17504720e9a9aba6b5ffd55377336d8f9b8466f35881ccc4ac9fda6026afb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3201f014125c53391931a31ce35962fd6c1c97d90607df04a7bf5e1b6d5af07(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94e1b1d63df48e410e445e20cb36d291c7d7c7a5dcb335d3b5c6a98e4fcf7e38(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4621719119831a28bb2aa47948aa5f88f15611b4c7b6ffcffe890911bf41d5c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaLimit]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4d17f65ac9ee3ca300af5239532466d9db1d850d671ebbd8e41bda2786ae076(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bbe2b944137feaace52bf3be20be8798915d780df121c1543eef5dd295f42d7(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__101b1ce1e9839098a07300bc2ce7bebfe5a7240f16e2a00b03622c7edbe96246(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ef6464a2f099cacf91198b45d1b00fad70027cec877c5f4a201aff3090f747f(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25d39c88b34c3eb33f39ae01cb2d1a8e363d02b63a27a74417a7c0a177fd4ada(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__905c6ef0338a922a29fc2d8a98b25863a9b0a593ab4d189e346f096246539436(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuota]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__65278396386c1d0e5d0de8ce2458c95887618e89ac7df63fbe77f500bd0f68e9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aaaa55c57f073a063c5b01815a6cef741559309c132ad4b7da6c494f7c5dce2e(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsQuotaOverrides, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f856a1481decc7a1050ad61befa2c93c277a9f60068ba391e668b0d89127b4e(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5b45e3c5574ac8a83d9a1c66a08b80f9a562a79337cb2774c47f198065d4c76(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06f9ac205755d2ae845760a7a14ca154e2cccb2f2a7caaa93b824e9a3332e17b(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d02040b0dc50e72121535dcc166552255db592c14e3180a9e8d1b60721d6aca5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41936c9125ec0231dc429630f3a9fd556ae9f9ea26b396df6b4b1b5f99a7f81a(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a7f3582625d30e926c8810d38e4d3581c22ff753ca004764a67d4858f7bfe7f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d998c911bdb8f887eed7cb90221957255f490a25e45ce97e0b90ed92a3c8d1d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__671fc1c9f0fad990ce74cf7b33b7d9a0d88f36234713306168c89ed3556c4a2f(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aff3305ed3d6c1803c4760aa51654f59ed5896702f613e86e182df31d8264c4b(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuota]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f355cc996fc24ac0f70943d038cd16164e8776d83c4df7c8490f4b7cfa55dbd(
    *,
    limit: typing.Union[ObservabilityPipelineConfigProcessorsQuotaOverridesLimit, typing.Dict[builtins.str, typing.Any]],
    field: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsQuotaOverridesField, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61af1950a287739bfec7ec9421099d1bbc57cdef0e3c27c130c0a7a74fd65445(
    *,
    name: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4f51342eb87a9e4827f8b019528d3f6a8827da5012805de5303ca8cf27f06d2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f27647872608485317446c5739734da21bb451fd11d0329a118bc86cbbb6ebee(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b30fced8be5916b435880ba13b6ee2cc9c52d016954b3e070bed031a061e5f8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a4d81c28d339208b5d5d536fd559e117876d8d1aebbcc0ef0490f8ac7ef0304(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0b8f1938e2b00e9e6a77fc265b4b2c29f9026109383a5465f8fcab02bcf1721(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__054ca0043f4cd4b80791b26e44442a1fcc3e134e48c8c95e6bcd662819e73f57(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuotaOverridesField]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d270a7dbd38bade2e82948257ebe1e533608b04624718e3321fb5899b11f3c9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3fc6cf54d93d2bca2ff30853ff466e3ff2c497c3d060f62411b9347d22b4ccdf(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f6c2541a7d9e4166f1c0b10708999ae1cd6b1515be8fe1a29658fd061aece745(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c61c388fd54d61cfa357e682b66b11a7ba6da2cfa3b25155bf425aa8106982e5(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverridesField]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db902c552d2bb6c42a48a64cc7557124218afbe8c1029eed7d25000136534b5a(
    *,
    enforce: builtins.str,
    limit: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cdfef76d784d00db4e3119037c0502459a82ec9f52e19e47eb8c27852027cafa(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14912c8194113e79c47573f65d75953a679c0a5b7b94988b767dba8676f4ee98(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbd539f8dd64bf8219e2d64702fbc7c388f087038f6aeb3cd4f65eee181fe64f(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c6aa3362248080f4f1632035003759e899a175cbd9db87e89553ea9d9af5e75(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverridesLimit]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a446a772f8343643efac3f7195c111a4f49d922bd14a05eb5393244f26d68891(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c18915bda1c7a71a74d1c81c0a2b97d1a35098b3645be1d155a708e3025de4da(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__192c5871f4a8dbcb2b8fac1841a041d7035e8222d19564222628518e5fa185d0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e6a8a01548a5b26af9de1bb871fbc04b64c4e4e5b52fd4901d4db76b9ee944f(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__112cc713991a24aaf2158c6965a522d5710d8ca4f0975cdb363e90a85c6bc3c8(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1964890f3bd2ad429c73e8406634a886b155ec5f8d594e2dc334ad8786a44925(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsQuotaOverrides]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fbaf9a09e95886f06779c71b9306242b7a5e36d8dbf6b8ebae10bba60a7d7090(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9d68a821dadde6c38c7c1199d162a1e928d08c3a567be15e96fa74284664778(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsQuotaOverridesField, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e37887fc23e3b304e78591dc2f7db64c3a1cde339f54511478bb8385ffca07a(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsQuotaOverrides]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d548294b48662fe7eb9a256753fb8b147d19c4eb1ca60fb3eb5c10eb88b05a81(
    *,
    group_by: typing.Sequence[builtins.str],
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    merge_strategies: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsReduceMergeStrategies, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97e22af6fe92079dc2f51cdad37742e06b9e426cdee0a835cf1ac92132f3933a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2cc28cfa5ac4b9e7f63f280cd6c5f6260dfb23b333cf4e9fb3feba2ccfb4768c(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97c9cca6df26b31fa6cc5a6c25365305036c41a85e483bb799367ecc5a1c2e08(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__003155d363318c7f4c2a4996344fed2c7464f50ee7d66f81382b2418b146417d(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8bf3f4a1eb5c8dd64f5a3847cc803b68e7b114233613fe115f7f509b9a3cc99(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45a5921ada25b692bbea4e39064297d03901bbb6343ae82be8185c4eb8873833(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsReduce]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__56be14925a8573b25db3bcc64ba1f8cf8e80ec52914d801e089be4c49b15c4dd(
    *,
    path: builtins.str,
    strategy: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f801179ebf2b28746a65158a561a55c0232014f4dd74b435eb54095ac3d03ad(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__76a8ed9987509fb1ac0a324a9aafc08a274f4913fd877c06b25d5a45703a2fba(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6de03841d1a5ddfa0a39cfc4d51c048ae300069311cee3c976e0397202cc3f94(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__451498f1f529506e0d15f0ef0a7c39570accbfb684b3935fdd0e9e419f41934a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__405c95b55cdc3067b479f7188fedf119a29660bc529bb01c175f0945cb3bfe29(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce06f180833be082f72e5855acfd2275953fbd57a9eb98f8686d0423af66b3f1(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsReduceMergeStrategies]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3a774aebcc6cbbc99ffb8d08ee48597b8c455983293d3a4b734d73292eef000(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20874e73504a8f9d1ff61ce1406d835d0c0058def6d0c68b3c0a371fefdbc3f5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f5b63ce90be8b80dab89537ffde01dd97be504130e327c98ece6aaa9a30598a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31d5870d27377b5e06663fcbb157e8397a65f7a92de6512147410a84cef5aeb0(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsReduceMergeStrategies]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c56210c3a985837e58860f7084802ad6ae2745406c983e4de404579f655cc1c5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__55c5bac94dedeea10cd35d810f8f905ee5a9fdbda925a1523298e53407f4cf82(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsReduceMergeStrategies, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e219ff4bfc7f4aba00e563805a47efc4c0056218171cc0bb3d685d776a52ae2(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7d7f817ef5f1eb137c6272f3ceec0e8b9e51b613bad8aaf6f2fbfd02335b416(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b846a44c7591cacf09ebe9012dab762c8166dea83430daba81b8f6ef82e979d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6fb8e38adb6cced3e4672e8fa0bf2f1fddaa33f5a9c1b7051ea6b70ae56a700e(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be41ba998fb981def1e0778fc8b5f0039ed7bc35ecf60ec70fc0a4f1fd3d9a35(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsReduce]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06ad0615220b708f5abd61c8dab0dd9d0cdfb6e0874ae9521118b49a257692b2(
    *,
    fields: typing.Sequence[builtins.str],
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c9c809131c784a41ae29a2d766ebda16c163c0b7feb171eba5c97cc12121766(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9149b01001eb8fe263e4df9315582a9dfcf0df249eeeccf18cee0de5252d23e0(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__abe77409dc99b706a81cbac3d4ed98c698f65156c8efa21af48f75587707bccb(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__324126a382f2f00328955a132b1fe2b0c3daf599a4c43162f2ad44e628ed45e4(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__979329cb1543b875992406ffdd426a21ca8cc88d89455dc877aea05cdcc5af52(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd3955f8117db0a8794a05752120835d2e9cc2703d70e0992234ca43ef819d07(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRemoveFields]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a9453a2b8752cb825e8b31f5efd74958ab3ee731e8b7bdb8a3271c0bb457c77(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7fb29adbddcd093bfec79a72d38771fe2434fbd3264564cd3fa4e76d7ca9d1e(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51a0a016fe05a3a01691e1a37dd24e28feb798e1b7a102d82c0e359cd9f4738d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fcba0db3dd4c734e744e26dc27fa70580933bcf7c6b505c8c932f77b58acbf25(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d9b0bf65b46fdaa8b15f47d643b1e5366af4f8d44af9bf1683ad9cd45da59ac(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf9c33a4bd1916d0cdab24f0fe988152237f66152841a3f13dfc125795983844(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsRemoveFields]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__849fb1f97819bfd610bcc90a4fa3cfbf8c464ffe831b9a07fcd7438516b944b1(
    *,
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    field: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsRenameFieldsField, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec911e68d925c617fd922cac083783e7833f677602ebb88e4c94bd7456820924(
    *,
    destination: builtins.str,
    preserve_source: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    source: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f15a43aca17468511a91f7c39e21032e56e79c6d30dda0e206d7aff61143181c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__431847aad0aefd13c0b38390d4ad971c3560f522579ab98cc3b930d20b3ccf34(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__09c4018382829499e17e0992b70b9ccd4008da22fe564b97ddbd12b5c88a5462(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__444d0b6aca6078ecfd9bb23385d581289243fd1c04ef7b0b159377f9227c9885(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53d57fb6f2a3439cbfeff088df8fcfa6faed091d21f77060c6f12d6081df94b1(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7984c0f51418aea142e787b5d5b72c7c4d094d389d6463b6c6c3c97b9f061b7a(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRenameFieldsField]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe2bb864112d4f75fb9c5f8d23d1fd4fe94b46d118b72387dcc1aed6ff2a3eed(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b11f18a0d13e6d6e72364b0a20d6a92cba117f5804c1b24bb65867bb0d13630f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c91df38a150972186b05915d4cbd99f279d37fb5d744c53231d3a1ca7350f6f5(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1c4b56ca879139b1345e317a4445b72f804c699f63c6efcd01138988887c2dd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85975616e971682b360160bd6e110e9fa12333cb2d27540dfd91b1e0e3184099(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsRenameFieldsField]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6672b12f2f5f04ed1ca63131aea669371ee240d74cd979a337a832c5272a152(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94d356b9b6ca82fd1bf51bf9ece912c324be80ea8b302a800878dd345707bbd9(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e39459a1c3d47277662c879c209ffaa31cac044c28ced771478783eb9db5408e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a84fa510e4257af026383cf992cd13cc365488a6b418e348b2c4669614786e2d(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52d9a68e33e2b04cc594f6a34e998c5c77581d41f87cf072182b48582b42c480(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6432e01b8081b3bbea81e403e201b33d00fb9ad2096cdad7d375410ba1f3376b(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsRenameFields]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45aa7c1efbb0e78d154b976ce58edea1332ca80237a6ea736fcf9a57b9f55de8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1fe62e2a071ceafd68f4a36aab2f942636673b3cc7e39c430b7b26f564a9021(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsRenameFieldsField, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__615f64cb9c2152ec249b81444b6a638c302a8a17016bdba5b2757fe2ba1189b0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__58476176361adeafef7afba54f462ddb1281e79233dbc5ea35f6bb795e9c3053(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b48fbf7f172310e68c602a7aaef870db514d47e0a9eee6401dc6b5a0d843801d(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5e08dae1e73188f72f20016a6682a8ef48c65d986bccc30f8b0a5a269f0faa4(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsRenameFields]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e47bfcb2b2ad30217375e55a95ed0be92f4887628a09813a7ef1034c49661870(
    *,
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    percentage: typing.Optional[jsii.Number] = None,
    rate: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b81392cc42bf0211a3affff5c9fe8d06c0f0b0b9ec1a83d39528c63e131e039a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f4e87bb47afd7f492a99813add8ea6b8b12a8f718bc762145b8d7f6af13fdcf(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a2e10edae8edbc721bee3ab26b350db31c1c0332c9a21c9033ebed832647d2c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e769294d49c414867d97dbaa99a011b94a1bb04ebc239836054ad5acc5b148fe(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d943360ebb1dc86319b983d7b3676f8d4fa8c128207e50434cfa54e6266257c4(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e7abe6fe2e45af9f2dc7846154becd11a2c301cf540f233f2d7941d21d5be2b(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsSample]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50609ff18a20eaf9fcfe2c7c21dbf2cf7ce743fe08be1de8db9a5a2bc3997b82(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33fd9391c07dc71ca3b37d709862aee9a192fa7ac9c2663dc0fd7fd0c8bd065b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1a9a20e2407fb94278471e3067d3478275f897a82540839e8d7475265662e96(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44b5d50c4ac24d6b1380fd7a02495de8873d23c4aaef59753eb906e03523b705(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1425f61925621ea8c6793dc82bf676347cc2ae7c20ba093328cd64254bdd289(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9a7947575c582beeba993c0ef9f60b0717204515e916d7b572e08ba3ab31d79(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__edf1f5bb1d7d83b4e4a227c4a2cde9ef6307b02bde8765ce02c6af84f10c7754(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSample]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d45b8b23acdb8b7a6cc62ab6b9f0c12f05ba831f0c6296f56332444a4fb3699d(
    *,
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    rules: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08b968c47fc1e321c06a72ff604b38a3965334bfe74e8f637dd91bf27ca52cb4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87e7b813bba84a34a431a0ec8a57879995dbf041706fdbe4aafb69ddb3638803(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d752732aa562f4f9c2de0ab032d312961d078c97892e3572ed89ca300712fcff(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c2f31a1ae0a1e6500b092ab7b9a46ea3f75f833e59f3118409535d41a4a5ee2(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d9fd8afc32fa5d6ba0ed00fe2a3266f7a141f45a08ef1c413af4ba612181db5(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f00b7678f7837de433d01cfb8e57d0dac917f5c534c0ee86885a534b717b8d1b(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsSensitiveDataScanner]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05b5b7bdabefe9ee2e54cea3e9ead640a1d3800dc81d23c8c68bfd0628f02b5c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41f9999e5422d1b570688f8203726674557194d9c066156c6d38282a59ad6b21(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dfe707d802883d77e6dd319a4639951e4f6fcb07eb05b5a392241fff1735d1f4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3168311236b95374c99ca27a10183c0c39ada353bde286ced9c29c1737b2d054(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f269588a9f9550fc50b65d7733855ed90ccba82844dc24dfddfd7724b1638e9(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed152f6a8070c6bf4f4f6526a0c847c4c33bca163d5818fc6225a26d03c7f14f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScanner]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab30b1591e168a1b4cadbb33861d1efa228d55d8f8377015c2a825b1cb0d3217(
    *,
    keyword_options: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    on_match: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch, typing.Dict[builtins.str, typing.Any]]] = None,
    pattern: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern, typing.Dict[builtins.str, typing.Any]]] = None,
    scope: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope, typing.Dict[builtins.str, typing.Any]]] = None,
    tags: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__abe24d056ca29c36e100e2e15143c9358ec34bf6b024769a30b306b0eaaaa467(
    *,
    keywords: typing.Optional[typing.Sequence[builtins.str]] = None,
    proximity: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__942c0173ef1cb852e34db26880744b74adec4a58c4eb4486b5e8f17e849160d4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7183e458565fe2a3c7a04474c06d9ad46ca1faade43b857c26e1b72d32ceb3c1(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7cec22abc39603aad7b9a552c7f7c3265ff03ff1bfba6fc2f7fbbf1d0e41634(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07d94108c670770b163485d030733d40ca8d5b7e1cbe385943bd6ff924c79378(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesKeywordOptions]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9259e53bb6041549096ee9420ca976b86f7cc3e825de83f4fef8ebc044fc53d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8f52970aebf4b1b330f6d993dde3639b27fbf77972799ef467256d8ffeb9248(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d818fe436cb1c08eac2db07d1a71becd12b7e07106543aa36abcd082f68fb40(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e6dc42c747416e4646d4b300bacff58c384bd24fdeda907ea7448aafe11bfad(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c26f552bb1c208c10c59ce53041c459a925ed5939b12dfd6ddc1bbe8f0f6e1c(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61f6f2a637bd07674c0e0d441d658fb6e860a506ef2c90baf3f62298da20a781(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__750e4314819aa924957f686f8a121c8011416b84e71466a82d256ba48f8e45bb(
    *,
    hash: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash, typing.Dict[builtins.str, typing.Any]]] = None,
    partial_redact: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact, typing.Dict[builtins.str, typing.Any]]] = None,
    redact: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e24b267c5a7f169aad2a70896dd39ec877d0834b1fda87f09eb199729d820301(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2feda08d85142e14600a06e5a4e8841771ade7e38896fa0ad73425750a41f015(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchHash]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a21a9e4591790308b3e7b314789d905601d8ab7ee3c25b7813bf7bfb88d37b98(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12308e13a1eb5aa71c31fb000ea5ea74eee62913c2fa27905c8afd55f2a74cd7(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatch]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82b384e22b8a6b2bf44b5a452351e3293df5af9ccf706068e070fe4126f6f30a(
    *,
    characters: typing.Optional[jsii.Number] = None,
    direction: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06fc5043f97a5d97abe4e7dfe62b60098abd31718e3652450c8f8ff97c39e649(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f7dfa49ed1f27402d4351e05e6bf11155546f1238bd7a5825518171bb215412(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5116c0c688cc5bb8e2572402f9513d8d42dad3f032beb777c54bc46a7cf8223(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c65f45f93dc3eeea75b0018dfbc7996eb1d3bb7d4e312f33230c8bf540a790b(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchPartialRedact]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05d8ff8b83e62e856bb38e0e013940a840451172478850dbd650c953dc8a81aa(
    *,
    replace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85f60d5dc17ffe0cd6871d01d0f2a3a832830c6d0053da7c529ca1f11963849c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b9f986d344b20e74df2abb05d7c35dc084f1781148ce2ccaa9be215d9f2fc91f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eddf070b0190bb6dc7705b164bfee3c01dd77d8453e0c9c9b1d041091149a086(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesOnMatchRedact]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b5b1dd8fd60daa6e610287943d57ffaaacff42a6e38fccbbb792b2725bb932e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0c337a4c74e0978791193dc0071559c9b68a716319bbf4f7a75958c83803cd1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ced9c1e1b980f083a99eed950a335545dda24a5388e71105808e4a5f0fd4b42d(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13781f6260033b8be238e8d85734de111de7cfb553ebd0573b3ccc3e7b97c699(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRules]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2fbd21d010640e75b18728a769c1116ad458447607c1334440d2f8a195f64bce(
    *,
    custom: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom, typing.Dict[builtins.str, typing.Any]]] = None,
    library: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9d366d92c943ba53a27ab99b98e9c3575cec845917a68c12333d234afaa3cb3(
    *,
    rule: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__791dfc5342d7c6843aaf94790780abbde07e429fc324cd0b643dae6b56014c12(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb1fb3528813d453f68b27fe9cfc828e439d45fe4b071248f2a242dcdc62214a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__75199fe1daa3abf1be653cfae6a5c93133f435828cf70e9e2fb6a1b3c196b74a(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternCustom]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6f0fc366d4159343213a171c644e74ee98d1350a39f7ef614abe8dd9723d070(
    *,
    id: typing.Optional[builtins.str] = None,
    use_recommended_keywords: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__014ceefeabbc9968967a88a541c0258e23b799c4c4ae03a0f761df2eea5bfddd(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e01415679eddf0febeeadeef9ea3acc27e2c780d724688ea8b3aef52ba47e9e8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8657435aeb22175637ea49ebf40d65a163f89441e1db7c13b53a2b7118818f20(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73328366ea97490ba035096470a6f4657db9206aa3f316fe6883b721b663d98b(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPatternLibrary]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bbe8ee578357bd41b004ca420a645d2b7c8e0612fe30ec621af31587cef6f174(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80102ff0d0eb052c83ceee8ad475c4fa0d705f3c4f4446d1652da0f01b150a0d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesPattern]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fab926fa0838f4740e932e97c795c218a5f3d795d028bab2a9920de3b42aea90(
    *,
    all: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    exclude: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude, typing.Dict[builtins.str, typing.Any]]] = None,
    include: typing.Optional[typing.Union[ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39ec9e9397165267a7dfae1cbb1e2165dfcf2c41889b35d31530daa43ba02e6b(
    *,
    fields: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1473ecbf9a4f6cd7e01f7e4b8535195d8b9ebf140093a0904666fb51c5da509a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39449c051b8b7a5622009d3af621210de6a61f8f36d37ceda4d3f004509c19aa(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__30ae5e434ae57aa01830973612f80d69f817c43edd4b62d194a3f0be56d9eb37(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeExclude]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f3d9ea90c2be40cada1f5f027673802ecb672ca1fd34ca233fc3a66503293a3(
    *,
    fields: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd16d288e2e489505e96a24408f25b2b40a87451737f7cab6b64275b02d41a54(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7283014cd70a395b20d300469e2bc866a652a673192ab33dd739410873e8283(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__705e62dc25ad60e0fc8badb18421c31f3500c2603cc053b6b8ffaffc4d858763(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScopeInclude]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__941dd9a80b7c5b91573d02117270eb21a0bed7c517ee2ad2158fe16ed56bac99(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eacfc8b58d835bb6dbd11691c5d555a97755d527d92b7480abd9743056f4ecd5(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c2837d69523ac0707b618c2917de590a066a4ef6d08663fa128a760cebc8364(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsSensitiveDataScannerRulesScope]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9221cfcfe79ad75010cc2319471701747db19ac85475580c2d8e0e3b64a7dec1(
    *,
    id: builtins.str,
    include: builtins.str,
    inputs: typing.Sequence[builtins.str],
    threshold: jsii.Number,
    window: jsii.Number,
    group_by: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b0fb4da87d3f92c820e3e798e2f0314cd7be3cbbe31a1c171789b7a64629d7e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__029bc261c795e350b5c8a33c00dfa7563dc7e8815659a778dfd075578da11b27(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd58544d69d5c5487e7f4210b7b5b6a7a0c018e5e9a7d899598005caae76fa67(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4a6297a7f2b8c8b010eda59b00d780db8bb0200fff506c31d0efae8da0b286e(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9d29bc30b8b1872572d874e4d726da2fce21957cf4f79341151b291dde8b5bc(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f6728cce86d5d42cdb77a6329401a9b20697de94fb44c248f688a4b963e261e9(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigProcessorsThrottle]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c53579cf940efbdd93f8a09277947a75240d47100234ddad1f0ba83c24c51e2e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__871b68c9c958b060a97c483c559a633aa1ad9b13cf45888b29535c90f9574226(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd362e9bc0c8d8fafd4eb651b3f348f2d73767e77a5c432bc8724f97fcf7c06e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4de3db0453c2325676df9b3b20f841671f4b4d5408d8f319b78713308f56de3a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6cded671082888b6ce6f6157b8103caaaf5e9d81fe371724fc4f827150c03d16(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e254521e2408bd6629ae9a2bbe428448f92b9cb77d9d17ac78eb822bc82abe29(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17a3d79e06223bf51704061300cf82a666ff2e002ac1da8b5149535a725f482f(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42c5b3333b81c445e498cebb9ffb12d459a145dcc3e76684bada5c71f53ca4ad(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigProcessorsThrottle]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49015850ddc7b28aa0df549fd07e8652551f233acd25899cb805b635a0122141(
    *,
    amazon_data_firehose: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesAmazonDataFirehose, typing.Dict[builtins.str, typing.Any]]]]] = None,
    amazon_s3: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesAmazonS3, typing.Dict[builtins.str, typing.Any]]]]] = None,
    datadog_agent: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesDatadogAgent, typing.Dict[builtins.str, typing.Any]]]]] = None,
    fluent_bit: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesFluentBit, typing.Dict[builtins.str, typing.Any]]]]] = None,
    fluentd: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesFluentd, typing.Dict[builtins.str, typing.Any]]]]] = None,
    google_pubsub: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesGooglePubsub, typing.Dict[builtins.str, typing.Any]]]]] = None,
    http_client: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesHttpClient, typing.Dict[builtins.str, typing.Any]]]]] = None,
    http_server: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesHttpServer, typing.Dict[builtins.str, typing.Any]]]]] = None,
    kafka: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesKafka, typing.Dict[builtins.str, typing.Any]]]]] = None,
    logstash: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesLogstash, typing.Dict[builtins.str, typing.Any]]]]] = None,
    rsyslog: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesRsyslog, typing.Dict[builtins.str, typing.Any]]]]] = None,
    socket: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesSocket, typing.Dict[builtins.str, typing.Any]]]]] = None,
    splunk_hec: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesSplunkHec, typing.Dict[builtins.str, typing.Any]]]]] = None,
    splunk_tcp: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesSplunkTcp, typing.Dict[builtins.str, typing.Any]]]]] = None,
    sumo_logic: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesSumoLogic, typing.Dict[builtins.str, typing.Any]]]]] = None,
    syslog_ng: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesSyslogNg, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__814557b96fbb60a0584b97b52bf00c335255ec5471ece858276e01d58a003ec5(
    *,
    id: builtins.str,
    auth: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86c0c4e4dfa61eb6ceca3b49c24240e9beee8307853199101101f20df5e4f621(
    *,
    assume_role: typing.Optional[builtins.str] = None,
    external_id: typing.Optional[builtins.str] = None,
    session_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06749e4eb0cde7c68205803ba48a151828b4aeedf58047d011cc4555225dcbcd(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__43ee397eec7b26087562ab1b6e95094c5d30482ffa4d972bd21340010e4438c1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ffb3ab0ffc8486fec0e43bae7ad4e3f1f994473f77f7c85ea3eaa2bdbe1da0f2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__135dee6a31f146da9e7fb10815c16f3bee8b73ea26c7c3dd32378a09fc2874c6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7ca4f876035ae6e3107da82f55b9b40824839a724b6c19547fbcd34a07cc608(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehoseAuth]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90eb7783604e99f91230d1f4e59dd528bfd361fc6e16e567dbdf76467810d316(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e0c05c9b34cceb115c5234461763afe0f0a1c7350d56c2c04d32c2dba839192f(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2dc6b2c73c9ea1832da8f3c17497cae1b8e33228cf9d0ccd678feac9e4d3bce2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42fb89495f9d99ae6a99d76efc3fe57cebbda0234b078fffd7401a49c048c9a3(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__191311178d5c9957516d5abe2bb2d674274904e8c5a270ecc0eb65dea3e25a01(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f507bb9b38eeb6d3ab713b9948b7bbd217341d7df208ce84de1fa3229e7ae77(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesAmazonDataFirehose]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce497cb22e32b7179f2e31a2f404fe83d0d3d35d77b2efcc4f41ccc57d36adb7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af4d444aef66fe7ab2c2c43e33573ad786f748e967d8fd9f7d58db6c26f385b5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7ea6d883b8c65e0c5bab192facc4b32d2dc99eab900c758a504cc13a1a4464b(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehose]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af38c4f5cb8f99768fcbc5421422d2571aa6bf43d3009721051a63d6f84edb09(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__46c4be08b7fccba7ac11df0345956a6872377631b0a1826e5d0ee6761693d41a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20569db3672c2dd6d0c2786e81a5eb1dd625be2cbc13134c91f5379540aa3a49(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2bd9f6796c9e4d3f23cd36d5aacecef223375b188f855738b7c67acee9d73892(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__30f95c130b4d2048cdf6307898e54b9383e66ef17b6122e867a98a510bee2245(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dccc29b028e36cbc738f230c518e00c7591abe8fe78a6b4a201c3a2294a2fef7(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonDataFirehoseTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ccf5b1c96cca4aac37aac29c8526778799456b1da77fba54985399c871fe312(
    *,
    id: builtins.str,
    region: builtins.str,
    auth: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesAmazonS3Auth, typing.Dict[builtins.str, typing.Any]]] = None,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesAmazonS3Tls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0642464453bcd3c7af976a86fcf10d64875e4ea7e5aa97f8a5073b23cc00b1a(
    *,
    assume_role: typing.Optional[builtins.str] = None,
    external_id: typing.Optional[builtins.str] = None,
    session_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f475c3812ef934eda4251e6c8ffa734170499b6301a59f07b37cb6bbcf451a3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61890ab6f55e38c7faeedadc9ce8862f635aa9feb9cf31d24aac59fa0f8b3967(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e5a657dfa9862f883d647c313d4198b72ec1c7845403f5ffbf9ec4a444937ad(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e187702d85c94d30d83f878f9c311f68d89cab8af3f79b12b39db4b5a917d3b2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a23d06d5750cd00f4b2964bd3b2af2784ec6e2cf05107f34f66f7c00058ba2f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3Auth]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b4fba9502ed63a3eb395e3c3a3731a89d5a48fb8bad6c0fcee73ec2bdeb82ea(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7db43fc07a40ba72823c43d1a87d3ea7e1d4d2b543f70aa5703d1a7ee7b30a26(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ae710f525609a123941eb88d4f9932fb0398253a411ccb67f653bd2120fd092(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33d14cb62609d8f270faa129502a417559896cf6765ad00bbb88d96e18a057c9(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f19fe6f5cf713ba6e3c8e4d7eb2dcdc4e8a13039b89187308cd53b99a5e2fff2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d6a3b516557e8483edff6e2ceaa7f5d0230cc8bd233c0a4ee1e8a130515665d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesAmazonS3]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__776c5d32da34aa1288dd3dd290b80f8811127418b8dbc8a6948b7afdec714df7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9144cd8293ad2d7e1967bdbf5a1cd2751c3f9332754c554e47352d4d64e5751a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07fc5e7127a78477a0938b0ca95178458e9869f08fe4a35a0ecd8635987ab0a7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__40122e961a36c88d87f518c274abdca6a7f808555d057858a272864c2b47540b(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80d9d0dcf5f68b29d1c50f72d2f198a33331ea65c95b392f2228ec4c7205142b(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9f368c6b2c532e8081d1c11e59b7abbb75fbed5c86be2e0f0f12b53a9c90526(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c75bbe446916c27a3b2a3aa448a346fd7e317f39f72fcdb74664e5c3b2455a92(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c7bd8e7395f34d805030cf1e0eb1257a7cc740ac263caae68c26b99785c5dba(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7cdc2db527b0da9a535bf15e07635a353dd53b3a8ed3cc548ef92f60325f9171(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5f88e9c6c57ad13da7c7f58155ff31be0fd1db7527ea10a7de521ab2013b526(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesAmazonS3Tls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__40201c60390f36fa192eeac8d0af2513cf89c03af6641e65c0f35add37d87ebe(
    *,
    id: builtins.str,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesDatadogAgentTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7cb4d298dccfbae1a99f65381f3c298ed79508c6b35c88c90a6c352dff1ac84c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1445b660cfe5960d6e6a6811c74ecff20a88d14b6ae3430099c92d0b9c4cda9d(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a92151ad31d93f6e95c11400ceb4d7370170773ed92b7161676add8d88bd557e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22258c5e1a53822dbda8a82930c51bb5fb3dba2f2b02c77ac988ca5799002a70(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dac69d6abd36ca22b48c6b2b504f2f465048bb3ee2e0da90803a74d8a55c0e8d(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c3c3cb4e6bc2164419addf08f2f631e5ada486ed221af5dcb3c4ebb0d61cd72(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesDatadogAgent]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__405f98baa0b8eba74e390c222687507c5ef0ddb82f7a807a62be6e3de9e3b97a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f5dfb5a7b5ce97d2cfc53b6fc85a61b693bd6dc19eece711917b5723d4554b5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17b5f01fc2a67116df0634133c082a48b04e533c19090f3c0806f9e442696735(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesDatadogAgent]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e1248ce1386d6f6612f15a5abcbbc84d0bb2700663daff7defe11323c2b3baf(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ecc3e40a7e2dfa553b85abdb00d6d8c8a8f2a76e6bb9eacce5beb39f96147cd1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e28492516ef7eaf0ab27516fdc5c328f418ca63e4424193c8061015d58c9c4ac(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e96fc24db2aa2d2b693c1a1a605564a7f5ff08a092fc4e3d30aa9dfe39b45f77(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5cfa784008904a2745ef31dcaae41ba3d484c2f272c399c9091c6b896226ae86(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b3b6172ee837de4bef4f6409a499b47dc989333cccaee51c0584ba943ab43c3(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesDatadogAgentTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2cd25eae20d2dad8351a1af1ce72dfc705b3e41186a3d76edf76cdb64409916b(
    *,
    id: builtins.str,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesFluentBitTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__393add17a7da4a090ce2467ab2b4abc33583c26af57f57276e26aaac29dea589(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2311abf9bf4a8c3519c20be559b9155b7ecb9d19ee5e76bd4f074c8a120b9046(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__800bcb5c130334fcba80fb64016e6c6c3c98c2eea1f4f66b9a7ccaaa79a95b03(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87f6940e80fe131edc59c612ced48437ec01227d39e2cbc7cc2e37de44bcdd96(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c21202673c5409286c5f4c0df2c84824ebe5ef79a85a728be0704939bfb96b70(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__590aadf9287b04e678800e2279d591dc8f7910bc5f85a3d30cfd8e805a949163(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesFluentBit]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0ca29f7e574a8f9089ddfb6541a52f83d3152ef0db3472e8e942004ce0bc1353(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbcbb6c60ddda45de9d7624cdc91e1cf4afbde2c27ac0d26b0c04e91b36ec698(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb82d4d3a9ee3d3e54cd75d7680996a41aa6f12bf126999afa8c53d1c9115321(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentBit]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a5f9f5bf5a8fd3d8cdd3b695e2766a81d4c1a4cb87a423d82e161c31b44cba8(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb6680abca0eb9c08dcfc644945ca754c238b502e2fe08b0e928b9b85f0bd614(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__46aeb70d6c9a9d22a2845abac1f1e83be7e8e72353bd4ed81154d0b89a529777(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f1b0b33a6e4cb0b3bb9fcb008deac4b7ca5ae7b09a1e569a96c60ab2040839e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0f38584acdd429598005b6d6f0634e35afdfb909112e8cae971c073e53d91b1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82cfbe1143a737ccadb5c8f3ca9b2124c749103163f035fdaad99a14d8989eb1(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentBitTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__449f5b3360770c32f6b1327d19442dfa5ab3501bb13792c3c1de3699ae5e0311(
    *,
    id: builtins.str,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesFluentdTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16a96912448a39d3d09a4456c841b628edc88ca7d9b5cf46c6f6af8032e7f4e0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25cd8cb57b7ac1cf25ce856f42103054baef3965bb7ef59231e3b582516a3377(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d31da2353841d1b394475aec359144d30eeb84897603c3631b6d9daa54aa83d3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1373e71dfa99e181e0ae6b2c075ac9660110c274da5d11375c939d336e551d68(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1125a7eb9a5bf0d4fd0614f9d04045457241c1778a28958e2227d4985932454(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ffedb5d90f25fc3953e90f87fdfd6b162cd44a31a2808069a0a6d958ec2c0c90(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesFluentd]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b271862879197b2066f620820d4d12d99f71967577e95b6c89f857780be19378(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__43cab42fe008ae310d66d43634bf6deb54b7ae28ce98b2d56c435b2ef8855390(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2155f4df9ce6b42765394c2d0f7ff19397c007b19b146e99ace513ea72765d3e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentd]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a6d051675a96143ec0c5dba73c446e357c16d3a648b4bbbd4688b74e0d2a61b(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7239af4dd1b81378ad2fd7b175076ec6fbe12e1868b1bf8cdda8bf84fa3ff539(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83e0942492667c26681ae433b7e1e47ffa6d6d06659fdd03a1bb811a747f1f76(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__598b9bfe95a2bc72059f68a4c138b531887c87dc35425baf4200bfaadabae58b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c64dfdb06fa0b58fee6a809461a1031809a611cb981653bd6d5256e5b4b868c6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf9af381ec42eaf327fa4f0830c76fbf6c120cbf7e0a095a310b5ae596755f15(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesFluentdTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5fba159cc0fc5ed5bb5f4104e26f34303a8a4909efe2121aa39de21a497a4b23(
    *,
    auth: typing.Union[ObservabilityPipelineConfigSourcesGooglePubsubAuth, typing.Dict[builtins.str, typing.Any]],
    decoding: builtins.str,
    id: builtins.str,
    project: builtins.str,
    subscription: builtins.str,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesGooglePubsubTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a46a87201ca7886b435b4693cb195cc2ac759dac41350991a2ebe4c52ffc3fd(
    *,
    credentials_file: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5f08f2a06d563674f4bdcd3cabd563cef70364c2f13dbd7b4f17620d94596e1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82a69a46991aa50a5da0dd443710cafc018be274a46331b93214fbe16046290f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e58e785a7c53a2d2aca876822254e2d2a97135fe338dd1be4ff4bc3dd5850dca(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsubAuth]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a3420f48293852d0ce4f41807bcab330e7fe0851dfef17be8eb16df02000886(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ae4903ca1cea458150cd2b593eabb6a77cef8bd7eb2feeeb5d3514e94ed0a69(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd13f55fb7ac356a2ddd13b8d75c918e9d7d312af96c450d54f484af033bc0d5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a557a61e42294caa1313cee6832b422095ba460d57890508ca53beba5766a3f(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5586bf7503c7a45dde71e81b5b583ce28c57baad8db9bf7b9c048fdfd7dcf448(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c76146663e8392d4a47f489b98e54e7df19aad199b2fc82aae37d8ae31228020(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesGooglePubsub]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4de0d9475ee44bff6b5feae78eb4871558048f4bc7345a00dbd5a7ea792b1eee(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c3eaea323893f35f1069b12208dea8d53caf7098897f3791ee4f5f8d4b36173(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2dc8e93cbfb95031f31e013a26ba4832ad7718e3179aea5cfe7eef18243da98d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__09b7d5b20eea66b74c2c3d9bf6e79087d3f21f960c781630f383061e58cdb5e4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73c92f37326364b6a47c027b4c33be8f06e25aee2b886f6f5bc1216c7b4c12d5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3963949ab3e718a3d4e7274982be4480d7df2d398ce53b5926f2bdee27cbcc82(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsub]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__308996af2623d83413cf11eb5359a424349a4d213b4b3d55ca24c63b3bdb638f(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a642671dee803811040423d6d91c0a3e8385d4ff371a0d3e6e5ec5cf4b33e52(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed2c939177282424d7aa4446aa6481ffe686c80a6dc85f58a0cbe1d4d5c52fd2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70be470027162e35f917efce474c2af0efc2f0d2d5be7a204f03267df5a78ab6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5967f2371bde3c4388725f5595a09e6dfbf21c88c46e47a11a411036b2c2f116(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b27ea97b03c179a07af36f8923ff69bc6cd19906726b728e1b6554ef502d8a1(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesGooglePubsubTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e3e191518b28cdac54de1021e53567c07c8e5c90a15f5dfb5047af119a293be(
    *,
    decoding: builtins.str,
    id: builtins.str,
    auth_strategy: typing.Optional[builtins.str] = None,
    scrape_interval_secs: typing.Optional[jsii.Number] = None,
    scrape_timeout_secs: typing.Optional[jsii.Number] = None,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesHttpClientTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__950d5cf2301754679d0d69b7d1efc1d8417fb1eb63cdf7e1febbbc950eb3c36b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8dd812aa4df778af515e30c0e6528ba61d3105c01f1aa5558f7e9f09cff2835b(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2c3a5a1a80971ba9e02d2eff39c6ff4b8d80d81a7f63cc4d0623b9b8298bf03(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a252003456b37cd5505bcdb41299bfddbd3c31798bfa7b1efc4f87b208aea682(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f2478ce9860abdb419d950951b9f83ee755037df8dc415ed5d6dcdbd12b75e9e(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7a1d548e4797f03dffea03d38819438a0c0be282c2c64a334fa5d97b9dc3cb9(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesHttpClient]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5bc1459d53ac55e91da6497811c3b0a8dabee8e47c2396daf70ece8424e96dcf(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__510081de4363b287a8185b64d182e4999a303444e0f0c30ce3ef659c2459d910(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e27d513f4958fed881429584c9e12421468e6b7c5fa6bfd4c0e8e15ec63cb2f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a6c00175f3c176cc0e296ddaba656b76df99c1ef2c91ca19901402967013dc93(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64301dd656aaf21b039aa5dbe8bd4b33780c8e1edcf1cdf9a7bae946c30a9b44(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd7ec85a24e8d2378e763b55d6129e6821e07a0b2edcd1d6a8d4ae23984b8dc1(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__abea684c5db6cd559df3ec4f5aaeae194eab882f291313707247193f4c496a0e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpClient]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__313fd0e30de8607003720758b782400b814694adb83c71423ba699d590280605(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88ee6cc3bb8a0bb678d607adc01cc45756d4c43991655eb00696cc88e153a0e3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__edaa1bfe9d7bf6ecb903822cdd4a51d82d212849ca84003646f806efa7e31e34(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc60176bab0da635df1e93502672213ac369bc991780e045c0763a61d8c0e504(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7e1fe430f0855e6c9db9fb579508dc54a0a7df7250bc96d9d0e503c0e2559dd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__685e92cca8ae24e33c1e4268b43a481311e5439998c96cc51df320e3898d92f8(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpClientTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70796920b01305b6365d4d9974a54258b82a67c2d45c78ece475a808ba25a608(
    *,
    auth_strategy: builtins.str,
    decoding: builtins.str,
    id: builtins.str,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesHttpServerTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d941524be1eb8a3ad3c28349a70177dbcb9a7a200bd1f310834bdb63f77307b8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70964a498552b40e6bd8d4cefe7b710eebc0f772b550cf11420e9a98b696e412(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cef9cad1b0e1bf503c3d471bfbc291b9dfb6453fd9d6daa0c186d6764f6825b5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__58ed91954147a94f640c4ca1c9e10c6f0667d00fa231c9d9b0c807ec90423a33(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a242407ff5fe0fd9e948e55f4159b386ed7840586932dc0e3a0b6368f7185a1(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb7c23f8991f00adfb33c75f6df14143b6d6d4274c4a3c96d50a97de91a30faf(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesHttpServer]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14de3e68bfa2e696201926c73d76122f973e53e084dd0f99f76e36412d07e3e1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89518dd4b4986238588b04f0be1e23517027b40001821ac4a7e00891a22af62f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d727e7c9a5800d5ab8a804edad8daf868f034998649c97207b82a80b810ffd73(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__990e1da786e1187de393d69f8a769fd57ef2ddb78885cf258ca9b31404b8a4eb(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef0820a16353cb157648b6f7ed7ba1f0b7ee803a297fa8892cfdf9e6aef33771(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpServer]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5171086ddf38d5a55da2a6bbf3604c620b7b2fa83c2ef49363b157e011bcbc7(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee76d9f27547e44ad03b82a306a17845d7116c9e22002735aaa15a86451bb8c4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d80ee1166bb7921f611a650a62daf3f9eeef0ff2b99d685bc3db296d5586fe8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d446afca6638b4333b096acd7df512b9cec201c0cb9501b0b3a4384983d29186(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1cd054d6c25b917ecf93c62a8a827b6d9ce806e399bb86891cd8d10b1480df0a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b788813a793699d1aa8a7a9c6500817ebf41f7eb20d2a68337b2bde17b392f26(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesHttpServerTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0bd79b2cf7c0464e23f9c8e94f48bce0ce006e782fa5311b6373760317e8d27(
    *,
    group_id: builtins.str,
    id: builtins.str,
    topics: typing.Sequence[builtins.str],
    librdkafka_option: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption, typing.Dict[builtins.str, typing.Any]]]]] = None,
    sasl: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesKafkaSasl, typing.Dict[builtins.str, typing.Any]]] = None,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesKafkaTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c5d0624a80c6c222871d6ebe171e184204118a3006ab0b82d2142b3b692e472(
    *,
    name: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__815877146f7eeb8059be1007d48c068cedbf6d686e14e473539c943c97d7449a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e90ed0f87e8b5272e82305d5464228e6088083a2a4a60062971eed7963f750c(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25d5d1eeae8368f66982cb98f462bb6de75c6845e73266cb003d46c3c7d58660(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__139ed0e40d7546603ce1debbe13e8e10d74f967ea0630b765466578391c762d1(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9568500e1b3b049446159d7d2b785919f84e9fc68b528263b5ee54e32ce38c64(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df9a850b4ee7e351ee8265e5db14f076b67dad75411ee00a2d075cdcad2bbf63(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__deb6cf15ad8e2384d1a3a62d175c405052c1fceda6fc565812ac6ff17da9abb7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d931536ed43a98a1d09cfddf6699b3c98dd0d9a6cf4741b8c6572a8fd07783c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6513f9dcb7f3b77aa3528e1a027158360e02e185b997dbdb7a164c5b0cd6019e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd31d6ee4bfb4f838ef0fbb863aca389c7a22eaa2ea77bb5027c5fcb746f21ab(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1e360c55060f7aad4d70cb3f9f4d9d6b4d376e13a44a89b842beee0c44d3912(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b199d24e78b213791c133e169c79090ca4a4f2dfe6d8fe53c0ec7e4a3c24e6d(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3216732c27083019e24476f70e8fd1f25323408442320f635402ec59203cc7c4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc099ed115eee72db525ca2256d4a145d37e9da7e1a22dd94ebb8ee3577d30cb(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8416d0b954c5f7cca370f6eab77bf27d5be7e1e1d5b068d6513f284462530798(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83a094957d0e77752b407fcf2f7822652e81f538f8c36440cba328efc207efb6(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesKafka]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5b5b34319f083966581dc59835a0f8cac9bfedd865462f47f492a03a386da30(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6948e6a338aa5a7846330e81694d07385095660a4b6d9924621a5f504cb053d7(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesKafkaLibrdkafkaOption, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__622359c6ffe3a4b3cdf81953983c0654ce8cf870588bfe923ad91b54dabece41(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84892662b215c640845022678839bf4f94e724876627d34cee3513d2ef93095b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9dfc515f7cade04b03f03c06623e6542a4066f9716d398c0948c9b6b30b4e1d7(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a8b183bb4fb95dfbbf0c35f44a7253b1c239e0562e6047b9db48fa1969e7d10(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafka]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b6e38ce744df0cb92bf762198c4adc184d3b7f046d504de1c3685045cf9735e(
    *,
    mechanism: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b878721355138368deecd0a1da77a1aa730833afd1439ef23ce898f8740ff10(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7bbf0f299715faef85571286f43dca85bf3d454bacbb9d8bea2fe4dd521242cb(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1db8d1a12cd7c6f6d25049a627cff5006490281ad1b101949eb8dfb106275111(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafkaSasl]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94d6c7bbbd7f2b61906e176457cf1a945c1143eb7863214425d60b683a1c10f5(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__000a52ce188d0410331c08333ed1ea695f7bd5d94181007456c5386772c41f83(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1020ee2daca202835bb81ae76cb11ab4c7c736dd047dec6ee1c5774188162218(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d9e79803cfd9e8e2b214f874bde22baea57ac0242f3c236b5618cb3fd093385(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04250b0879c2d4d54cf4ad0d3e29d8a6d1f5e45a70a47240abe5cd84d46d4fb8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cce2a5a64b073f774d5aa097a3952fed90604f78b678a80e15d859f530f3ee54(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesKafkaTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00632662e2ae3748896ebdd76cd48ec33ddf96422f123ec28e3d34fab2ff26b9(
    *,
    id: builtins.str,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesLogstashTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1880f10d144a4c4edf67c565de3dbaf45b5be17b2916e32663d4479be8761960(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d6c2605b08f1e69ce12d4306458304d6d57854387a8d06f58198f11c17a3413(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c8c1c3f2ca4995fe12d5c81210bd32728bdd6c96a43e67c6fa80261db6b92dce(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b04dd46fa76f9f620cca4fc4e7143c90b91fabd350101ce5cec7516d9abf5ad(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e1c78da85fffb0625f178303af26932d5855cbc86cd0750c3dca8a994dc6487(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b21bec8a0c75a12be21ca182470f08bd831758d237afd171780c30d0f0d4f0c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesLogstash]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e768cc9b4e0aab458cf987d857d40f9c9faacdc33860a1ce1f1f65809c5d6f2c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f21497ca96e3545c1717669ecfaf6cbe91ed528fbcbde330c6abe3efc2a2a504(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a6034e710e6901d3da07e94d5515b90b7fd0428d4b8e941d55946e1f56ebcd4(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesLogstash]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f3a19080c3ff74695ebca98c671327bcb468dc7e296fcb9e7fd1a04b5a6f3ab4(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f7fba8efbbf6754dbbc90dc82f7d10a022034a659ee4749c6231635a31f436e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af1dd35dffd2dc67edc261090a0ccb9fe75b4be2991da39f2cb8ff13bc01e21c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe43d5472cfeae03929d3e2a85c9e7d6baa827b1be58c13f0a26a74bc120b729(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c0da2b364999a4e3dd2b323bd2b4744e7f89cddd284daf2b48252b61dc3b8a9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1be112c672886cd886650f1d91b844cad51a159aedd7739a0b5d9624dc7251bf(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesLogstashTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b48de712acdfad9d5d2f7e9f51bf90cfa89a1103c4dbf1922bfaa8590b7dcce(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11adbeab3cccfefe5e9fb704888f517a3d9449c82aff154632abe031620bb0ed(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesAmazonDataFirehose, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92140c26ef63a2e0b6a9298a1d63759f13978278ed8f2e9ae9fff8b4a8e9c881(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesAmazonS3, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c1a4612504dc0bc02164c43e0fb103a0984d6fe5dc39443dd949f6cb4e2093d(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesDatadogAgent, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49d4b1050700ee86e4ecf16a395ca4f7d5c3bd4a1ed362d62bb21d87d74ed225(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesFluentBit, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2159e0d7f672df042a71e79acdef2dbdc664cf0d3385553e48abecde4fdfab0a(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesFluentd, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d55e7cf6df20373e570ae98ebe023c1eed18d1bfdce87e8725cf6073f5b1381(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesGooglePubsub, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__860bba32e929a6c931f2d425bf09c187dc8d9bb55a372942c5c706655764145f(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesHttpClient, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0aa995d00830bc9702cc312103d9c7185f498ec03b1f677e191f4467e888de12(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesHttpServer, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0afd50a302db25761c4c4735ab30449ba0ba4769957bd601ed8b9bfbae9d6e63(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesKafka, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c8f907ad20d7563f028fd8e644bd785258ad4846a804c65b84071890aeb512c(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesLogstash, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf6a3bcb0e08e4fad0f94d014f33d7a877ee460cb7810e1203a5a5720189d941(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesRsyslog, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eed231a0b55ab8220cf84c9cfcffb2933588119862020794073d5d27749355a2(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesSocket, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__031aa6a7c56a1824e5dc35c76230fd29b1219f253856d4ad16932f33486f0454(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesSplunkHec, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5985b2f8187374b7830ef0eaf6e4744abc0cba319a4c7d801a1d27dc36551f08(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesSplunkTcp, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da0c0e45cc07b8c35f7ea34df4b5a0224ee9d1415621a96ecdaa284317cf1b8f(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesSumoLogic, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a004f92a182e3a6b416e2d5bf73ea09a1a9b49404581b8490decae644221c699(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ObservabilityPipelineConfigSourcesSyslogNg, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b515a1ba47e4634acb7fe55d0b955434b2dc901b54e5b829571084232f32cbd(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSources]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__333cfc949924460ce41d52496a76fb0aa416339cb9c3334b5b4e22f9ec603bb2(
    *,
    id: builtins.str,
    mode: typing.Optional[builtins.str] = None,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesRsyslogTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__375ab1abafe8d96c5e249635cce2422ed4a266bfd559c5d0ab8fb54fc620ddba(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49ac59f1f27563aa321c588dc3bfd6f35001e5d810ebde9455ffec4e3d697604(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04ee6d31e44b9a55e14ac2a1947b1bb45b38c73b10478f764a61625790b61aab(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28809b7cef21be86b6c12043bbab96e4cf578d50b417c750e462e15532e72be6(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__758978785b032aaf8ebdd1ab6a53135bf72fbffe26e649b3a40a359da0612c00(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b733bdc496cf27ca33ead91ab19a4a97fb9cdf95af061c43905f2f72f2ce4b7(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesRsyslog]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6c31494c248d7281df1c12945fddd8bdcde67442268d0423709f32a74e87bed(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef6cbe3481c997bd8fd91b08eafa382051a06943ddc9903a9b9542798df70ae8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51202d3309586b0485550b44fdc7d732159a5829d7398bed7b114ab11c98d777(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0be279cc96ac206c62e9c2618d0208e5ba136a0eaf936cb6e3f869eb422965c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesRsyslog]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d96dde02487308407e161cccaf6f08fd6ff86a5a0ecaef96107c75ee1e58f50e(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff7e989c1d2207ac54529824b807aef78d8f6932ed43926fdfb027eee68c2d5f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3090394baebed16adfd9274286d1966b1fdb748bdef708c7362896d09d8757f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0fdae11f6af7417d183df302ba55e09cc4c2f82f7e2aaa67d11c5ed5ecb6f404(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16d82dd59f6bbe8404397f65b9a4b153eb9d3cc5151a13917ad526e3ed01b86a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f889d8dbbb849ff07889b07118d2ae090450037dd2048aa8a396aa60393ca27(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesRsyslogTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5dd3a661781ee69470ecef4b441002eef7c450fc8a7fd8260c704081266b9e39(
    *,
    id: builtins.str,
    mode: builtins.str,
    framing: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesSocketFraming, typing.Dict[builtins.str, typing.Any]]] = None,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesSocketTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b7a9a67dfe0bf0b3609a737dd85f9c803d3efeea628e77f88a61bdeb837f9c7(
    *,
    character_delimited: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited, typing.Dict[builtins.str, typing.Any]]] = None,
    method: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7fb125bc9dd6847f936ed83559e7ebd35acc651dca19ca149735e79a14f75fa1(
    *,
    delimiter: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74eaf563e46430334524dce78a34eeee10940cd76c50ada377898bc6232a0001(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7aebe4af325ba1779ee9e4796057a0a96f114adc7b6fd663018ae01b61623a2c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13bb98ea128c6389a3c523f8c73ee4d89b255feaea8d5e64593553ab087b5651(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketFramingCharacterDelimited]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d225c5f8bb0b73fb9297f446c2e1ec675dc0be1e77a33e4a3dc45ca3ba2c8de1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18ae1684a014220674220842cf81d7b3d7ef2eeee1ffdb75efe4107ab6e7b157(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c02ffb3b1831c78328c9170f665c49b012749d2e14c016672c9c0bfeb17bf60c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketFraming]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20cda3e271400486a7ae9820f3bf0a743ba5a3581a49a000ea86e5c29519d320(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5fcbb88538c4c42fa8c4016c11da66afa3109bed3b8578cff1c9e16a431cd865(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a9e7375bd4ed32934c79c234c0341d473bfaad1b20882557ee5c54a337c0cbb0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f38258f468ced89a122a3d8e7fab9ac7bd2a19eae5629499cb4835908ab17679(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1429493dbf926d40f34a447a0355b87bddb762399184e6b753c99dd9da9ede16(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b2f03bf24419e920e970bbb2b4e0205aa8167b6743df2dc220827f73d69d858(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSocket]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4416435eceeb10e9b6eb93738b7655fd80aeb99be33fabe43df95ddbb3f6bda3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef8b7270251f8d812fb81ab7e856a371e7290d1d3de90dcf4793a8ae96857349(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b2c96fc5b8a0277a8c7f38b2bddd4c93618f21b3f91bd3d0a23eb8266b43951(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a46c2f2b563bec3f049f805a5dad577c1ac1a3a4e117033c81885ab9c29ba14e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocket]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36afa286ae273d16baf77e834d6bcb476fec7b15f18b1ba29a8296b97b899380(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f31039e3b8afcc25f5fcb6a3a0e51865e1d3f4682f7715888aee011e03183fd(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac62490dd7180c047a710a72209d7b135a533dc73019535648ee1a01936db4cd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a8796b892b48f9ee1d4c3583562a079296affb27bebd7c80728a05c378d7db9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9dd3e15a93ea8d8a48189a82b69ac47206d6055b6e4dc32992f5de91e2c6b9f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ea6f20bac48dbfef8b067e2251e569d1194699df93d8c2b9d68af78b0297228(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSocketTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f341a0d9122e1dd3fb48de65ddb364316413f84d08f646438c6d23029d20b6b(
    *,
    id: builtins.str,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesSplunkHecTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0fe57b5393b2ed0e252dbcd907b418eb06881cbbf0797d7653270e5d6359e0d0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__958727286e4594e4946116c1e4d7123e5f8264c11d69b5e427046625f087af48(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac1e1c746be707c3dd89389d92dc14b3cbcafdc18772c88e4be0203777df8e91(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__762f90407201b4ac6f6b72e57218fc2d811415cbbb0d364977763fa4a6a357bd(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__315caf67c21fc39d5861da75d93dd38cd452d7962204a0957254426adcfc621f(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b587f31a75b2d112042f94757864d4b3a189cb938123435c905075e609376f4(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSplunkHec]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d38aae60116982095370f3068aeded1c51331e57799a8895bec8b6ae13dd6c9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93a9ddd405dd0ba8788b23ab94896457f5e2ef22eb06c9fdee46171bce35ed26(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5b2cc3adb9ef8349ad4aee27921ab010ccbdea736e19c1a42389c70843354fd(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkHec]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1bb980c38e14b804ec27b4b9a41cbab3d114c59cb54f0cd8cc9c84e8238a4767(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f21bfdd3b5ffc571424b32f96682533dd746fa667364d78495dae6df4c0e4ed(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cbaa10f8d8893e3573efbb1bdd8bf5ff4cfe249e74f64210b994e1faef3c4aad(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1b4e3aa10edf3434d0105318c561c34288ad0bcbbdab70a989dc45ab0a4cc71(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d97320ade901ed6270240907cafffea014ee619b98344e584b4aae00814807fd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__443dbb6f1376cb3c29c1b4c354fb5e1c102afc5e8e400ffacbaf5bfaa28b6f10(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkHecTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1780475ca2aea03c289c4a01e71307ef06fcda76e1db222c979690baa4a092b(
    *,
    id: builtins.str,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesSplunkTcpTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d3af8cff99bb73b99d64182512f3550cbd884a8118a43115bef3a8842ce9507(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e57b1de6a49433c62c3dfea2ba82edcb9a1d1097d0d1d5300f2d9700b1362789(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c23891b6ab75880f9ec304af1d084565c3c6ba96047c8f2536e6af83612f4fe(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99b4af3e08ebf7bfcf0f4f63f0a9a57722b4ea6cd6150bc3b6f5d789f9341be2(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__167c939fee5205855469b62d6dd26284c2b36efa8ed07df2dcd0109d52f888ce(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a34db31d434bf1f831f1d8042c4ac3fb8676719efc7258ee28eb0b36a82f84f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSplunkTcp]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27a1c402d671ffda3af8f8220471cefbd502c69b8d10601bab0d975aa0dcc9da(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45dc6d2274f9feac1203a158d455c9072b57b1448d759ac900060845047645ce(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73a3aaac9062b441306b3261fd53728ef2675bca3cbc15b6c91e1b6c75251060(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkTcp]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__77caedc7b1bfa3d34ad9a15f91187d408ea80ab5d4b755f5540ebcd05728af6c(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__275f0e17ff0bb5de820a76753f96f399bafb2f23607c8fcc7fb2337824e6eb86(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73e4f4293245e3165f276c3cfcac3ddb713d6c63ea7169a08678e0c1f7b7463b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c940747f9a0d61d6d699195a6658799c035abcb485c5b2e3f6df7ce45397634(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c602fc443606c72bfb07d46c7d55a63edb7a3f2a26885639bc1fae5fb76c3a01(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb46a1d3b5e46b4bd4d2e5d69a8acdfa2e513649fe42bec9314fefe4ffef11e7(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSplunkTcpTls]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b0ff3a38f052df98ff009bcd0b9140e6dde3ad1530371d2c77a7cdb2ab045eb(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71b917066f1980b229fa3860f7597e7de0fd640eef38a3edb1f0114de7178c0d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6be1940a4049fb7f49f8ceeb6b40853934f93ba491196f5720b02ef092577118(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f26b722c7a8e4b4c60a1e8fe6a8b7a21bdab28ed80789091b288d3d92c56531(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c661c63758c97f5695d140e94825caab980e37d1a8cd3c5ab6710e3997f94b98(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__321ad901cc3fdaac5780275a3cde2dcc6aa1e77236ed24607a9c5363df9fe734(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06e9b43e272671e285250aec3705313b176a74e857edbbbeec9f944326cb1ea3(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSumoLogic]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee2517c57fc4274be22e6561a02869ef78a912e77f6d3d40e1b4ce6ccc7bbf15(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eaad48e223ed645c28810a8d0c6348d9a2fc249aa030be8b04899b959554e5d1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9725041f45570baa3ed0c5b88db130a41064ba63b3416be28b61c017cd8a5114(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSumoLogic]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34002abd46dce6eac9a0480ebf11f2badadb447654d142dbad08138e4f59f95b(
    *,
    id: builtins.str,
    mode: typing.Optional[builtins.str] = None,
    tls: typing.Optional[typing.Union[ObservabilityPipelineConfigSourcesSyslogNgTls, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c55619f2dd5e536c17ab96a5e8f80c9c8e096f2806cca9e65e3019ae36387acc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b31f8c3597105fd4a6db5216516d959c96493685fdf52797f037a147ed82ab2c(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2d47b030cd310393717403d94821c9b7ac02814574c090fba8164c3b772c136(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__436839e88ba74c54965530667f17056b6de4cea653f5c94830e761fa0741f24a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31e3d7e4132840d56451dc06e6efb3644bf17b845a475931178ae59a48ecc321(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3822ebfb0d62d3e16521d9e857ac9f9120159a9577f710e9921804772287458d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ObservabilityPipelineConfigSourcesSyslogNg]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2b441f833d15d7c20acd26fd40078f4ecdd6b6030f13cb1fdeee2a8f131b409(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b67248204f24d2ecafdaba33477a0081f6d47ea982962643333575cd0a8a5b1c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1aa29287d5c9bc1320b9ea50721d66218e485c32c592e03c6f7191a5e9e4399c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00d8a9a143d3706eeea4aedd391ed86deaf9c8612d71868b865547cf5cd1b854(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSyslogNg]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a14ae29c24727e6d0b2c0e4b3126642380ff301d9cf9941d7671f5a490cc0b5(
    *,
    ca_file: typing.Optional[builtins.str] = None,
    crt_file: typing.Optional[builtins.str] = None,
    key_file: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa64acbecfb5495641266bd8fc22f1ac001ebcfbd2bef98ecc1db2e641ec5abc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a978e81625750fe3bd28b51d769a4dcd7c46700d9f436b0df5c1259f7e51b7f4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__005b46f9c5963154edf8385e687f0d6725b49db29f0d78e3cf50be26e35eb6b8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe01f3f75082a2cf8a096adb30feaa0e47edae5c77a49345c8b8140977b2bb08(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__434988332d85616272ab347b8649c76324fbdddb2d987a9d3c9427232421ee95(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ObservabilityPipelineConfigSourcesSyslogNgTls]],
) -> None:
    """Type checking stubs"""
    pass
