# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _cuvis_pyil
else:
    import _cuvis_pyil

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def cuvis_version_swig():
    return _cuvis_pyil.cuvis_version_swig()

def cuvis_calib_get_id_swig(i_calib):
    return _cuvis_pyil.cuvis_calib_get_id_swig(i_calib)

def cuvis_session_file_get_hash_swig(i_session):
    return _cuvis_pyil.cuvis_session_file_get_hash_swig(i_session)

def cuvis_measurement_get_calib_id_swig(i_mesu):
    return _cuvis_pyil.cuvis_measurement_get_calib_id_swig(i_mesu)

def cuvis_proc_cont_get_calib_id_swig(i_procCont):
    return _cuvis_pyil.cuvis_proc_cont_get_calib_id_swig(i_procCont)

def cuvis_measurement_get_data_info_swig(i_mesu, o_pType, i_id):
    return _cuvis_pyil.cuvis_measurement_get_data_info_swig(i_mesu, o_pType, i_id)

def cuvis_measurement_get_data_string_swig(i_mesu, i_key):
    return _cuvis_pyil.cuvis_measurement_get_data_string_swig(i_mesu, i_key)

def cuvis_comp_pixel_format_get_swig(i_acqCont, i_id):
    return _cuvis_pyil.cuvis_comp_pixel_format_get_swig(i_acqCont, i_id)

def cuvis_comp_available_pixel_format_get_swig(i_acqCont, i_id, i_index):
    return _cuvis_pyil.cuvis_comp_available_pixel_format_get_swig(i_acqCont, i_id, i_index)

def new_p_int():
    return _cuvis_pyil.new_p_int()

def copy_p_int(value):
    return _cuvis_pyil.copy_p_int(value)

def delete_p_int(obj):
    return _cuvis_pyil.delete_p_int(obj)

def p_int_assign(obj, value):
    return _cuvis_pyil.p_int_assign(obj, value)

def p_int_value(obj):
    return _cuvis_pyil.p_int_value(obj)

def new_p_ulong():
    return _cuvis_pyil.new_p_ulong()

def copy_p_ulong(value):
    return _cuvis_pyil.copy_p_ulong(value)

def delete_p_ulong(obj):
    return _cuvis_pyil.delete_p_ulong(obj)

def p_ulong_assign(obj, value):
    return _cuvis_pyil.p_ulong_assign(obj, value)

def p_ulong_value(obj):
    return _cuvis_pyil.p_ulong_value(obj)

def new_p_double():
    return _cuvis_pyil.new_p_double()

def copy_p_double(value):
    return _cuvis_pyil.copy_p_double(value)

def delete_p_double(obj):
    return _cuvis_pyil.delete_p_double(obj)

def p_double_assign(obj, value):
    return _cuvis_pyil.p_double_assign(obj, value)

def p_double_value(obj):
    return _cuvis_pyil.p_double_value(obj)

def new_p_unsigned_char(nelements):
    return _cuvis_pyil.new_p_unsigned_char(nelements)

def delete_p_unsigned_char(ary):
    return _cuvis_pyil.delete_p_unsigned_char(ary)

def p_unsigned_char_getitem(ary, index):
    return _cuvis_pyil.p_unsigned_char_getitem(ary, index)

def p_unsigned_char_setitem(ary, index, value):
    return _cuvis_pyil.p_unsigned_char_setitem(ary, index, value)

def new_p_unsigned_int(nelements):
    return _cuvis_pyil.new_p_unsigned_int(nelements)

def delete_p_unsigned_int(ary):
    return _cuvis_pyil.delete_p_unsigned_int(ary)

def p_unsigned_int_getitem(ary, index):
    return _cuvis_pyil.p_unsigned_int_getitem(ary, index)

def p_unsigned_int_setitem(ary, index, value):
    return _cuvis_pyil.p_unsigned_int_setitem(ary, index, value)

def cuvis_read_calib_info_wl_vec(info):
    return _cuvis_pyil.cuvis_read_calib_info_wl_vec(info)

def cuvis_read_imbuf_uint8(imbuf):
    return _cuvis_pyil.cuvis_read_imbuf_uint8(imbuf)

def cuvis_read_imbuf_uint16(imbuf):
    return _cuvis_pyil.cuvis_read_imbuf_uint16(imbuf)

def cuvis_read_imbuf_uint32(imbuf):
    return _cuvis_pyil.cuvis_read_imbuf_uint32(imbuf)

def cuvis_read_imbuf_float32(imbuf):
    return _cuvis_pyil.cuvis_read_imbuf_float32(imbuf)
CUVIS_MAXBUF = _cuvis_pyil.CUVIS_MAXBUF
r""" The cuvis namespace contains all SDK functions.  macro for creating allocate and free functions for c data structures macro for creating acquisition getter functions  macro for creating stubs of sync and async acquisition setter functions  macro for creating acquisition-component getter functions  macro for creating stubs of sync and async acquisition-component setter functions   handle  handle value of 0 is reserved for invalid handles  placeholder data type   max string buffer length (e.g. for paths)"""
CUVIS_MODE_CAPABILITY_ACQUISITION_CAPTURE = _cuvis_pyil.CUVIS_MODE_CAPABILITY_ACQUISITION_CAPTURE
r"""
     cstring data type definition  field for binary flags  time since epoch in millisecond steps  measurement handle  measurement session_info file handle  calibration handle  acquisition context handle  processing context handle  exporter handle (all exporter types)  data viewer handle  data viewer result handle (view)  worker handle  handle to an async function call result.

    A handle can be checked by the function 'cuvis_async_call_get'  handle to an async capture result.

    A handle can be checked by the function 'cuvis_async_capture_get'  holds capabilities for operation mode as flags
    """
CUVIS_MODE_CAPABILITY_ACQUISITION_TIMELAPSE = _cuvis_pyil.CUVIS_MODE_CAPABILITY_ACQUISITION_TIMELAPSE
CUVIS_MODE_CAPABILITY_ACQUISITION_CONTINUOUS = _cuvis_pyil.CUVIS_MODE_CAPABILITY_ACQUISITION_CONTINUOUS
CUVIS_MODE_CAPABILITY_ACQUISITION_SNAPSHOT = _cuvis_pyil.CUVIS_MODE_CAPABILITY_ACQUISITION_SNAPSHOT
CUVIS_MODE_CAPABILITY_ACQUISITION_SETINTEGRATIONTIME = _cuvis_pyil.CUVIS_MODE_CAPABILITY_ACQUISITION_SETINTEGRATIONTIME
CUVIS_MODE_CAPABILITY_ACQUISITION_SETGAIN = _cuvis_pyil.CUVIS_MODE_CAPABILITY_ACQUISITION_SETGAIN
CUVIS_MODE_CAPABILITY_ACQUISITION_AVERAGING = _cuvis_pyil.CUVIS_MODE_CAPABILITY_ACQUISITION_AVERAGING
CUVIS_MODE_CAPABILITY_PROCESSING_SENSOR_RAW = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_SENSOR_RAW
CUVIS_MODE_CAPABILITY_PROCESSING_CUBE_RAW = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_CUBE_RAW
CUVIS_MODE_CAPABILITY_PROCESSING_CUBE_REF = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_CUBE_REF
CUVIS_MODE_CAPABILITY_PROCESSING_CUBE_DARKSUBTRACT = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_CUBE_DARKSUBTRACT
CUVIS_MODE_CAPABILITY_PROCESSING_CUBE_FLATFIELDING = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_CUBE_FLATFIELDING
CUVIS_MODE_CAPABILITY_PROCESSING_CUBE_SPECTRALRADIANCE = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_CUBE_SPECTRALRADIANCE
CUVIS_MODE_CAPABILITY_PROCESSING_SAVE_FILE = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_SAVE_FILE
CUVIS_MODE_CAPABILITY_PROCESSING_CLEAR_RAW = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_CLEAR_RAW
CUVIS_MODE_CAPABILITY_PROCESSING_CALC_LIVE = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_CALC_LIVE
CUVIS_MODE_CAPABILITY_PROCESSING_AUTOEXPOSURE = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_AUTOEXPOSURE
CUVIS_MODE_CAPABILITY_PROCESSING_ORIENTATION = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_ORIENTATION
CUVIS_MODE_CAPABILITY_PROCESSING_SET_WHITE = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_SET_WHITE
CUVIS_MODE_CAPABILITY_PROCESSING_SET_DARK = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_SET_DARK
CUVIS_MODE_CAPABILITY_PROCESSING_SET_SPRADCALIB = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_SET_SPRADCALIB
CUVIS_MODE_CAPABILITY_PROCESSING_SET_DISTANCECALIB = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_SET_DISTANCECALIB
CUVIS_MODE_CAPABILITY_PROCESSING_SET_DISTANCE_VALUE = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_SET_DISTANCE_VALUE
CUVIS_MODE_CAPABILITY_PROCESSING_USE_DARK_SPRADCALIB = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_USE_DARK_SPRADCALIB
CUVIS_MODE_CAPABILITY_PROCESSING_USE_WHITE_SPRADCALIB = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_USE_WHITE_SPRADCALIB
CUVIS_MODE_CAPABILITY_PROCESSING_REQUIRE_WHITEDARK_REFLECTANCE = _cuvis_pyil.CUVIS_MODE_CAPABILITY_PROCESSING_REQUIRE_WHITEDARK_REFLECTANCE
AcquisitionCapture = _cuvis_pyil.AcquisitionCapture
AcquisitionTimelapse = _cuvis_pyil.AcquisitionTimelapse
AcquisitionContinuous = _cuvis_pyil.AcquisitionContinuous
AcquisitionSnapshot = _cuvis_pyil.AcquisitionSnapshot
AcquisitionSetIntegrationtime = _cuvis_pyil.AcquisitionSetIntegrationtime
AcquisitionSetGain = _cuvis_pyil.AcquisitionSetGain
AcquisitionAveraging = _cuvis_pyil.AcquisitionAveraging
ProcessingSensorRaw = _cuvis_pyil.ProcessingSensorRaw
ProcessingCubeRaw = _cuvis_pyil.ProcessingCubeRaw
ProcessingCubeRef = _cuvis_pyil.ProcessingCubeRef
ProcessingCubeDarkSubtract = _cuvis_pyil.ProcessingCubeDarkSubtract
ProcessingCubeFlatFielding = _cuvis_pyil.ProcessingCubeFlatFielding
ProcessingCubeSpectralRadiance = _cuvis_pyil.ProcessingCubeSpectralRadiance
ProcessingSaveFile = _cuvis_pyil.ProcessingSaveFile
ProcessingClearRaw = _cuvis_pyil.ProcessingClearRaw
ProcessingCalcLive = _cuvis_pyil.ProcessingCalcLive
ProcessingAutoExposure = _cuvis_pyil.ProcessingAutoExposure
ProcessingOrientation = _cuvis_pyil.ProcessingOrientation
ProcessingSetWhite = _cuvis_pyil.ProcessingSetWhite
ProcessingSetDark = _cuvis_pyil.ProcessingSetDark
ProcessingSetSprad = _cuvis_pyil.ProcessingSetSprad
ProcessingSetDistanceCalib = _cuvis_pyil.ProcessingSetDistanceCalib
ProcessingSetDistanceValue = _cuvis_pyil.ProcessingSetDistanceValue
ProcessingUseDarkSpradcalib = _cuvis_pyil.ProcessingUseDarkSpradcalib
ProcessingUseWhiteSpradCalib = _cuvis_pyil.ProcessingUseWhiteSpradCalib
ProcessingRequireWhiteDarkReflectance = _cuvis_pyil.ProcessingRequireWhiteDarkReflectance
CUVIS_MESU_FLAG_OVERILLUMINATED = _cuvis_pyil.CUVIS_MESU_FLAG_OVERILLUMINATED
r"""
     the measurement was over-illuminated

        One of the devices sensor data points were over-saturated while recording
        This may not be directly visible in the data cube, as the sensor data needs
        extensive processing.
        Notes: only the spectral data is checked. The pan image's saturation is not checked.

        If this flag is set, additional information can retrieved by calling
    'cuvis_measurement_get_data_sensor_info' with the key 'CUVIS_MESU_FLAG_OVERILLUMINATED_KEY'
    """
CUVIS_MESU_FLAG_POOR_REFERENCE = _cuvis_pyil.CUVIS_MESU_FLAG_POOR_REFERENCE
r"""
     A reference measurement used has poor quality

    One or more of the reference measurements used had a poor data quality.
    This may lead to invalid results.

    If this flag is set, additional information can retrieved by calling
    'cuvis_measurement_get_data_sensor_info' with the key 'CUVIS_MESU_FLAG_POOR_REFERENCE_KEY'
    """
CUVIS_MESU_FLAG_POOR_WHITE_BALANCING = _cuvis_pyil.CUVIS_MESU_FLAG_POOR_WHITE_BALANCING
r"""
     the white balancing detected bad data

    If this flag is set, additional information can retrieved by calling
    'cuvis_measurement_get_data_sensor_info' with the key 'CUVIS_MESU_FLAG_POOR_WHITE_BALANCING_KEY'
    """
CUVIS_MESU_FLAG_DARK_INTTIME = _cuvis_pyil.CUVIS_MESU_FLAG_DARK_INTTIME
r"""
     the dark's integration time does not match the measurement

    If this flag is set, additional information can retrieved by calling
    'cuvis_measurement_get_data_sensor_info' with the key 'CUVIS_MESU_FLAG_DARK_INTTIME_KEY'
    """
CUVIS_MESU_FLAG_DARK_TEMP = _cuvis_pyil.CUVIS_MESU_FLAG_DARK_TEMP
r"""
     the sensor temperature at dark's recording does not match measurement's recording device temperature

    If this flag is set, additional information can retrieved by calling
    'cuvis_measurement_get_data_sensor_info' with the key 'CUVIS_MESU_FLAG_DARK_TEMP_KEY'
    """
CUVIS_MESU_FLAG_WHITE_INTTIME = _cuvis_pyil.CUVIS_MESU_FLAG_WHITE_INTTIME
r"""
     the white's integration time does not match the measurement

    If this flag is set, additional information can retrieved by calling
    'cuvis_measurement_get_data_sensor_info' with the key 'CUVIS_MESU_FLAG_WHITE_INTTIME_KEY'
    """
CUVIS_MESU_FLAG_WHITE_TEMP = _cuvis_pyil.CUVIS_MESU_FLAG_WHITE_TEMP
r"""
     the sensor temperature at white's recording does not match measurement's recording device temperature

    If this flag is set, additional information can retrieved by calling
    'cuvis_measurement_get_data_sensor_info' with the key 'CUVIS_MESU_FLAG_WHITE_TEMP_KEY'
    """
CUVIS_MESU_FLAG_WHITEDARK_INTTIME = _cuvis_pyil.CUVIS_MESU_FLAG_WHITEDARK_INTTIME
r"""
     the white's dark integration time does not match the measurement

    If this flag is set, additional information can retrieved by calling
    'cuvis_measurement_get_data_sensor_info' with the key 'CUVIS_MESU_FLAG_WHITEDARK_INTTIME_KEY'
    """
CUVIS_MESU_FLAG_WHITEDARK_TEMP = _cuvis_pyil.CUVIS_MESU_FLAG_WHITEDARK_TEMP
r"""
     the sensor temperature at white's dark recording does not match measurement's recording device temperature

    If this flag is set, additional information can retrieved by calling
    'cuvis_measurement_get_data_sensor_info' with the key 'CUVIS_MESU_FLAG_WHITEDARK_TEMP_KEY'
    """
CUVIS_MESU_FLAG_PAN_OVERILLUMINATED = _cuvis_pyil.CUVIS_MESU_FLAG_PAN_OVERILLUMINATED
r"""
     the measurements pan image was over-illuminated

        One of the devices pan sensor data points were over-saturated while recording
        This may not be directly visible in the data cube, as the sensor data needs
        extensive processing.
        Notes: only the pan data is checked. The spectral image's saturation is not checked.

        If this flag is set, additional information can retrieved by calling
    'cuvis_measurement_get_data_sensor_info' with the key 'CUVIS_MESU_FLAG_PAN_OVERILLUMINATED_KEY'
    """
CUVIS_MESU_CUBE_KEY = _cuvis_pyil.CUVIS_MESU_CUBE_KEY
r""" name of the data field for the hyperspectral cube (in all modes except 'Preview)'"""
CUVIS_MESU_PAN_KEY = _cuvis_pyil.CUVIS_MESU_PAN_KEY
r""" name of the pan image (pixels registered to  'CUVIS_MESU_CUBE_KEY)'"""
CUVIS_MESU_GPS_KEY = _cuvis_pyil.CUVIS_MESU_GPS_KEY
r""" name of the GPS data field, if available"""
CUVIS_MESU_PREVIEW_KEY = _cuvis_pyil.CUVIS_MESU_PREVIEW_KEY
r""" name of the generate preview image, if available. The preview will be generated by the 'cuvis_proc_cont_apply' function"""
CUVIS_MESU_DARKREF_KEY = _cuvis_pyil.CUVIS_MESU_DARKREF_KEY
r"""
     If this field is present, a dark was set while recording the measurement.
    This is the dark that is implicitly loaded when a processing context is created
    with the current measurement and used, if a dark is needed (unless overwritten by
    'cuvis_proc_cont_set_reference' )
    The reference file should be located in ../Calibration/<reference-name>.cu3 or the
    precise path defined by the string value of the data tag
    """
CUVIS_MESU_WHITEREF_KEY = _cuvis_pyil.CUVIS_MESU_WHITEREF_KEY
r"""
     If this field is present, a white was set while recording the measurement.
    This is the white that is implicitly loaded when a processing context is created
    with the current measurement and used, if a dark is needed (unless overwritten by
    'cuvis_proc_cont_set_reference' )
    The reference file should be located in ../Calibration/<reference-name>.cu3 or the
    precise path defined by the string value of the data tag
    """
CUVIS_MESU_WHITEDARKREF_KEY = _cuvis_pyil.CUVIS_MESU_WHITEDARKREF_KEY
r"""
     If this field is present, a white's dark was set while recording the measurement.
    This is the white' dark that is implicitly loaded when a processing context is created
    with the current measurement and used, if a dark is needed (unless overwritten by
    'cuvis_proc_cont_set_reference' )
    The reference file should be located in ../Calibration/<reference-name>.cu3 or the
    precise path defined by the string value of the data tag
    """
CUVIS_MESU_FLAG_OVERILLUMINATED_KEY = _cuvis_pyil.CUVIS_MESU_FLAG_OVERILLUMINATED_KEY
r""" see 'CUVIS_MESU_FLAG_OVERILLUMINATED'"""
CUVIS_MESU_FLAG_PAN_OVERILLUMINATED_KEY = _cuvis_pyil.CUVIS_MESU_FLAG_PAN_OVERILLUMINATED_KEY
r""" see 'CUVIS_MESU_FLAG_OVERILLUMINATED'"""
CUVIS_MESU_FLAG_POOR_REFERENCE_KEY = _cuvis_pyil.CUVIS_MESU_FLAG_POOR_REFERENCE_KEY
r""" see 'CUVIS_MESU_FLAG_POOR_REFERENCE'"""
CUVIS_MESU_FLAG_POOR_WHITE_BALANCING_KEY = _cuvis_pyil.CUVIS_MESU_FLAG_POOR_WHITE_BALANCING_KEY
r""" see 'CUVIS_MESU_FLAG_POOR_WHITE_BALANCING'"""
CUVIS_MESU_FLAG_DARK_INTTIME_KEY = _cuvis_pyil.CUVIS_MESU_FLAG_DARK_INTTIME_KEY
r""" see 'CUVIS_MESU_FLAG_DARK_INTTIME'"""
CUVIS_MESU_FLAG_DARK_TEMP_KEY = _cuvis_pyil.CUVIS_MESU_FLAG_DARK_TEMP_KEY
r""" see 'CUVIS_MESU_FLAG_DARK_TEMP'"""
CUVIS_MESU_FLAG_WHITE_INTTIME_KEY = _cuvis_pyil.CUVIS_MESU_FLAG_WHITE_INTTIME_KEY
r""" see 'CUVIS_MESU_FLAG_WHITE_INTTIME'"""
CUVIS_MESU_FLAG_WHITE_TEMP_KEY = _cuvis_pyil.CUVIS_MESU_FLAG_WHITE_TEMP_KEY
r""" see 'CUVIS_MESU_FLAG_WHITE_TEMP'"""
CUVIS_MESU_FLAG_WHITEDARK_INTTIME_KEY = _cuvis_pyil.CUVIS_MESU_FLAG_WHITEDARK_INTTIME_KEY
r""" see 'CUVIS_MESU_FLAG_WHITEDARK_INTTIME'"""
CUVIS_MESU_FLAG_WHITEDARK_TEMP_KEY = _cuvis_pyil.CUVIS_MESU_FLAG_WHITEDARK_TEMP_KEY
r""" see 'CUVIS_MESU_FLAG_WHITEDARK_TEMP'"""
CUVIS_MESU_CUBE_INFO_KEY = _cuvis_pyil.CUVIS_MESU_CUBE_INFO_KEY
r""" name of the info channel of its respective cube."""
CUVIS_MESU_PAN_INFO_KEY = _cuvis_pyil.CUVIS_MESU_PAN_INFO_KEY
r""" name of the info channel of its respective pan image."""
CUVIS_MESU_INFO_OK = _cuvis_pyil.CUVIS_MESU_INFO_OK
r""" no flag set, only valid, if pixel value is equal 0"""
CUVIS_MESU_INFO_OVERILLUMINATED = _cuvis_pyil.CUVIS_MESU_INFO_OVERILLUMINATED
r""" one or more channels of the spectrum are over-exposed / the pan image is over-exposed at this position"""
CUVIS_MESU_INFO_BAD_PIXEL = _cuvis_pyil.CUVIS_MESU_INFO_BAD_PIXEL
r""" the pixel is marked bad, eg. a pixel of the respective spectrum is dead"""
CUVIS_MESU_INFO_OVERILLUMINATED_REFERENCE = _cuvis_pyil.CUVIS_MESU_INFO_OVERILLUMINATED_REFERENCE
r""" one or more channels of the spectrum of the white reference that was used to calculate this position was over-exposed"""
CUVIS_MESU_INFO_UNDERFLOW_MEASUREMENT_MIN_DARK = _cuvis_pyil.CUVIS_MESU_INFO_UNDERFLOW_MEASUREMENT_MIN_DARK
r""" the meausurement was darker then the dark reference at this position (underflow)"""
CUVIS_MESU_INFO_UNDERFLOW_WHITE_MIN_DARK = _cuvis_pyil.CUVIS_MESU_INFO_UNDERFLOW_WHITE_MIN_DARK
r""" the white reference was darker then the dark reference at this position (underflow)"""
CUVIS_MESU_INFO_REFERENCE_CALC_OVERFLOW = _cuvis_pyil.CUVIS_MESU_INFO_REFERENCE_CALC_OVERFLOW
r""" the reflectance value exceeded the maximum value possible by the data format (i.e. the value reflectance reached or exceeded 655.35% (uint16 value of 65535)"""
CUVIS_MESU_INFO_INCOMPLETE = _cuvis_pyil.CUVIS_MESU_INFO_INCOMPLETE
r""" the spectrum at this position is incomplete, e.g by a bad / too close distance calibration"""
status_ok = _cuvis_pyil.status_ok
r""" the function encountered no problems"""
status_error = _cuvis_pyil.status_error
r""" the function failed for some reason. Call cuvis_get_last_error_msg for details"""
status_deferred = _cuvis_pyil.status_deferred
r""" a async function has not been started yet"""
status_overwritten = _cuvis_pyil.status_overwritten
r""" the async call was overwritten by another async call to the same internal values"""
status_timeout = _cuvis_pyil.status_timeout
r""" obtaining a async function result has timed out. Call again later"""
status_no_measurement = _cuvis_pyil.status_no_measurement
r""" polling a measurement returned no result / frame was dropped"""
status_not_available = _cuvis_pyil.status_not_available
r""" retrieving a value is (currently) not possible"""
status_not_processed = _cuvis_pyil.status_not_processed
r""" processing the measurement with the worker failed, raw data is available"""
status_not_stored = _cuvis_pyil.status_not_stored
r""" storing the measurement with the worker/exporter failed"""
status_no_view = _cuvis_pyil.status_no_view
r""" obtaining the measurement's view with the worker failed, raw data is available"""
hardware_state_offline = _cuvis_pyil.hardware_state_offline
r""" at least one required components is offline"""
hardware_state_partially_online = _cuvis_pyil.hardware_state_partially_online
r""" all required components are online, at least one optional component is offline"""
hardware_state_online = _cuvis_pyil.hardware_state_online
r""" all components are online"""
loglevel_fatal = _cuvis_pyil.loglevel_fatal
r""" only report error not recoverable"""
loglevel_error = _cuvis_pyil.loglevel_error
r""" report errors and 'loglevel_fatal' messages"""
loglevel_warning = _cuvis_pyil.loglevel_warning
r""" report warnings and 'loglevel_error' messages."""
loglevel_info = _cuvis_pyil.loglevel_info
r""" report status information and 'loglevel_warning' messages."""
loglevel_debug = _cuvis_pyil.loglevel_debug
r""" report all messages, including debug messages"""
imbuffer_format_uint8 = _cuvis_pyil.imbuffer_format_uint8
r""" 8 bit, unsigned"""
imbuffer_format_uint16 = _cuvis_pyil.imbuffer_format_uint16
r""" 16 bit, unsigned"""
imbuffer_format_uint32 = _cuvis_pyil.imbuffer_format_uint32
r""" 32 bit, unsigned"""
imbuffer_format_float = _cuvis_pyil.imbuffer_format_float
r""" IEEE 754 single-precision (32 bit) floating-point value (a.k.a float)"""
session_item_type_frames = _cuvis_pyil.session_item_type_frames
r""" all regular measurements, also list dropped frames"""
session_item_type_frames_no_gaps = _cuvis_pyil.session_item_type_frames_no_gaps
r""" all regular measurements, excluding dropped frames (i.e. actual images)"""
session_item_type_references = _cuvis_pyil.session_item_type_references
r""" all reference measurements"""
data_type_unsupported = _cuvis_pyil.data_type_unsupported
r""" the data type is unsupported or unknown by the SDK"""
data_type_image = _cuvis_pyil.data_type_image
r""" data type is image, retrieve with 'cuvis_measurement_get_data_image'"""
data_type_gps = _cuvis_pyil.data_type_gps
r""" data type is gps, retrieve with 'cuvis_measurement_get_data_gps'"""
data_type_string = _cuvis_pyil.data_type_string
r""" data type is string, retrieve with 'cuvis_measurement_get_data_string'"""
data_type_sensor_info = _cuvis_pyil.data_type_sensor_info
r""" data type is sensor info, retrieve with 'cuvis_measurement_get_data_sensor_info'"""
Cube_Raw = _cuvis_pyil.Cube_Raw
r"""
    processed as cube, but without reference

            The measurement is processed into a cube. Effects of
            sensor temperature, vignetting,
            missing flat-fielding, etc. are not
            corrected.
    """
Cube_DarkSubtract = _cuvis_pyil.Cube_DarkSubtract
r"""
    processed as cube, with dark subtract as reference.

            Subtracts the dark from the raw measurement.
            I_DS = I_RAW - I_DARK
    """
Cube_Reflectance = _cuvis_pyil.Cube_Reflectance
r"""
    processed as cube, with dark subtract and white as reference

              Calculates the reflectance as follows:

              I_REF = 10000(I_RAW - I_DARK) / (I_WHITE - I_WHITEDARK)

              Depending on the camera, I_WHITEDARK will be substituted
              I_DARK, is missing. Note the factor of 10000.
              A value of 100% corresponds to 10000 counts.
    """
Cube_SpectralRadiance = _cuvis_pyil.Cube_SpectralRadiance
r"""
    processed as cube, with spectral radiance calibration

                The spectral radiance calibration is camera-dependent.
                It's value is given in the units of W m^{-2} sr^{-1} um^{-1}
    """
Preview = _cuvis_pyil.Preview
r""" unprocessed (no cube), only preview image"""
Reference_Dark = _cuvis_pyil.Reference_Dark
r""" a dark reference for dark subtract/reflectance/sp. rad"""
Reference_White = _cuvis_pyil.Reference_White
r""" white reference measurement, brightness defined as 100%"""
Reference_WhiteDark = _cuvis_pyil.Reference_WhiteDark
r""" the dark corresponding to the white reference measurement"""
Reference_SpRad = _cuvis_pyil.Reference_SpRad
r""" spectral sprad measurement object (spectral fields)"""
Reference_Distance = _cuvis_pyil.Reference_Distance
r"""
    spectral distance reference (spectral fields). If normal mesu.
            is used, measurement is calculated from it
    """
OperationMode_Software = _cuvis_pyil.OperationMode_Software
r""" software trigger, aka "single shot mode" or "software mode"."""
OperationMode_Internal = _cuvis_pyil.OperationMode_Internal
r""" triggered by internal clock, aka "video mode"."""
OperationMode_External = _cuvis_pyil.OperationMode_External
r""" triggered by external trigger, aka "trigger mode"."""
OperationMode_Undefined = _cuvis_pyil.OperationMode_Undefined
r""" undefiend (e.g. changing)"""
pan_sharpening_interpolation_type_NearestNeighbor = _cuvis_pyil.pan_sharpening_interpolation_type_NearestNeighbor
r""" nearest neighbor interpolation"""
pan_sharpening_interpolation_type_Linear = _cuvis_pyil.pan_sharpening_interpolation_type_Linear
r""" bilinear interpolation (recommended)"""
pan_sharpening_interpolation_type_Cubic = _cuvis_pyil.pan_sharpening_interpolation_type_Cubic
r""" bicubic interpolation"""
pan_sharpening_interpolation_type_Lanczos = _cuvis_pyil.pan_sharpening_interpolation_type_Lanczos
r"""Lanczos (8x8)"""
pan_sharpening_algorithm_Noop = _cuvis_pyil.pan_sharpening_algorithm_Noop
r"""
     Interpolate 'CUVIS_PAN_SHAPRENING_INTERPOLATION_TYPE' but no operation
    is applied to apply the pan image information to the data. This mode is
    recommended together with NearestNeighbor interpolation.
    """
pan_sharpening_algorithm_CubertMacroPixel = _cuvis_pyil.pan_sharpening_algorithm_CubertMacroPixel
r"""
     cuvis macro pixel algorithm
    Author: Dr. Rene Heine

    Weights spectral "macro pixel" with local pan image gradient
    """
pan_sharpening_algorithm_CubertPanRatio = _cuvis_pyil.pan_sharpening_algorithm_CubertPanRatio
r"""
     cuvis pan ratio algorithm
    Author: Arnd Brandes

    Relative pan-image brighness (white refernce and current image) is used as weight for specral image
    """
pan_sharpening_algorithm_AlphablendPanOverlay = _cuvis_pyil.pan_sharpening_algorithm_AlphablendPanOverlay
r"""
     cuvis pan overlay algorithm
    Author: Philip Manke

    Mode used viewing classifier results with the pan image as an overlay. ONLY works with images from viewer
    """
tiff_compression_mode_None = _cuvis_pyil.tiff_compression_mode_None
r""" do not compress data"""
tiff_compression_mode_LZW = _cuvis_pyil.tiff_compression_mode_LZW
r""" compress LZW."""
tiff_format_Single = _cuvis_pyil.tiff_format_Single
r""" Export each channel as separate files"""
tiff_format_MultiChannel = _cuvis_pyil.tiff_format_MultiChannel
r""" Create a multi-channel tiff (recommended format)"""
tiff_format_MultiPage = _cuvis_pyil.tiff_format_MultiPage
r""" Create a multi-page tiff, i.e. each channel is a "sub-image" within the tiff."""
view_category_image = _cuvis_pyil.view_category_image
r""" data is process as an image for displaying. Pan-sharpening may have been applied. The bit depth is always 8 per channel"""
view_category_data = _cuvis_pyil.view_category_data
r""" data contains calculation results. The format is always single precision floating point."""
component_type_image_sensor = _cuvis_pyil.component_type_image_sensor
r""" the component is an image sensor (camera)"""
component_type_misc_sensor = _cuvis_pyil.component_type_misc_sensor
r""" the component is a non-camera, e.g. GPS"""
class cuvis_imbuffer_t(object):
    r"""
     image buffer data structure with meta-data

    The image buffer data structure holds a anonymous
    raw data pointer, that can be interpreted to give
    a meaningful data array with the help of the other
    members:
    The 'format' gives the information of the data type,
    the 'width', 'length', and 'channels' give the
    number of elements in the array.

    The 'wavelength' property is only set for hyperspectral cubes
    but not for normal images. If it exists, it is an array with the number
    of channels

    Example:

    .. code-block:: c++

        // format = CUVIS_IMBUFFER_FORMAT_UINT16
        // x in [0, width)
        // y in [0,   height)
        // chn in [0, channels)
        unsigned index = (y * width + x) * channels + chn;
        uint16_t value = ((uint16_t*) raw)[index];
        unsigned lambda = cube.wavelength[chn];

    see also: 'IMBUFFER_GET'
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    raw = property(_cuvis_pyil.cuvis_imbuffer_t_raw_get, _cuvis_pyil.cuvis_imbuffer_t_raw_set, doc=r"""
    the memory reference of the cube.
                    Valid as long as the parent element (e.g. measurement)
                    is valid and unchanged.
    """)
    bytes = property(_cuvis_pyil.cuvis_imbuffer_t_bytes_get, _cuvis_pyil.cuvis_imbuffer_t_bytes_set, doc=r""" number of bytes per data element""")
    length = property(_cuvis_pyil.cuvis_imbuffer_t_length_get, _cuvis_pyil.cuvis_imbuffer_t_length_set, doc=r"""  total number of bytes in array""")
    width = property(_cuvis_pyil.cuvis_imbuffer_t_width_get, _cuvis_pyil.cuvis_imbuffer_t_width_set, doc=r""" width of buffer""")
    height = property(_cuvis_pyil.cuvis_imbuffer_t_height_get, _cuvis_pyil.cuvis_imbuffer_t_height_set, doc=r""" height of buffer""")
    channels = property(_cuvis_pyil.cuvis_imbuffer_t_channels_get, _cuvis_pyil.cuvis_imbuffer_t_channels_set, doc=r""" number of channels""")
    format = property(_cuvis_pyil.cuvis_imbuffer_t_format_get, _cuvis_pyil.cuvis_imbuffer_t_format_set, doc=r"""
     the buffer format

    The buffer format defines what the member 'raw' can be casted into.
    """)
    wavelength = property(_cuvis_pyil.cuvis_imbuffer_t_wavelength_get, _cuvis_pyil.cuvis_imbuffer_t_wavelength_set, doc=r"""
     the wavelength vector

    If the 'cuvis_imbuffer_t' is not a hyperspectral cube, the value will be nullptr
    For cubes this is an array of length channels, the elements define the
    cube's wavelength in nanometers.
    """)

    def __init__(self):
        _cuvis_pyil.cuvis_imbuffer_t_swiginit(self, _cuvis_pyil.new_cuvis_imbuffer_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_imbuffer_t

# Register cuvis_imbuffer_t in _cuvis_pyil:
_cuvis_pyil.cuvis_imbuffer_t_swigregister(cuvis_imbuffer_t)
class cuvis_sensor_info_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    averages = property(_cuvis_pyil.cuvis_sensor_info_t_averages_get, _cuvis_pyil.cuvis_sensor_info_t_averages_set, doc=r""" number of averages used""")
    temperature = property(_cuvis_pyil.cuvis_sensor_info_t_temperature_get, _cuvis_pyil.cuvis_sensor_info_t_temperature_set, doc=r""" the sensors's temperature while readout (0 if not applicable)""")
    gain = property(_cuvis_pyil.cuvis_sensor_info_t_gain_get, _cuvis_pyil.cuvis_sensor_info_t_gain_set, doc=r""" gain value while recording""")
    readout_time = property(_cuvis_pyil.cuvis_sensor_info_t_readout_time_get, _cuvis_pyil.cuvis_sensor_info_t_readout_time_set, doc=r""" the timestamp (UTC) of the image readout (senor's hardware clock )""")
    width = property(_cuvis_pyil.cuvis_sensor_info_t_width_get, _cuvis_pyil.cuvis_sensor_info_t_width_set, doc=r""" width of buffer""")
    height = property(_cuvis_pyil.cuvis_sensor_info_t_height_get, _cuvis_pyil.cuvis_sensor_info_t_height_set, doc=r""" height of buffer""")
    raw_frame_id = property(_cuvis_pyil.cuvis_sensor_info_t_raw_frame_id_get, _cuvis_pyil.cuvis_sensor_info_t_raw_frame_id_set, doc=r""" ID given to this measurement by the device hardware or driver""")
    pixel_format = property(_cuvis_pyil.cuvis_sensor_info_t_pixel_format_get, _cuvis_pyil.cuvis_sensor_info_t_pixel_format_set, doc=r""" The sensor read-out pixel format used by this device. Informs how many bits per pixel are available.""")
    integration_time = property(_cuvis_pyil.cuvis_sensor_info_t_integration_time_get, _cuvis_pyil.cuvis_sensor_info_t_integration_time_set, doc=r""" The real integration time of the sensor (exposure time) in ms""")

    def __init__(self):
        _cuvis_pyil.cuvis_sensor_info_t_swiginit(self, _cuvis_pyil.new_cuvis_sensor_info_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_sensor_info_t

# Register cuvis_sensor_info_t in _cuvis_pyil:
_cuvis_pyil.cuvis_sensor_info_t_swigregister(cuvis_sensor_info_t)
class cuvis_gps_t(object):
    r""" The gps data structure"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    longitude = property(_cuvis_pyil.cuvis_gps_t_longitude_get, _cuvis_pyil.cuvis_gps_t_longitude_set, doc=r""" gps longitude in decimal degrees""")
    latitude = property(_cuvis_pyil.cuvis_gps_t_latitude_get, _cuvis_pyil.cuvis_gps_t_latitude_set, doc=r""" gps latitude in decimal degrees""")
    altitude = property(_cuvis_pyil.cuvis_gps_t_altitude_get, _cuvis_pyil.cuvis_gps_t_altitude_set, doc=r""" gps altitude in meters""")
    time = property(_cuvis_pyil.cuvis_gps_t_time_get, _cuvis_pyil.cuvis_gps_t_time_set, doc=r""" the timestamp (UTC) while recoding the gps.""")

    def __init__(self):
        _cuvis_pyil.cuvis_gps_t_swiginit(self, _cuvis_pyil.new_cuvis_gps_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_gps_t

# Register cuvis_gps_t in _cuvis_pyil:
_cuvis_pyil.cuvis_gps_t_swigregister(cuvis_gps_t)
class cuvis_session_info_t(object):
    r""" internal session_info info of acquisition context"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_cuvis_pyil.cuvis_session_info_t_name_get, _cuvis_pyil.cuvis_session_info_t_name_set, doc=r""" session_info name""")
    session_no = property(_cuvis_pyil.cuvis_session_info_t_session_no_get, _cuvis_pyil.cuvis_session_info_t_session_no_set, doc=r""" SessionFile number. Will be increased by stopping & starting recording""")
    sequence_no = property(_cuvis_pyil.cuvis_session_info_t_sequence_no_get, _cuvis_pyil.cuvis_session_info_t_sequence_no_set, doc=r""" Sequence number. Increases with each recorded frame. Reset, if session_no changes""")

    def __init__(self):
        _cuvis_pyil.cuvis_session_info_t_swiginit(self, _cuvis_pyil.new_cuvis_session_info_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_session_info_t

# Register cuvis_session_info_t in _cuvis_pyil:
_cuvis_pyil.cuvis_session_info_t_swigregister(cuvis_session_info_t)
class cuvis_calibration_info_t(object):
    r""" internal info/data of calibration"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    model_name = property(_cuvis_pyil.cuvis_calibration_info_t_model_name_get, _cuvis_pyil.cuvis_calibration_info_t_model_name_set, doc=r""" camera model name""")
    serial_no = property(_cuvis_pyil.cuvis_calibration_info_t_serial_no_get, _cuvis_pyil.cuvis_calibration_info_t_serial_no_set, doc=r""" camera serial number""")
    calibration_date = property(_cuvis_pyil.cuvis_calibration_info_t_calibration_date_get, _cuvis_pyil.cuvis_calibration_info_t_calibration_date_set, doc=r""" timestamp (UTC) of calibration date""")
    annotation_name = property(_cuvis_pyil.cuvis_calibration_info_t_annotation_name_get, _cuvis_pyil.cuvis_calibration_info_t_annotation_name_set, doc=r""" calibration annotation name""")
    unique_id = property(_cuvis_pyil.cuvis_calibration_info_t_unique_id_get, _cuvis_pyil.cuvis_calibration_info_t_unique_id_set, doc=r""" calibration unique ID""")
    file_path = property(_cuvis_pyil.cuvis_calibration_info_t_file_path_get, _cuvis_pyil.cuvis_calibration_info_t_file_path_set, doc=r""" calibration file path""")
    cube_width = property(_cuvis_pyil.cuvis_calibration_info_t_cube_width_get, _cuvis_pyil.cuvis_calibration_info_t_cube_width_set, doc=r""" cube width, -1 if unknown""")
    cube_height = property(_cuvis_pyil.cuvis_calibration_info_t_cube_height_get, _cuvis_pyil.cuvis_calibration_info_t_cube_height_set, doc=r""" cube height, -1 if unknown""")
    cube_channels = property(_cuvis_pyil.cuvis_calibration_info_t_cube_channels_get, _cuvis_pyil.cuvis_calibration_info_t_cube_channels_set, doc=r""" cube number of channels, -1 if unknown""")
    cube_wavelengths = property(_cuvis_pyil.cuvis_calibration_info_t_cube_wavelengths_get, _cuvis_pyil.cuvis_calibration_info_t_cube_wavelengths_set, doc=r""" cubes wavelengths (nm) vector, contains 'cube_channels' values, can be nullptr if wavelengths are unknown""")

    def __init__(self):
        _cuvis_pyil.cuvis_calibration_info_t_swiginit(self, _cuvis_pyil.new_cuvis_calibration_info_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_calibration_info_t

# Register cuvis_calibration_info_t in _cuvis_pyil:
_cuvis_pyil.cuvis_calibration_info_t_swigregister(cuvis_calibration_info_t)
class cuvis_mesu_metadata_t(object):
    r""" The measurement meta structure"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_cuvis_pyil.cuvis_mesu_metadata_t_name_get, _cuvis_pyil.cuvis_mesu_metadata_t_name_set, doc=r""" The name of the measurement""")
    path = property(_cuvis_pyil.cuvis_mesu_metadata_t_path_get, _cuvis_pyil.cuvis_mesu_metadata_t_path_set, doc=r""" The output file path""")
    comment = property(_cuvis_pyil.cuvis_mesu_metadata_t_comment_get, _cuvis_pyil.cuvis_mesu_metadata_t_comment_set, doc=r""" The User Comment linked to the measurement""")
    capture_time = property(_cuvis_pyil.cuvis_mesu_metadata_t_capture_time_get, _cuvis_pyil.cuvis_mesu_metadata_t_capture_time_set, doc=r""" The Capture Time of the Measurement""")
    factory_calibration = property(_cuvis_pyil.cuvis_mesu_metadata_t_factory_calibration_get, _cuvis_pyil.cuvis_mesu_metadata_t_factory_calibration_set, doc=r""" The factory calibration date of the device""")
    product_name = property(_cuvis_pyil.cuvis_mesu_metadata_t_product_name_get, _cuvis_pyil.cuvis_mesu_metadata_t_product_name_set, doc=r""" The name of the device, which took the measurement""")
    serial_number = property(_cuvis_pyil.cuvis_mesu_metadata_t_serial_number_get, _cuvis_pyil.cuvis_mesu_metadata_t_serial_number_set, doc=r""" The serial number of the device, which took the measurement""")
    assembly = property(_cuvis_pyil.cuvis_mesu_metadata_t_assembly_get, _cuvis_pyil.cuvis_mesu_metadata_t_assembly_set, doc=r""" The Assembly Data of the device""")
    integration_time = property(_cuvis_pyil.cuvis_mesu_metadata_t_integration_time_get, _cuvis_pyil.cuvis_mesu_metadata_t_integration_time_set, doc=r""" The integration time of the measurement (exposure time) in ms""")
    averages = property(_cuvis_pyil.cuvis_mesu_metadata_t_averages_get, _cuvis_pyil.cuvis_mesu_metadata_t_averages_set, doc=r""" Number of averaging taken""")
    distance = property(_cuvis_pyil.cuvis_mesu_metadata_t_distance_get, _cuvis_pyil.cuvis_mesu_metadata_t_distance_set, doc=r""" Distance, the measurement was recorded in mm. If not provided, value is -1""")
    session_info_name = property(_cuvis_pyil.cuvis_mesu_metadata_t_session_info_name_get, _cuvis_pyil.cuvis_mesu_metadata_t_session_info_name_set, doc=r""" session_info name""")
    session_info_session_no = property(_cuvis_pyil.cuvis_mesu_metadata_t_session_info_session_no_get, _cuvis_pyil.cuvis_mesu_metadata_t_session_info_session_no_set, doc=r""" SessionFile number. Will be increased by stopping & starting recording""")
    session_info_sequence_no = property(_cuvis_pyil.cuvis_mesu_metadata_t_session_info_sequence_no_get, _cuvis_pyil.cuvis_mesu_metadata_t_session_info_sequence_no_set, doc=r""" Sequence number. Increases with each recorded frame. Reset, if session_no changes""")
    processing_mode = property(_cuvis_pyil.cuvis_mesu_metadata_t_processing_mode_get, _cuvis_pyil.cuvis_mesu_metadata_t_processing_mode_set, doc=r""" The current processing mode of the cube""")
    processing_mode_at_capture = property(_cuvis_pyil.cuvis_mesu_metadata_t_processing_mode_at_capture_get, _cuvis_pyil.cuvis_mesu_metadata_t_processing_mode_at_capture_set, doc=r""" The processing mode at the time of the cube was recorded""")
    measurement_flags = property(_cuvis_pyil.cuvis_mesu_metadata_t_measurement_flags_get, _cuvis_pyil.cuvis_mesu_metadata_t_measurement_flags_set, doc=r""" measurement flags""")
    measurement_frame_id = property(_cuvis_pyil.cuvis_mesu_metadata_t_measurement_frame_id_get, _cuvis_pyil.cuvis_mesu_metadata_t_measurement_frame_id_set, doc=r""" The frame ID assigned by cuvis to this measurement""")

    def __init__(self):
        _cuvis_pyil.cuvis_mesu_metadata_t_swiginit(self, _cuvis_pyil.new_cuvis_mesu_metadata_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_mesu_metadata_t

# Register cuvis_mesu_metadata_t in _cuvis_pyil:
_cuvis_pyil.cuvis_mesu_metadata_t_swigregister(cuvis_mesu_metadata_t)
class cuvis_save_args_t(object):
    r"""
     options for saving as cu3/cu3s files

    The cube exporter works asynchronically. For

    # offline saving to session file
    When processing sesion files ('allow_session_file=true)' offline, the option 'allow_drop' should be set to false.
    In this case measurements are added to the internal buffer until the size given by 'hard_limit'
    is reached.
    In this mode, the options 'soft_limit' and 'max_buftime' are ignroed.

    # online saving to session file
    When recording sesion files ('allow_session_file=true)' live, the options 'allow_drop' should be set to true.

    When a new measurement is added to the cube exporter, the following strategy is applied:

    1. The internal buffer has a total limit of size 'hard_limit'. If the buffer is full,
    it will be dropped (end).

    2. If the buffer is not full, the 'soft_limit' is checked. If it is reachd, the ordering of the frame numbers is ignored
    and the measurement with the lowest sequence nubmer is stored to the disk directly. (This can mess up the order of the frames
    set 'soft_limit' = 'hard_limit' to disable this behaviour)

    3. All meausurements in the internal buffer are checked: If they are held in the buffer for longer then the time given by
    'max_buftime', they are saved to disk directly. (This can mess up the order of the frames
    set 'max_buftime' to a higher value allow for longer hold time intervals.)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    allow_fragmentation = property(_cuvis_pyil.cuvis_save_args_t_allow_fragmentation_get, _cuvis_pyil.cuvis_save_args_t_allow_fragmentation_set, doc=r"""
     allow to split file to multiple files.

    When exporting to a cu3s file ('allow_session_file=true)' the allow_fragmentation flag controlles
    if all measurements (of the same session name) are written to one file like a single file (set to false) or
    if each measurement is saved to a separate cu3s file (set to true). The latter option generates substantial
    overhead.

    When exporting to a (legacy) cu3 file ('allow_session_file=false)', the fragmentation flag will lead
    to multiple files exported: a <name>.cu3 file, followed by <name>_<postfix>.tiff files. These come as a tuple
    and must be kept together, else the file will be corrupted. This export option is intended for legacy programs
    that were deisnged to read raw data with the previous software verison 2.x.
    """)
    allow_overwrite = property(_cuvis_pyil.cuvis_save_args_t_allow_overwrite_get, _cuvis_pyil.cuvis_save_args_t_allow_overwrite_set, doc=r"""
     allow to overwrite an existing file.

    This option anables to allow to ovewrite files on the disk, if they exist.

    Notes: When exporting to legacy format of version 2.x ('allow_session_file=false' and 'allow_fragmentation=true)',
    only the existance of the *.cu3 file is checked, existing *.tiff files are neither cleaned up nor checked if they exist
    prior overwriting.
    """)
    allow_drop = property(_cuvis_pyil.cuvis_save_args_t_allow_drop_get, _cuvis_pyil.cuvis_save_args_t_allow_drop_set, doc=r"""
     allow to drop files, if output buffers are full

    This options controlls the export behaviour. If internal write buffers are full,
    new measurements are either dropped or kept.

    The policy to drop measurements on full buffer (allow_drop=true) is recommended for online opration. The
    idea is to rather drop measurements and thus allow the acquisition to continue without slowing down.
    When this policy is set, the 'soft_limit' and the 'max_buftime' options are also used (see there).

    If new measurements are forced to be kept (allow_drop=true), the exporter will wait until the measurement can be written.
    This polocy is recommended for batch-processing measurements (offline). The options 'soft_limit' and 'max_buftime'
    are ignored.

    Notes: This option only applies, if 'allow_session_file=true'.
    """)
    allow_session_file = property(_cuvis_pyil.cuvis_save_args_t_allow_session_file_get, _cuvis_pyil.cuvis_save_args_t_allow_session_file_set, doc=r""" save files of same session number to a single cu3s file. If 'allow_fragmentation' is set, cu3s fill be split by measurement. Default in Wrappers: True""")
    allow_info_file = property(_cuvis_pyil.cuvis_save_args_t_allow_info_file_get, _cuvis_pyil.cuvis_save_args_t_allow_info_file_set, doc=r"""
     save additional info file.

    The info file is written to the same path as the export files.
    It is a plain text file and consits of the a header showing the recoridng FPS and mode and
    a body, where each frame number from 0 till the last frame written is shown by their name.
    Missing frames are noted as "dropped".

    Notes: The output of this file is not flushed until the exporter writes to a different file or is closed. Thus, it is not
    suited to be used as a way to monitor frame drops during live acquisiton.

    This option is ignored, when 'allow_session_file' is set to false.
    """)
    operation_mode = property(_cuvis_pyil.cuvis_save_args_t_operation_mode_get, _cuvis_pyil.cuvis_save_args_t_operation_mode_set, doc=r"""
     give the current operation mode.

    Save the operation mode used while recording.
    Only used if 'allow_session_file' is set.
    """)
    fps = property(_cuvis_pyil.cuvis_save_args_t_fps_get, _cuvis_pyil.cuvis_save_args_t_fps_set, doc=r"""
     the fps used in operation_mode video

    only used if 'allow_session_file=true' and 'operation_mode=Internal'.
    """)
    soft_limit = property(_cuvis_pyil.cuvis_save_args_t_soft_limit_get, _cuvis_pyil.cuvis_save_args_t_soft_limit_set, doc=r"""
     Out-of-order frames are sorted within the cache, as long as the cache useage is below this limit.

    The soft limit is only used if 'allow_drop=true' and 'allow_session_file=true'.

    The internal chache may hold up to 'soft_limit' number of frames that are out of sequence.

    For example: Let the the seqence number of the measurement written last be #14, and let the internal
    cache hold the frames  #16,#17,...#24 (9 images in chache) and let the soft limit be 10
    If we assume the next frame to be #25, the 10 images in cache reached the soft limit, forcing
    the first frame with the lowest nubmer (#16) to be written (#15 is makred as 'dropped').
    If the next image actually is #15, this image is then written out of sequence, resulting in the
    order #14, #16, #15.

    Theese are the states of the example avove.

    > write to disk: #14

    > cache: #16,#17,...#24 [soft limit: 10]

    > insert: #25

    > write to disk: #16

    > cache: #17,...#24, #25 [soft limit: 10]

    > insert: #15

    > write to disk: #15

    > cache: #17,...#24, #25 [soft limit: 10]

    This behaviour is a compromise between keeping the seuqence in order and at the same time
    not storing too many images if a frame was acutally dropped.
    Increase the soft_limit to a value same or grater the 'hard_limit' to disable this behaviour.
    """)
    hard_limit = property(_cuvis_pyil.cuvis_save_args_t_hard_limit_get, _cuvis_pyil.cuvis_save_args_t_hard_limit_set, doc=r"""
     Maximum number of elements in output cache

    The hard limit is only used if 'allow_session_file=true'.

    The output cache has a maximum size of 'hard_limit'. If more measurements
    are added, adding another measurment is not possible.
    Adding a measurement will lock the calling function if 'allow_drop' is set to false.
    If 'allow_drop' is set to true, the added frame is directrly dropped and not stored.

    Notes: This behaviour also applies when using the exproter within a worker.
    """)
    max_buftime = property(_cuvis_pyil.cuvis_save_args_t_max_buftime_get, _cuvis_pyil.cuvis_save_args_t_max_buftime_set, doc=r"""
     Any frame is forced to be written after this time (in ms), latest.

    The maximum buffer time option is only used if 'allow_drop=true' and
    'allow_session_file=true'.

    The time a buffer is held in the exporter's cache is tracked. If the time given
    by the max_buftime is exceeded, a measuremnt is written to disk.

    This option also helps to guarantee a measurements to be serialized to a permanent
    storage and avoid data loss upon power or abnormal program termination.

    This option will overwrite the 'soft_limit' for this frame, if needed.

    """)
    full_export = property(_cuvis_pyil.cuvis_save_args_t_full_export_get, _cuvis_pyil.cuvis_save_args_t_full_export_set, doc=r"""
     Whether processing results are also saved in the export.

    If enabled, all cube data and accompanying meta-data are stored in the exported file as well.
    This vastly increases file size and the time and processing resources needed for the export.

    If disabled, only the raw image from the camera and raw data from any additional devices are stored.
    This in turn requires the data to be reprocessed when loading it again.
    """)

    def __init__(self):
        _cuvis_pyil.cuvis_save_args_t_swiginit(self, _cuvis_pyil.new_cuvis_save_args_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_save_args_t

# Register cuvis_save_args_t in _cuvis_pyil:
_cuvis_pyil.cuvis_save_args_t_swigregister(cuvis_save_args_t)
class cuvis_proc_args_t(object):
    r""" processing arguments"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    processing_mode = property(_cuvis_pyil.cuvis_proc_args_t_processing_mode_get, _cuvis_pyil.cuvis_proc_args_t_processing_mode_set, doc=r"""
     the processing mode to be used.

    use 'cuvis_proc_cont_is_capable' to check,
    if the mode is currently possible of a specific measurement
    """)
    allow_recalib = property(_cuvis_pyil.cuvis_proc_args_t_allow_recalib_get, _cuvis_pyil.cuvis_proc_args_t_allow_recalib_set, doc=r"""
     allow to use different calibration (expert option)

    This options allows to process raw data with a different calibration.
    this is, however, limited to the same hardware.

    If the hardware was mechanically changed, results may be poor or not usable
    at all. Unless the accuracy of the result can be verified, this option is
    not recommended.
    """)

    def __init__(self):
        _cuvis_pyil.cuvis_proc_args_t_swiginit(self, _cuvis_pyil.new_cuvis_proc_args_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_proc_args_t

# Register cuvis_proc_args_t in _cuvis_pyil:
_cuvis_pyil.cuvis_proc_args_t_swigregister(cuvis_proc_args_t)
class cuvis_export_general_settings_t(object):
    r""" general export settings"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    export_dir = property(_cuvis_pyil.cuvis_export_general_settings_t_export_dir_get, _cuvis_pyil.cuvis_export_general_settings_t_export_dir_set, doc=r""" The export directory""")
    channel_selection = property(_cuvis_pyil.cuvis_export_general_settings_t_channel_selection_get, _cuvis_pyil.cuvis_export_general_settings_t_channel_selection_set, doc=r"""
     The export channel selection

    Use "all" or "full" for all available channels

    Use ranges for wavelength range start-end or start:end or start:step:end ;
    All values in Nanometers.
    Examples: 450:10:550 or 450-550
    """)
    spectra_multiplier = property(_cuvis_pyil.cuvis_export_general_settings_t_spectra_multiplier_get, _cuvis_pyil.cuvis_export_general_settings_t_spectra_multiplier_set, doc=r"""
     multiply spectrum by fixed factor before exporting

    This is most usefull for bitshifting the data - especially when the pan image is also added to the export.
    """)
    pan_scale = property(_cuvis_pyil.cuvis_export_general_settings_t_pan_scale_get, _cuvis_pyil.cuvis_export_general_settings_t_pan_scale_set, doc=r"""
     amount of pan-sharpening

    The value is relative to the pan image size, give a value between 0 and 1
    """)
    pan_interpolation_type = property(_cuvis_pyil.cuvis_export_general_settings_t_pan_interpolation_type_get, _cuvis_pyil.cuvis_export_general_settings_t_pan_interpolation_type_set, doc=r"""
     for pansharpening use this interpolation type to scale up the cube before adjusting the weights

    As a first step to pan-sharpening the spectral data needs to be re-sampled to the target resolution
    This parameter determines the method for this resampling.
    """)
    pan_algorithm = property(_cuvis_pyil.cuvis_export_general_settings_t_pan_algorithm_get, _cuvis_pyil.cuvis_export_general_settings_t_pan_algorithm_set, doc=r""" method for calculating the weights""")
    pre_pan_sharpen_cube = property(_cuvis_pyil.cuvis_export_general_settings_t_pre_pan_sharpen_cube_get, _cuvis_pyil.cuvis_export_general_settings_t_pre_pan_sharpen_cube_set, doc=r"""
     pansharpen cube before calculating user plugin

    Normally pan sharpening is applied after calculating the user plugin. Prepansharpening can be used to get
    a pansharpened cube when no real userplugin shall be applied. Prepansharpening is calculated on the whole
    spectral cube which is heavy on performance.
    """)
    blend_opacity = property(_cuvis_pyil.cuvis_export_general_settings_t_blend_opacity_get, _cuvis_pyil.cuvis_export_general_settings_t_blend_opacity_set, doc=r"""
     opacity for 'pan_sharpening_algorithm_AlphablendPanOverlay', give a value between 0 and 1
    a value of 1.0 represents usage of 100% pan image, 0 will be 100% view image
    """)
    add_pan = property(_cuvis_pyil.cuvis_export_general_settings_t_add_pan_get, _cuvis_pyil.cuvis_export_general_settings_t_add_pan_set, doc=r"""
     add pan to exported image.

    If applicable, the pan image is scaled to target pan-sharpening resolution.
    """)
    add_fullscale_pan = property(_cuvis_pyil.cuvis_export_general_settings_t_add_fullscale_pan_get, _cuvis_pyil.cuvis_export_general_settings_t_add_fullscale_pan_set, doc=r"""
     add full-resolution pan to exported image.

    If applicable, the image is added directly to the output.
    else, the image is stored separately.
    """)
    permissive = property(_cuvis_pyil.cuvis_export_general_settings_t_permissive_get, _cuvis_pyil.cuvis_export_general_settings_t_permissive_set, doc=r"""
     Set exporter to "permisive mode"

    If set, errors will be skipped and alternative values assumed, wherever possible.

    E.g., if 'add_pan' is selected but there is no panchromatic image avaialbe, the export is not possible.
    In permissive mode, however, the add_pan option is de-activated and an exprot without pan image is conducted
    instead.

    Notes: This mode may lead to unexpected behaviour and should be used with caution.
    """)

    def __init__(self):
        _cuvis_pyil.cuvis_export_general_settings_t_swiginit(self, _cuvis_pyil.new_cuvis_export_general_settings_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_export_general_settings_t

# Register cuvis_export_general_settings_t in _cuvis_pyil:
_cuvis_pyil.cuvis_export_general_settings_t_swigregister(cuvis_export_general_settings_t)
class cuvis_export_view_settings_t(object):
    r""" Additional settings for exporting to a userplugin view. See also 'cuvis_export_general_settings_t'"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    userplugin = property(_cuvis_pyil.cuvis_export_view_settings_t_userplugin_get, _cuvis_pyil.cuvis_export_view_settings_t_userplugin_set, doc=r""" The userplugin xml string. See userplugin manual.""")
    pan_failback = property(_cuvis_pyil.cuvis_export_view_settings_t_pan_failback_get, _cuvis_pyil.cuvis_export_view_settings_t_pan_failback_set, doc=r""" failback to pan image if cube is not available""")

    def __init__(self):
        _cuvis_pyil.cuvis_export_view_settings_t_swiginit(self, _cuvis_pyil.new_cuvis_export_view_settings_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_export_view_settings_t

# Register cuvis_export_view_settings_t in _cuvis_pyil:
_cuvis_pyil.cuvis_export_view_settings_t_swigregister(cuvis_export_view_settings_t)
class cuvis_export_tiff_settings_t(object):
    r""" Additional settings for exporting tiff. See also 'cuvis_export_general_settings_t'"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    compression_mode = property(_cuvis_pyil.cuvis_export_tiff_settings_t_compression_mode_get, _cuvis_pyil.cuvis_export_tiff_settings_t_compression_mode_set, doc=r""" the compression mode for tiff export""")
    format = property(_cuvis_pyil.cuvis_export_tiff_settings_t_format_get, _cuvis_pyil.cuvis_export_tiff_settings_t_format_set, doc=r""" the tiff export mode / format""")

    def __init__(self):
        _cuvis_pyil.cuvis_export_tiff_settings_t_swiginit(self, _cuvis_pyil.new_cuvis_export_tiff_settings_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_export_tiff_settings_t

# Register cuvis_export_tiff_settings_t in _cuvis_pyil:
_cuvis_pyil.cuvis_export_tiff_settings_t_swigregister(cuvis_export_tiff_settings_t)
class cuvis_viewer_settings_t(object):
    r"""viewer settings"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    userplugin = property(_cuvis_pyil.cuvis_viewer_settings_t_userplugin_get, _cuvis_pyil.cuvis_viewer_settings_t_userplugin_set, doc=r""" The userplugin xml string. See userplugin manual.""")
    pan_scale = property(_cuvis_pyil.cuvis_viewer_settings_t_pan_scale_get, _cuvis_pyil.cuvis_viewer_settings_t_pan_scale_set, doc=r"""
     amount of pan-sharpening

    The value is relative to the pan image size, give a value between 0 and 1
    """)
    pan_interpolation_type = property(_cuvis_pyil.cuvis_viewer_settings_t_pan_interpolation_type_get, _cuvis_pyil.cuvis_viewer_settings_t_pan_interpolation_type_set, doc=r""" for pansharpening use this interpolation type to scale up the cube before adjusting the weights""")
    pan_algorithm = property(_cuvis_pyil.cuvis_viewer_settings_t_pan_algorithm_get, _cuvis_pyil.cuvis_viewer_settings_t_pan_algorithm_set, doc=r""" method for calculating the weights""")
    pre_pan_sharpen_cube = property(_cuvis_pyil.cuvis_viewer_settings_t_pre_pan_sharpen_cube_get, _cuvis_pyil.cuvis_viewer_settings_t_pre_pan_sharpen_cube_set, doc=r"""
     pansharpen cube before calculating user plugin

    Normally pan sharpening is applied after calculating the user plugin. Prepansharpening can be used to get
    a pansharpened cube when no real userplugin shall be applied. Prepansharpening is calculated on the whole
    spectral cube which is heavy on performance.
    """)
    complete = property(_cuvis_pyil.cuvis_viewer_settings_t_complete_get, _cuvis_pyil.cuvis_viewer_settings_t_complete_set, doc=r""" also include parts that were not marked as "show".""")
    blend_opacity = property(_cuvis_pyil.cuvis_viewer_settings_t_blend_opacity_get, _cuvis_pyil.cuvis_viewer_settings_t_blend_opacity_set, doc=r"""
     opacity for 'pan_sharpening_algorithm_AlphablendPanOverlay', give a value between 0 and 1
    a value of 1.0 represents usage of 100% pan image, 0 will be 100% view image
    """)
    pan_failback = property(_cuvis_pyil.cuvis_viewer_settings_t_pan_failback_get, _cuvis_pyil.cuvis_viewer_settings_t_pan_failback_set, doc=r""" failback to pan image if cube is not available""")

    def __init__(self):
        _cuvis_pyil.cuvis_viewer_settings_t_swiginit(self, _cuvis_pyil.new_cuvis_viewer_settings_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_viewer_settings_t

# Register cuvis_viewer_settings_t in _cuvis_pyil:
_cuvis_pyil.cuvis_viewer_settings_t_swigregister(cuvis_viewer_settings_t)
class cuvis_view_data_t(object):
    r""" The view meta structure"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    id = property(_cuvis_pyil.cuvis_view_data_t_id_get, _cuvis_pyil.cuvis_view_data_t_id_set, doc=r""" The id of the view""")
    category = property(_cuvis_pyil.cuvis_view_data_t_category_get, _cuvis_pyil.cuvis_view_data_t_category_set, doc=r""" the type of view data""")
    data = property(_cuvis_pyil.cuvis_view_data_t_data_get, _cuvis_pyil.cuvis_view_data_t_data_set, doc=r""" the actual data. View data is always 8 bit, i.e. imbuffer bytes = 1""")
    show = property(_cuvis_pyil.cuvis_view_data_t_show_get, _cuvis_pyil.cuvis_view_data_t_show_set, doc=r""" 1 if dataset is intended for showing, 0 else""")

    def __init__(self):
        _cuvis_pyil.cuvis_view_data_t_swiginit(self, _cuvis_pyil.new_cuvis_view_data_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_view_data_t

# Register cuvis_view_data_t in _cuvis_pyil:
_cuvis_pyil.cuvis_view_data_t_swigregister(cuvis_view_data_t)
class cuvis_component_info_t(object):
    r""" Information about components"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_cuvis_pyil.cuvis_component_info_t_type_get, _cuvis_pyil.cuvis_component_info_t_type_set, doc=r""" type of the component""")
    displayname = property(_cuvis_pyil.cuvis_component_info_t_displayname_get, _cuvis_pyil.cuvis_component_info_t_displayname_set, doc=r""" the name that can be displayed human-readable""")
    sensorinfo = property(_cuvis_pyil.cuvis_component_info_t_sensorinfo_get, _cuvis_pyil.cuvis_component_info_t_sensorinfo_set, doc=r""" the sensor's meta-informaiton""")
    userfield = property(_cuvis_pyil.cuvis_component_info_t_userfield_get, _cuvis_pyil.cuvis_component_info_t_userfield_set, doc=r""" additional sensor informaiton""")
    pixelformat = property(_cuvis_pyil.cuvis_component_info_t_pixelformat_get, _cuvis_pyil.cuvis_component_info_t_pixelformat_set, doc=r""" additional sensor informaiton""")

    def __init__(self):
        _cuvis_pyil.cuvis_component_info_t_swiginit(self, _cuvis_pyil.new_cuvis_component_info_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_component_info_t

# Register cuvis_component_info_t in _cuvis_pyil:
_cuvis_pyil.cuvis_component_info_t_swigregister(cuvis_component_info_t)
class cuvis_event_base_data_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    event_id = property(_cuvis_pyil.cuvis_event_base_data_t_event_id_get, _cuvis_pyil.cuvis_event_base_data_t_event_id_set)

    def __init__(self):
        _cuvis_pyil.cuvis_event_base_data_t_swiginit(self, _cuvis_pyil.new_cuvis_event_base_data_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_event_base_data_t

# Register cuvis_event_base_data_t in _cuvis_pyil:
_cuvis_pyil.cuvis_event_base_data_t_swigregister(cuvis_event_base_data_t)
class cuvis_event_acquisition_data_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    source = property(_cuvis_pyil.cuvis_event_acquisition_data_t_source_get, _cuvis_pyil.cuvis_event_acquisition_data_t_source_set)

    def __init__(self):
        _cuvis_pyil.cuvis_event_acquisition_data_t_swiginit(self, _cuvis_pyil.new_cuvis_event_acquisition_data_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_event_acquisition_data_t

# Register cuvis_event_acquisition_data_t in _cuvis_pyil:
_cuvis_pyil.cuvis_event_acquisition_data_t_swigregister(cuvis_event_acquisition_data_t)
class cuvis_event_processing_event_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    source = property(_cuvis_pyil.cuvis_event_processing_event_t_source_get, _cuvis_pyil.cuvis_event_processing_event_t_source_set)

    def __init__(self):
        _cuvis_pyil.cuvis_event_processing_event_t_swiginit(self, _cuvis_pyil.new_cuvis_event_processing_event_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_event_processing_event_t

# Register cuvis_event_processing_event_t in _cuvis_pyil:
_cuvis_pyil.cuvis_event_processing_event_t_swigregister(cuvis_event_processing_event_t)
class cuvis_event_quality_event_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    source = property(_cuvis_pyil.cuvis_event_quality_event_t_source_get, _cuvis_pyil.cuvis_event_quality_event_t_source_set)

    def __init__(self):
        _cuvis_pyil.cuvis_event_quality_event_t_swiginit(self, _cuvis_pyil.new_cuvis_event_quality_event_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_event_quality_event_t

# Register cuvis_event_quality_event_t in _cuvis_pyil:
_cuvis_pyil.cuvis_event_quality_event_t_swigregister(cuvis_event_quality_event_t)
class cuvis_event_component_data_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    compent_id = property(_cuvis_pyil.cuvis_event_component_data_t_compent_id_get, _cuvis_pyil.cuvis_event_component_data_t_compent_id_set)

    def __init__(self):
        _cuvis_pyil.cuvis_event_component_data_t_swiginit(self, _cuvis_pyil.new_cuvis_event_component_data_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_event_component_data_t

# Register cuvis_event_component_data_t in _cuvis_pyil:
_cuvis_pyil.cuvis_event_component_data_t_swigregister(cuvis_event_component_data_t)
class cuvis_worker_settings_t(object):
    r""" settings for the worker"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    input_queue_size = property(_cuvis_pyil.cuvis_worker_settings_t_input_queue_size_get, _cuvis_pyil.cuvis_worker_settings_t_input_queue_size_set, doc=r"""
     Size of the input queue for measurements and session files

    The worker has an input queue that accepts measurements and entire session files.
    To limit the memory usage, the queue is bounded by this value
    """)
    mandatory_queue_size = property(_cuvis_pyil.cuvis_worker_settings_t_mandatory_queue_size_get, _cuvis_pyil.cuvis_worker_settings_t_mandatory_queue_size_set, doc=r"""
     Number of threads working on mandatory processing steps

    Set the number of processing slots / threads / queue size for mandatory processing steps in the worker
    Mandatory steps always include exporting the measurement, if an exporter is set in the worker.
    If the measurement needs to be processed before it can be exported, the processing is also a mandatory step.
    """)
    supplementary_queue_size = property(_cuvis_pyil.cuvis_worker_settings_t_supplementary_queue_size_get, _cuvis_pyil.cuvis_worker_settings_t_supplementary_queue_size_set, doc=r"""
     Number of threads working on supplementary processing steps

    Set the number of processing slots / threads / queue size for supplementary processing steps in the worker
    Supplementary steps always include generating a view of the measurement, if a viewer is set in the worker.
    If no exporter is set, all steps are supplementary.
    """)
    output_queue_size = property(_cuvis_pyil.cuvis_worker_settings_t_output_queue_size_get, _cuvis_pyil.cuvis_worker_settings_t_output_queue_size_set, doc=r"""
     Size of the workers result queue

    Should be at least as big as "mandatory_queue_size" and "supplementary_queue_size" together
    """)
    can_skip_measurements = property(_cuvis_pyil.cuvis_worker_settings_t_can_skip_measurements_get, _cuvis_pyil.cuvis_worker_settings_t_can_skip_measurements_set, doc=r"""
     Wether the worker is allowed to reject measurements from the acquisition context, if its queues are full

    If set to true (1), the worker will skip processing measurements it pulls from the acqusition context, when its mandatory queue is full.
    If set to false (0), the worker will wait until a processing slot in its mandatory queue is available, before pulling a new measurement from the acquisition context.
    This setting DOES NOT apply to measurements and session files given to the worker via the "cuvis_worker_ingest_xyz" functions.
    """)
    can_skip_supplementary_steps = property(_cuvis_pyil.cuvis_worker_settings_t_can_skip_supplementary_steps_get, _cuvis_pyil.cuvis_worker_settings_t_can_skip_supplementary_steps_set, doc=r"""
     Wether the worker is allowed to skip supplementary processing steps, if its queues are full.

    If set to true (1), the worker will skip supplementary processing steps, when its supplementary queue is full.
    If set to false (0), the worker will wait until a processing slot in its supplementary queue is available, before starting processing on a new measurement.
    This setting DOES applies to measurements and session files given to the worker via the "cuvis_worker_ingest_xyz" functions.
    """)
    can_drop_results = property(_cuvis_pyil.cuvis_worker_settings_t_can_drop_results_get, _cuvis_pyil.cuvis_worker_settings_t_can_drop_results_set, doc=r""" Wether the worker is allowed to drop processing results  if its output queue is full""")

    def __init__(self):
        _cuvis_pyil.cuvis_worker_settings_t_swiginit(self, _cuvis_pyil.new_cuvis_worker_settings_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_worker_settings_t

# Register cuvis_worker_settings_t in _cuvis_pyil:
_cuvis_pyil.cuvis_worker_settings_t_swigregister(cuvis_worker_settings_t)
class cuvis_worker_state_t(object):
    r""" Collection of worker stats"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    measurementsInQueue = property(_cuvis_pyil.cuvis_worker_state_t_measurementsInQueue_get, _cuvis_pyil.cuvis_worker_state_t_measurementsInQueue_set, doc=r""" Measurements currently in the input queue""")
    sessionFilesInQueue = property(_cuvis_pyil.cuvis_worker_state_t_sessionFilesInQueue_get, _cuvis_pyil.cuvis_worker_state_t_sessionFilesInQueue_set, doc=r""" Session files currently in the input queue""")
    framesInQueue = property(_cuvis_pyil.cuvis_worker_state_t_framesInQueue_get, _cuvis_pyil.cuvis_worker_state_t_framesInQueue_set, doc=r""" Total number of frames currently in the input queue accounting for sesssion file size""")
    measurementsBeingProcessed = property(_cuvis_pyil.cuvis_worker_state_t_measurementsBeingProcessed_get, _cuvis_pyil.cuvis_worker_state_t_measurementsBeingProcessed_set, doc=r""" Number of measurments the worker is currently processing""")
    resultsInQueue = property(_cuvis_pyil.cuvis_worker_state_t_resultsInQueue_get, _cuvis_pyil.cuvis_worker_state_t_resultsInQueue_set, doc=r""" Number of results currently in the result queue""")
    hasAcquisitionContext = property(_cuvis_pyil.cuvis_worker_state_t_hasAcquisitionContext_get, _cuvis_pyil.cuvis_worker_state_t_hasAcquisitionContext_set, doc=r""" Wether the worker has an acquisition context set""")
    isProcessing = property(_cuvis_pyil.cuvis_worker_state_t_isProcessing_get, _cuvis_pyil.cuvis_worker_state_t_isProcessing_set, doc=r""" Wether the worker is currently allowed to process measurements; same attribute as queried by cuvis_worker_is_processing.""")

    def __init__(self):
        _cuvis_pyil.cuvis_worker_state_t_swiginit(self, _cuvis_pyil.new_cuvis_worker_state_t())
    __swig_destroy__ = _cuvis_pyil.delete_cuvis_worker_state_t

# Register cuvis_worker_state_t in _cuvis_pyil:
_cuvis_pyil.cuvis_worker_state_t_swigregister(cuvis_worker_state_t)
CUVIS_EVENT_PROCESSING = _cuvis_pyil.CUVIS_EVENT_PROCESSING

CUVIS_EVENT_ACQUISTION = _cuvis_pyil.CUVIS_EVENT_ACQUISTION
CUVIS_EVENT_COMPONENT = _cuvis_pyil.CUVIS_EVENT_COMPONENT
CUVIS_EVENT_TRIGGER_SKIPPED = _cuvis_pyil.CUVIS_EVENT_TRIGGER_SKIPPED

def cuvis_event_get_acquisition_data(i_event, o_p_acquisition_data):
    return _cuvis_pyil.cuvis_event_get_acquisition_data(i_event, o_p_acquisition_data)

def cuvis_register_external_event_callback(i_callback, i_type, o_p_handler_id):
    r"""
     Register an event handler.
    The event handler will be called on all events which satisfy the supplied event handler type. Returns an id for the event handler
    to allow unregistering of the specific event handler
    only valid during the runtime of the callback.

    :type i_callback: void, in
    :param i_callback: the event handler function callback
    :type i_type: int, in
    :param i_type: the type of the event handler which is registered
    :type o_p_handler_id: int, out
    :param o_p_handler_id: a pointer where the handler id will be written to
    """
    return _cuvis_pyil.cuvis_register_external_event_callback(i_callback, i_type, o_p_handler_id)

def cuvis_unregister_event_callback(i_handler_id):
    r""" Unregisters an event handler. Supply a valid handler id to specific the correct callback which is going to be unregistered"""
    return _cuvis_pyil.cuvis_unregister_event_callback(i_handler_id)

def cuvis_get_last_error_msg():
    r""" Call this function for obtaining the last error message"""
    return _cuvis_pyil.cuvis_get_last_error_msg()

def cuvis_set_last_error_locale(i_locale_id):
    r"""
     Set the locale for localized error messages

    :type i_locale_id: string, in
    :param i_locale_id: set the locale id, e.g. "de" for german. See the "locale" directory for available translations.
    """
    return _cuvis_pyil.cuvis_set_last_error_locale(i_locale_id)

def cuvis_get_last_error_msg_localized():
    r"""
     Call this function for obtaining the last localized error message

    remember to set locale with 'cuvis_set_last_error_locale' first.
    """
    return _cuvis_pyil.cuvis_get_last_error_msg_localized()

def cuvis_set_log_level(level):
    r"""
     Set the internal log level. Log output will be redirected to cout

    If this function is not called, a failback logger is used, with loglevel "warning"
    The failback logger is de-activated, when this function is called or when a callback is
    registered for the log messages.
    However, when this function is called, messages are logged to console, even when a callaback is
    registered.
    debug = 4, info = 3, warning = 2, error = 1, fatal = 0

    :type level: int, in
    :param level: the log level to be set
    """
    return _cuvis_pyil.cuvis_set_log_level(level)

def cuvis_register_log_callback(i_callback, i_min_level):
    r"""
     Register an additional logger.
    Only one classic callback will be set, multiple calls will overwrite the previous callback. The callback's message argument pointer is
    only valid during the runtime of the callback.
    The "classic" logger will output original messages, instead of it's respective translations. For localized (translated) messages, See also: cuvis_reset_log_callback_localized.
    Notes: The classical logger and localized logger can be used simultaneously.
    :type i_callback: void, in
    :param i_callback: the function callback
    :type i_min_level: int, in
    :param i_min_level: the minimum level of the callback
    """
    return _cuvis_pyil.cuvis_register_log_callback(i_callback, i_min_level)

def cuvis_reset_log_callback():
    r""" Unregister the additional logger. This will not clear the localized logger"""
    return _cuvis_pyil.cuvis_reset_log_callback()

def cuvis_register_log_callback_localized(i_callback_localized, i_min_level, i_locale_id):
    r"""
     Register an additional logger with localized language.
    Only one callback will be set, multiple calls will overwrite the previous callback. The callback's message argument pointer is
    only valid during the runtime of the callback.
    Notes: The classical logger and localized logger can be used simultaneously.
    :type i_callback_localized: void, in
    :param i_callback_localized: the function callback
    :type i_min_level: int, in
    :param i_min_level: the minimum level of the callback
    :type i_locale_id: string, in
    :param i_locale_id: set the locale id, e.g. "de-DE.UTF8" for german. See the "locale" directory for available translations.
    """
    return _cuvis_pyil.cuvis_register_log_callback_localized(i_callback_localized, i_min_level, i_locale_id)

def cuvis_reset_log_callback_localized():
    r""" Unregister the additional localized logger. This will not clear the classic logger"""
    return _cuvis_pyil.cuvis_reset_log_callback_localized()

def cuvis_init(i_settings_path, i_global_loglevel, i_logfile_name):
    r"""
     The init function set the settings path.

    :type i_settings_path: string, in
    :param i_settings_path: The path to the settings directory.
    :type i_global_loglevel: int, in
    :param i_global_loglevel: The log level that will be used for the backend logging system
    :type i_logfile_name: string, in
    :param i_logfile_name: The name of the logfile that is going to be written
    """
    return _cuvis_pyil.cuvis_init(i_settings_path, i_global_loglevel, i_logfile_name)

def cuvis_shutdown():
    r""" Function for shutting down Cuvis safely. Gently stops all threads."""
    return _cuvis_pyil.cuvis_shutdown()

def cuvis_get_userplugin_engine_version(o_pVersion):
    r"""
     Get the Userplugin processing engine version number

    :type o_pVersion: string, out
    :param o_pVersion: The output version string. The provided array must have the length of 'CUVIS_MAXBUF'
    """
    return _cuvis_pyil.cuvis_get_userplugin_engine_version(o_pVersion)

def cuvis_async_call_get(io_pAsyncResult, timeout_ms):
    r"""
     get the result of a async call.

    Get the return code (and error message, if applicable) of an async function, that has been called.
    If result is not 'status_ok' use the 'cuvis_get_last_error_msg' function to get details.

    If the timeout is used (value above 0ms), 'status_timeout' or 'status_deferred' will be returned, if the function is not yet finished.
    In that case, the asyncResult handle is still valid and can be used again.
    If the result is 'status_ok' the function has finished. For both 'status_ok' and 'status_error', the handle is now invalid.

    If the result is 'status_overwritten' the function's call was overwritten by another (similar) call. The actual value set by this
    async function was not used, but the one of the other call. On this result, the handle is now invalid.

    :type io_pAsyncResult: int, in/out
    :param io_pAsyncResult: the async handle obtained by calling a async function. If the call finished, the handle will be invalidated
    :type timeout_ms: int, in
    :param timeout_ms: the timeout in ms. Give 0 to wait for ever.
    :rtype: int
    :return: 'status_ok' if the async function finished successfully. 'status_timeout' or 'status_deferred' will be returned,
        if the function is not yet finished. If the call failed, because it was overwritten it this function will return
        'status_overwritten'. If it failed for other reasons, the this function returns 'status_error'.
    """
    return _cuvis_pyil.cuvis_async_call_get(io_pAsyncResult, timeout_ms)

def cuvis_async_capture_free(io_pAsyncResult):
    r""" Free an async measurement result without calling it"""
    return _cuvis_pyil.cuvis_async_capture_free(io_pAsyncResult)

def cuvis_async_call_free(io_pAsyncResult):
    r""" Free an async call result without calling it"""
    return _cuvis_pyil.cuvis_async_call_free(io_pAsyncResult)

def cuvis_async_call_status(i_pAsyncResult, io_pStatusResult):
    r""" checks the status of the async call object and returns it"""
    return _cuvis_pyil.cuvis_async_call_status(i_pAsyncResult, io_pStatusResult)

def cuvis_async_capture_status(i_pAsyncResult, io_pStatusResult):
    r""" checks the status of the async capture object and returns it"""
    return _cuvis_pyil.cuvis_async_capture_status(i_pAsyncResult, io_pStatusResult)

def cuvis_acq_cont_capture(i_acqCont, o_pMesu, timeout_ms):
    r"""
    Capture a measurement

    This function is only available in operation mode "Software". The function executes a software trigger synchronously.


    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type o_pMesu: int, out
    :param o_pMesu: the handle of the recorded image will be written to this variable
    :type timeout_ms: int, in
    :param timeout_ms: the timeout in ms. Give 0 to wait for ever.
    :rtype: int
    :return: status_ok if the measurement was recorded. 'status_timeout' or 'status_deferred' is returned, if the capture was not completed (yet)
    """
    return _cuvis_pyil.cuvis_acq_cont_capture(i_acqCont, o_pMesu, timeout_ms)

def cuvis_acq_cont_capture_async(i_acqCont, o_pAsyncResult):
    r"""
     Capture a measurement async

    This function is only available in operation mode "Software". The function executes a software trigger asynchronously.
    The recorded measurement can be obtained by the function 'cuvis_async_capture_get'.

    If o_pAsyncResult is set to NULL, the measurement is added to the Acqusition Context's internal queue.
    Retrieve it with 'cuvis_acq_cont_get_next_measurement' or via the worker (if used) 'cuvis_worker_get_next_result'

    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type o_pAsyncResult: int, out
    :param o_pAsyncResult: the async capture handle will be written to this variable or NULL
    :rtype: int
    :return: status_ok if the async call could be executed.
    """
    return _cuvis_pyil.cuvis_acq_cont_capture_async(i_acqCont, o_pAsyncResult)

def cuvis_async_capture_get(io_pAsyncResult, timeout_ms, o_pMesu):
    r"""
    get the result of a async capture.

    Get the return code (and error message, if applicable) of an async capture, that has been called.
    If result is not 'status_ok' use the 'cuvis_get_last_error_msg' function to get details.

    If the timeout is used (value above 0ms), 'status_timeout' or 'status_deferred' will be returned, if the function is not yet finished.
    In that case, the asyncResult handle is still valid and can be used again.
    If the result is 'status_ok' the function has finished. For both 'status_ok' and 'status_error', the handle is now invalid.

    :type io_pAsyncResult: int, in/out
    :param io_pAsyncResult: the async handle obtained by calling 'cuvis_acq_cont_capture_async'. If the call finished, the handle will be invalidated
    :type timeout_ms: int, in
    :param timeout_ms: the timeout in ms. Give 0 to wait for ever.
    :type o_pMesu: int, out
    :param o_pMesu: write the measurement handle to this variable, if the call was successful. Else write CUVIS_HANDLE_NULL
    :rtype: int
    :return: 'status_ok' if the async function finished successfully. 'status_timeout' or 'status_deferred' will be returned,
        if the function is not yet finished. If it failed for other reasons, the this function returns 'status_error'.
    """
    return _cuvis_pyil.cuvis_async_capture_get(io_pAsyncResult, timeout_ms, o_pMesu)

def cuvis_measurement_copy_handle(i_mesu, o_pMesu):
    r"""
     Creates an additional measurement handle

    Creates an additional handle that points to the same instance as the supplied handle

    :type i_mesu: int, in
    :param i_mesu: The handle of the measurement to copy
    :type o_pMesu: int, out
    :param o_pMesu: The new handle of the measurement.
    :rtype: int
    :return: 'status_ok' if the measurement handle could be doubled
    """
    return _cuvis_pyil.cuvis_measurement_copy_handle(i_mesu, o_pMesu)

def cuvis_measurement_load(i_path, o_pMesu):
    r"""
     Load a measurement from disk.

    The measurement is a cu3 file - and if fragmented some additional tiff files with a postfix, e.g. _cube.tiff
    To load the file, all fragmented parts must be in the same directory. Fragmented files must not be renamed.

    :type i_path: string, in
    :param i_path: the file path of the measurement
    :type o_pMesu: int, out
    :param o_pMesu: the handle of the measurement.
    :rtype: int
    :return: 'status_ok', if the measurement could be loaded.
    """
    return _cuvis_pyil.cuvis_measurement_load(i_path, o_pMesu)

def cuvis_measurement_deep_copy(i_mesu, o_pMesu):
    r"""
     create a deep copy of a measurement

    All operations on a measurement are performed on the same object. If different processing needs to be perfomed on a measurement
    It should be deep-copied. The copied meausrement's name will be changed to end with "_copy"

    :type i_mesu: int, in
    :param i_mesu: The measurement copy source.
    :type o_pMesu: int, out
    :param o_pMesu: The copy will be linked to the handle given.
    """
    return _cuvis_pyil.cuvis_measurement_deep_copy(i_mesu, o_pMesu)

def cuvis_measurement_clear_cube(i_mesu):
    r"""
     Clears the cube from a measurement

    Clears the proceessing result, i. e. the cube, from the measurement. This returns the measurement the state before
    applying the processing. This can be usefull for reduced data usage.

    :type i_mesu: int, in
    :param i_mesu: The measurement
    """
    return _cuvis_pyil.cuvis_measurement_clear_cube(i_mesu)

def cuvis_measurement_clear_implicit_reference(i_mesu, i_type):
    r"""
     Clears an implicit reference measurement

    Implict measurements are created, when a measurement is processed with a processing context, where
    explicit references are set. Then, these references are remebemred by the measurement. When changing
    the processing context, the references are implicitly available, still. Clearing them may be interesing
    if the references set are wrong/invalid or if disk space is a concearn.

    :type i_mesu: int, in
    :param i_mesu: The measurement
    :type i_type: int, in
    :param i_type: The type of the reference to be cleard
    """
    return _cuvis_pyil.cuvis_measurement_clear_implicit_reference(i_mesu, i_type)

def cuvis_session_file_copy_handle(i_sess, o_pSess):
    r"""
    Creates an additional session file handle

    Creates an additional handle that points to the same instance as the supplied handle

    :type i_sess: int, in
    :param i_sess: The handle of the session file to copy
    :type o_pSess: int, out
    :param o_pSess: The new handle of the session file.
    :rtype: int
    :return: 'status_ok' if the session file handle could be doubled
    """
    return _cuvis_pyil.cuvis_session_file_copy_handle(i_sess, o_pSess)

def cuvis_session_file_load(i_path, o_pSess):
    r"""
     Load a session_info file from disk.

    The session_info file is a cu3s file and consists of binary cu3 measurement data. Call 'cuvis_session_file_get_mesu'
    to obtain a single measurement frame. SessionFile files can be create with the Cube Exporter
    (see 'cuvis_exporter_create_cube)'
    Notes: Do not read a file currently opened for writing.

    :type i_path: string, in
    :param i_path: the file path of the session_info file
    :type o_pSess: int, out
    :param o_pSess: the handle of the session_info file.
    :rtype: int
    :return: 'status_ok', if the measurement could be loaded.
    """
    return _cuvis_pyil.cuvis_session_file_load(i_path, o_pSess)

def cuvis_session_file_free(o_pSess):
    r"""
     Release a session_info file handle

    Release a measurement by it's handle. The handle will be overwritten to 'CUVIS_HANDLE_NULL'
    This will not affect any measurements on disk.
    Measurements loaded from the session_info file remain valid.

    :type o_pSess: int, in/out
    :param o_pSess: The handle to the measurement to be deleted
    :rtype: int
    :return: 'status_ok' if the session_info file was released.
    """
    return _cuvis_pyil.cuvis_session_file_free(o_pSess)

def cuvis_session_file_get_mesu(i_sess, i_frameNo, i_type, o_pMesu):
    r"""
     Load a measurement from the session_info file

    :type i_sess: int, in
    :param i_sess: the session_info file handle
    :type i_frameNo: int, in
    :param i_frameNo: the frame no. Counting from 0, must be below value of 'cuvis_session_file_get_size' of it's respective ``i_type``
    :type i_type: int, in
    :param i_type: the type of listing (size depends on type)
    :type o_pMesu: int, out
    :param o_pMesu: the handle of the measurement.
    :rtype: int
    :return: 'status_ok', if the measurement could be loaded.
                 'status_no_measurement' if the measurement was dropped.
                 'status_error' if the frame exeeds the number of frames.
    """
    return _cuvis_pyil.cuvis_session_file_get_mesu(i_sess, i_frameNo, i_type, o_pMesu)

def cuvis_session_file_get_reference_mesu(i_sess, i_frameNo, i_type, o_pMesu):
    r"""
     Load a reference measurement from the session_info file

    :type i_sess: int, in
    :param i_sess: the session_info file handle
    :type i_frameNo: int, in
    :param i_frameNo: the reference number. Counting from 0. If ``i_type`` is not set, refers to the index of all references and must be below the value of 'cuvis_session_file_get_size' using type session_item_type_references. If ``i_type`` is set, must be 0.
    :type i_type: int, in
    :param i_type: the type of reference measurement requested
    :type o_pMesu: int, out
    :param o_pMesu: the handle of the measurement.
    :rtype: int
    :return: 'status_ok', if the reference could be loaded.
                 'status_no_measurement' if the reference does not exist.
                 'status_error' if the i_frameNo exeeds the number of references.
    """
    return _cuvis_pyil.cuvis_session_file_get_reference_mesu(i_sess, i_frameNo, i_type, o_pMesu)

def cuvis_session_file_get_size(i_sess, i_type, o_pSize):
    r"""
     Get number of total frames of session_info file

    :type i_sess: int, in
    :param i_sess: the session_info file handle
    :type i_type: int, in
    :param i_type: the type of listing (size depends on type)
    :type o_pSize: int, out
    :param o_pSize: the size is written here.
    :rtype: int
    :return: 'status_ok' if no error occurred.
    """
    return _cuvis_pyil.cuvis_session_file_get_size(i_sess, i_type, o_pSize)

def cuvis_session_file_get_thumbnail(i_sess, o_pThumbnail):
    r"""
     Get the thumbnail image of a session file

    Return the thumbnail of a session file. The image data is valid as long as
    the session file handle is not released.

    see also: 'cuvis_reserved_keys'

    :type i_sess: int, in
    :param i_sess: The session file handle
    :type o_pThumbnail: :py:class:`cuvis_imbuffer_t`, out
    :param o_pThumbnail: The image buffer to be filled
    :rtype: int
    :return: 'status_ok' if the buffer could be filled with the image element.
                 'status_not_available' if the requested data was empty, or the key could not be found
    """
    return _cuvis_pyil.cuvis_session_file_get_thumbnail(i_sess, o_pThumbnail)

def cuvis_session_file_get_fps(i_sess, o_pFps):
    r"""
     get a session_info file's FPS

    The session_info file meta-Information will be available only if the mode 'cuvis_session_file_get_operation_mode' returns "Internal"

    :type i_sess: int, in
    :param i_sess: the session_info file handle
    :type o_pFps: float, out
    :param o_pFps: the frames per second the session_info was recorded with.
    :rtype: int
    :return: status_ok if fps could be retrieved, status_not_available if the session_info file has not FPS property set.
    """
    return _cuvis_pyil.cuvis_session_file_get_fps(i_sess, o_pFps)

def cuvis_session_file_get_hash(i_sess, o_pHash):
    r"""
     get a session_info file's hash

    :type i_sess: int, in
    :param i_sess: the session_info file handle
    :type o_pHash: string, out
    :param o_pHash: the hash of the sessionfile.
    :rtype: int
    :return: status_ok if hash could be retrieved, status_not_available if the sessionfile has no hash property set.
    """
    return _cuvis_pyil.cuvis_session_file_get_hash(i_sess, o_pHash)

def cuvis_session_file_get_operation_mode(i_sess, o_pMode):
    r"""
     returns the operation mode the session_info file was recorded in

    The operation mode gives indication how the session_info file was recorded.

    :type i_sess: int, in
    :param i_sess: the session_info file handle
    :type o_pMode: int, out
    :param o_pMode: the operation mode of the session_info file.
    :rtype: int
    :return: status_ok if no error occurred.
    """
    return _cuvis_pyil.cuvis_session_file_get_operation_mode(i_sess, o_pMode)

def cuvis_acq_cont_get_next_measurement(i_acqCont, o_pMesu, timeout_ms):
    r"""
    Get measurement from internal cache

    This function is only available in operation mode "Internal" or "External". The function obtains the image from the internal
    memory, if available.


    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type o_pMesu: int, out
    :param o_pMesu: the handle of the recorded image will be written to this variable.
    :type timeout_ms: int, in
    :param timeout_ms: the timeout in ms. Give 0 to wait for ever.
    :rtype: int
    :return: status_ok if the measurement was recorded. Returns status_no_measurement if no measurement was made available during the timeout time. If any error occurred status_error is returned.
    """
    return _cuvis_pyil.cuvis_acq_cont_get_next_measurement(i_acqCont, o_pMesu, timeout_ms)

def cuvis_acq_cont_has_next_measurement(i_acqCont, o_pHasNext):
    r"""
     check if any measurements are available in the buffer

    This function is only available in operation mode "Internal" or "External".

    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type o_pHasNext: int, in
    :param o_pHasNext: value of 0 is written, if no measurements are available. value > 0, if a measurement is available.
    :rtype: int
    :return: status_ok if no error occurred. If any error occurred status_error is returned.
    """
    return _cuvis_pyil.cuvis_acq_cont_has_next_measurement(i_acqCont, o_pHasNext)

def cuvis_measurement_save(i_mesu, i_path, args):
    r"""
     Save a measurement to disk

    Saves a single measurement to the disk in cu3 format.
    The file name is given by the measurement's name (see 'cuvis_measurement_set_name)'

    :type i_path: string, in
    :param i_path: The file directory
    :type i_mesu: int, in
    :param i_mesu: The handle of the measurement to be saved
    :type args: :py:class:`cuvis_save_args_t`, in
    :param args: The saving options
    :rtype: int
    :return: 'status_ok', if the measurement was save successfully.
    """
    return _cuvis_pyil.cuvis_measurement_save(i_mesu, i_path, args)

def cuvis_measurement_set_name(i_mesu, i_name):
    r"""
     Set the name of the measurement in memory

    By default, a newly aquired measurement has the name <SESSIONNAME>_<session_no>_<sequence_no> (see 'CUVIS_SESSION_INFO)'.
    This will also be the name of the file while saving it. This can be changed by this function.

    :type i_mesu: int, in
    :param i_mesu: The measurements to be changed
    :type i_name: string, in
    :param i_name: The new measurement's name
    :rtype: int
    :return: 'status_ok', if the measurement's name was set successfully.
    """
    return _cuvis_pyil.cuvis_measurement_set_name(i_mesu, i_name)

def cuvis_measurement_set_comment(i_mesu, i_comment):
    r"""
     Set the comment of the measurement in memory

    :type i_mesu: int, in
    :param i_mesu: The measurements to be changed
    :type i_comment: string, in
    :param i_comment: The new measurement's comment
    :rtype: int
    :return: 'status_ok', if the measurement's name was set successfully.
    """
    return _cuvis_pyil.cuvis_measurement_set_comment(i_mesu, i_comment)

def cuvis_measurement_free(io_pMesu):
    r"""
     Release a measurement handle

    Release a measurement by it's handle. The handle will be overwritten to 'CUVIS_HANDLE_NULL'
    This will not affect any measurements on disk.

    :type io_pMesu: int, in/out
    :param io_pMesu: The handle to the measurement to be deleted
    :rtype: int
    :return: 'status_ok' if the measurement was released.
    """
    return _cuvis_pyil.cuvis_measurement_free(io_pMesu)

def cuvis_measurement_get_metadata(i_mesu, o_pMetaData):
    r"""
     Obtain metadata from measurement

    The meta-data from the measurement contains information about
    the measurement when it was recorded: when and how. Meta-Data
    do not contain the actual recorded data.

    :type i_mesu: int, in
    :param i_mesu: The measurement's handle
    :type o_pMetaData: :py:class:`cuvis_mesu_metadata_t`, out
    :param o_pMetaData: The meta structure to be filled
    :rtype: int
    :return: 'status_ok', if the meta-data could be loaded without errors
    """
    return _cuvis_pyil.cuvis_measurement_get_metadata(i_mesu, o_pMetaData)

def cuvis_measurement_get_data_image(i_mesu, i_key, o_pBuf):
    r"""
     Get image data from measurement

    Return image data from a measurement. The image data is valid as long as
    the measurement handle is not released and the measurement is not
    re-processed.

    This function can only be called, if he data type is 'data_type_image'.
    This can be checked by the function 'cuvis_measurement_get_data_info'.

    see also: 'cuvis_reserved_keys'

    :type i_mesu: int, in
    :param i_mesu: The measurement handle
    :type i_key: string, in
    :param i_key: The data frame identification key (see 'cuvis_measurement_get_data_info' or 'cuvis_reserved_keys)'
    :type o_pBuf: :py:class:`cuvis_imbuffer_t`, out
    :param o_pBuf: The image buffer to be filled
    :rtype: int
    :return: 'status_ok' if the buffer could be filled with the image element.
                 'status_not_available' if the requested data was empty, or the key could not be found
    """
    return _cuvis_pyil.cuvis_measurement_get_data_image(i_mesu, i_key, o_pBuf)

def cuvis_measurement_get_data_string_length(i_mesu, i_key, o_pLength):
    r"""
     Get the length of string data from measurement

    Return the length of a string data from a measurement.

    This function can only be called, if he data type is 'data_type_string'.
    This can be checked by the function 'cuvis_measurement_get_data_info'.

    see also: 'cuvis_reserved_keys'

    :type i_mesu: int, in
    :param i_mesu: The measurement handle
    :type i_key: string, in
    :param i_key: the data frame identification key (see 'cuvis_measurement_get_data_info' or 'cuvis_reserved_keys)'
    :type o_pLength: int, out
    :param o_pLength: The length of the string data
    :rtype: int
    :return: 'status_ok' if the length could be returned
    """
    return _cuvis_pyil.cuvis_measurement_get_data_string_length(i_mesu, i_key, o_pLength)

def cuvis_measurement_get_data_sensor_info(i_mesu, i_key, o_pValue):
    r"""
     Get image info data from measurement

    Return image data from a measurement. Tis

    This function can only be called, if he data type is 'data_type_string'.
    This can be checked by the function 'cuvis_measurement_get_data_info'.

    see also: 'cuvis_reserved_keys'

    :type i_mesu: int, in
    :param i_mesu: The measurement handle
    :type i_key: string, in
    :param i_key: the data frame identification key (see 'cuvis_measurement_get_data_info' or 'cuvis_reserved_keys)'
    :type o_pValue: :py:class:`cuvis_sensor_info_t`, out
    :param o_pValue: The string buffer to be filled. The provided array must have the length of 'CUVIS_MAXBUF'
    :rtype: int
    :return: 'status_ok' if the buffer could be filled with the string.
    """
    return _cuvis_pyil.cuvis_measurement_get_data_sensor_info(i_mesu, i_key, o_pValue)

def cuvis_measurement_get_data_gps(i_mesu, i_key, o_pGps):
    r"""
     Get GPS data from measurement

    Return gps data from a measurement.

    This function can only be called, if he data type is 'data_type_gps'.
    This can be checked by the function 'cuvis_measurement_get_data_info'.

    see also: 'cuvis_reserved_keys'

    :type i_mesu: int, in
    :param i_mesu: The measurement handle
    :type i_key: string, in
    :param i_key: the data frame identification key (see 'cuvis_measurement_get_data_info' or 'cuvis_reserved_keys)'
    :type o_pGps: :py:class:`cuvis_gps_t`, out
    :param o_pGps: The gps buffer to be filled.
    :rtype: int
    :return: 'status_ok' if the buffer could be filled with the gps data set.
    """
    return _cuvis_pyil.cuvis_measurement_get_data_gps(i_mesu, i_key, o_pGps)

def cuvis_measurement_get_data_count(i_mesu, o_pCount):
    r"""
     Retrieve the number of data elements

    :type i_mesu: int, in
    :param i_mesu: The measurement handle
    :type o_pCount: int, out
    :param o_pCount: The number of data elements
    :rtype: int
    :return: 'status_ok' if the data element count could be retrieved
    """
    return _cuvis_pyil.cuvis_measurement_get_data_count(i_mesu, o_pCount)

def cuvis_calib_copy_handle(i_calibration, o_pCalibration):
    r"""
    Creates an additional calibration handle

    Creates an additional handle that points to the same instance as the supplied handle

    :type i_calibration: int, in
    :param i_calibration: The handle of the calibration to copy
    :type o_pCalibration: int, out
    :param o_pCalibration: The new handle of the calibration.
    :rtype: int
    :return: 'status_ok' if the calibration handle could be doubled
    """
    return _cuvis_pyil.cuvis_calib_copy_handle(i_calibration, o_pCalibration)

def cuvis_calib_create_from_path(i_factoryDir, o_pCalibration):
    r"""
     Create a calibration from factory path

    The calibration is created from a factory path, containing the license and calibration
    file "init.daq" as well as further calibration files (e.g. SpRad.cu3).

    The calibration is lazy-loading, i.e. the AcquisitionContext and the
    ProcessingContext will only be initialized, when explicitly called.

    Notes: do not load multiple calibration instances of the same camera

    :type i_factoryDir: string, in
    :param i_factoryDir: The path to the factory directory
    :type o_pCalibration: int, in
    :param o_pCalibration: the handle of the calibration
    :rtype: int
    :return: 'status_ok' if the calibration could be loaded
    """
    return _cuvis_pyil.cuvis_calib_create_from_path(i_factoryDir, o_pCalibration)

def cuvis_calib_create_from_session_file(i_sess, o_pCalibration):
    r"""
     Create a calibration from session file

    Create a calibration from an existion session file.

    The calibration is lazy-loading, i.e. the AcquisitionContext and the
    ProcessingContext will only be initialized, when explicitly called.

    When you create a processing context from the calibration cerated with
    this function, you won't have the references from the session file set.
    Use 'cuvis_proc_cont_create_from_session_file' to load a processing context
    where the referenecs are taken from the session file.

    Notes: do not load multiple calibration instances of the same camera

    :type i_sess: int, in
    :param i_sess: The session file
    :type o_pCalibration: int, in
    :param o_pCalibration: the handle of the calibration
    :rtype: int
    :return: 'status_ok' if the calibration could be loaded
    """
    return _cuvis_pyil.cuvis_calib_create_from_session_file(i_sess, o_pCalibration)

def cuvis_calib_free(io_pCalibration):
    r"""
     Clear a loaded calibration by it's handle

    The internal memory is freed.

    :type io_pCalibration: int, in/out
    :param io_pCalibration: The handle of the calibration. The handle
        number will be invalidated.
    :rtype: int
    :return: 'status_ok' if the calibration could be released
    """
    return _cuvis_pyil.cuvis_calib_free(io_pCalibration)

def cuvis_acq_cont_copy_handle(i_acqCont, o_pAcqCont):
    r"""
     Creates an additional acquisition context handle

    Creates an additional handle that points to the same instance as the supplied handle

    :type i_acqCont: int, in
    :param i_acqCont: The handle of the acquisition context to copy
    :type o_pAcqCont: int, out
    :param o_pAcqCont: The new handle of the acquisition context.
    :rtype: int
    :return: 'status_ok' if the acquisition context handle could be doubled
    """
    return _cuvis_pyil.cuvis_acq_cont_copy_handle(i_acqCont, o_pAcqCont)

def cuvis_acq_cont_create_from_calib(i_calib, o_pAcqCont):
    r"""
     Load a acquisition context from a given calibration

    Load the acquisition context from the calibration. This will load the hardware and initialize it.
    Do not load multiple instances of the came calibration / camera.

    :type i_calib: int, in
    :param i_calib: The calibration instance the processing context will be loaded from
    :type o_pAcqCont: int, out
    :param o_pAcqCont: The handle of the acquisition context.
    :rtype: int
    :return: 'status_ok' if the acquisition context could be loaded
    """
    return _cuvis_pyil.cuvis_acq_cont_create_from_calib(i_calib, o_pAcqCont)

def cuvis_acq_cont_create_from_session_file(i_sess, i_simulate, o_pAcqCont):
    r"""
     Load a acquisition context from a given session_file

    The acquisition context from the embedded acquisition context of the session_info file.

    :type i_sess: int, in
    :param i_sess: The session_file the processing context will be loaded from
    :type i_simulate: int, in
    :param i_simulate: If True, uses the provided session file for simulated data capturing
    :type o_pAcqCont: int, out
    :param o_pAcqCont: The handle of the acquisition context.
    :rtype: int
    :return: 'status_ok' if the acquisition context could be loaded
    """
    return _cuvis_pyil.cuvis_acq_cont_create_from_session_file(i_sess, i_simulate, o_pAcqCont)

def cuvis_acq_cont_get_state(i_acqCont, o_pState):
    r"""
     get the online state of the hardware

    Hardware can be used, when at least it's required components are online.
    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type o_pState: int, out
    :param o_pState: the state will be written here
    :rtype: int
    :return: status_ok, if no internal error occurred.
    """
    return _cuvis_pyil.cuvis_acq_cont_get_state(i_acqCont, o_pState)

def cuvis_acq_cont_ready_get(i_acqCont, o_pIsReady):
    r"""
     get initialization state of the acquisition context

    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type o_pIsReady: int, out
    :param o_pIsReady: whether the acquisition context has completed all initialization tasks
    :rtype: int
    :return: status_ok, if no internal error occurred.
    """
    return _cuvis_pyil.cuvis_acq_cont_ready_get(i_acqCont, o_pIsReady)

def cuvis_acq_cont_get_session_info(i_acqCont, o_pSessionInfo):
    r"""
     get the acquisition session_info

    Get the acquisition session_info settings. Also use this function to get the current sequence number.
    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type o_pSessionInfo: :py:class:`cuvis_session_info_t`, out
    :param o_pSessionInfo: the state will be written here
    :rtype: int
    :return: status_ok, if no internal error occurred.
    """
    return _cuvis_pyil.cuvis_acq_cont_get_session_info(i_acqCont, o_pSessionInfo)

def cuvis_acq_cont_set_session_info(i_acqCont, i_pSessionInfo):
    r"""
     set the acquisition session_info

    Set the acquisition session_info settings.
    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type i_pSessionInfo: :py:class:`cuvis_session_info_t`, out
    :param i_pSessionInfo: the session_info details to be set
    :rtype: int
    :return: status_ok, if no internal error occurred.
    """
    return _cuvis_pyil.cuvis_acq_cont_set_session_info(i_acqCont, i_pSessionInfo)

def cuvis_acq_cont_queue_size_set(i_acqCont, i_size):
    r"""
     set the receive queue buffer size

    Set the amounts of measurements that will be stored internally, ready for retrieval. Default=100.
    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type i_size: int, in
    :param i_size: the new queue size
    :rtype: int
    :return: status_ok if the new queue size could be set.
    """
    return _cuvis_pyil.cuvis_acq_cont_queue_size_set(i_acqCont, i_size)

def cuvis_acq_cont_free(io_pAcqCont):
    r"""
     Clear a loaded acquisition context by it's handle

    The internal memory is freed.

    :type io_pAcqCont: int, in/out
    :param io_pAcqCont: The handle of the processing context. The handle
        number will be invalidated.
    :rtype: int
    :return: 'status_ok' if the acquisition context could be released
    """
    return _cuvis_pyil.cuvis_acq_cont_free(io_pAcqCont)

def cuvis_acq_cont_get_component_info(i_acqCont, i_id, o_pCompInfo):
    r"""
     Get components general info

    Return general component information about a component build into the acquisition hardware. This helps
    identifying the correct component for settings specific component settings (e.g. gain)

    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type i_id: int, in
    :param i_id: the device id (value between 0 and below 'cuvis_acq_cont_get_component_count)'
    :type o_pCompInfo: :py:class:`cuvis_component_info_t`, out
    :param o_pCompInfo: the component info to be filled
    :rtype: int
    :return: cuvis_ok if the info fields could be filled.
    """
    return _cuvis_pyil.cuvis_acq_cont_get_component_info(i_acqCont, i_id, o_pCompInfo)

def cuvis_acq_cont_get_component_count(i_acqCont, o_pCount):
    r"""
     Get the number of components

    The acquisition hardware is build from one or more components. Get the component count.
    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type o_pCount: int, out
    :param o_pCount: the number of components is written here
    :rtype: int
    :return: cuvis_ok if the number of components could be set
    """
    return _cuvis_pyil.cuvis_acq_cont_get_component_count(i_acqCont, o_pCount)

def cuvis_comp_pixel_format_set(i_acqCont, i_id, i_pPixelFormat):
    r"""
     Set components pixelformat

    Set components pixelformat

    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type i_id: int, in
    :param i_id: the device id (value between 0 and below 'cuvis_acq_cont_get_component_count)'
    :type i_pPixelFormat: string, in
    :param i_pPixelFormat: the components pixelformat
    :rtype: int
    :return: cuvis_ok if the pixelformat was set.
    """
    return _cuvis_pyil.cuvis_comp_pixel_format_set(i_acqCont, i_id, i_pPixelFormat)

def cuvis_comp_pixel_format_set_async(i_acqCont, o_pAsyncResult, i_id, i_pPixelFormat):
    r"""
     Set components pixelformat

    Set components pixelformat (asynchronous)

    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type o_pAsyncResult: int, out
    :param o_pAsyncResult: The Async object that will contain the result of the operation
    :type i_id: int, in
    :param i_id: the device id (value between 0 and below 'cuvis_acq_cont_get_component_count)'
    :type i_pPixelFormat: string, in
    :param i_pPixelFormat: the components pixelformat
    :rtype: int
    :return: cuvis_ok if the pixelformat was set.
    """
    return _cuvis_pyil.cuvis_comp_pixel_format_set_async(i_acqCont, o_pAsyncResult, i_id, i_pPixelFormat)

def cuvis_comp_available_pixel_format_count_get(i_acqCont, i_id, o_pCount):
    r"""
     Get components actual pixelformat

    Return the amount of components available pixelformats

    :type i_acqCont: int, in
    :param i_acqCont: the acquisition context
    :type i_id: int, in
    :param i_id: the device id (value between 0 and below 'cuvis_acq_cont_get_component_count)'
    :type o_pCount: int, out
    :param o_pCount: amount of available pixel formats
    :rtype: int
    :return: cuvis_ok if the amount was returned.
    """
    return _cuvis_pyil.cuvis_comp_available_pixel_format_count_get(i_acqCont, i_id, o_pCount)

def cuvis_proc_cont_copy_handle(i_procCont, o_pProcCont):
    r"""
    Creates an additional processing context handle

    Creates an additional handle that points to the same instance as the supplied handle

    :type i_procCont: int, in
    :param i_procCont: The handle of the processing context to copy
    :type o_pProcCont: int, out
    :param o_pProcCont: The new handle of the processing context.
    :rtype: int
    :return: 'status_ok' if the processing context handle could be doubled
    """
    return _cuvis_pyil.cuvis_proc_cont_copy_handle(i_procCont, o_pProcCont)

def cuvis_proc_cont_create_from_calib(i_calib, o_pProcCont):
    r"""
     Load a processing context from a given calibration

    Load the processing context from the calibration.

    :type i_calib: int, in
    :param i_calib: The calibration instance the processing context will be loaded from
    :type o_pProcCont: int, out
    :param o_pProcCont: The handle of the processing context.
    :rtype: int
    :return: 'status_ok' if the processing context could be loaded
    """
    return _cuvis_pyil.cuvis_proc_cont_create_from_calib(i_calib, o_pProcCont)

def cuvis_proc_cont_create_from_mesu(i_mesu, o_pProcCont):
    r"""
     Load a processing context from a given measurement

    The processing context is loaded from the CALIBRATION directory, relative to
    the measurement given ( ../Calibration/* ) . This directory is present in the normal camera operation
    / recording, but the reference might get lost, if you manually move the
    measurements. In that case, this function will fail.

    :type i_mesu: int, in
    :param i_mesu: The measurement with a valid reference to the processing context
    :type o_pProcCont: int, out
    :param o_pProcCont: The handle of the processing context.
    :rtype: int
    :return: 'status_ok' if the processing context could be loaded
    """
    return _cuvis_pyil.cuvis_proc_cont_create_from_mesu(i_mesu, o_pProcCont)

def cuvis_proc_cont_create_from_session_file(i_sess, o_pProcCont):
    r"""
     Load a processing context from a given session_file

    The processing context from the embedded processing context of the session_info file.

    :type i_sess: int, in
    :param i_sess: The session_file with a valid reference to the processing context
    :type o_pProcCont: int, out
    :param o_pProcCont: The handle of the processing context.
    :rtype: int
    :return: 'status_ok' if the processing context could be loaded
    """
    return _cuvis_pyil.cuvis_proc_cont_create_from_session_file(i_sess, o_pProcCont)

def cuvis_proc_cont_get_reference(i_procCont, o_pMesu, i_type):
    r"""
     get a specific reference from the processing context

    The processing context can hold explicit references (e.g. a dark),
    see 'cuvis_proc_cont_set_reference'. These reference can be obtained
    by this functions

    Notes: Implicit references given by a measurement are not returned. If they are available can only be
    checked indirectly by the 'cuvis_proc_cont_is_capable' or by checking for the measurement's data keys
    'CUVIS_MESU_DARKREF_KEY', 'CUVIS_MESU_WHITEREF_KEY' and 'CUVIS_MESU_WHITEDARKREF_KEY'

    :type i_procCont: int, in
    :param i_procCont: The handle of the processing context
    :type o_pMesu: int, out
    :param o_pMesu: The reference measurement's handle
    :type i_type: int, in
    :param i_type: The type of the measurement to be retrieved.
    :rtype: int
    :return: 'status_ok' if the reference measurement is available and could be loaded
    """
    return _cuvis_pyil.cuvis_proc_cont_get_reference(i_procCont, o_pMesu, i_type)

def cuvis_proc_cont_set_reference(i_procCont, i_mesu, i_type):
    r"""
     Set a reference measurement

    The available processing modes ('cuvis_processing_mode_t)' require certain references to be set.
    When a measurement is recorded with references in place, these references are available per measurement implicitly.
    However, if you want to process measurements with different references, or if the measurement lacks a reference,
    they can be set with this function.

    .. code-block:: c++

        CUVIS_MESU mesu;
        cuvis_measurement_load("mesu.cu3",&mesu);
        //contains implicit Reference_Dark

        CUVIS_PROC_CONT pc;
        cuvis_proc_cont_create_from_mesu(mesu,&pc); //will implicitly load Reference_Dark

        CUVIS_MESU white;
        cuvis_measurement_load("white.cu3",&white);

        cuvis_proc_cont_set_reference(pc, white, Reference_White);

        //Cube_Reflectance requires Reference_Dark and Reference_White
        cuvis_proc_cont_apply(pc,mesu,{Cube_Reflectance});
    Notes: The reference explicitly set by this function has priority over the implicit measurement.

    :type i_procCont: int, in
    :param i_procCont: The handle of the processing context
    :type i_mesu: int, in
    :param i_mesu: The measurement to be used as explicit reference
    :type i_type: int, in
    :param i_type: The type of the reference
    """
    return _cuvis_pyil.cuvis_proc_cont_set_reference(i_procCont, i_mesu, i_type)

def cuvis_proc_cont_clear_reference(i_procCont, i_type):
    r"""
     Clears a reference measurement

    Clears a reference explicitly set by 'cuvis_proc_cont_set_reference'

    :type i_procCont: int, in
    :param i_procCont: The handle of the processing context
    :type i_type: int, in
    :param i_type: The type of the reference
    """
    return _cuvis_pyil.cuvis_proc_cont_clear_reference(i_procCont, i_type)

def cuvis_proc_cont_calc_distance(i_procCont, i_distanceMM):
    r"""
     Set the operating distance by value

    Some cameras require a distance reference (calibration). This is usually obtained from a measurement at
    that distance. However, if the distance is known, it can be set manually.

    Notes: Some OEM-Cameras or older models do not support this.
    Internally, a measurement is created. It can be obtained by 'cuvis_proc_cont_get_reference'.

    :type i_procCont: int, in
    :param i_procCont: The handle of the processing context
    :type i_distanceMM: float, in
    :param i_distanceMM: The distance in millimeters.
    :rtype: int
    :return: 'status_ok' if the distance could be set
    """
    return _cuvis_pyil.cuvis_proc_cont_calc_distance(i_procCont, i_distanceMM)

def cuvis_proc_cont_has_reference(i_procCont, i_type, o_pHasReference):
    r"""
     Check if an explicit reference was set

    :type i_procCont: int, in
    :param i_procCont: The handle of the processing context
    :type i_type: int, in
    :param i_type: The reference type
    :type o_pHasReference: int, out
    :param o_pHasReference: true, if reference is explicitly set. false, otherwise
    :rtype: int
    :return: 'status_ok' if no error occurred.
    """
    return _cuvis_pyil.cuvis_proc_cont_has_reference(i_procCont, i_type, o_pHasReference)

def cuvis_proc_cont_is_capable(i_procCont, i_mesu, i_args, o_pIsCapable):
    r"""
     Check if a processing mode is possible for a measurement

    Depending on the measurement, it's intrinsic references, the processing
    context's explicit references and the internal camera calibration itself
    the availability of a mode varies.

    Use this function, to check whether a specific mode is explicitly possible for
    a measurement.

    :type i_procCont: int, in
    :param i_procCont: The handle of the processing context
    :type i_mesu: int, in
    :param i_mesu: The measurement to be checked
    :type i_args: :py:class:`cuvis_proc_args_t`, in
    :param i_args: The processing options to be checked
    :type o_pIsCapable: int, out
    :param o_pIsCapable: true, if mode is possible. false, otherwise
    :rtype: int
    :return: 'status_ok' if no error occurred.
    """
    return _cuvis_pyil.cuvis_proc_cont_is_capable(i_procCont, i_mesu, i_args, o_pIsCapable)

def cuvis_proc_cont_apply(i_procCont, i_mesu):
    r"""
     (Re-)Process a measurement

    Process a measurement according to the current settings of the processing context.
    Those get set via 'cuvis_proc_cont_set_args'
    The availability of the modes depends, use 'cuvis_proc_cont_is_capable' to check
    if the processing is possible.

    In short:
    'Cube_Raw' does not require references ('Reference_Distance' is optional)

    'Cube_DarkSubtract' requires 'Reference_Dark' (and 'Reference_Distance' is optional)

    'Cube_Reflectance' requires 'Reference_Dark' and 'Reference_White' reference (and 'Reference_Distance'
    is optional), the 'Reference_WhiteDark' is strongly recommended if using different integration times.

    'Cube_SpectralRadiance' depends on the camera model: All cameras require 'Reference_SpRad'. The Fireflye requires: 'Reference_Dark', 'Reference_White', the Ultris series requires only 'Reference_Dark'.

    :type i_procCont: int, in
    :param i_procCont: The handle of the processing context
    :type i_mesu: int, in
    :param i_mesu: The measurement to be processed
    :rtype: int
    :return: 'status_ok' if measurement was processed.
    """
    return _cuvis_pyil.cuvis_proc_cont_apply(i_procCont, i_mesu)

def cuvis_proc_cont_set_args(i_procCont, i_args):
    r"""
     Sets the processing arguments for a processing contex

    For processing a measurement see 'cuvis_proc_cont_apply'

    :type i_procCont: int, in
    :param i_procCont: The handle of the processing context
    :type i_args: :py:class:`cuvis_proc_args_t`, in
    :param i_args: The processing arguments that will be set
    :rtype: int
    :return: 'status_ok' if measurement was processed.
    """
    return _cuvis_pyil.cuvis_proc_cont_set_args(i_procCont, i_args)

def cuvis_proc_cont_free(io_pProcCont):
    r"""
     Clear a loaded processing context by it's handle

    The internal memory is freed.
    :type io_pProcCont: int, in/out
    :param io_pProcCont: The handle of the processing context. The handle
        number will be invalidated.
    :rtype: int
    :return: 'status_ok' if processing context could be freed.
    """
    return _cuvis_pyil.cuvis_proc_cont_free(io_pProcCont)

def cuvis_exporter_create_cube(o_pExporter, generalSettings, formatSettings):
    r"""
    Create a cube exporter

    :type o_pExporter: int, out
    :param o_pExporter: The handle of the exporter
    :type generalSettings: :py:class:`cuvis_export_general_settings_t`, in
    :param generalSettings: General export settings
    :type formatSettings: :py:class:`cuvis_save_args_t`, in
    :param formatSettings: Additional Cube export settings
    :rtype: int
    :return: 'status_ok' if the exporter was created successfully
    """
    return _cuvis_pyil.cuvis_exporter_create_cube(o_pExporter, generalSettings, formatSettings)

def cuvis_exporter_create_tiff(o_pExporter, generalSettings, formatSettings):
    r"""
     Create a tiff exporter

    :type o_pExporter: int, out
    :param o_pExporter: The handle of the exporter
    :type generalSettings: :py:class:`cuvis_export_general_settings_t`, in
    :param generalSettings: General export settings
    :type formatSettings: :py:class:`cuvis_export_tiff_settings_t`, in
    :param formatSettings: Additional TIF export settings
    :rtype: int
    :return: 'status_ok' if the exporter was created successfully
    """
    return _cuvis_pyil.cuvis_exporter_create_tiff(o_pExporter, generalSettings, formatSettings)

def cuvis_exporter_create_envi(o_pExporter, generalSettings):
    r"""
     Create a ENVI exporter

    :type o_pExporter: int, out
    :param o_pExporter: The handle of the exporter
    :type generalSettings: :py:class:`cuvis_export_general_settings_t`, in
    :param generalSettings: General export settings
    :rtype: int
    :return: 'status_ok' if the exporter was created successfully
    """
    return _cuvis_pyil.cuvis_exporter_create_envi(o_pExporter, generalSettings)

def cuvis_exporter_create_view(o_pExporter, generalSettings, formatSettings):
    r"""
     Create a VIEW exporter

    Not to be confused with the VIEWER. The view exporter saves views to disk.

    :type o_pExporter: int, out
    :param o_pExporter: The handle of the exporter
    :type generalSettings: :py:class:`cuvis_export_general_settings_t`, in
    :param generalSettings: General export settings
    :type formatSettings: :py:class:`cuvis_export_view_settings_t`, in
    :param formatSettings: Additional view export settings
    :rtype: int
    :return: 'status_ok' if the exporter was created successfully
    """
    return _cuvis_pyil.cuvis_exporter_create_view(o_pExporter, generalSettings, formatSettings)

def cuvis_exporter_apply(i_exporter, i_mesu):
    r"""
     Export a measurement with an exporter

    :type i_exporter: int, in
    :param i_exporter: The exporter
    :type i_mesu: int, in
    :param i_mesu: the measurement
    :rtype: int
    :return: 'status_ok' if the measurement was exported successfully. 'status_not_stored' if the measurement could not be stored.
    """
    return _cuvis_pyil.cuvis_exporter_apply(i_exporter, i_mesu)

def cuvis_exporter_flush(i_exporter):
    r"""
     Flush an exporter

    :type i_exporter: int, in
    :param i_exporter: The exporter to flush
    :rtype: int
    :return: 'status_ok' if the exporter was flushed successfully.
    """
    return _cuvis_pyil.cuvis_exporter_flush(i_exporter)

def cuvis_exporter_get_queue_used(i_exporter, o_pQueueUsed):
    return _cuvis_pyil.cuvis_exporter_get_queue_used(i_exporter, o_pQueueUsed)

def cuvis_exporter_free(io_pExporter):
    r"""
     Release an exporter

    :type io_pExporter: int, in/out
    :param io_pExporter: Exporter to be released. If successfully, handle will be invalidated
    :rtype: int
    :return: 'status_ok' if the exporter was cleared.
    """
    return _cuvis_pyil.cuvis_exporter_free(io_pExporter)

def cuvis_viewer_copy_handle(i_viewer, o_pViewer):
    r"""
    Creates an additional viewer handle

    Creates an additional handle that points to the same instance as the supplied handle

    :type i_viewer: int, in
    :param i_viewer: The handle of the viewer to copy
    :type o_pViewer: int, out
    :param o_pViewer: The new handle of the viewer.
    :rtype: int
    :return: 'status_ok' if the viewer handle could be doubled
    """
    return _cuvis_pyil.cuvis_viewer_copy_handle(i_viewer, o_pViewer)

def cuvis_viewer_create(o_pViewer, viewerSettings):
    r"""
     Create a viewer

    Not to be confused with the view exporter. The viewer returns the view in the memory

    :type o_pViewer: int, out
    :param o_pViewer: The handle of the viewer
    :type viewerSettings: :py:class:`cuvis_viewer_settings_t`, in
    :param viewerSettings: view settings
    :rtype: int
    :return: 'status_ok' if the exporter was created successfully
    """
    return _cuvis_pyil.cuvis_viewer_create(o_pViewer, viewerSettings)

def cuvis_viewer_apply(i_viewer, i_mesu, o_pView):
    r"""
     Generate a view from a measurement

    The view is processed from a measurement by the viewer. The resulting view handle can be accessed by the
    'cuvis_view_get_data_count' to get number of elements,  'cuvis_view_get_data' to get a single date element
    and 'cuvis_view_free' to release the view (this must always be called)

    :type i_viewer: int, in
    :param i_viewer: The viewer
    :type i_mesu: int, in
    :param i_mesu: the measurement
    :type o_pView: int, out
    :param o_pView: the resulting view handle.
    :rtype: int
    :return: 'status_ok' if the measurement was processed successfully.
    """
    return _cuvis_pyil.cuvis_viewer_apply(i_viewer, i_mesu, o_pView)

def cuvis_viewer_free(io_pViewer):
    r"""
     Release a viewer

    :type io_pViewer: int, in/out
    :param io_pViewer: Viewer to be released. If successfully, handle will be invalidated
    :rtype: int
    :return: 'status_ok' if the exporter was cleared.
    """
    return _cuvis_pyil.cuvis_viewer_free(io_pViewer)

def cuvis_view_get_data_count(i_view, o_pCount):
    r"""
     retrieves the number of view data elements
    :type i_view: int, in
    :param i_view: the view handle
    :type o_pCount: int, out
    :param o_pCount: The number of elements
    """
    return _cuvis_pyil.cuvis_view_get_data_count(i_view, o_pCount)

def cuvis_view_get_data(i_view, i_index, o_pData):
    r"""
     Obtain data from view

    The data contains the actual view

    :type i_view: int, in
    :param i_view: The view handle
    :type i_index: int, in
    :param i_index: The element number
    :type o_pData: :py:class:`cuvis_view_data_t`, out
    :param o_pData: The actual view data
    :rtype: int
    :return: 'status_ok', if the meta-data could be loaded without errors
    """
    return _cuvis_pyil.cuvis_view_get_data(i_view, i_index, o_pData)

def cuvis_view_free(io_pView):
    r"""
     Release a view

    :type io_pView: int, in/out
    :param io_pView: View to be released. If successfully, handle will be invalidated
    :rtype: int
    :return: 'status_ok' if the exporter was cleared.
    """
    return _cuvis_pyil.cuvis_view_free(io_pView)

def cuvis_calib_get_capabilities(i_calibration, i_mode, o_pCapabilities):
    r"""
    Get the capabilites of a given mode

    Use this function to evaluate which functions are available for a camera calibration.
    :type i_calibration: int, in
    :param i_calibration: The calibration
    :type i_mode: int, in
    :param i_mode: The mode to check the capabiliets
    :type o_pCapabilities: int, out
    :param o_pCapabilities: write the capabilites here. See CUVIS_MODE_CAPABILITIES_x flags.
    """
    return _cuvis_pyil.cuvis_calib_get_capabilities(i_calibration, i_mode, o_pCapabilities)

def cuvis_measurement_get_capabilities(i_mesu, o_pCapabilities):
    r"""
     Get the capabilites of the measurement which were present in the calibration during capture.
       This doesn't indicate which capabilities are currently available for the measurement.
       See 'cuvis_proc_cont_is_capable'

    Use this function to evaluate which functions are available for a given measurement.
    :type i_mesu: int, in
    :param i_mesu: The measurement
    :type o_pCapabilities: int, out
    :param o_pCapabilities: write the capabilites here. See CUVIS_MODE_CAPABILITIES_x flags.
    """
    return _cuvis_pyil.cuvis_measurement_get_capabilities(i_mesu, o_pCapabilities)

def cuvis_measurement_get_calib_id(i_mesu, o_pCalibId):
    r"""
     Get the unique calibration id of a measurement

    The id unique to a calibration is stored into everything created from it, as such a measurement also contains this id.

    :type i_mesu: int, in
    :param i_mesu: the measurement
    :type o_pCalibId: string, out
    :param o_pCalibId: the output string
    """
    return _cuvis_pyil.cuvis_measurement_get_calib_id(i_mesu, o_pCalibId)

def cuvis_calib_get_id(i_calib, o_pCalibId):
    r"""
     Get the unique id of a calibration

    :type i_calib: int, in
    :param i_calib: the calibration
    :type o_pCalibId: string, out
    :param o_pCalibId: the unique id output string
    """
    return _cuvis_pyil.cuvis_calib_get_id(i_calib, o_pCalibId)

def cuvis_calib_get_info(i_calib, o_pCalibInfo):
    r"""
     Get info of a calibration

    :type i_calib: int, in
    :param i_calib: the calibration
    :type o_pCalibInfo: :py:class:`cuvis_calibration_info_t`, out
    :param o_pCalibInfo: the info data struct
    """
    return _cuvis_pyil.cuvis_calib_get_info(i_calib, o_pCalibInfo)

def cuvis_calib_get_component_info(i_calib, i_id, o_pCompInfo):
    r"""
     Get components general info

    Return general component information about a component build into the acquisition hardware the calibration is made for.
    This helps identifying the correct component for settings specific component settings (e.g. gain)

    :type i_calib: int, in
    :param i_calib: the calibration
    :type i_id: int, in
    :param i_id: the device id (value between 0 and below 'cuvis_acq_cont_get_component_count)'
    :type o_pCompInfo: :py:class:`cuvis_component_info_t`, out
    :param o_pCompInfo: the component info to be filled
    :rtype: int
    :return: cuvis_ok if the info fields could be filled.
    """
    return _cuvis_pyil.cuvis_calib_get_component_info(i_calib, i_id, o_pCompInfo)

def cuvis_calib_get_component_count(i_calib, o_pCount):
    r"""
     Get the number of components

    The acquisition hardware is build from one or more components. Get the component count.
    :type i_calib: int, in
    :param i_calib: the calibration
    :type o_pCount: int, out
    :param o_pCount: the number of components is written here
    :rtype: int
    :return: cuvis_ok if the number of components could be set
    """
    return _cuvis_pyil.cuvis_calib_get_component_count(i_calib, o_pCount)

def cuvis_proc_cont_get_calib_id(i_procCont, o_pCalibId):
    r"""
     Get the unique calibration id of a processing context

    The id unique to a calibration is stored into everything created from it, as such a processing context also contains this id.

    :type i_procCont: int, in
    :param i_procCont: the processing context
    :type o_pCalibId: string, out
    :param o_pCalibId: the output string
    """
    return _cuvis_pyil.cuvis_proc_cont_get_calib_id(i_procCont, o_pCalibId)

def cuvis_worker_create(o_pWorker, worker_settings):
    r"""
     Create a Worker

    The encapsulates the functions of the Acquisiton Context, Processing Context, Exporter, and Viewer into a single
    container and manages the communications between these.
    It also enables multi-threaded operation
    Notes: The set functions need to be called in order for the worker to be enabled.

    :type o_pWorker: int, out
    :param o_pWorker: The worker handle to be created
    :type worker_settings: :py:class:`cuvis_worker_settings_t`, in
    :param worker_settings: The worker configuration
    """
    return _cuvis_pyil.cuvis_worker_create(o_pWorker, worker_settings)

def cuvis_worker_free(io_pWorker):
    r""" release a worker"""
    return _cuvis_pyil.cuvis_worker_free(io_pWorker)

def cuvis_worker_set_acq_cont(i_worker, i_acq_cont):
    r""" set the acquistion context for the worker. Give CUVIS_HANDLE_NULL to clear"""
    return _cuvis_pyil.cuvis_worker_set_acq_cont(i_worker, i_acq_cont)

def cuvis_worker_set_proc_cont(i_worker, i_proc_cont):
    r""" set the processing context for the worker. Give CUVIS_HANDLE_NULL to clear"""
    return _cuvis_pyil.cuvis_worker_set_proc_cont(i_worker, i_proc_cont)

def cuvis_worker_set_exporter(i_worker, i_exporter):
    r""" set the exporter for the worker. Give CUVIS_HANDLE_NULL to clear"""
    return _cuvis_pyil.cuvis_worker_set_exporter(i_worker, i_exporter)

def cuvis_worker_set_viewer(i_worker, i_viewer):
    r""" set the viewer for the worker. Give CUVIS_HANDLE_NULL to clear"""
    return _cuvis_pyil.cuvis_worker_set_viewer(i_worker, i_viewer)

def cuvis_worker_query_session_progress(i_worker, o_frames_read):
    r""" Get the current percentage of frames done of the current session. -1.0 if no session file is currently being processed."""
    return _cuvis_pyil.cuvis_worker_query_session_progress(i_worker, o_frames_read)

def cuvis_worker_ingest_session_file(i_worker, i_session_file, i_frame_selection):
    r"""
     set a session file for the worker to process (read access only). Give CUVIS_HANDLE_NULL to clear.
    Set parameter SkipDroppedFrames to 1 to skip any dropped frames contained in the session - 0 will insert empty frames.
    """
    return _cuvis_pyil.cuvis_worker_ingest_session_file(i_worker, i_session_file, i_frame_selection)

def cuvis_worker_ingest_mesu(i_worker, i_mesu):
    r""" Push a mesurement into the worker to process. Worker must have neither a session file nor an acquisition context."""
    return _cuvis_pyil.cuvis_worker_ingest_mesu(i_worker, i_mesu)

def cuvis_worker_get_next_result(i_worker, o_pMesu, o_pView, i_Timeout_ms):
    r"""
     Get the next result in order

    The measurement will be readyly recorded, processed (if set), stored (if set) and have a view (if set).

    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pMesu: int, out
    :param o_pMesu: The recorded measurement or NULL if recording failed
    :type o_pView: int, out
    :param o_pView: The view, if calculated sucessfully, else NULL
    :type i_Timeout_ms: int, in
    :param i_Timeout_ms: The number of milliseconds to wait for a result. -1 to wait indefinitely
    :rtype: int
    :return: 'status_ok' or on error: 'status_error', 'status_not_processed', 'status_not_stored', or 'status_no_view', or 'status_not_available'
    """
    return _cuvis_pyil.cuvis_worker_get_next_result(i_worker, o_pMesu, o_pView, i_Timeout_ms)

def cuvis_worker_has_next_result(i_worker, o_pHasNext):
    r"""
     Check, if a new worker result is available
    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pHasNext: int, out
    :param o_pHasNext: 1 if a result is available now, else 0
    """
    return _cuvis_pyil.cuvis_worker_has_next_result(i_worker, o_pHasNext)

def cuvis_worker_get_input_queue_limit(i_worker, o_pInputQueueLimit):
    r"""
     Query the maximum queue size of the input queue
    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pInputQueueLimit: int, out
    :param o_pInputQueueLimit: The maximum size of the input queue
    """
    return _cuvis_pyil.cuvis_worker_get_input_queue_limit(i_worker, o_pInputQueueLimit)

def cuvis_worker_get_mandatory_queue_limit(i_worker, o_pMandatoryLimit):
    r"""
     Query the maximum queue size of the mandatory queue
    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pMandatoryLimit: int, out
    :param o_pMandatoryLimit: The maximum size of the mandatory queue. This is also the maximum number of measurements processed simultaneously
    """
    return _cuvis_pyil.cuvis_worker_get_mandatory_queue_limit(i_worker, o_pMandatoryLimit)

def cuvis_worker_get_supplementary_queue_limit(i_worker, o_pSupplementaryLimit):
    r"""
     Query the maximum queue size of the supplementary queue
    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pSupplementaryLimit: int, out
    :param o_pSupplementaryLimit: The maximum size of the supplementary queue. This is also the maximum number of measurements processed simultaneously
    """
    return _cuvis_pyil.cuvis_worker_get_supplementary_queue_limit(i_worker, o_pSupplementaryLimit)

def cuvis_worker_get_output_queue_limit(i_worker, o_pOutputQueueLimit):
    r"""
     Query the maximum queue size of the output queue
    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pOutputQueueLimit: int, out
    :param o_pOutputQueueLimit: The maximum size of the output queue
    """
    return _cuvis_pyil.cuvis_worker_get_output_queue_limit(i_worker, o_pOutputQueueLimit)

def cuvis_worker_get_queue_used(i_worker, o_pQueueUsed):
    r"""
     Query the number of items currently in the result queue.
    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pQueueUsed: int, out
    :param o_pQueueUsed: The number of results currently in the output queue
    """
    return _cuvis_pyil.cuvis_worker_get_queue_used(i_worker, o_pQueueUsed)

def cuvis_worker_get_can_drop_results(i_worker, o_pCanDrop):
    r"""
     Query current drop behavior
    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pCanDrop: int, out
    :param o_pCanDrop: If 1, the worker is allowed to drop results when the output queue is full
    """
    return _cuvis_pyil.cuvis_worker_get_can_drop_results(i_worker, o_pCanDrop)

def cuvis_worker_get_can_skip_measurements(i_worker, o_pCanSkip):
    r"""
     Query current skip behavior
    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pCanSkip: int, out
    :param o_pCanSkip: If 1, the worker is allowed to entirely skip processing measurements, if the mandatory queue is full
    """
    return _cuvis_pyil.cuvis_worker_get_can_skip_measurements(i_worker, o_pCanSkip)

def cuvis_worker_get_can_skip_supplementary(i_worker, o_pCanSkip):
    r"""
     Query current skip behavior
    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pCanSkip: int, out
    :param o_pCanSkip: If 1, the worker is allowed to skip supplementary processing of measurements, if the supplementary queue is full
    """
    return _cuvis_pyil.cuvis_worker_get_can_skip_supplementary(i_worker, o_pCanSkip)

def cuvis_worker_is_processing_mandatory(i_worker, o_pProcessingMandatory):
    r"""
     Query wether the processing step is currently mandatory
    The result is only valid, if a processing context is assigned to the worker.
    If no processing context is assigned, will always return 0 (false)
    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pProcessingMandatory: int, out
    :param o_pProcessingMandatory: If 1, the appying the processing context to the measurement is part of the mandatory processing steps
    """
    return _cuvis_pyil.cuvis_worker_is_processing_mandatory(i_worker, o_pProcessingMandatory)

def cuvis_worker_start(i_worker):
    r""" Start the worker"""
    return _cuvis_pyil.cuvis_worker_start(i_worker)

def cuvis_worker_stop(i_worker):
    r""" Pause the worker"""
    return _cuvis_pyil.cuvis_worker_stop(i_worker)

def cuvis_worker_drop_all_queued(i_worker):
    r""" Command the worker to discard all measurements it is currently processing and empty the result queue."""
    return _cuvis_pyil.cuvis_worker_drop_all_queued(i_worker)

def cuvis_worker_is_processing(i_worker, o_pIsProcessing):
    r"""
     Query wether the worker is currently allowed to process measurements - wether it is running.
    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pIsProcessing: int, out
    :param o_pIsProcessing: If 1, the worker is allowed process measurements. This does not mean, that it is currently working on a measurement - see cuvis_worker_get_threads_busy
    """
    return _cuvis_pyil.cuvis_worker_is_processing(i_worker, o_pIsProcessing)

def cuvis_worker_get_threads_busy(i_worker, o_pThreadsBusy):
    r"""
     Query how many measurements the worker is processing right now
    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pThreadsBusy: int, out
    :param o_pThreadsBusy: The number of measurements currently being processed
    """
    return _cuvis_pyil.cuvis_worker_get_threads_busy(i_worker, o_pThreadsBusy)

def cuvis_worker_get_state(i_worker, o_pWorkerState):
    r"""
     Query multiple attributes of the worker at once, see cuvis_worker_state_t
    :type i_worker: int, in
    :param i_worker: The worker handle
    :type o_pWorkerState: :py:class:`cuvis_worker_state_t`, out
    :param o_pWorkerState: Collection of worker stats
    """
    return _cuvis_pyil.cuvis_worker_get_state(i_worker, o_pWorkerState)

def cuvis_set_special(arg1):
    
    return _cuvis_pyil.cuvis_set_special(arg1)

def cuvis_imbuffer_allocate():
    return _cuvis_pyil.cuvis_imbuffer_allocate()

def cuvis_imbuffer_free(ptr):
    return _cuvis_pyil.cuvis_imbuffer_free(ptr)

def cuvis_gps_allocate():
    return _cuvis_pyil.cuvis_gps_allocate()

def cuvis_gps_free(ptr):
    return _cuvis_pyil.cuvis_gps_free(ptr)

def cuvis_sensor_info_allocate():
    return _cuvis_pyil.cuvis_sensor_info_allocate()

def cuvis_sensor_info_free(ptr):
    return _cuvis_pyil.cuvis_sensor_info_free(ptr)

def cuvis_session_info_allocate():
    return _cuvis_pyil.cuvis_session_info_allocate()

def cuvis_session_info_free(ptr):
    return _cuvis_pyil.cuvis_session_info_free(ptr)

def cuvis_mesu_metadata_allocate():
    return _cuvis_pyil.cuvis_mesu_metadata_allocate()

def cuvis_mesu_metadata_free(ptr):
    return _cuvis_pyil.cuvis_mesu_metadata_free(ptr)

def cuvis_save_args_allocate():
    return _cuvis_pyil.cuvis_save_args_allocate()

def cuvis_save_args_free(ptr):
    return _cuvis_pyil.cuvis_save_args_free(ptr)

def cuvis_proc_args_allocate():
    return _cuvis_pyil.cuvis_proc_args_allocate()

def cuvis_proc_args_free(ptr):
    return _cuvis_pyil.cuvis_proc_args_free(ptr)

def cuvis_export_general_settings_allocate():
    return _cuvis_pyil.cuvis_export_general_settings_allocate()

def cuvis_export_general_settings_free(ptr):
    return _cuvis_pyil.cuvis_export_general_settings_free(ptr)

def cuvis_export_cube_settings_allocate():
    return _cuvis_pyil.cuvis_export_cube_settings_allocate()

def cuvis_export_cube_settings_free(ptr):
    return _cuvis_pyil.cuvis_export_cube_settings_free(ptr)

def cuvis_export_view_settings_allocate():
    return _cuvis_pyil.cuvis_export_view_settings_allocate()

def cuvis_export_view_settings_free(ptr):
    return _cuvis_pyil.cuvis_export_view_settings_free(ptr)

def cuvis_export_tiff_settings_allocate():
    return _cuvis_pyil.cuvis_export_tiff_settings_allocate()

def cuvis_export_tiff_settings_free(ptr):
    return _cuvis_pyil.cuvis_export_tiff_settings_free(ptr)

def cuvis_viewer_settings_allocate():
    return _cuvis_pyil.cuvis_viewer_settings_allocate()

def cuvis_viewer_settings_free(ptr):
    return _cuvis_pyil.cuvis_viewer_settings_free(ptr)

def cuvis_view_data_allocate():
    return _cuvis_pyil.cuvis_view_data_allocate()

def cuvis_view_data_free(ptr):
    return _cuvis_pyil.cuvis_view_data_free(ptr)

def cuvis_component_info_allocate():
    return _cuvis_pyil.cuvis_component_info_allocate()

def cuvis_component_info_free(ptr):
    return _cuvis_pyil.cuvis_component_info_free(ptr)

def cuvis_worker_settings_allocate():
    return _cuvis_pyil.cuvis_worker_settings_allocate()

def cuvis_worker_settings_free(ptr):
    return _cuvis_pyil.cuvis_worker_settings_free(ptr)

def cuvis_worker_state_allocate():
    return _cuvis_pyil.cuvis_worker_state_allocate()

def cuvis_worker_state_free(ptr):
    return _cuvis_pyil.cuvis_worker_state_free(ptr)

def cuvis_calibration_info_allocate():
    return _cuvis_pyil.cuvis_calibration_info_allocate()

def cuvis_calibration_info_free(ptr):
    return _cuvis_pyil.cuvis_calibration_info_free(ptr)

def cuvis_acq_cont_fps_get(i_acqCont, o_pvalue):
    return _cuvis_pyil.cuvis_acq_cont_fps_get(i_acqCont, o_pvalue)

def cuvis_acq_cont_fps_set(i_acqCont, value):
    return _cuvis_pyil.cuvis_acq_cont_fps_set(i_acqCont, value)

def cuvis_acq_cont_fps_set_async(i_acqCont, o_pAsyncResult, value):
    return _cuvis_pyil.cuvis_acq_cont_fps_set_async(i_acqCont, o_pAsyncResult, value)

def cuvis_acq_cont_average_get(i_acqCont, o_pvalue):
    return _cuvis_pyil.cuvis_acq_cont_average_get(i_acqCont, o_pvalue)

def cuvis_acq_cont_average_set(i_acqCont, value):
    return _cuvis_pyil.cuvis_acq_cont_average_set(i_acqCont, value)

def cuvis_acq_cont_average_set_async(i_acqCont, o_pAsyncResult, value):
    return _cuvis_pyil.cuvis_acq_cont_average_set_async(i_acqCont, o_pAsyncResult, value)

def cuvis_acq_cont_integration_time_get(i_acqCont, o_pvalue):
    return _cuvis_pyil.cuvis_acq_cont_integration_time_get(i_acqCont, o_pvalue)

def cuvis_acq_cont_integration_time_set(i_acqCont, value):
    return _cuvis_pyil.cuvis_acq_cont_integration_time_set(i_acqCont, value)

def cuvis_acq_cont_integration_time_set_async(i_acqCont, o_pAsyncResult, value):
    return _cuvis_pyil.cuvis_acq_cont_integration_time_set_async(i_acqCont, o_pAsyncResult, value)

def cuvis_acq_cont_auto_exp_get(i_acqCont, o_pvalue):
    return _cuvis_pyil.cuvis_acq_cont_auto_exp_get(i_acqCont, o_pvalue)

def cuvis_acq_cont_auto_exp_set(i_acqCont, value):
    return _cuvis_pyil.cuvis_acq_cont_auto_exp_set(i_acqCont, value)

def cuvis_acq_cont_auto_exp_set_async(i_acqCont, o_pAsyncResult, value):
    return _cuvis_pyil.cuvis_acq_cont_auto_exp_set_async(i_acqCont, o_pAsyncResult, value)

def cuvis_acq_cont_auto_exp_comp_get(i_acqCont, o_pvalue):
    return _cuvis_pyil.cuvis_acq_cont_auto_exp_comp_get(i_acqCont, o_pvalue)

def cuvis_acq_cont_auto_exp_comp_set(i_acqCont, value):
    return _cuvis_pyil.cuvis_acq_cont_auto_exp_comp_set(i_acqCont, value)

def cuvis_acq_cont_auto_exp_comp_set_async(i_acqCont, o_pAsyncResult, value):
    return _cuvis_pyil.cuvis_acq_cont_auto_exp_comp_set_async(i_acqCont, o_pAsyncResult, value)

def cuvis_acq_cont_operation_mode_get(i_acqCont, o_pvalue):
    return _cuvis_pyil.cuvis_acq_cont_operation_mode_get(i_acqCont, o_pvalue)

def cuvis_acq_cont_operation_mode_set(i_acqCont, value):
    return _cuvis_pyil.cuvis_acq_cont_operation_mode_set(i_acqCont, value)

def cuvis_acq_cont_operation_mode_set_async(i_acqCont, o_pAsyncResult, value):
    return _cuvis_pyil.cuvis_acq_cont_operation_mode_set_async(i_acqCont, o_pAsyncResult, value)

def cuvis_acq_cont_continuous_set(i_acqCont, value):
    return _cuvis_pyil.cuvis_acq_cont_continuous_set(i_acqCont, value)

def cuvis_acq_cont_continuous_set_async(i_acqCont, o_pAsyncResult, value):
    return _cuvis_pyil.cuvis_acq_cont_continuous_set_async(i_acqCont, o_pAsyncResult, value)

def cuvis_acq_cont_bandwidth_get(i_acqCont, o_pvalue):
    return _cuvis_pyil.cuvis_acq_cont_bandwidth_get(i_acqCont, o_pvalue)

def cuvis_acq_cont_queue_size_get(i_acqCont, o_pvalue):
    return _cuvis_pyil.cuvis_acq_cont_queue_size_get(i_acqCont, o_pvalue)

def cuvis_acq_cont_queue_used_get(i_acqCont, o_pvalue):
    return _cuvis_pyil.cuvis_acq_cont_queue_used_get(i_acqCont, o_pvalue)

def cuvis_comp_online_get(i_acqCont, i_id, o_pvalue):
    
    return _cuvis_pyil.cuvis_comp_online_get(i_acqCont, i_id, o_pvalue)

def cuvis_comp_temperature_get(i_acqCont, i_id, o_pvalue):
    return _cuvis_pyil.cuvis_comp_temperature_get(i_acqCont, i_id, o_pvalue)

def cuvis_comp_bandwidth_get(i_acqCont, i_id, o_pvalue):
    return _cuvis_pyil.cuvis_comp_bandwidth_get(i_acqCont, i_id, o_pvalue)

def cuvis_comp_driver_queue_size_get(i_acqCont, i_id, o_pvalue):
    return _cuvis_pyil.cuvis_comp_driver_queue_size_get(i_acqCont, i_id, o_pvalue)

def cuvis_comp_driver_queue_used_get(i_acqCont, i_id, o_pvalue):
    return _cuvis_pyil.cuvis_comp_driver_queue_used_get(i_acqCont, i_id, o_pvalue)

def cuvis_comp_hardware_queue_size_get(i_acqCont, i_id, o_pvalue):
    return _cuvis_pyil.cuvis_comp_hardware_queue_size_get(i_acqCont, i_id, o_pvalue)

def cuvis_comp_hardware_queue_used_get(i_acqCont, i_id, o_pvalue):
    return _cuvis_pyil.cuvis_comp_hardware_queue_used_get(i_acqCont, i_id, o_pvalue)

def cuvis_comp_gain_get(i_acqCont, i_id, o_pvalue):
    return _cuvis_pyil.cuvis_comp_gain_get(i_acqCont, i_id, o_pvalue)

def cuvis_comp_gain_set(i_acqCont, i_id, value):
    return _cuvis_pyil.cuvis_comp_gain_set(i_acqCont, i_id, value)

def cuvis_comp_gain_set_async(i_acqCont, i_id, o_pAsyncResult, value):
    return _cuvis_pyil.cuvis_comp_gain_set_async(i_acqCont, i_id, o_pAsyncResult, value)

def cuvis_comp_integration_time_factor_get(i_acqCont, i_id, o_pvalue):
    return _cuvis_pyil.cuvis_comp_integration_time_factor_get(i_acqCont, i_id, o_pvalue)

def cuvis_comp_integration_time_factor_set(i_acqCont, i_id, value):
    return _cuvis_pyil.cuvis_comp_integration_time_factor_set(i_acqCont, i_id, value)

def cuvis_comp_integration_time_factor_set_async(i_acqCont, i_id, o_pAsyncResult, value):
    return _cuvis_pyil.cuvis_comp_integration_time_factor_set_async(i_acqCont, i_id, o_pAsyncResult, value)

def new_p_cuvis_data_type_t():
    return _cuvis_pyil.new_p_cuvis_data_type_t()

def copy_p_cuvis_data_type_t(value):
    return _cuvis_pyil.copy_p_cuvis_data_type_t(value)

def delete_p_cuvis_data_type_t(obj):
    return _cuvis_pyil.delete_p_cuvis_data_type_t(obj)

def p_cuvis_data_type_t_assign(obj, value):
    return _cuvis_pyil.p_cuvis_data_type_t_assign(obj, value)

def p_cuvis_data_type_t_value(obj):
    return _cuvis_pyil.p_cuvis_data_type_t_value(obj)

def new_p_cuvis_operation_mode_t():
    return _cuvis_pyil.new_p_cuvis_operation_mode_t()

def copy_p_cuvis_operation_mode_t(value):
    return _cuvis_pyil.copy_p_cuvis_operation_mode_t(value)

def delete_p_cuvis_operation_mode_t(obj):
    return _cuvis_pyil.delete_p_cuvis_operation_mode_t(obj)

def p_cuvis_operation_mode_t_assign(obj, value):
    return _cuvis_pyil.p_cuvis_operation_mode_t_assign(obj, value)

def p_cuvis_operation_mode_t_value(obj):
    return _cuvis_pyil.p_cuvis_operation_mode_t_value(obj)

def new_p_cuvis_hardware_state_t():
    return _cuvis_pyil.new_p_cuvis_hardware_state_t()

def copy_p_cuvis_hardware_state_t(value):
    return _cuvis_pyil.copy_p_cuvis_hardware_state_t(value)

def delete_p_cuvis_hardware_state_t(obj):
    return _cuvis_pyil.delete_p_cuvis_hardware_state_t(obj)

def p_cuvis_hardware_state_t_assign(obj, value):
    return _cuvis_pyil.p_cuvis_hardware_state_t_assign(obj, value)

def p_cuvis_hardware_state_t_value(obj):
    return _cuvis_pyil.p_cuvis_hardware_state_t_value(obj)

def new_p_cuvis_status_t():
    return _cuvis_pyil.new_p_cuvis_status_t()

def copy_p_cuvis_status_t(value):
    return _cuvis_pyil.copy_p_cuvis_status_t(value)

def delete_p_cuvis_status_t(obj):
    return _cuvis_pyil.delete_p_cuvis_status_t(obj)

def p_cuvis_status_t_assign(obj, value):
    return _cuvis_pyil.p_cuvis_status_t_assign(obj, value)

def p_cuvis_status_t_value(obj):
    return _cuvis_pyil.p_cuvis_status_t_value(obj)

def new_p_cuvis_worker_state_t():
    return _cuvis_pyil.new_p_cuvis_worker_state_t()

def copy_p_cuvis_worker_state_t(value):
    return _cuvis_pyil.copy_p_cuvis_worker_state_t(value)

def delete_p_cuvis_worker_state_t(obj):
    return _cuvis_pyil.delete_p_cuvis_worker_state_t(obj)

def p_cuvis_worker_state_t_assign(obj, value):
    return _cuvis_pyil.p_cuvis_worker_state_t_assign(obj, value)

def p_cuvis_worker_state_t_value(obj):
    return _cuvis_pyil.p_cuvis_worker_state_t_value(obj)

