"""Some functions to create specific plots of simulation results

Those used to be methods of the Instrument class, working directly with the
arrays stored therein. The variants here are free functions acting on
SimResultsNumpyAny instances which store simulation results in numpy arrays.

The plot functions herre are only intended to be used with data that
fits in memory, just like the original methods.
"""

import numpy as np
from matplotlib import pyplot as plt

from lisainstrument.instru.instru_store import SimResultsNumpyAny


def plot_fluctuations(
    sim: SimResultsNumpyAny, output: str | None = None, skip: int = 0
) -> None:
    """Plot beatnote frequency fluctuations generated by the simulation.

    Args:
        sim: Instance with simulation results
        output: output file, None to show the plots
        skip: number of initial samples to skip [samples]
    """
    # Plot signals
    _, axes = plt.subplots(3, 1, figsize=(16, 18))

    def plot(axis, x, label):
        axis.plot(
            sim.t[skip:], np.broadcast_to(x, sim.meta_data.size)[skip:], label=label
        )

    md = sim.mosa_data
    for mosa in md.mosa_names:
        plot(axes[0], md.sci_carrier_fluctuations[mosa], mosa)
        plot(axes[1], md.tmi_carrier_fluctuations[mosa], mosa)
        plot(axes[2], md.ref_carrier_fluctuations[mosa], mosa)
    # Format plot
    axes[0].set_title("Beatnote frequency fluctuations")
    axes[2].set_xlabel("Time [s]")
    axes[0].set_ylabel("Inter-spacecraft frequency [Hz]")
    axes[1].set_ylabel("Test-mass frequency [Hz]")
    axes[2].set_ylabel("Reference frequency [Hz]")
    for axis in axes:
        axis.grid()
        axis.legend()
    # Save or show glitch
    if output is not None:
        plt.savefig(output, bbox_inches="tight")
    else:
        plt.show()


def plot_offsets(
    sim: SimResultsNumpyAny, output: str | None = None, skip: int = 0
) -> None:
    """Plot beatnote frequency offsets generated by the simulation.

    Args:
        sim: Instance with simulation results
        output: output file, None to show the plots
        skip: number of initial samples to skip [samples]
    """
    # Plot signals
    _, axes = plt.subplots(3, 1, figsize=(16, 18))

    def plot(axis, x, label):
        axis.plot(
            sim.t[skip:], np.broadcast_to(x, sim.meta_data.size)[skip:], label=label
        )

    md = sim.mosa_data
    for mosa in md.mosa_names:
        plot(axes[0], md.sci_carrier_offsets[mosa], mosa)
        plot(axes[1], md.tmi_carrier_offsets[mosa], mosa)
        plot(axes[2], md.ref_carrier_offsets[mosa], mosa)
    # Format plot
    axes[0].set_title("Beatnote frequency offsets")
    axes[2].set_xlabel("Time [s]")
    axes[0].set_ylabel("Inter-spacecraft frequency [Hz]")
    axes[1].set_ylabel("Test-mass frequency [Hz]")
    axes[2].set_ylabel("Reference frequency [Hz]")
    for axis in axes:
        axis.grid()
        axis.legend()
    # Save or show glitch
    if output is not None:
        plt.savefig(output, bbox_inches="tight")
    else:
        plt.show()


def plot_totals(
    sim: SimResultsNumpyAny, output: str | None = None, skip: int = 0
) -> None:
    """Plot beatnote total frequencies generated by the simulation.

    Args:
        sim: Instance with simulation results
        output: output file, None to show the plots
        skip: number of initial samples to skip [samples]
    """
    # Plot signals
    _, axes = plt.subplots(3, 1, figsize=(16, 18))

    def plot(axis, x, label):
        axis.plot(
            sim.t[skip:], np.broadcast_to(x, sim.meta_data.size)[skip:], label=label
        )

    md = sim.mosa_data
    for mosa in md.mosa_names:
        plot(axes[0], md.sci_carriers[mosa], mosa)
        plot(axes[1], md.tmi_carriers[mosa], mosa)
        plot(axes[2], md.ref_carriers[mosa], mosa)
    # Format plot
    axes[0].set_title("Beatnote total frequencies")
    axes[2].set_xlabel("Time [s]")
    axes[0].set_ylabel("Inter-spacecraft frequency [Hz]")
    axes[1].set_ylabel("Test-mass frequency [Hz]")
    axes[2].set_ylabel("Reference frequency [Hz]")
    for axis in axes:
        axis.grid()
        axis.legend()
    # Save or show glitch
    if output is not None:
        plt.savefig(output, bbox_inches="tight")
    else:
        plt.show()


def plot_mprs(
    sim: SimResultsNumpyAny, output: str | None = None, skip: int = 0
) -> None:
    """Plot measured pseudo-ranges (MPRs) generated by the simulation.

    Args:
        sim: Instance with simulation results
        output: output file, None to show the plots
        skip: number of initial samples to skip [samples]
    """
    # Plot signals
    _, axes = plt.subplots(2, 1, figsize=(16, 12))

    def plot(axis, x, label):
        axis.plot(
            sim.t[skip:], np.broadcast_to(x, sim.meta_data.size)[skip:], label=label
        )

    md = sim.mosa_data
    for mosa in md.mosa_names:
        plot(axes[0], md.mprs[mosa], mosa)
        plot(axes[1], np.gradient(md.mprs[mosa], sim.meta_data.dt), mosa)
    # Format plot
    axes[0].set_title("Measured pseudo-ranges")
    axes[1].set_xlabel("Time [s]")
    axes[0].set_ylabel("Pseudo-range [s]")
    axes[1].set_ylabel("Pseudo-range derivative [s/s]")
    for axis in axes:
        axis.grid()
        axis.legend()
    # Save or show glitch
    if output is not None:
        plt.savefig(output, bbox_inches="tight")
    else:
        plt.show()


def plot_dws(sim: SimResultsNumpyAny, output: str | None = None, skip: int = 0) -> None:
    """Plot DWS measurements generated by the simulation.

    Args:
        sim: Instance with simulation results
        output: output file, None to show the plots
        skip: number of initial samples to skip [samples]
    """
    # Plot signals
    _, axes = plt.subplots(2, 1, figsize=(16, 12))

    def plot(axis, x, label):
        axis.plot(
            sim.t[skip:], np.broadcast_to(x, sim.meta_data.size)[skip:], label=label
        )

    md = sim.mosa_data
    for mosa in md.mosa_names:
        plot(axes[0], md.sci_dws_phis[mosa], mosa)
        plot(axes[1], md.sci_dws_etas[mosa], mosa)
    # Format plot
    axes[0].set_title("DWS measurements")
    axes[1].set_xlabel("Time [s]")
    axes[0].set_ylabel("ISI Yaw (phi) [rad/s]")
    axes[1].set_ylabel("ISI Pitch (eta) [rad/s]")
    for axis in axes:
        axis.grid()
        axis.legend()
    # Save or show glitch
    if output is not None:
        plt.savefig(output, bbox_inches="tight")
    else:
        plt.show()


def plot_dict(
    data: dict[str, np.ndarray | float],
    output: str | None = None,
    dt: float = 1.0,
    t0: float = 0.0,
    size: int | str = "auto",
    title: str = "Signals",
):
    """Plot all signals from a dictionary.

    Intended for plotting data from all MOSAs or all spacecrafts. All
    datasets must have the same sampling period and time offset. Scalars
    are interpreted as constant time series.

    Args:
        data: dictionary with data to plot.
        output: output file, None to show the plots
        dt: sampling period [s]
        t0: initial time [s]
        size: duration of time series [samples], or 'auto'
        title: plot title
    """
    if size == "auto":
        csize = max(
            (len(s) for s in data.values() if isinstance(s, np.ndarray)), default=100
        )
    else:
        csize = int(size)
    t = t0 + np.arange(csize) * dt
    # Plot signals
    plt.figure(figsize=(12, 4))
    for key, signal in data.items():
        plt.plot(t, np.broadcast_to(signal, csize), label=key)
    plt.grid()
    plt.legend()
    plt.xlabel("Time [s]")
    plt.ylabel("Signal")
    plt.title(title)
    # Save or show
    if output is not None:
        plt.savefig(output, bbox_inches="tight")
    else:
        plt.show()
