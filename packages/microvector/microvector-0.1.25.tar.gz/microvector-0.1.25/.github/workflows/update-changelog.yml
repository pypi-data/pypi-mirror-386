name: Update Changelog

on:
    release:
        types: [published]
    workflow_dispatch: # Allow manual triggering

permissions:
    contents: write # Needed to commit changelog updates
    models: read # Needed to access GitHub Models

jobs:
    update-changelog:
        name: Generate and Update Changelog
        runs-on: ubuntu-latest

        steps:
            - name: Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0 # Full history needed for git diff

            - name: Get previous release tag
              id: prev_release
              run: |
                  # Get the tag before the current one
                  CURRENT_TAG="${{ github.event.release.tag_name }}"
                  PREV_TAG=$(git tag --sort=-version:refname | grep -A1 "^${CURRENT_TAG}$" | tail -1)

                  if [ -z "$PREV_TAG" ] || [ "$PREV_TAG" = "$CURRENT_TAG" ]; then
                    # If no previous tag, get first commit
                    PREV_TAG=$(git rev-list --max-parents=0 HEAD)
                    echo "first_release=true" >> $GITHUB_OUTPUT
                  else
                    echo "first_release=false" >> $GITHUB_OUTPUT
                  fi

                  echo "prev_tag=$PREV_TAG" >> $GITHUB_OUTPUT
                  echo "ðŸ“ Previous release: $PREV_TAG"

            - name: Generate git diff
              id: git_diff
              run: |
                  CURRENT_TAG="${{ github.event.release.tag_name }}"
                  PREV_TAG="${{ steps.prev_release.outputs.prev_tag }}"

                  # Generate detailed diff
                  git diff ${PREV_TAG}..${CURRENT_TAG} > full_diff.txt

                  # Generate summary of changed files
                  git diff --stat ${PREV_TAG}..${CURRENT_TAG} > diff_summary.txt

                  # Get commit messages
                  git log ${PREV_TAG}..${CURRENT_TAG} --pretty=format:"- %s (%h)" > commits.txt

                  echo "âœ… Git diff generated"
                  echo "ðŸ“Š Changed files:"
                  cat diff_summary.txt

            - name: Download benchmark results
              id: download_benchmarks
              continue-on-error: true
              uses: actions/download-artifact@v4
              with:
                  pattern: benchmark-results-python-*
                  merge-multiple: true
                  path: ./benchmark-data

            - name: Prepare benchmark summary
              id: benchmark_summary
              run: |
                  if [ -d "./benchmark-data" ]; then
                    echo "has_benchmarks=true" >> $GITHUB_OUTPUT
                    
                    # Combine all benchmark metrics into one summary
                    python << 'PYTHON_SCRIPT'
                  import json
                  import os
                  from pathlib import Path

                  benchmark_dir = Path('./benchmark-data')
                  if benchmark_dir.exists():
                      # Find all metric files
                      metric_files = list(benchmark_dir.glob('benchmark_metrics.json'))
                      
                      if metric_files:
                          # Read the first one (they should all be similar)
                          with open(metric_files[0], 'r') as f:
                              metrics = json.load(f)
                          
                          # Create a human-readable summary
                          summary_lines = ["## Performance Metrics\n"]
                          
                          if 'embedding_500_rate' in metrics:
                              summary_lines.append(f"- Embedding rate: {metrics['embedding_500_rate']} docs/sec (500 docs)")
                          if 'embedding_2000_rate' in metrics:
                              summary_lines.append(f"- Embedding rate: {metrics['embedding_2000_rate']} docs/sec (2000 docs)")
                          if 'search_500_time' in metrics:
                              search_ms = float(metrics['search_500_time']) * 1000
                              summary_lines.append(f"- Search latency: {search_ms:.1f}ms (500 docs)")
                          if 'memory_delta_mb' in metrics:
                              summary_lines.append(f"- Memory usage: {metrics['memory_delta_mb']}MB delta")
                          
                          summary = "\n".join(summary_lines)
                          
                          # Save to file
                          with open('benchmark_summary.txt', 'w') as f:
                              f.write(summary)
                          
                          print("âœ… Benchmark summary created")
                      else:
                          print("âš ï¸ No benchmark metrics found")
                          with open('benchmark_summary.txt', 'w') as f:
                              f.write("No benchmark data available for this release.")
                  else:
                      print("âš ï¸ No benchmark directory found")
                      with open('benchmark_summary.txt', 'w') as f:
                          f.write("No benchmark data available for this release.")
                  PYTHON_SCRIPT
                  else
                    echo "has_benchmarks=false" >> $GITHUB_OUTPUT
                    echo "No benchmark data available for this release." > benchmark_summary.txt
                  fi

            - name: Install gh-models extension
              run: |
                  gh extension install https://github.com/github/gh-models
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

            - name: Generate changelog entry with AI
              id: generate_changelog
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  CURRENT_TAG="${{ github.event.release.tag_name }}"
                  PREV_TAG="${{ steps.prev_release.outputs.prev_tag }}"
                  IS_FIRST="${{ steps.prev_release.outputs.first_release }}"

                  # Create a comprehensive context file for the AI
                  cat > ai_context.txt << 'CONTEXT_EOF'
                  # Release Information
                  Current Version: ${CURRENT_TAG}
                  Previous Version: ${PREV_TAG}
                  First Release: ${IS_FIRST}

                  # Commit Messages
                  $(cat commits.txt)

                  # File Changes Summary
                  $(cat diff_summary.txt)

                  # Benchmark Data
                  $(cat benchmark_summary.txt)

                  # Sample of Code Changes (first 2000 lines of diff)
                  $(head -n 2000 full_diff.txt)
                  CONTEXT_EOF

                  # Use GitHub Models to generate changelog entry
                  cat ai_context.txt | gh models run xai/grok-3 \
                    "You are a technical writer creating a changelog entry for a Python library called microvector - a lightweight local vector database.

                  Based on the git diff, commit messages, and benchmark data provided, create a changelog entry following the Keep a Changelog format.

                  The entry should:
                  1. Start with ## [${CURRENT_TAG}] - $(date +%Y-%m-%d)
                  2. Categorize changes into: Added, Changed, Deprecated, Removed, Fixed, Security
                  3. Write clear, user-facing descriptions (not just commit messages)
                  4. If performance improvements are evident from benchmarks, mention them in a 'Performance' section
                  5. Focus on changes that matter to users of the library
                  6. Use bullet points (- ) for each item
                  7. Be concise but informative
                  8. Include relevant technical details where helpful

                  If this is the first release, include a brief introduction about what the library does.

                  Only output the changelog entry in markdown format, nothing else. Do not include code blocks or backticks around the output." \
                  > changelog_entry.md

                  echo "âœ… Changelog entry generated"
                  echo "ðŸ“ Preview:"
                  cat changelog_entry.md

            - name: Update CHANGELOG.md
              run: |
                  # Read the new entry
                  NEW_ENTRY=$(cat changelog_entry.md)

                  # Read current changelog
                  if [ ! -f CHANGELOG.md ]; then
                    # Create new changelog if it doesn't exist
                    cat > CHANGELOG.md << 'EOF'
                  # Changelog

                  All notable changes to this project will be documented in this file.

                  The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
                  and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

                  ## [Unreleased]

                  EOF
                  fi

                  # Use Python to insert the new entry
                  python << 'PYTHON_SCRIPT'
                  import re
                  from pathlib import Path

                  # Read the changelog
                  changelog_path = Path('CHANGELOG.md')
                  changelog = changelog_path.read_text()

                  # Read the new entry
                  new_entry = Path('changelog_entry.md').read_text().strip()

                  # Add release link to the changelog entry
                  version = "${{ github.event.release.tag_name }}"
                  release_url = "https://github.com/${{ github.repository }}/releases/tag/${version}"

                  # Modify the version header to include a link to the release
                  # Pattern: ## [version] - date
                  version_pattern = rf'## \[{re.escape(version)}\]'
                  if re.search(version_pattern, new_entry):
                      new_entry = re.sub(
                          version_pattern,
                          f'## [{version}]({release_url})',
                          new_entry,
                          count=1
                      )

                  # Find the [Unreleased] section and insert after it
                  # Pattern: find "## [Unreleased]" and any content after it until the next "## ["
                  pattern = r'(## \[Unreleased\].*?)(\n## \[|$)'

                  def replacement(match):
                      unreleased_section = match.group(1)
                      next_section = match.group(2)
                      
                      # Insert the new entry between Unreleased and the next section
                      return f"{unreleased_section}\n\n{new_entry}\n{next_section}"

                  updated_changelog = re.sub(pattern, replacement, changelog, count=1, flags=re.DOTALL)

                  # Write back
                  changelog_path.write_text(updated_changelog)

                  print("âœ… CHANGELOG.md updated successfully")
                  PYTHON_SCRIPT

                  echo "ðŸ“„ Updated CHANGELOG.md:"
                  head -n 50 CHANGELOG.md

            - name: Commit and push changelog
              run: |
                  git config user.name "github-actions[bot]"
                  git config user.email "github-actions[bot]@users.noreply.github.com"

                  git add CHANGELOG.md

                  if git diff --staged --quiet; then
                    echo "No changes to commit"
                  else
                    git commit -m "ðŸ“ Update CHANGELOG for ${{ github.event.release.tag_name }}"
                    git push
                    echo "âœ… Changelog committed and pushed"
                  fi

            - name: Add changelog to release notes
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  # Extract just the new version section from CHANGELOG.md
                  VERSION="${{ github.event.release.tag_name }}"

                  python << 'PYTHON_SCRIPT'
                  import re
                  from pathlib import Path

                  version = "${VERSION}"
                  changelog = Path('CHANGELOG.md').read_text()

                  # Extract just this version's section
                  pattern = rf'## \[{re.escape(version)}\].*?(?=\n## \[|\Z)'
                  match = re.search(pattern, changelog, re.DOTALL)

                  if match:
                      section = match.group(0)
                      Path('release_notes.md').write_text(section)
                      print("âœ… Extracted release notes")
                  else:
                      print("âš ï¸ Could not find version section in changelog")
                      Path('release_notes.md').write_text("See CHANGELOG.md for details.")
                  PYTHON_SCRIPT

                  # Get current release notes
                  CURRENT_NOTES=$(gh release view "${{ github.event.release.tag_name }}" --json body --jq '.body')
                  NEW_NOTES=$(cat release_notes.md)

                  # Create changelog link
                  VERSION="${{ github.event.release.tag_name }}"
                  # Remove 'v' prefix if present for the anchor link
                  VERSION_ANCHOR=$(echo "$VERSION" | sed 's/^v//')
                  CHANGELOG_LINK="https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md#${VERSION_ANCHOR}"

                  # Create combined notes file with changelog link
                  cat > combined_notes.md << EOF
                  ${CURRENT_NOTES}

                  ---

                  ${NEW_NOTES}

                  ---

                  ðŸ“ **[View Full Changelog](${CHANGELOG_LINK})**
                  EOF

                  # Update release with combined notes
                  gh release edit "${{ github.event.release.tag_name }}" --notes-file combined_notes.md

                  echo "âœ… Release notes updated with changelog"
