'''
Kinds Of Macros
---------------

Standard One
""""""""""""

Macros must be expanded into ast.Expr, I mean statement.

Params are assigned unless ``yr_`` prefixed. extra mangling if hygienic

Expr
""""

Macros that can be expanded as part of an expression

Block
"""""

Macros that accept a block of code, when unexpanded look like a meaningless with statement

UnImplemented Yet

X(Y) and Z(X, E) Macros
"""""""""""""""""""""""

.. warning:: experimental, without a clear use-case in mind

It's all about preprocessing an X list of elements.

See `Wikipedia about X Macros in C <https://en.wikipedia.org/wiki/X_macro>`__

The C preprocessor operates on text, we don't, so let's see what can we do

- X macros: Define a list of names. each name on their own line

- Y macros: Expands like standard macro, the only parameter is the name of the current x item. Has:

  + x_token: anywhere in a "str" such as function definitions

  + x_quoted: gets replaced with "item"

  + x: the item name (so something at runtime)

This is ok-ish (pretty limited) for templating, but you may also want to be able to create expressions

- Z macros: Skeletons packing the X macro, 1st arg is the name of the xmacro, 2nd is the name of the emacro.

  + formal emacro gets replaced with actual emacro name

  + xmacro gets relaced with a tuple of names

  + xmacro_quoted gets replaced with a tuple of strings


Additionally you can X(len) that is useful for asserts

.. versionchanged:: 0.0.2

    Added X/Y/Z Macros

Plans for v0.0.3:

- maybe introduce a _content,

- maybe indexing?


Parameters Specification
------------------------

.. image:: _static/macro_params.png
.. graphviz::
    :align: center
    :break: eww, help me write that as text/diagram

    digraph def_macro_params {
        mLang;
        expr;
        hygienic;
        strip;
        **extra;
    }

    digraph macro_params {
        positional_params_only,
        yr_*,
    }


Look at the `yeastr-test-proj repo for examples <https://github.com/yeastr-org/yeastr-test-proj/blob/dev/src/yeastr_test/macros.pyy>`__

'''

# TODO: rename to MacroContext?
class Macros:
    """Contains all the macros"""
    def __init__(self):
        self._macros = {}

    def add(self, fn, flags, _args, kwargs):
        """The actual @def_macro() decorator may call this

        Here fn is the decorated function that is inspected to get the source
        for the macro that gets added"""
        # Just-In-Time / Import-time def_macro
        fn.ym_flags = flags
        fn.ymacrokw = kwargs
        prepare_source()
        _ast = _fn.body[0].body
        # strip_macro_docstring(_fn.body[0].body) # ewwwww, move that?
        if (
            _ast[0].__class__ == ast.Expr
            and _ast[0].value.__class__ == ast.Constant
            and _ast[0].value.value.__class__ == str
        ):
            _ast.pop(0)  # skip the docstring
        self._macros.update({
            fn.name: (fn, _ast)
        })

    def add_ast(self, fn, name, _ast, flags, _args, kwargs):
        """The usual @def_macro and @def_macro() may call this"""
        # Ahead-of-time / build-time / import-hooks def_macro
        bmacro = fn
        bmacro.name = name
        bmacro.ym_flags = flags
        bmacro.ymacrokw = kwargs
        self._macros.update({name: (fn, _ast)})

    def retrieve(self, ast_node, required=False):
        """
        :param ast_node: of the macro to retrieve
        :type ast_node: ast.Name

        :param required: raise when not found, dumping the name of all knowing macros, defaults to False
        :type required: bool

        :returns: A copy of the body of the macro as the last element of the returned tuple
        :rtype: Tuple[str, Any, List[ast.AST]]
        """
        if ast_node.__class__ == ast.Name:
            mname = ast_node.id
            if (duple := self._macros.get(mname)) is not None:
                return mname, duple[0], ast_copy(duple[1])
        if required:
            raise TransformError(f'Macro {ast_node.id} missing. known: {list(self._macros.keys())}')


_macros = Macros()


@def_macro(expr=True)
def mLang_evaluate_mIf():
    """Unparse and eval the test condition of an :code:`mIf`"""
    eval(compile(ast.unparse(call.args[0]), '_mLang.py', 'eval'), mglobals, mlocals)

@def_macro
def perform_body(yr_loop, yr_hint):
    """Macro expansion body logics

    :param loop: a loop label
    :type loop: there's no Loop type
    :param hint: debug parameter for unknown actions
    :type hint: Any
    """
    if action is None:
        ...
    elif action == 'skip':
        assert yam_with_call_name(loop.it, _, 'mIf')
        del loop.it  # delete with mIf
        loop.i = max(loop.i - 1, -1)
    elif action in ('otherwise', 'skip-else'):
        assert yam_with_call_name(loop.it, _, 'mIf')
        del loop.it  # delete with mIf
        assert yam_with_call_name(loop.it, _, 'mElse')
        del loop.it  # delete with mElse
        loop.iter[loop.i:loop.i] = new_body
        loop.i = max(loop.i - 2, -1)
    elif action in ('then', 'mEval'):
        assert yam_with_call_name(loop.it, _, 'mIf' if action == 'then' else 'mEval')
        del loop.it  # delete with mIf
        loop.iter[loop.i:loop.i] = new_body
        loop.i -= 1
        loop.i = max(loop.i - 1, -1)
    else:
        assert False, f'unexpected {action} ({hint})'

@def_macro
def do_mLang():
    """Conditional macro expansion and maybe constexpr"""
    # first of all, this one is Top-Down, but everything else is Bottom-Up
    # But since it's a language, interpreting it Bottom Up would be so weird
    mglobals = {'ast': ast, '__builtins__': restricted_builtins}
    mEval_ctx = {'__builtins__': restricted_builtins}
    ymacrokw = fn__.ymacrokw
    mlocals = dict(ymacrokw)
    mlocals.update(efiltermapd(
        lambda k: k.arg in ymacrokw.keys(),
        lambda k: (k.arg, mLang_conv(k.value)),
        moon.node.keywords
    ))
    def perform(starting_node, next_node=None):
        if yam_with_call_name(starting_node, call, 'mIf'):
            if mLang_evaluate_mIf():
                if yam_with_call_name(next_node, _, 'mElse'):
                    return 'skip-else', starting_node.body
                return 'then', starting_node.body
            else:
                if yam_with_call_name(next_node, _, 'mElse'):
                    return 'otherwise', next_node.body
                else:
                    return 'skip', []
        elif yam_call_name(starting_node, 'mEval'):
            return 'mEval', ast.parse(
                str(eval(ast.unparse(starting_node.args[0]), mEval_ctx)),
                '_mEval.py',
                'eval',
            ).body
        fields = [
            (field, getattr(starting_node, field))
            for field in starting_node._fields
            if hasattr(starting_node, field)
        ]
        with For((field, mbody_ast_field) in fields) as fields_loop:
            if isinstance(mbody_ast_field, list):
                with For(subnode in mbody_ast_field, indexed=True) as subnodes_loop:
                    try:
                        action, new_body = perform(
                            subnode, subnodes_loop.iter[subnodes_loop.i + 1]
                        )
                    except IndexError:
                        action, new_body = perform(subnode)
                    perform_body(subnodes_loop, 'nested')

            elif isinstance(mbody_ast_field, ast.AST):
                action, new_node = perform(mbody_ast_field, next_node)
                if action == 'mEval':
                    setattr(starting_node, field, new_node)
                elif action is None:
                    ...
                else:
                    assert False, f'unexpected {action} (field)'
        return None, None
    # this is not inside of perform
    with For(mbody_ast in _ast, indexed=True) as mbody_loop:
        try:
            action, new_body = perform(mbody_ast, mbody_loop.iter[mbody_loop.i + 1])
        except IndexError:
            action, new_body = perform(mbody_ast)
        assert action != 'mEval', 'unexpected mEval at top'
        perform_body(mbody_loop, 'top')
    with For(mbody_ast in _ast, indexed=True) as mbody_loop:
        if any((yam_with_call_name(mbody_loop.item, _, unexpected)
                for unexpected in ('mIf', 'mElse', 'mEval'))):
            breakpoint()


@def_macro
def macros_to_be_expanded(_macros, yr_node):
    """Overwrites :code:`needs_expansion` and :code:`retrieved`

    :param _macros: the _macros singleton...
    :type _macros: Macros
    :param node: check this node is a known macro call
    :type node: ast.AST
    """
    needs_expansion = (
        node.__class__ == ast.Call
        and node.func.__class__ in (ast.Name, ast.Attribute)
        and node not in deferred_macroe
        and (retrieved := _macros.retrieve(node.func)) is not None
    )

@def_macro
def standard_macro_style_params_replacement():
    if not isinstance(moon.up.node, ast.Expr):
        raise NotImplementedError(f'macro expansion within {moon.up.node.__class__}')
    where = [
        p[3:] if p.startswith('yr_') else None
        for p in signature(fn__).parameters.keys()
    ]
    if fn__.ym_flags & YMF_hygienic:
        assert all((p is None for p in where)), 'incompatibilities?'
    replacements = []
    with MoonGrabber() as keepalive:
        def moon_filter(moon):
            if moon.node.__class__ == ast.Name and moon.node.id in where:
                keepalive(moon.up)
                return moon
        def moon_walk(moonwalker):
            for _n in moonwalker.tree:
                arg = moon.node.args[where.index(_n.node.id)]
                _n.replace(arg)
                replacements.append(arg)
            return True
        for ast__ in _ast:
            MoonWalking(ast__, filter_cb=moon_filter, before_reversing_cb=moon_walk)

@def_macro
def expression_macro_style_params_replacement():
    formal_params = list(signature(fn__).parameters.keys())
    with MoonGrabber() as keepalive:
        def moon_filter(moon):
            if (
                moon.node.__class__ == ast.Name
                and moon.node.id in formal_params
            ):
                keepalive(moon.up)
                return moon
        def moon_walk(moonwalker):
            for _n in moonwalker.tree:
                _n.replace(
                    ast.Name(formal_params[formal_param_i]) if yam_name(
                        (actual_param := moon.node.args[
                            (formal_param_i := formal_params.index(_n.node.id))
                        ]),
                        '_',
                    ) else actual_param
                )
            return True
        for ast__ in _ast:
            MoonWalking(ast__, filter_cb=moon_filter, before_reversing_cb=moon_walk)


@def_macro
def xy_macro_direct_expansion():
    if fn__.ym_flags & YMF_hygienic:
        assert all((p is None for p in where)), 'incompatibilities?'
    if fn__.ym_flags & YMF_mLang:
        raise NotImplementedError('X Macro with mLang')
    assert len(moon.node.args) == 1, 'mismatching XMacro(YMacro) arity'
    assert moon.node.args[0].__class__ == ast.Name, 'bad XMacro(YMacro) param'
    if moon.node.args[0].id == 'len':
        moon.expanded = [ast.Constant(len(_ast))]
        moon.was_len = True
    else:
        moon.was_len = False
        xYname, xYfn, xYast = _macros.retrieve(moon.node.args[0], required=True)
        assert xYfn.ym_flags & YMF_YMacro, ast.unparse(moon.up.node)
        if xYfn.ym_flags & YMF_mLang:
            raise NotImplementedError('Y Macro with mLang')
        ym_params = list(signature(xYfn).parameters.keys())
        ym_quoted = emap(lambda p: f'{p}_quoted', ym_params)
        moon.expanded = []
        with MoonGrabber() as keepalive:
            def moon_filter(moon):
                if (
                    moon.node.__class__ == ast.Name
                    and (
                        (fpname := moon.node.id in ym_params)
                        or moon.node.id in ym_quoted
                    )
                ):
                    moon.argname = moon.node.id
                    moon.suffix = ''
                    if not fpname:
                        moon.suffix = '_quoted'
                    keepalive(moon.up)
                    return moon
                elif (
                    moon.node.__class__ == str
                    and f'{ym_params[0]}_token' in moon.node
                ):
                    moon.suffix = '_token'
                    moon.up
                    return moon
            for _x in _ast:
                if not yam_expr_name(_x, xname, xstr):
                    raise NotImplementedError('XMacro is not a list of names, this is TODO')
                preserved_xYast = ast_copy(xYast)
                fake_module = ast.Module(body=preserved_xYast)
                with For(MoonWalking(fake_module, filter_cb=moon_filter).tree) as xymoons:
                    if xymoons.it.suffix == '_quoted':
                        xymoons.it.replace(ast.Constant(xstr))
                    elif xymoons.it.suffix == '_token':
                        xymoons.it.replace_str(re.sub(f'{ym_params[0]}_token', xstr, xymoons.it.node))
                    else:
                        xymoons.it.replace(ast.Name(xstr, ctx=xymoons.it.node.ctx))
                # eventually mLang, if we manage to refactor, probably here
                moon.expanded.extend(preserved_xYast)


@def_macro
def zx_macro_style_params_replacement():
    if fn__.ym_flags & YMF_hygienic:
        raise NotImplementedError('Z Macro with hygienic')
    if fn__.ym_flags & YMF_mLang:
        raise NotImplementedError('Z Macro with mLang')
    z_params = list(signature(fn__).parameters.keys())
    if len(moon.node.args) != 2:
        raise NotImplementedError('Z(X, E) macro, check arity')
    if any((arg.__class__ != ast.Name for arg in moon.node.args)):
        raise NotImplementedError('Z args must be static known names')
    zXname, zXfn, zXast = _macros.retrieve(moon.node.args[0], required=True)
    assert zXfn.ym_flags & YMF_XMacro
    if zXfn.ym_flags & YMF_mLang:
        raise NotImplementedError('X Macro with mLang')
    with MoonGrabber() as keepalive:
        def moon_filter(zmoon):
            if (
                zmoon.node.__class__ == ast.Name
                and (
                    (unquoted := zmoon.node.id in z_params)
                    or (
                        zmoon.node.id.endswith('_quoted')
                        and zmoon.node.id[:-len('_quoted')] in z_params
                    )
                )
            ):
                if unquoted:
                    zmoon.param_i = z_params.index(zmoon.node.id)
                    zmoon.quoted = False
                else:
                    zmoon.param_i = z_params.index(zmoon.node.id[:-len('_quoted')])
                    zmoon.quoted = True
                keepalive(zmoon.up)
                return zmoon
        def moon_walk(moonwalker):
            for _n in moonwalker.tree:
                if _n.param_i == 0:
                    _n.replace(ast.Tuple(elts=[
                        ast.Constant(x.value.id) if _n.quoted else x.value
                        for x in zXast
                    ]))
                else:
                    # emacro formal name to actual name
                    _n.node.id = moon.node.args[_n.param_i].id
            return True
        for ast__ in _ast:
            MoonWalking(ast__, filter_cb=moon_filter, before_reversing_cb=moon_walk)


@def_macro
def expressionlike_macro_expansion(yr_hint):
    if len(_ast) > 1:
        raise TransformError(f'{hint} macro expanded into multiple expressions')
    moon.replace(_ast[0].value)

@def_macro
def xy_macro_expansion():
    if moon.was_len:
        moon.up.replace(moon.expanded[0])
    else:
        assert moon.up.node.__class__ == ast.Expr, f'did you want Z(W) instead of X(Y)? {ast.unparse(moon.up.node)}'
        moon.up.pop_extend(moon.expanded)


@def_macro
def standard_macro_expansion():
    if fn__.ym_flags & (YMF_expr | YMF_XMacro | YMF_YMacro | YMF_ZMacro):
        raise TransformError(f'Incorrect expansion of {mname}')
    assignments = []
    with For(signature(fn__).parameters) as l:
        try:
            ass = ast.Assign(
                targets=[ast.Name(id=mp % l.it)],
                value=moon.node.args[l.i],
                lineno=1,
            )
        except IndexError:
            raise TransformError(f'wrong arity {l.i} (missing {l.it}) in {ast.unparse(moon.node)}')
        if ass.value not in replacements:
            _ast.insert(0, ass)
            assignments.append(ass)
    where = fn__.__code__.co_varnames if fn__.ym_flags & YMF_hygienic\
        else signature(fn__).parameters
    def moon_filter(moon):
        if (
            isinstance(moon.node, ast.Name)
            and moon.node.id in where
            and moon.up.node not in assignments
            and moon.node not in replacements
        ):
            return moon
    def moon_walk(moonwalker):
        for _n in moonwalker.tree:
            #print(f'mangling {_n.node.id} -> {mp % _n.node.id}')
            _n.node.id = mp % _n.node.id
        return True
    for ast__ in _ast:
        MoonWalking(ast__, filter_cb=moon_filter, before_reversing_cb=moon_walk)
    moon.up.pop_extend(_ast)

@def_macro
def with_macros_impl(_macros):
    """One round of macro expansion

    Expands all of the "currently visible" standard/expr macros

    Expands X(Y) macro

    Expands Z(X, W) macro into W(x) macros
    """
    # TODO: unstripped Z macro definition?
    mname, fn__, _ast = retrieved
    #print(f'EXPANDING {mname}')
    with For(arg in moon.node.keywords, recompute_end=False) as kwdloop:
        if (
            arg.arg == 'defer_expansion'
            and isinstance(arg.value, ast.Constant)
            and arg.value.value
        ):
            del kwdloop.it
            deferred_macroe.append(moon.node)
            macroexpansionloop.Continue
    if fn__.ym_flags & YMF_XMacro:
        xy_macro_direct_expansion()
    elif fn__.ym_flags & YMF_ZMacro:
        assert moon.node.args[0].__class__ == ast.Name, 'bad ZMacro 1st param, must be XMacro'
        assert moon.node.args[1].__class__ == ast.Name, 'bad ZMacro 2nd param, must be a name'
        zx_macro_style_params_replacement()
    elif fn__.ym_flags & YMF_expr:
        expression_macro_style_params_replacement()
    else:
        standard_macro_style_params_replacement()

    if fn__.ym_flags & YMF_mLang:
        do_mLang()

    if fn__.ym_flags & YMF_expr:
        expressionlike_macro_expansion('expression')
    elif fn__.ym_flags & YMF_XMacro:
        xy_macro_expansion()
    elif fn__.ym_flags & YMF_ZMacro:
        expressionlike_macro_expansion('Z')
    else:
        standard_macro_expansion()


@def_macro
def with_macros_impl_wrapper(macros_, some_ast, never_defer):
    """Entry Point, expands a bunch of macros grouped by depth"""
    mp = 'ymacro_%s'
    deferred_macroe = []
    # we are expanding all the macro found, then we repeat
    # until no more macros are to be expanded
    # this highly different from what you'd expect from a lisp perspective
    with MoonGrabber() as macro_keepalive:
        def filter_macro_moons(moon):
            macros_to_be_expanded(macros_, moon.node)
            if needs_expansion:
                moon.retrieved = retrieved
                macro_keepalive(moon, moon.up, moon.up.up)
                return moon
        # A macro that expands into itself is just infinite
        # But it's not true recursion, memory usage won't ramp up!
        # adding a depth check, so you don't wait forever
        depth_counter = 0
        depth_limit = 500 # sys.getrecursionlimit()
        macro_moons = list(MoonWalking(some_ast, filter_cb=filter_macro_moons).tree)
        with While(macro_moons) as loop_until_no_macros:
            if depth_counter > depth_limit:
                raise RecursionError(f'macro expansion limit({depth_limit}): ' +
                    ", ".join((moon.retrieved[0] for moon in macro_moons))
                )
            if never_defer:
                deferred_macroe = []
            with For(moon in macro_moons) as macroexpansionloop:
                retrieved = moon.retrieved
                with_macros_impl(macros_)
            macro_keepalive.reset()
            macro_moons = list(MoonWalking(some_ast, filter_cb=filter_macro_moons).tree)
            depth_counter += 1

