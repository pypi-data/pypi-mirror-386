
# python wrapper for package codeberg.org/slidge/slidgnal/slidgnal within overall package signal
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -output=generated -no-make=true .

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _signal
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from signal import signal
# and then refer to everything using signal. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice []signal.Attachment
class Slice_signal_Attachment(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.Slice_signal_Attachment_CTor()
			_signal.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_signal_Attachment.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		s = 'signal.Slice_signal_Attachment len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'signal.Slice_signal_Attachment([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _signal.Slice_signal_Attachment_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _signal.Slice_signal_Attachment_len(self.handle)
				return Slice_signal_Attachment(handle=_signal.Slice_signal_Attachment_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Attachment(handle=_signal.Slice_signal_Attachment_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_signal.Slice_signal_Attachment_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_signal_Attachment.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Attachment(handle=_signal.Slice_signal_Attachment_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_signal.Slice_signal_Attachment_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []signal.Contact
class Slice_signal_Contact(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.Slice_signal_Contact_CTor()
			_signal.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_signal_Contact.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		s = 'signal.Slice_signal_Contact len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'signal.Slice_signal_Contact([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _signal.Slice_signal_Contact_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _signal.Slice_signal_Contact_len(self.handle)
				return Slice_signal_Contact(handle=_signal.Slice_signal_Contact_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Contact(handle=_signal.Slice_signal_Contact_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_signal.Slice_signal_Contact_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_signal_Contact.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Contact(handle=_signal.Slice_signal_Contact_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_signal.Slice_signal_Contact_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


#---- Enums from Go (collections of consts with same type) ---
from enum import Enum

class EventKind(Enum):
	"""
	EventKind represents all event types recognized by the Python session adapter, as emitted by the
	Go session adapter.
	
	"""
	EventUnknown = 0
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventLogin = 1
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventArchiveSync = 2
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventConnect = 3
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventLogout = 4
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventContact = 5
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventMessage = 6
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventTyping = 7
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventReceipt = 8
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventDelete = 9
	"""
	The event types handled by the overarching session adapter handler.
	
	"""

EventUnknown = 0
"""
The event types handled by the overarching session adapter handler.

"""
EventLogin = 1
"""
The event types handled by the overarching session adapter handler.

"""
EventArchiveSync = 2
"""
The event types handled by the overarching session adapter handler.

"""
EventConnect = 3
"""
The event types handled by the overarching session adapter handler.

"""
EventLogout = 4
"""
The event types handled by the overarching session adapter handler.

"""
EventContact = 5
"""
The event types handled by the overarching session adapter handler.

"""
EventMessage = 6
"""
The event types handled by the overarching session adapter handler.

"""
EventTyping = 7
"""
The event types handled by the overarching session adapter handler.

"""
EventReceipt = 8
"""
The event types handled by the overarching session adapter handler.

"""
EventDelete = 9
"""
The event types handled by the overarching session adapter handler.

"""

class MessageKind(Enum):
	"""
	MessageKind represents all concrete message types (plain-text messages, edit messages, reactions)
	recognized by the Python session adapter.
	
	"""
	MessagePlain = 0
	"""
	The message types handled by the overarching session event handler.
	
	"""
	MessageAttachment = 1
	"""
	The message types handled by the overarching session event handler.
	
	"""
	MessageReaction = 2
	"""
	The message types handled by the overarching session event handler.
	
	"""
	MessageEdit = 3
	"""
	The message types handled by the overarching session event handler.
	
	"""

MessagePlain = 0
"""
The message types handled by the overarching session event handler.

"""
MessageAttachment = 1
"""
The message types handled by the overarching session event handler.

"""
MessageReaction = 2
"""
The message types handled by the overarching session event handler.

"""
MessageEdit = 3
"""
The message types handled by the overarching session event handler.

"""

class ReceiptKind(Enum):
	"""
	ReceiptKind represents the different types of delivery receipts possible in Signal.
	
	"""
	ReceiptUnknown = 0
	"""
	The delivery receipts handled by the overarching session event handler.
	
	"""
	ReceiptDelivered = 1
	"""
	The delivery receipts handled by the overarching session event handler.
	
	"""
	ReceiptRead = 2
	"""
	The delivery receipts handled by the overarching session event handler.
	
	"""

ReceiptUnknown = 0
"""
The delivery receipts handled by the overarching session event handler.

"""
ReceiptDelivered = 1
"""
The delivery receipts handled by the overarching session event handler.

"""
ReceiptRead = 2
"""
The delivery receipts handled by the overarching session event handler.

"""

class TypingState(Enum):
	"""
	A TypingState represents different states of typing notificates for incoming and outgoing messages.
	
	"""
	TypingStateStopped = 0
	"""
	The distinct typing states handled by the overarching session event handler.
	
	"""
	TypingStateStarted = 1
	"""
	The distinct typing states handled by the overarching session event handler.
	
	"""

TypingStateStopped = 0
"""
The distinct typing states handled by the overarching session event handler.

"""
TypingStateStarted = 1
"""
The distinct typing states handled by the overarching session event handler.

"""



#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct signal.Message
class Message(go.GoClass):
	"""A Message represents one of many kinds of bidirectional communication payloads, for example, a\ntext message, a file (image, video) attachment, an emoji reaction, etc. Messages of different\nkinds are denoted as such, and re-use fields where the semantics overlap.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Message_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Kind = args[0]
			if "Kind" in kwargs:
				self.Kind = kwargs["Kind"]
			if  1 < len(args):
				self.ID = args[1]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  2 < len(args):
				self.ChatID = args[2]
			if "ChatID" in kwargs:
				self.ChatID = kwargs["ChatID"]
			if  3 < len(args):
				self.SenderID = args[3]
			if "SenderID" in kwargs:
				self.SenderID = kwargs["SenderID"]
			if  4 < len(args):
				self.TargetID = args[4]
			if "TargetID" in kwargs:
				self.TargetID = kwargs["TargetID"]
			if  5 < len(args):
				self.Body = args[5]
			if "Body" in kwargs:
				self.Body = kwargs["Body"]
			if  6 < len(args):
				self.Timestamp = args[6]
			if "Timestamp" in kwargs:
				self.Timestamp = kwargs["Timestamp"]
			if  7 < len(args):
				self.IsCarbon = args[7]
			if "IsCarbon" in kwargs:
				self.IsCarbon = kwargs["IsCarbon"]
			if  8 < len(args):
				self.Typing = args[8]
			if "Typing" in kwargs:
				self.Typing = kwargs["Typing"]
			if  9 < len(args):
				self.Reaction = args[9]
			if "Reaction" in kwargs:
				self.Reaction = kwargs["Reaction"]
			if  10 < len(args):
				self.ReplyTo = args[10]
			if "ReplyTo" in kwargs:
				self.ReplyTo = kwargs["ReplyTo"]
			if  11 < len(args):
				self.Attachments = args[11]
			if "Attachments" in kwargs:
				self.Attachments = kwargs["Attachments"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Message{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Message ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Kind(self):
		return _signal.signal_Message_Kind_Get(self.handle)
	@Kind.setter
	def Kind(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_Kind_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_Kind_Set(self.handle, value)
	@property
	def ID(self):
		return _signal.signal_Message_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_ID_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_ID_Set(self.handle, value)
	@property
	def ChatID(self):
		return _signal.signal_Message_ChatID_Get(self.handle)
	@ChatID.setter
	def ChatID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_ChatID_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_ChatID_Set(self.handle, value)
	@property
	def SenderID(self):
		return _signal.signal_Message_SenderID_Get(self.handle)
	@SenderID.setter
	def SenderID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_SenderID_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_SenderID_Set(self.handle, value)
	@property
	def TargetID(self):
		return _signal.signal_Message_TargetID_Get(self.handle)
	@TargetID.setter
	def TargetID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_TargetID_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_TargetID_Set(self.handle, value)
	@property
	def Body(self):
		return _signal.signal_Message_Body_Get(self.handle)
	@Body.setter
	def Body(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_Body_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_Body_Set(self.handle, value)
	@property
	def Timestamp(self):
		return _signal.signal_Message_Timestamp_Get(self.handle)
	@Timestamp.setter
	def Timestamp(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_Timestamp_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_Timestamp_Set(self.handle, value)
	@property
	def IsCarbon(self):
		return _signal.signal_Message_IsCarbon_Get(self.handle)
	@IsCarbon.setter
	def IsCarbon(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_IsCarbon_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_IsCarbon_Set(self.handle, value)
	@property
	def Typing(self):
		return Typing(handle=_signal.signal_Message_Typing_Get(self.handle))
	@Typing.setter
	def Typing(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_Typing_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Reaction(self):
		return Reaction(handle=_signal.signal_Message_Reaction_Get(self.handle))
	@Reaction.setter
	def Reaction(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_Reaction_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ReplyTo(self):
		return Reply(handle=_signal.signal_Message_ReplyTo_Get(self.handle))
	@ReplyTo.setter
	def ReplyTo(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_ReplyTo_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Attachments(self):
		return Slice_signal_Attachment(handle=_signal.signal_Message_Attachments_Get(self.handle))
	@Attachments.setter
	def Attachments(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_Attachments_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct signal.Session
class Session(go.GoClass):
	"""A Session represents a connection to Signal under a given [Gateway]. In general, sessions are\ninactive until [Session.Login] is called and out-of-band registration is completed, in which case\nour internal event handlers will attempt to propagate any incoming events. Calls to session\nfunctions, such as [Session.GetContacts], will return an error immediately if the session is not\nactive and  authenticated.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Session_CTor()
			_signal.IncRef(self.handle)
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Session{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Session ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Login(self):
		"""Login() str"""
		return _signal.signal_Session_Login(self.handle)
	def Logout(self):
		"""Logout() str
		
		Logout disconnects and unlinks the current active [Session]. If there is no active session, this
		function returns a nil error.
		"""
		return _signal.signal_Session_Logout(self.handle)
	def Disconnect(self):
		"""Disconnect() str
		
		Disconnect stops any active connection to Signal without removing authentication credentials.
		"""
		return _signal.signal_Session_Disconnect(self.handle)
	def SendMessage(self, message):
		"""SendMessage(object message) str, str
		
		SendMessage processes the given [Message], and sends it to to Signal. Messages can contain a
		multitude of different fields denoting different semantics, see the [Message] type for more
		information.
		"""
		return _signal.signal_Session_SendMessage(self.handle, message.handle)
	def SendTyping(self, typing):
		"""SendTyping(object typing) str
		
		SendTyping sends a typing notification from us to a given contact on Signal.
		"""
		return _signal.signal_Session_SendTyping(self.handle, typing.handle)
	def SendReceipt(self, receipt):
		"""SendReceipt(object receipt) str
		
		SendReceipt sends a read receipt for for a given set of messages to Signal.
		"""
		return _signal.signal_Session_SendReceipt(self.handle, receipt.handle)
	def SendDelete(self, delete):
		"""SendDelete(object delete) str
		
		SendDelete sends a "Delete for Everyone" message to Signal for a given message ID.
		"""
		return _signal.signal_Session_SendDelete(self.handle, delete.handle)
	def GetBackupContacts(self):
		"""GetBackupContacts() []object, str
		
		GetBackupContacts fetches any contacts stored in local backup, which is usually populated by
		archive transfer during initial connection. Contact information returned may be partial.
		"""
		return Slice_signal_Contact(handle=_signal.signal_Session_GetBackupContacts(self.handle))
	def GetContact(self, id):
		"""GetContact(str id) object, str
		
		GetContact returns a concrete [Contact] representation for the account ID given. If no contact
		information could be found, an empty contact will be returned with no error.
		"""
		return Contact(handle=_signal.signal_Session_GetContact(self.handle, id))
	def SetEventHandler(self, h, goRun=False):
		"""SetEventHandler(callable h) 
		
		SetEventHandler assigns the given handler function for propagating internal events into the Python
		gateway. Note that the event handler function is not entirely safe to use directly, and all calls
		should instead be sent to the [Gateway] via its internal call channel.
		"""
		_signal.signal_Session_SetEventHandler(self.handle, h, goRun)

# Python type for struct signal.ArchiveSync
class ArchiveSync(go.GoClass):
	"""ArchiveSync represents event data for initial synchronization of chat state during login.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_ArchiveSync_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Error = args[0]
			if "Error" in kwargs:
				self.Error = kwargs["Error"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.ArchiveSync{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.ArchiveSync ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Error(self):
		return _signal.signal_ArchiveSync_Error_Get(self.handle)
	@Error.setter
	def Error(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_ArchiveSync_Error_Set(self.handle, value.handle)
		else:
			_signal.signal_ArchiveSync_Error_Set(self.handle, value)

# Python type for struct signal.EventPayload
class EventPayload(go.GoClass):
	"""EventPayload represents the collected payloads for all event types handled by the overarching\nsession adapter handler. Only specific fields will be populated in events emitted by internal\nhandlers, see documentation for specific types for more information.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_EventPayload_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Login = args[0]
			if "Login" in kwargs:
				self.Login = kwargs["Login"]
			if  1 < len(args):
				self.Logout = args[1]
			if "Logout" in kwargs:
				self.Logout = kwargs["Logout"]
			if  2 < len(args):
				self.ArchiveSync = args[2]
			if "ArchiveSync" in kwargs:
				self.ArchiveSync = kwargs["ArchiveSync"]
			if  3 < len(args):
				self.Connect = args[3]
			if "Connect" in kwargs:
				self.Connect = kwargs["Connect"]
			if  4 < len(args):
				self.Contact = args[4]
			if "Contact" in kwargs:
				self.Contact = kwargs["Contact"]
			if  5 < len(args):
				self.Message = args[5]
			if "Message" in kwargs:
				self.Message = kwargs["Message"]
			if  6 < len(args):
				self.Typing = args[6]
			if "Typing" in kwargs:
				self.Typing = kwargs["Typing"]
			if  7 < len(args):
				self.Receipt = args[7]
			if "Receipt" in kwargs:
				self.Receipt = kwargs["Receipt"]
			if  8 < len(args):
				self.Delete = args[8]
			if "Delete" in kwargs:
				self.Delete = kwargs["Delete"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.EventPayload{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.EventPayload ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Login(self):
		return Login(handle=_signal.signal_EventPayload_Login_Get(self.handle))
	@Login.setter
	def Login(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Login_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Logout(self):
		return Logout(handle=_signal.signal_EventPayload_Logout_Get(self.handle))
	@Logout.setter
	def Logout(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Logout_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ArchiveSync(self):
		return ArchiveSync(handle=_signal.signal_EventPayload_ArchiveSync_Get(self.handle))
	@ArchiveSync.setter
	def ArchiveSync(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_ArchiveSync_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Connect(self):
		return Connect(handle=_signal.signal_EventPayload_Connect_Get(self.handle))
	@Connect.setter
	def Connect(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Connect_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Contact(self):
		return Contact(handle=_signal.signal_EventPayload_Contact_Get(self.handle))
	@Contact.setter
	def Contact(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Contact_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Message(self):
		return Message(handle=_signal.signal_EventPayload_Message_Get(self.handle))
	@Message.setter
	def Message(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Message_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Typing(self):
		return Typing(handle=_signal.signal_EventPayload_Typing_Get(self.handle))
	@Typing.setter
	def Typing(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Typing_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Receipt(self):
		return Receipt(handle=_signal.signal_EventPayload_Receipt_Get(self.handle))
	@Receipt.setter
	def Receipt(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Receipt_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Delete(self):
		return Delete(handle=_signal.signal_EventPayload_Delete_Get(self.handle))
	@Delete.setter
	def Delete(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Delete_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct signal.Login
class Login(go.GoClass):
	"""Login represents event data for login events, typically carrying QR code information used for\nout-of-band authentication.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Login_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.QRCode = args[0]
			if "QRCode" in kwargs:
				self.QRCode = kwargs["QRCode"]
			if  1 < len(args):
				self.DeviceID = args[1]
			if "DeviceID" in kwargs:
				self.DeviceID = kwargs["DeviceID"]
			if  2 < len(args):
				self.Error = args[2]
			if "Error" in kwargs:
				self.Error = kwargs["Error"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Login{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Login ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def QRCode(self):
		return _signal.signal_Login_QRCode_Get(self.handle)
	@QRCode.setter
	def QRCode(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Login_QRCode_Set(self.handle, value.handle)
		else:
			_signal.signal_Login_QRCode_Set(self.handle, value)
	@property
	def DeviceID(self):
		return _signal.signal_Login_DeviceID_Get(self.handle)
	@DeviceID.setter
	def DeviceID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Login_DeviceID_Set(self.handle, value.handle)
		else:
			_signal.signal_Login_DeviceID_Set(self.handle, value)
	@property
	def Error(self):
		return _signal.signal_Login_Error_Get(self.handle)
	@Error.setter
	def Error(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Login_Error_Set(self.handle, value.handle)
		else:
			_signal.signal_Login_Error_Set(self.handle, value)

# Python type for struct signal.Logout
class Logout(go.GoClass):
	"""Logout represents event data for logout events, either expected (due to unlinking of a device) or\nunexpected (due to upstream errors).\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Logout_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Reason = args[0]
			if "Reason" in kwargs:
				self.Reason = kwargs["Reason"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Logout{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Logout ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Reason(self):
		return _signal.signal_Logout_Reason_Get(self.handle)
	@Reason.setter
	def Reason(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Logout_Reason_Set(self.handle, value.handle)
		else:
			_signal.signal_Logout_Reason_Set(self.handle, value)

# Python type for struct signal.Reply
class Reply(go.GoClass):
	"""A Reply represents a reference to a previous message being replied to, with partial data set.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Reply_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.AuthorID = args[1]
			if "AuthorID" in kwargs:
				self.AuthorID = kwargs["AuthorID"]
			if  2 < len(args):
				self.Body = args[2]
			if "Body" in kwargs:
				self.Body = kwargs["Body"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Reply{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Reply ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ID(self):
		return _signal.signal_Reply_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Reply_ID_Set(self.handle, value.handle)
		else:
			_signal.signal_Reply_ID_Set(self.handle, value)
	@property
	def AuthorID(self):
		return _signal.signal_Reply_AuthorID_Get(self.handle)
	@AuthorID.setter
	def AuthorID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Reply_AuthorID_Set(self.handle, value.handle)
		else:
			_signal.signal_Reply_AuthorID_Set(self.handle, value)
	@property
	def Body(self):
		return _signal.signal_Reply_Body_Get(self.handle)
	@Body.setter
	def Body(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Reply_Body_Set(self.handle, value.handle)
		else:
			_signal.signal_Reply_Body_Set(self.handle, value)

# Python type for struct signal.Avatar
class Avatar(go.GoClass):
	"""A Avatar represents a small image set for a [Contact] or [Group].\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Avatar_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Delete = args[0]
			if "Delete" in kwargs:
				self.Delete = kwargs["Delete"]
			if  1 < len(args):
				self.Data = args[1]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Avatar{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Avatar ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Delete(self):
		return _signal.signal_Avatar_Delete_Get(self.handle)
	@Delete.setter
	def Delete(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Avatar_Delete_Set(self.handle, value.handle)
		else:
			_signal.signal_Avatar_Delete_Set(self.handle, value)
	@property
	def Data(self):
		return go.Slice_byte(handle=_signal.signal_Avatar_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Avatar_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct signal.Connect
class Connect(go.GoClass):
	"""Connect represents event data for connection events, typically carrying connection errors and\nother metadata.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Connect_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.AccountID = args[0]
			if "AccountID" in kwargs:
				self.AccountID = kwargs["AccountID"]
			if  1 < len(args):
				self.PhoneNumber = args[1]
			if "PhoneNumber" in kwargs:
				self.PhoneNumber = kwargs["PhoneNumber"]
			if  2 < len(args):
				self.Error = args[2]
			if "Error" in kwargs:
				self.Error = kwargs["Error"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Connect{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Connect ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def AccountID(self):
		return _signal.signal_Connect_AccountID_Get(self.handle)
	@AccountID.setter
	def AccountID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Connect_AccountID_Set(self.handle, value.handle)
		else:
			_signal.signal_Connect_AccountID_Set(self.handle, value)
	@property
	def PhoneNumber(self):
		return _signal.signal_Connect_PhoneNumber_Get(self.handle)
	@PhoneNumber.setter
	def PhoneNumber(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Connect_PhoneNumber_Set(self.handle, value.handle)
		else:
			_signal.signal_Connect_PhoneNumber_Set(self.handle, value)
	@property
	def Error(self):
		return _signal.signal_Connect_Error_Get(self.handle)
	@Error.setter
	def Error(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Connect_Error_Set(self.handle, value.handle)
		else:
			_signal.signal_Connect_Error_Set(self.handle, value)

# Python type for struct signal.Typing
class Typing(go.GoClass):
	"""Typing contains event data related to typing notifications.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Typing_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.State = args[0]
			if "State" in kwargs:
				self.State = kwargs["State"]
			if  1 < len(args):
				self.SenderID = args[1]
			if "SenderID" in kwargs:
				self.SenderID = kwargs["SenderID"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Typing{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Typing ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def State(self):
		return _signal.signal_Typing_State_Get(self.handle)
	@State.setter
	def State(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Typing_State_Set(self.handle, value.handle)
		else:
			_signal.signal_Typing_State_Set(self.handle, value)
	@property
	def SenderID(self):
		return _signal.signal_Typing_SenderID_Get(self.handle)
	@SenderID.setter
	def SenderID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Typing_SenderID_Set(self.handle, value.handle)
		else:
			_signal.signal_Typing_SenderID_Set(self.handle, value)

# Python type for struct signal.Reaction
class Reaction(go.GoClass):
	"""A Reaction is a quick, emoji response to an existing message. Signal generally allows only a\nsingle reaction to messages, and has special rules around removal of reactions.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Reaction_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Emoji = args[0]
			if "Emoji" in kwargs:
				self.Emoji = kwargs["Emoji"]
			if  1 < len(args):
				self.Remove = args[1]
			if "Remove" in kwargs:
				self.Remove = kwargs["Remove"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Reaction{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Reaction ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Emoji(self):
		return _signal.signal_Reaction_Emoji_Get(self.handle)
	@Emoji.setter
	def Emoji(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Reaction_Emoji_Set(self.handle, value.handle)
		else:
			_signal.signal_Reaction_Emoji_Set(self.handle, value)
	@property
	def Remove(self):
		return _signal.signal_Reaction_Remove_Get(self.handle)
	@Remove.setter
	def Remove(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Reaction_Remove_Set(self.handle, value.handle)
		else:
			_signal.signal_Reaction_Remove_Set(self.handle, value)

# Python type for struct signal.Receipt
class Receipt(go.GoClass):
	"""A Receipt represents a notice of delivery or presentation for [Message] instances sent or\nreceived. Receipts can be delivered for many messages at once, but are generally all delivered\nunder one specific state at a time.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Receipt_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Kind = args[0]
			if "Kind" in kwargs:
				self.Kind = kwargs["Kind"]
			if  1 < len(args):
				self.SenderID = args[1]
			if "SenderID" in kwargs:
				self.SenderID = kwargs["SenderID"]
			if  2 < len(args):
				self.MessageIDs = args[2]
			if "MessageIDs" in kwargs:
				self.MessageIDs = kwargs["MessageIDs"]
			if  3 < len(args):
				self.IsCarbon = args[3]
			if "IsCarbon" in kwargs:
				self.IsCarbon = kwargs["IsCarbon"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Receipt{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Receipt ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Kind(self):
		return _signal.signal_Receipt_Kind_Get(self.handle)
	@Kind.setter
	def Kind(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Receipt_Kind_Set(self.handle, value.handle)
		else:
			_signal.signal_Receipt_Kind_Set(self.handle, value)
	@property
	def SenderID(self):
		return _signal.signal_Receipt_SenderID_Get(self.handle)
	@SenderID.setter
	def SenderID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Receipt_SenderID_Set(self.handle, value.handle)
		else:
			_signal.signal_Receipt_SenderID_Set(self.handle, value)
	@property
	def MessageIDs(self):
		return go.Slice_string(handle=_signal.signal_Receipt_MessageIDs_Get(self.handle))
	@MessageIDs.setter
	def MessageIDs(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Receipt_MessageIDs_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def IsCarbon(self):
		return _signal.signal_Receipt_IsCarbon_Get(self.handle)
	@IsCarbon.setter
	def IsCarbon(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Receipt_IsCarbon_Set(self.handle, value.handle)
		else:
			_signal.signal_Receipt_IsCarbon_Set(self.handle, value)

# Python type for struct signal.Attachment
class Attachment(go.GoClass):
	"""A Attachment represents any binary data provided alongside a [Message], for instance, an image\nor voice message.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Attachment_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.ContentType = args[0]
			if "ContentType" in kwargs:
				self.ContentType = kwargs["ContentType"]
			if  1 < len(args):
				self.Filename = args[1]
			if "Filename" in kwargs:
				self.Filename = kwargs["Filename"]
			if  2 < len(args):
				self.Data = args[2]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Attachment{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Attachment ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ContentType(self):
		return _signal.signal_Attachment_ContentType_Get(self.handle)
	@ContentType.setter
	def ContentType(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Attachment_ContentType_Set(self.handle, value.handle)
		else:
			_signal.signal_Attachment_ContentType_Set(self.handle, value)
	@property
	def Filename(self):
		return _signal.signal_Attachment_Filename_Get(self.handle)
	@Filename.setter
	def Filename(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Attachment_Filename_Set(self.handle, value.handle)
		else:
			_signal.signal_Attachment_Filename_Set(self.handle, value)
	@property
	def Data(self):
		return go.Slice_byte(handle=_signal.signal_Attachment_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Attachment_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct signal.Contact
class Contact(go.GoClass):
	"""A Contact represents any entity that be communicated with directly in Signal. This typically\nrepresents people, but not a group-chat.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Contact_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.PhoneNumber = args[1]
			if "PhoneNumber" in kwargs:
				self.PhoneNumber = kwargs["PhoneNumber"]
			if  2 < len(args):
				self.Name = args[2]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  3 < len(args):
				self.Avatar = args[3]
			if "Avatar" in kwargs:
				self.Avatar = kwargs["Avatar"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Contact{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Contact ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ID(self):
		return _signal.signal_Contact_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Contact_ID_Set(self.handle, value.handle)
		else:
			_signal.signal_Contact_ID_Set(self.handle, value)
	@property
	def PhoneNumber(self):
		return _signal.signal_Contact_PhoneNumber_Get(self.handle)
	@PhoneNumber.setter
	def PhoneNumber(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Contact_PhoneNumber_Set(self.handle, value.handle)
		else:
			_signal.signal_Contact_PhoneNumber_Set(self.handle, value)
	@property
	def Name(self):
		return _signal.signal_Contact_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Contact_Name_Set(self.handle, value.handle)
		else:
			_signal.signal_Contact_Name_Set(self.handle, value)
	@property
	def Avatar(self):
		return Avatar(handle=_signal.signal_Contact_Avatar_Get(self.handle))
	@Avatar.setter
	def Avatar(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Contact_Avatar_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct signal.Delete
class Delete(go.GoClass):
	"""Delete represents a message deletion event, for any type of message.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Delete_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.AuthorID = args[0]
			if "AuthorID" in kwargs:
				self.AuthorID = kwargs["AuthorID"]
			if  1 < len(args):
				self.ChatID = args[1]
			if "ChatID" in kwargs:
				self.ChatID = kwargs["ChatID"]
			if  2 < len(args):
				self.MessageID = args[2]
			if "MessageID" in kwargs:
				self.MessageID = kwargs["MessageID"]
			if  3 < len(args):
				self.IsCarbon = args[3]
			if "IsCarbon" in kwargs:
				self.IsCarbon = kwargs["IsCarbon"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Delete{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Delete ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def AuthorID(self):
		return _signal.signal_Delete_AuthorID_Get(self.handle)
	@AuthorID.setter
	def AuthorID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Delete_AuthorID_Set(self.handle, value.handle)
		else:
			_signal.signal_Delete_AuthorID_Set(self.handle, value)
	@property
	def ChatID(self):
		return _signal.signal_Delete_ChatID_Get(self.handle)
	@ChatID.setter
	def ChatID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Delete_ChatID_Set(self.handle, value.handle)
		else:
			_signal.signal_Delete_ChatID_Set(self.handle, value)
	@property
	def MessageID(self):
		return _signal.signal_Delete_MessageID_Get(self.handle)
	@MessageID.setter
	def MessageID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Delete_MessageID_Set(self.handle, value.handle)
		else:
			_signal.signal_Delete_MessageID_Set(self.handle, value)
	@property
	def IsCarbon(self):
		return _signal.signal_Delete_IsCarbon_Get(self.handle)
	@IsCarbon.setter
	def IsCarbon(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Delete_IsCarbon_Set(self.handle, value.handle)
		else:
			_signal.signal_Delete_IsCarbon_Set(self.handle, value)

# Python type for struct signal.LinkedDevice
class LinkedDevice(go.GoClass):
	"""A LinkedDevice represents a unique pairing session between the gateway and Signal. It is not\nunique to the underlying \"main\" device (or user/phone number), as multiple linked devices may be\npaired with any main device.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_LinkedDevice_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.ArchiveSynced = args[1]
			if "ArchiveSynced" in kwargs:
				self.ArchiveSynced = kwargs["ArchiveSynced"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.LinkedDevice{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.LinkedDevice ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ID(self):
		"""ID is an opaque string identifying this [LinkedDevice] to a [Session]. Noted that this string
		is currently equivalent to a password, and needs to be protected accordingly.
		"""
		return _signal.signal_LinkedDevice_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_LinkedDevice_ID_Set(self.handle, value.handle)
		else:
			_signal.signal_LinkedDevice_ID_Set(self.handle, value)
	@property
	def ArchiveSynced(self):
		"""Whether or not we've previously tried to sync this device from the main device's archive.
		"""
		return _signal.signal_LinkedDevice_ArchiveSynced_Get(self.handle)
	@ArchiveSynced.setter
	def ArchiveSynced(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_LinkedDevice_ArchiveSynced_Set(self.handle, value.handle)
		else:
			_signal.signal_LinkedDevice_ArchiveSynced_Set(self.handle, value)

# Python type for struct signal.Gateway
class Gateway(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Gateway_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.DBPath = args[0]
			if "DBPath" in kwargs:
				self.DBPath = kwargs["DBPath"]
			if  1 < len(args):
				self.Name = args[1]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  2 < len(args):
				self.LogLevel = args[2]
			if "LogLevel" in kwargs:
				self.LogLevel = kwargs["LogLevel"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Gateway{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Gateway ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def DBPath(self):
		"""Common configuration.
		"""
		return _signal.signal_Gateway_DBPath_Get(self.handle)
	@DBPath.setter
	def DBPath(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Gateway_DBPath_Set(self.handle, value.handle)
		else:
			_signal.signal_Gateway_DBPath_Set(self.handle, value)
	@property
	def Name(self):
		return _signal.signal_Gateway_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Gateway_Name_Set(self.handle, value.handle)
		else:
			_signal.signal_Gateway_Name_Set(self.handle, value)
	@property
	def LogLevel(self):
		return _signal.signal_Gateway_LogLevel_Get(self.handle)
	@LogLevel.setter
	def LogLevel(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Gateway_LogLevel_Set(self.handle, value.handle)
		else:
			_signal.signal_Gateway_LogLevel_Set(self.handle, value)
	def Init(self):
		"""Init() str"""
		return _signal.signal_Gateway_Init(self.handle)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewSession(g, d):
	"""NewSession(object g, object d) object
	
	NewSession returns a new, inactive connection to Signal. Sessions are expected to be activated
	via subsequent calls to [Session.Login], which will generally continue out-of-band; see the
	relevant documentation for more details.
	"""
	return Session(handle=_signal.signal_NewSession(g.handle, d.handle))
def NewGateway():
	"""NewGateway() object"""
	return Gateway(handle=_signal.signal_NewGateway())


# ---- Functions ---


