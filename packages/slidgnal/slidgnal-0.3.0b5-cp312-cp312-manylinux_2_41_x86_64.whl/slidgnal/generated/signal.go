/*
cgo stubs for package signal.
File is generated by gopy. Do not edit.
gopy build -output=generated -no-make=true .
*/

package main

/*

#cgo CFLAGS: "-I/root/.local/share/uv/python/cpython-3.12.12-linux-x86_64-gnu/include/python3.12" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/root/.local/share/uv/python/cpython-3.12.12-linux-x86_64-gnu/lib" "-lpython3.12" -lpthread -ldl -lutil -lm

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	signal "codeberg.org/slidge/slidgnal/slidgnal"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: signal below: ---

// ---- External Types Outside of Targeted Packages ---

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: signal ---

// ---- Types ---

// Converters for pointer handles for type: *signal.ArchiveSync
func ptrFromHandle_Ptr_signal_ArchiveSync(h CGoHandle) *signal.ArchiveSync {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.ArchiveSync")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.ArchiveSync{})).(*signal.ArchiveSync)
}
func handleFromPtr_Ptr_signal_ArchiveSync(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.ArchiveSync", p))
}

// Converters for pointer handles for type: *signal.Attachment
func ptrFromHandle_Ptr_signal_Attachment(h CGoHandle) *signal.Attachment {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Attachment")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Attachment{})).(*signal.Attachment)
}
func handleFromPtr_Ptr_signal_Attachment(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Attachment", p))
}

// Converters for pointer handles for type: *signal.Avatar
func ptrFromHandle_Ptr_signal_Avatar(h CGoHandle) *signal.Avatar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Avatar")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Avatar{})).(*signal.Avatar)
}
func handleFromPtr_Ptr_signal_Avatar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Avatar", p))
}

// Converters for pointer handles for type: *signal.Connect
func ptrFromHandle_Ptr_signal_Connect(h CGoHandle) *signal.Connect {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Connect")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Connect{})).(*signal.Connect)
}
func handleFromPtr_Ptr_signal_Connect(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Connect", p))
}

// Converters for pointer handles for type: *signal.Contact
func ptrFromHandle_Ptr_signal_Contact(h CGoHandle) *signal.Contact {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Contact")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Contact{})).(*signal.Contact)
}
func handleFromPtr_Ptr_signal_Contact(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Contact", p))
}

// Converters for pointer handles for type: *signal.Delete
func ptrFromHandle_Ptr_signal_Delete(h CGoHandle) *signal.Delete {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Delete")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Delete{})).(*signal.Delete)
}
func handleFromPtr_Ptr_signal_Delete(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Delete", p))
}

// Converters for pointer handles for type: *signal.EventPayload
func ptrFromHandle_Ptr_signal_EventPayload(h CGoHandle) *signal.EventPayload {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.EventPayload")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.EventPayload{})).(*signal.EventPayload)
}
func handleFromPtr_Ptr_signal_EventPayload(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.EventPayload", p))
}

// Converters for pointer handles for type: *signal.Gateway
func ptrFromHandle_Ptr_signal_Gateway(h CGoHandle) *signal.Gateway {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Gateway")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Gateway{})).(*signal.Gateway)
}
func handleFromPtr_Ptr_signal_Gateway(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Gateway", p))
}

// Converters for pointer handles for type: *signal.LinkedDevice
func ptrFromHandle_Ptr_signal_LinkedDevice(h CGoHandle) *signal.LinkedDevice {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.LinkedDevice")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.LinkedDevice{})).(*signal.LinkedDevice)
}
func handleFromPtr_Ptr_signal_LinkedDevice(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.LinkedDevice", p))
}

// Converters for pointer handles for type: *signal.Login
func ptrFromHandle_Ptr_signal_Login(h CGoHandle) *signal.Login {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Login")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Login{})).(*signal.Login)
}
func handleFromPtr_Ptr_signal_Login(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Login", p))
}

// Converters for pointer handles for type: *signal.Logout
func ptrFromHandle_Ptr_signal_Logout(h CGoHandle) *signal.Logout {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Logout")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Logout{})).(*signal.Logout)
}
func handleFromPtr_Ptr_signal_Logout(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Logout", p))
}

// Converters for pointer handles for type: *signal.Message
func ptrFromHandle_Ptr_signal_Message(h CGoHandle) *signal.Message {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Message")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Message{})).(*signal.Message)
}
func handleFromPtr_Ptr_signal_Message(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Message", p))
}

// Converters for pointer handles for type: *signal.Reaction
func ptrFromHandle_Ptr_signal_Reaction(h CGoHandle) *signal.Reaction {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Reaction")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Reaction{})).(*signal.Reaction)
}
func handleFromPtr_Ptr_signal_Reaction(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Reaction", p))
}

// Converters for pointer handles for type: *signal.Receipt
func ptrFromHandle_Ptr_signal_Receipt(h CGoHandle) *signal.Receipt {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Receipt")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Receipt{})).(*signal.Receipt)
}
func handleFromPtr_Ptr_signal_Receipt(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Receipt", p))
}

// Converters for pointer handles for type: *signal.Reply
func ptrFromHandle_Ptr_signal_Reply(h CGoHandle) *signal.Reply {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Reply")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Reply{})).(*signal.Reply)
}
func handleFromPtr_Ptr_signal_Reply(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Reply", p))
}

// Converters for pointer handles for type: *signal.Session
func ptrFromHandle_Ptr_signal_Session(h CGoHandle) *signal.Session {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Session")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Session{})).(*signal.Session)
}
func handleFromPtr_Ptr_signal_Session(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Session", p))
}

// Converters for pointer handles for type: *signal.Typing
func ptrFromHandle_Ptr_signal_Typing(h CGoHandle) *signal.Typing {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*signal.Typing")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Typing{})).(*signal.Typing)
}
func handleFromPtr_Ptr_signal_Typing(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*signal.Typing", p))
}

// Converters for implicit pointer handles for type: []signal.Attachment
func ptrFromHandle_Slice_signal_Attachment(h CGoHandle) *[]signal.Attachment {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]signal.Attachment")
	if p == nil {
		return nil
	}
	return p.(*[]signal.Attachment)
}
func deptrFromHandle_Slice_signal_Attachment(h CGoHandle) []signal.Attachment {
	p := ptrFromHandle_Slice_signal_Attachment(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_signal_Attachment(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]signal.Attachment", p))
}

// --- wrapping slice: []signal.Attachment ---
//
//export Slice_signal_Attachment_CTor
func Slice_signal_Attachment_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_signal_Attachment(&[]signal.Attachment{}))
}

//export Slice_signal_Attachment_len
func Slice_signal_Attachment_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_signal_Attachment(handle))
}

//export Slice_signal_Attachment_elem
func Slice_signal_Attachment_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_signal_Attachment(handle)
	return handleFromPtr_signal_Attachment(&(s[_idx]))
}

//export Slice_signal_Attachment_subslice
func Slice_signal_Attachment_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_signal_Attachment(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_signal_Attachment(&ss))
}

//export Slice_signal_Attachment_set
func Slice_signal_Attachment_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_signal_Attachment(handle)
	s[_idx] = *ptrFromHandle_signal_Attachment(_vl)
}

//export Slice_signal_Attachment_append
func Slice_signal_Attachment_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_signal_Attachment(handle)
	*s = append(*s, *ptrFromHandle_signal_Attachment(_vl))
}

// Converters for implicit pointer handles for type: []signal.Contact
func ptrFromHandle_Slice_signal_Contact(h CGoHandle) *[]signal.Contact {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]signal.Contact")
	if p == nil {
		return nil
	}
	return p.(*[]signal.Contact)
}
func deptrFromHandle_Slice_signal_Contact(h CGoHandle) []signal.Contact {
	p := ptrFromHandle_Slice_signal_Contact(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_signal_Contact(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]signal.Contact", p))
}

// --- wrapping slice: []signal.Contact ---
//
//export Slice_signal_Contact_CTor
func Slice_signal_Contact_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_signal_Contact(&[]signal.Contact{}))
}

//export Slice_signal_Contact_len
func Slice_signal_Contact_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_signal_Contact(handle))
}

//export Slice_signal_Contact_elem
func Slice_signal_Contact_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_signal_Contact(handle)
	return handleFromPtr_signal_Contact(&(s[_idx]))
}

//export Slice_signal_Contact_subslice
func Slice_signal_Contact_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_signal_Contact(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_signal_Contact(&ss))
}

//export Slice_signal_Contact_set
func Slice_signal_Contact_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_signal_Contact(handle)
	s[_idx] = *ptrFromHandle_signal_Contact(_vl)
}

//export Slice_signal_Contact_append
func Slice_signal_Contact_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_signal_Contact(handle)
	*s = append(*s, *ptrFromHandle_signal_Contact(_vl))
}

// Converters for non-pointer handles for type: signal.ArchiveSync
func ptrFromHandle_signal_ArchiveSync(h CGoHandle) *signal.ArchiveSync {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.ArchiveSync")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.ArchiveSync{})).(*signal.ArchiveSync)
}
func handleFromPtr_signal_ArchiveSync(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.ArchiveSync", p))
}

// Converters for non-pointer handles for type: signal.Attachment
func ptrFromHandle_signal_Attachment(h CGoHandle) *signal.Attachment {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Attachment")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Attachment{})).(*signal.Attachment)
}
func handleFromPtr_signal_Attachment(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Attachment", p))
}

// Converters for non-pointer handles for type: signal.Avatar
func ptrFromHandle_signal_Avatar(h CGoHandle) *signal.Avatar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Avatar")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Avatar{})).(*signal.Avatar)
}
func handleFromPtr_signal_Avatar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Avatar", p))
}

// Converters for non-pointer handles for type: signal.Connect
func ptrFromHandle_signal_Connect(h CGoHandle) *signal.Connect {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Connect")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Connect{})).(*signal.Connect)
}
func handleFromPtr_signal_Connect(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Connect", p))
}

// Converters for non-pointer handles for type: signal.Contact
func ptrFromHandle_signal_Contact(h CGoHandle) *signal.Contact {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Contact")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Contact{})).(*signal.Contact)
}
func handleFromPtr_signal_Contact(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Contact", p))
}

// Converters for non-pointer handles for type: signal.Delete
func ptrFromHandle_signal_Delete(h CGoHandle) *signal.Delete {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Delete")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Delete{})).(*signal.Delete)
}
func handleFromPtr_signal_Delete(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Delete", p))
}

// Converters for non-pointer handles for type: signal.EventPayload
func ptrFromHandle_signal_EventPayload(h CGoHandle) *signal.EventPayload {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.EventPayload")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.EventPayload{})).(*signal.EventPayload)
}
func handleFromPtr_signal_EventPayload(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.EventPayload", p))
}

// Converters for non-pointer handles for type: signal.Gateway
func ptrFromHandle_signal_Gateway(h CGoHandle) *signal.Gateway {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Gateway")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Gateway{})).(*signal.Gateway)
}
func handleFromPtr_signal_Gateway(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Gateway", p))
}

// Converters for non-pointer handles for type: signal.LinkedDevice
func ptrFromHandle_signal_LinkedDevice(h CGoHandle) *signal.LinkedDevice {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.LinkedDevice")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.LinkedDevice{})).(*signal.LinkedDevice)
}
func handleFromPtr_signal_LinkedDevice(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.LinkedDevice", p))
}

// Converters for non-pointer handles for type: signal.Login
func ptrFromHandle_signal_Login(h CGoHandle) *signal.Login {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Login")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Login{})).(*signal.Login)
}
func handleFromPtr_signal_Login(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Login", p))
}

// Converters for non-pointer handles for type: signal.Logout
func ptrFromHandle_signal_Logout(h CGoHandle) *signal.Logout {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Logout")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Logout{})).(*signal.Logout)
}
func handleFromPtr_signal_Logout(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Logout", p))
}

// Converters for non-pointer handles for type: signal.Message
func ptrFromHandle_signal_Message(h CGoHandle) *signal.Message {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Message")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Message{})).(*signal.Message)
}
func handleFromPtr_signal_Message(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Message", p))
}

// Converters for non-pointer handles for type: signal.Reaction
func ptrFromHandle_signal_Reaction(h CGoHandle) *signal.Reaction {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Reaction")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Reaction{})).(*signal.Reaction)
}
func handleFromPtr_signal_Reaction(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Reaction", p))
}

// Converters for non-pointer handles for type: signal.Receipt
func ptrFromHandle_signal_Receipt(h CGoHandle) *signal.Receipt {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Receipt")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Receipt{})).(*signal.Receipt)
}
func handleFromPtr_signal_Receipt(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Receipt", p))
}

// Converters for non-pointer handles for type: signal.Reply
func ptrFromHandle_signal_Reply(h CGoHandle) *signal.Reply {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Reply")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Reply{})).(*signal.Reply)
}
func handleFromPtr_signal_Reply(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Reply", p))
}

// Converters for non-pointer handles for type: signal.Session
func ptrFromHandle_signal_Session(h CGoHandle) *signal.Session {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Session")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Session{})).(*signal.Session)
}
func handleFromPtr_signal_Session(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Session", p))
}

// Converters for non-pointer handles for type: signal.Typing
func ptrFromHandle_signal_Typing(h CGoHandle) *signal.Typing {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "signal.Typing")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(signal.Typing{})).(*signal.Typing)
}
func handleFromPtr_signal_Typing(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("signal.Typing", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: signal.Receipt ---
//
//export signal_Receipt_CTor
func signal_Receipt_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Receipt(&signal.Receipt{}))
}

//export signal_Receipt_Kind_Get
func signal_Receipt_Kind_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_signal_Receipt(handle)
	return C.longlong(int(op.Kind))
}

//export signal_Receipt_Kind_Set
func signal_Receipt_Kind_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_signal_Receipt(handle)
	op.Kind = signal.ReceiptKind(int(val))
}

//export signal_Receipt_SenderID_Get
func signal_Receipt_SenderID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Receipt(handle)
	return C.CString(op.SenderID)
}

//export signal_Receipt_SenderID_Set
func signal_Receipt_SenderID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Receipt(handle)
	op.SenderID = C.GoString(val)
}

//export signal_Receipt_MessageIDs_Get
func signal_Receipt_MessageIDs_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_Receipt(handle)
	return handleFromPtr_Slice_string(&op.MessageIDs)
}

//export signal_Receipt_MessageIDs_Set
func signal_Receipt_MessageIDs_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_Receipt(handle)
	op.MessageIDs = deptrFromHandle_Slice_string(val)
}

//export signal_Receipt_IsCarbon_Get
func signal_Receipt_IsCarbon_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_signal_Receipt(handle)
	return boolGoToPy(op.IsCarbon)
}

//export signal_Receipt_IsCarbon_Set
func signal_Receipt_IsCarbon_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_signal_Receipt(handle)
	op.IsCarbon = boolPyToGo(val)
}

// --- wrapping struct: signal.Avatar ---
//
//export signal_Avatar_CTor
func signal_Avatar_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Avatar(&signal.Avatar{}))
}

//export signal_Avatar_Delete_Get
func signal_Avatar_Delete_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_signal_Avatar(handle)
	return boolGoToPy(op.Delete)
}

//export signal_Avatar_Delete_Set
func signal_Avatar_Delete_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_signal_Avatar(handle)
	op.Delete = boolPyToGo(val)
}

//export signal_Avatar_Data_Get
func signal_Avatar_Data_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_Avatar(handle)
	return handleFromPtr_Slice_byte(&op.Data)
}

//export signal_Avatar_Data_Set
func signal_Avatar_Data_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_Avatar(handle)
	op.Data = deptrFromHandle_Slice_byte(val)
}

// --- wrapping struct: signal.Logout ---
//
//export signal_Logout_CTor
func signal_Logout_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Logout(&signal.Logout{}))
}

//export signal_Logout_Reason_Get
func signal_Logout_Reason_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Logout(handle)
	return C.CString(op.Reason)
}

//export signal_Logout_Reason_Set
func signal_Logout_Reason_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Logout(handle)
	op.Reason = C.GoString(val)
}

// --- wrapping struct: signal.Message ---
//
//export signal_Message_CTor
func signal_Message_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Message(&signal.Message{}))
}

//export signal_Message_Kind_Get
func signal_Message_Kind_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_signal_Message(handle)
	return C.longlong(int(op.Kind))
}

//export signal_Message_Kind_Set
func signal_Message_Kind_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_signal_Message(handle)
	op.Kind = signal.MessageKind(int(val))
}

//export signal_Message_ID_Get
func signal_Message_ID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Message(handle)
	return C.CString(op.ID)
}

//export signal_Message_ID_Set
func signal_Message_ID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Message(handle)
	op.ID = C.GoString(val)
}

//export signal_Message_ChatID_Get
func signal_Message_ChatID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Message(handle)
	return C.CString(op.ChatID)
}

//export signal_Message_ChatID_Set
func signal_Message_ChatID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Message(handle)
	op.ChatID = C.GoString(val)
}

//export signal_Message_SenderID_Get
func signal_Message_SenderID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Message(handle)
	return C.CString(op.SenderID)
}

//export signal_Message_SenderID_Set
func signal_Message_SenderID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Message(handle)
	op.SenderID = C.GoString(val)
}

//export signal_Message_TargetID_Get
func signal_Message_TargetID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Message(handle)
	return C.CString(op.TargetID)
}

//export signal_Message_TargetID_Set
func signal_Message_TargetID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Message(handle)
	op.TargetID = C.GoString(val)
}

//export signal_Message_Body_Get
func signal_Message_Body_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Message(handle)
	return C.CString(op.Body)
}

//export signal_Message_Body_Set
func signal_Message_Body_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Message(handle)
	op.Body = C.GoString(val)
}

//export signal_Message_Timestamp_Get
func signal_Message_Timestamp_Get(handle CGoHandle) C.ulonglong {
	op := ptrFromHandle_signal_Message(handle)
	return C.ulonglong(op.Timestamp)
}

//export signal_Message_Timestamp_Set
func signal_Message_Timestamp_Set(handle CGoHandle, val C.ulonglong) {
	op := ptrFromHandle_signal_Message(handle)
	op.Timestamp = uint64(val)
}

//export signal_Message_IsCarbon_Get
func signal_Message_IsCarbon_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_signal_Message(handle)
	return boolGoToPy(op.IsCarbon)
}

//export signal_Message_IsCarbon_Set
func signal_Message_IsCarbon_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_signal_Message(handle)
	op.IsCarbon = boolPyToGo(val)
}

//export signal_Message_Typing_Get
func signal_Message_Typing_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_Message(handle)
	return handleFromPtr_signal_Typing(&op.Typing)
}

//export signal_Message_Typing_Set
func signal_Message_Typing_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_Message(handle)
	op.Typing = *ptrFromHandle_signal_Typing(val)
}

//export signal_Message_Reaction_Get
func signal_Message_Reaction_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_Message(handle)
	return handleFromPtr_signal_Reaction(&op.Reaction)
}

//export signal_Message_Reaction_Set
func signal_Message_Reaction_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_Message(handle)
	op.Reaction = *ptrFromHandle_signal_Reaction(val)
}

//export signal_Message_ReplyTo_Get
func signal_Message_ReplyTo_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_Message(handle)
	return handleFromPtr_signal_Reply(&op.ReplyTo)
}

//export signal_Message_ReplyTo_Set
func signal_Message_ReplyTo_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_Message(handle)
	op.ReplyTo = *ptrFromHandle_signal_Reply(val)
}

//export signal_Message_Attachments_Get
func signal_Message_Attachments_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_Message(handle)
	return handleFromPtr_Slice_signal_Attachment(&op.Attachments)
}

//export signal_Message_Attachments_Set
func signal_Message_Attachments_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_Message(handle)
	op.Attachments = deptrFromHandle_Slice_signal_Attachment(val)
}

// --- wrapping struct: signal.Reply ---
//
//export signal_Reply_CTor
func signal_Reply_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Reply(&signal.Reply{}))
}

//export signal_Reply_ID_Get
func signal_Reply_ID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Reply(handle)
	return C.CString(op.ID)
}

//export signal_Reply_ID_Set
func signal_Reply_ID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Reply(handle)
	op.ID = C.GoString(val)
}

//export signal_Reply_AuthorID_Get
func signal_Reply_AuthorID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Reply(handle)
	return C.CString(op.AuthorID)
}

//export signal_Reply_AuthorID_Set
func signal_Reply_AuthorID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Reply(handle)
	op.AuthorID = C.GoString(val)
}

//export signal_Reply_Body_Get
func signal_Reply_Body_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Reply(handle)
	return C.CString(op.Body)
}

//export signal_Reply_Body_Set
func signal_Reply_Body_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Reply(handle)
	op.Body = C.GoString(val)
}

// --- wrapping struct: signal.ArchiveSync ---
//
//export signal_ArchiveSync_CTor
func signal_ArchiveSync_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_ArchiveSync(&signal.ArchiveSync{}))
}

//export signal_ArchiveSync_Error_Get
func signal_ArchiveSync_Error_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_ArchiveSync(handle)
	return C.CString(op.Error)
}

//export signal_ArchiveSync_Error_Set
func signal_ArchiveSync_Error_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_ArchiveSync(handle)
	op.Error = C.GoString(val)
}

// --- wrapping struct: signal.Attachment ---
//
//export signal_Attachment_CTor
func signal_Attachment_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Attachment(&signal.Attachment{}))
}

//export signal_Attachment_ContentType_Get
func signal_Attachment_ContentType_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Attachment(handle)
	return C.CString(op.ContentType)
}

//export signal_Attachment_ContentType_Set
func signal_Attachment_ContentType_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Attachment(handle)
	op.ContentType = C.GoString(val)
}

//export signal_Attachment_Filename_Get
func signal_Attachment_Filename_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Attachment(handle)
	return C.CString(op.Filename)
}

//export signal_Attachment_Filename_Set
func signal_Attachment_Filename_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Attachment(handle)
	op.Filename = C.GoString(val)
}

//export signal_Attachment_Data_Get
func signal_Attachment_Data_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_Attachment(handle)
	return handleFromPtr_Slice_byte(&op.Data)
}

//export signal_Attachment_Data_Set
func signal_Attachment_Data_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_Attachment(handle)
	op.Data = deptrFromHandle_Slice_byte(val)
}

// --- wrapping struct: signal.Connect ---
//
//export signal_Connect_CTor
func signal_Connect_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Connect(&signal.Connect{}))
}

//export signal_Connect_AccountID_Get
func signal_Connect_AccountID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Connect(handle)
	return C.CString(op.AccountID)
}

//export signal_Connect_AccountID_Set
func signal_Connect_AccountID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Connect(handle)
	op.AccountID = C.GoString(val)
}

//export signal_Connect_PhoneNumber_Get
func signal_Connect_PhoneNumber_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Connect(handle)
	return C.CString(op.PhoneNumber)
}

//export signal_Connect_PhoneNumber_Set
func signal_Connect_PhoneNumber_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Connect(handle)
	op.PhoneNumber = C.GoString(val)
}

//export signal_Connect_Error_Get
func signal_Connect_Error_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Connect(handle)
	return C.CString(op.Error)
}

//export signal_Connect_Error_Set
func signal_Connect_Error_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Connect(handle)
	op.Error = C.GoString(val)
}

// --- wrapping struct: signal.Gateway ---
//
//export signal_Gateway_CTor
func signal_Gateway_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Gateway(&signal.Gateway{}))
}

//export signal_Gateway_DBPath_Get
func signal_Gateway_DBPath_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Gateway(handle)
	return C.CString(op.DBPath)
}

//export signal_Gateway_DBPath_Set
func signal_Gateway_DBPath_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Gateway(handle)
	op.DBPath = C.GoString(val)
}

//export signal_Gateway_Name_Get
func signal_Gateway_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Gateway(handle)
	return C.CString(op.Name)
}

//export signal_Gateway_Name_Set
func signal_Gateway_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Gateway(handle)
	op.Name = C.GoString(val)
}

//export signal_Gateway_LogLevel_Get
func signal_Gateway_LogLevel_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Gateway(handle)
	return C.CString(op.LogLevel)
}

//export signal_Gateway_LogLevel_Set
func signal_Gateway_LogLevel_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Gateway(handle)
	op.LogLevel = C.GoString(val)
}

//export signal_Gateway_Init
func signal_Gateway_Init(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*signal.Gateway")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(signal.Gateway{})).(*signal.Gateway).Init()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: signal.LinkedDevice ---
//
//export signal_LinkedDevice_CTor
func signal_LinkedDevice_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_LinkedDevice(&signal.LinkedDevice{}))
}

//export signal_LinkedDevice_ID_Get
func signal_LinkedDevice_ID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_LinkedDevice(handle)
	return C.CString(op.ID)
}

//export signal_LinkedDevice_ID_Set
func signal_LinkedDevice_ID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_LinkedDevice(handle)
	op.ID = C.GoString(val)
}

//export signal_LinkedDevice_ArchiveSynced_Get
func signal_LinkedDevice_ArchiveSynced_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_signal_LinkedDevice(handle)
	return boolGoToPy(op.ArchiveSynced)
}

//export signal_LinkedDevice_ArchiveSynced_Set
func signal_LinkedDevice_ArchiveSynced_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_signal_LinkedDevice(handle)
	op.ArchiveSynced = boolPyToGo(val)
}

// --- wrapping struct: signal.Login ---
//
//export signal_Login_CTor
func signal_Login_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Login(&signal.Login{}))
}

//export signal_Login_QRCode_Get
func signal_Login_QRCode_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Login(handle)
	return C.CString(op.QRCode)
}

//export signal_Login_QRCode_Set
func signal_Login_QRCode_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Login(handle)
	op.QRCode = C.GoString(val)
}

//export signal_Login_DeviceID_Get
func signal_Login_DeviceID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Login(handle)
	return C.CString(op.DeviceID)
}

//export signal_Login_DeviceID_Set
func signal_Login_DeviceID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Login(handle)
	op.DeviceID = C.GoString(val)
}

//export signal_Login_Error_Get
func signal_Login_Error_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Login(handle)
	return C.CString(op.Error)
}

//export signal_Login_Error_Set
func signal_Login_Error_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Login(handle)
	op.Error = C.GoString(val)
}

// --- wrapping struct: signal.Contact ---
//
//export signal_Contact_CTor
func signal_Contact_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Contact(&signal.Contact{}))
}

//export signal_Contact_ID_Get
func signal_Contact_ID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Contact(handle)
	return C.CString(op.ID)
}

//export signal_Contact_ID_Set
func signal_Contact_ID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Contact(handle)
	op.ID = C.GoString(val)
}

//export signal_Contact_PhoneNumber_Get
func signal_Contact_PhoneNumber_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Contact(handle)
	return C.CString(op.PhoneNumber)
}

//export signal_Contact_PhoneNumber_Set
func signal_Contact_PhoneNumber_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Contact(handle)
	op.PhoneNumber = C.GoString(val)
}

//export signal_Contact_Name_Get
func signal_Contact_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Contact(handle)
	return C.CString(op.Name)
}

//export signal_Contact_Name_Set
func signal_Contact_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Contact(handle)
	op.Name = C.GoString(val)
}

//export signal_Contact_Avatar_Get
func signal_Contact_Avatar_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_Contact(handle)
	return handleFromPtr_signal_Avatar(&op.Avatar)
}

//export signal_Contact_Avatar_Set
func signal_Contact_Avatar_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_Contact(handle)
	op.Avatar = *ptrFromHandle_signal_Avatar(val)
}

// --- wrapping struct: signal.Delete ---
//
//export signal_Delete_CTor
func signal_Delete_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Delete(&signal.Delete{}))
}

//export signal_Delete_AuthorID_Get
func signal_Delete_AuthorID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Delete(handle)
	return C.CString(op.AuthorID)
}

//export signal_Delete_AuthorID_Set
func signal_Delete_AuthorID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Delete(handle)
	op.AuthorID = C.GoString(val)
}

//export signal_Delete_ChatID_Get
func signal_Delete_ChatID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Delete(handle)
	return C.CString(op.ChatID)
}

//export signal_Delete_ChatID_Set
func signal_Delete_ChatID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Delete(handle)
	op.ChatID = C.GoString(val)
}

//export signal_Delete_MessageID_Get
func signal_Delete_MessageID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Delete(handle)
	return C.CString(op.MessageID)
}

//export signal_Delete_MessageID_Set
func signal_Delete_MessageID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Delete(handle)
	op.MessageID = C.GoString(val)
}

//export signal_Delete_IsCarbon_Get
func signal_Delete_IsCarbon_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_signal_Delete(handle)
	return boolGoToPy(op.IsCarbon)
}

//export signal_Delete_IsCarbon_Set
func signal_Delete_IsCarbon_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_signal_Delete(handle)
	op.IsCarbon = boolPyToGo(val)
}

// --- wrapping struct: signal.EventPayload ---
//
//export signal_EventPayload_CTor
func signal_EventPayload_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_EventPayload(&signal.EventPayload{}))
}

//export signal_EventPayload_Login_Get
func signal_EventPayload_Login_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_EventPayload(handle)
	return handleFromPtr_signal_Login(&op.Login)
}

//export signal_EventPayload_Login_Set
func signal_EventPayload_Login_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_EventPayload(handle)
	op.Login = *ptrFromHandle_signal_Login(val)
}

//export signal_EventPayload_Logout_Get
func signal_EventPayload_Logout_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_EventPayload(handle)
	return handleFromPtr_signal_Logout(&op.Logout)
}

//export signal_EventPayload_Logout_Set
func signal_EventPayload_Logout_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_EventPayload(handle)
	op.Logout = *ptrFromHandle_signal_Logout(val)
}

//export signal_EventPayload_ArchiveSync_Get
func signal_EventPayload_ArchiveSync_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_EventPayload(handle)
	return handleFromPtr_signal_ArchiveSync(&op.ArchiveSync)
}

//export signal_EventPayload_ArchiveSync_Set
func signal_EventPayload_ArchiveSync_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_EventPayload(handle)
	op.ArchiveSync = *ptrFromHandle_signal_ArchiveSync(val)
}

//export signal_EventPayload_Connect_Get
func signal_EventPayload_Connect_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_EventPayload(handle)
	return handleFromPtr_signal_Connect(&op.Connect)
}

//export signal_EventPayload_Connect_Set
func signal_EventPayload_Connect_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_EventPayload(handle)
	op.Connect = *ptrFromHandle_signal_Connect(val)
}

//export signal_EventPayload_Contact_Get
func signal_EventPayload_Contact_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_EventPayload(handle)
	return handleFromPtr_signal_Contact(&op.Contact)
}

//export signal_EventPayload_Contact_Set
func signal_EventPayload_Contact_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_EventPayload(handle)
	op.Contact = *ptrFromHandle_signal_Contact(val)
}

//export signal_EventPayload_Message_Get
func signal_EventPayload_Message_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_EventPayload(handle)
	return handleFromPtr_signal_Message(&op.Message)
}

//export signal_EventPayload_Message_Set
func signal_EventPayload_Message_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_EventPayload(handle)
	op.Message = *ptrFromHandle_signal_Message(val)
}

//export signal_EventPayload_Typing_Get
func signal_EventPayload_Typing_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_EventPayload(handle)
	return handleFromPtr_signal_Typing(&op.Typing)
}

//export signal_EventPayload_Typing_Set
func signal_EventPayload_Typing_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_EventPayload(handle)
	op.Typing = *ptrFromHandle_signal_Typing(val)
}

//export signal_EventPayload_Receipt_Get
func signal_EventPayload_Receipt_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_EventPayload(handle)
	return handleFromPtr_signal_Receipt(&op.Receipt)
}

//export signal_EventPayload_Receipt_Set
func signal_EventPayload_Receipt_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_EventPayload(handle)
	op.Receipt = *ptrFromHandle_signal_Receipt(val)
}

//export signal_EventPayload_Delete_Get
func signal_EventPayload_Delete_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_signal_EventPayload(handle)
	return handleFromPtr_signal_Delete(&op.Delete)
}

//export signal_EventPayload_Delete_Set
func signal_EventPayload_Delete_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_signal_EventPayload(handle)
	op.Delete = *ptrFromHandle_signal_Delete(val)
}

// --- wrapping struct: signal.Session ---
//
//export signal_Session_CTor
func signal_Session_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Session(&signal.Session{}))
}

//export signal_Session_Login
func signal_Session_Login(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*signal.Session")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(signal.Session{})).(*signal.Session).Login()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export signal_Session_Logout
func signal_Session_Logout(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*signal.Session")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(signal.Session{})).(*signal.Session).Logout()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export signal_Session_Disconnect
func signal_Session_Disconnect(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*signal.Session")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(signal.Session{})).(*signal.Session).Disconnect()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export signal_Session_SendMessage
func signal_Session_SendMessage(_handle CGoHandle, message CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*signal.Session")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(signal.Session{})).(*signal.Session).SendMessage(*ptrFromHandle_signal_Message(message))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export signal_Session_SendTyping
func signal_Session_SendTyping(_handle CGoHandle, typing CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*signal.Session")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(signal.Session{})).(*signal.Session).SendTyping(*ptrFromHandle_signal_Typing(typing))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export signal_Session_SendReceipt
func signal_Session_SendReceipt(_handle CGoHandle, receipt CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*signal.Session")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(signal.Session{})).(*signal.Session).SendReceipt(*ptrFromHandle_signal_Receipt(receipt))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export signal_Session_SendDelete
func signal_Session_SendDelete(_handle CGoHandle, delete CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*signal.Session")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(signal.Session{})).(*signal.Session).SendDelete(*ptrFromHandle_signal_Delete(delete))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export signal_Session_GetBackupContacts
func signal_Session_GetBackupContacts(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*signal.Session")
	if __err != nil {
		return handleFromPtr_Slice_signal_Contact(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(signal.Session{})).(*signal.Session).GetBackupContacts()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_signal_Contact(nil)
	}
	return handleFromPtr_Slice_signal_Contact(&cret)
}

//export signal_Session_GetContact
func signal_Session_GetContact(_handle CGoHandle, id *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*signal.Session")
	if __err != nil {
		return handleFromPtr_signal_Contact(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(signal.Session{})).(*signal.Session).GetContact(C.GoString(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_signal_Contact(nil)
	}
	return handleFromPtr_signal_Contact(&cret)
}

//export signal_Session_SetEventHandler
func signal_Session_SetEventHandler(_handle CGoHandle, h *C.PyObject, goRun C.char) {
	_fun_arg := h
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*signal.Session")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(signal.Session{})).(*signal.Session).SetEventHandler(func(arg_0 signal.EventKind, arg_1 *signal.EventPayload) {
			if C.PyCallable_Check(_fun_arg) == 0 {
				return
			}
			_gstate := C.PyGILState_Ensure()
			_fcargs := C.PyTuple_New(2)
			C.PyTuple_SetItem(_fcargs, 0, C.gopy_build_int64(C.int64_t(arg_0)))
			C.PyTuple_SetItem(_fcargs, 1, C.gopy_build_int64(C.int64_t(handleFromPtr_Ptr_signal_EventPayload(arg_1))))
			C.PyObject_CallObject(_fun_arg, _fcargs)
			C.gopy_decref(_fcargs)
			C.gopy_err_handle()
			C.PyGILState_Release(_gstate)
		})
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(signal.Session{})).(*signal.Session).SetEventHandler(func(arg_0 signal.EventKind, arg_1 *signal.EventPayload) {
			if C.PyCallable_Check(_fun_arg) == 0 {
				return
			}
			_gstate := C.PyGILState_Ensure()
			_fcargs := C.PyTuple_New(2)
			C.PyTuple_SetItem(_fcargs, 0, C.gopy_build_int64(C.int64_t(arg_0)))
			C.PyTuple_SetItem(_fcargs, 1, C.gopy_build_int64(C.int64_t(handleFromPtr_Ptr_signal_EventPayload(arg_1))))
			C.PyObject_CallObject(_fun_arg, _fcargs)
			C.gopy_decref(_fcargs)
			C.gopy_err_handle()
			C.PyGILState_Release(_gstate)
		})
	}
}

// --- wrapping struct: signal.Typing ---
//
//export signal_Typing_CTor
func signal_Typing_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Typing(&signal.Typing{}))
}

//export signal_Typing_State_Get
func signal_Typing_State_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_signal_Typing(handle)
	return C.longlong(int(op.State))
}

//export signal_Typing_State_Set
func signal_Typing_State_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_signal_Typing(handle)
	op.State = signal.TypingState(int(val))
}

//export signal_Typing_SenderID_Get
func signal_Typing_SenderID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Typing(handle)
	return C.CString(op.SenderID)
}

//export signal_Typing_SenderID_Set
func signal_Typing_SenderID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Typing(handle)
	op.SenderID = C.GoString(val)
}

// --- wrapping struct: signal.Reaction ---
//
//export signal_Reaction_CTor
func signal_Reaction_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_signal_Reaction(&signal.Reaction{}))
}

//export signal_Reaction_Emoji_Get
func signal_Reaction_Emoji_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_signal_Reaction(handle)
	return C.CString(op.Emoji)
}

//export signal_Reaction_Emoji_Set
func signal_Reaction_Emoji_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_signal_Reaction(handle)
	op.Emoji = C.GoString(val)
}

//export signal_Reaction_Remove_Get
func signal_Reaction_Remove_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_signal_Reaction(handle)
	return boolGoToPy(op.Remove)
}

//export signal_Reaction_Remove_Set
func signal_Reaction_Remove_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_signal_Reaction(handle)
	op.Remove = boolPyToGo(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export signal_NewGateway
func signal_NewGateway() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_signal_Gateway(signal.NewGateway())

}

//export signal_NewSession
func signal_NewSession(g CGoHandle, d CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_signal_Session(signal.NewSession(ptrFromHandle_Ptr_signal_Gateway(g), *ptrFromHandle_signal_LinkedDevice(d)))

}

// ---- Functions ---
