# -*- coding: utf-8 -*-
import typing

# Import specific members from typing used in hints
from typing import (
    Any,
    Callable,
    Dict,
    FrozenSet,
    Generic,
    Iterable,
    Iterator,
    List,
    Mapping,
    Optional,
    Sequence,
    Set,
    Tuple,
    TypeVar,
    Union,
    overload,
)

import datetime
from enum import Enum

from mh_operator.SDK import Agilent, System

# Discovered Generic TypeVars:
T = TypeVar("T")
TKey = TypeVar("TKey")
TValue = TypeVar("TValue")

# Stubs for namespace: System.util.collections

class HashSet2(Generic[T], Iterable[Any], Sequence[T], Iterable[T]):  # Class
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, set: Iterable[T]) -> None: ...

    Count: int  # readonly
    IsReadOnly: bool  # readonly

    def GetEnumerator(self) -> Iterator[T]: ...
    def Contains(self, item: T) -> bool: ...
    def CopyTo(self, array: List[T], arrayIndex: int) -> None: ...
    def Add(self, item: T) -> None: ...
    def AddAll(self, set: Iterable[T]) -> None: ...
    def Clear(self) -> None: ...
    def Remove(self, item: T) -> bool: ...
    def IsEmpty(self) -> bool: ...
    def RetainAll(self, collection: Sequence[T]) -> bool: ...

class LinkedDictionary(
    Generic[TKey, TValue],
    Iterable[System.Collections.Generic.KeyValuePair[TKey, TValue]],
    Sequence[System.Collections.Generic.KeyValuePair[TKey, TValue]],
    Iterable[Any],
    Dict[TKey, TValue],
):  # Class
    def __init__(self) -> None: ...
    def __getitem__(self, key: TKey) -> TValue: ...
    def __setitem__(self, key: TKey, value_: TValue) -> None: ...
    Keys: Sequence[TKey]  # readonly
    Values: Sequence[TValue]  # readonly

    def TryGetValue(self, key: TKey, value_: TValue) -> bool: ...
    def Add(self, key: TKey, value_: TValue) -> None: ...
    def ContainsKey(self, key: TKey) -> bool: ...
    def Remove(self, key: TKey) -> bool: ...

    # Nested Types

    class KeyCollection(
        Generic[TKey, TValue], Iterable[Any], Iterable[TKey], Sequence[TKey]
    ):  # Class
        def __init__(
            self,
            link: System.Collections.Generic.LinkedList[
                System.Collections.Generic.KeyValuePair[TKey, TValue]
            ],
            dic: Dict[
                TKey,
                System.Collections.Generic.LinkedListNode[
                    System.Collections.Generic.KeyValuePair[TKey, TValue]
                ],
            ],
        ) -> None: ...

        Count: int  # readonly
        IsReadOnly: bool  # readonly

        def GetEnumerator(self) -> Iterator[TKey]: ...
        def Contains(self, item: TKey) -> bool: ...
        def CopyTo(self, array: List[TKey], arrayIndex: int) -> None: ...
        def Add(self, item: TKey) -> None: ...
        def Clear(self) -> None: ...
        def Remove(self, item: TKey) -> bool: ...

        # Nested Types

        class Enumerator(
            Generic[TKey, TValue], Iterator[Any], System.IDisposable, Iterator[TKey]
        ):  # Struct
            def __init__(
                self,
                link: System.Collections.Generic.LinkedList[
                    System.Collections.Generic.KeyValuePair[TKey, TValue]
                ],
            ) -> None: ...

            Current: TKey  # readonly

            def MoveNext(self) -> bool: ...
            def Reset(self) -> None: ...
            def Dispose(self) -> None: ...

    class ValueCollection(
        Generic[TKey, TValue], Iterable[Any], Sequence[TValue], Iterable[TValue]
    ):  # Class
        def __init__(
            self,
            link: System.Collections.Generic.LinkedList[
                System.Collections.Generic.KeyValuePair[TKey, TValue]
            ],
        ) -> None: ...

        Count: int  # readonly
        IsReadOnly: bool  # readonly

        def GetEnumerator(self) -> Iterator[TValue]: ...
        def Contains(self, item: TValue) -> bool: ...
        def CopyTo(self, array: List[TValue], arrayIndex: int) -> None: ...
        def Add(self, item: TValue) -> None: ...
        def Clear(self) -> None: ...
        def Remove(self, item: TValue) -> bool: ...

        # Nested Types

        class Enumerator(
            Generic[TKey, TValue], Iterator[Any], System.IDisposable, Iterator[TValue]
        ):  # Struct
            def __init__(
                self,
                link: System.Collections.Generic.LinkedList[
                    System.Collections.Generic.KeyValuePair[TKey, TValue]
                ],
            ) -> None: ...

            Current: TValue  # readonly

            def MoveNext(self) -> bool: ...
            def Reset(self) -> None: ...
            def Dispose(self) -> None: ...

class OrderedTree:  # Class
    def __init__(self) -> None: ...

    Count: int  # readonly
    def __getitem__(self, key: System.IComparable) -> Any: ...
    def __setitem__(self, key: System.IComparable, value_: Any) -> None: ...
    Keys: System.util.collections.OrderedTreeEnumerator  # readonly
    Values: System.util.collections.OrderedTreeEnumerator  # readonly

    def GetEnumerator(self) -> System.util.collections.OrderedTreeEnumerator: ...
    def RemoveMax(self) -> None: ...
    def GetMaxKey(self) -> System.IComparable: ...
    def RemoveMin(self) -> None: ...
    def Add(self, key: System.IComparable, data: Any) -> None: ...
    @overload
    def Elements(self) -> System.util.collections.OrderedTreeEnumerator: ...
    @overload
    def Elements(
        self, ascending: bool
    ) -> System.util.collections.OrderedTreeEnumerator: ...
    def GetMaxValue(self) -> Any: ...
    def GetMinKey(self) -> System.IComparable: ...
    def GetMinValue(self) -> Any: ...
    def RotateLeft(self, x: System.util.collections.OrderedTreeNode) -> None: ...
    def GetData(self, key: System.IComparable) -> Any: ...
    def Clear(self) -> None: ...
    def ContainsKey(self, key: System.IComparable) -> bool: ...
    def Remove(self, key: System.IComparable) -> None: ...
    def IsEmpty(self) -> bool: ...
    def KeyElements(
        self, ascending: bool
    ) -> System.util.collections.OrderedTreeEnumerator: ...
    def RotateRight(self, x: System.util.collections.OrderedTreeNode) -> None: ...

class OrderedTreeEnumerator(Iterator[Any]):  # Class
    def __init__(
        self,
        tnode: System.util.collections.OrderedTreeNode,
        keys: bool,
        ascending: bool,
        sentinelNode: System.util.collections.OrderedTreeNode,
    ) -> None: ...

    Current: Any  # readonly
    Key: System.IComparable
    Value: Any

    def GetEnumerator(self) -> System.util.collections.OrderedTreeEnumerator: ...
    def Reset(self) -> None: ...
    def HasMoreElements(self) -> bool: ...
    def MoveNext(self) -> bool: ...
    def NextElement(self) -> Any: ...

class OrderedTreeNode:  # Class
    def __init__(self) -> None: ...

    BLACK: bool = ...  # static # readonly
    RED: bool = ...  # static # readonly

    Color: bool
    Data: Any
    Key: System.IComparable
    Left: System.util.collections.OrderedTreeNode
    Parent: System.util.collections.OrderedTreeNode
    Right: System.util.collections.OrderedTreeNode

class ReadOnlyDictionary(
    Generic[TKey, TValue],
    Sequence[System.Collections.Generic.KeyValuePair[TKey, TValue]],
    Dict[TKey, TValue],
    Iterable[Any],
    Sequence[Any],
    Iterable[System.Collections.Generic.KeyValuePair[TKey, TValue]],
):  # Class
    def __init__(self, dictionaryToWrap: Dict[TKey, TValue]) -> None: ...

    Count: int  # readonly
    def __getitem__(self, key: TKey) -> TValue: ...
    def __setitem__(self, key: TKey, value_: TValue) -> None: ...
    Keys: Sequence[TKey]  # readonly
    Values: Sequence[TValue]  # readonly

    def TryGetValue(self, key: TKey, value_: TValue) -> bool: ...
    def ContainsKey(self, key: TKey) -> bool: ...
