# -*- coding: utf-8 -*-
import typing

# Import specific members from typing used in hints
from typing import (
    Any,
    Callable,
    Dict,
    FrozenSet,
    Generic,
    Iterable,
    Iterator,
    List,
    Mapping,
    Optional,
    Sequence,
    Set,
    Tuple,
    TypeVar,
    Union,
    overload,
)

import datetime
from enum import Enum

from mh_operator.SDK import Agilent, System

from . import UI, Common, ComplianceConfiguration, Properties

# Discovered Generic TypeVars:
T = TypeVar("T")
from . import ProgressEventArgs
from .Compliance import (
    AuditTrailDataSet,
    IAuditTrail,
    IBatchFileService,
    ICommandPermission,
    ICompliance,
    IComplianceCommand,
    IDataStorage,
    IFileInfo,
    IImpersonationContext,
    ILogonECM,
    IReportCompliance,
    IReportFileService,
    IRevisionHistory,
    IUnknownsFileService,
)
from .ComplianceUI import (
    FileDialogMode,
    IBatchDialog,
    IComplianceConfigurationEdit,
    IComplianceUI,
    IFileAndFolderDialog,
    IFileDialog,
    IFolderDialog,
    ILibraryDialog,
    ILogonDialog,
    IMethodDialog,
    ISampleFileDialog,
    IUnknownsFileDialog,
)

# Stubs for namespace: Agilent.MassSpectrometry.DataAnalysis.Quantitative.DataStorageECM

class AuditTrail(IAuditTrail, System.IDisposable):  # Class
    def __init__(self) -> None: ...

    AlwaysAuditTrail: bool  # readonly
    IsAuditTrailing: bool  # readonly
    IsReadOnly: bool  # readonly

    def LockAuditTrail(self) -> AuditTrailDataSet: ...
    def SaveAuditTrail(self) -> None: ...
    def UnlockAuditTrail(self) -> None: ...
    def Dispose(self) -> None: ...
    def AddEntry(
        self, command: IComplianceCommand, exception: System.Exception
    ) -> None: ...

class BatchFileService(IBatchFileService, System.IDisposable):  # Class
    DefaultDataFolder: str  # readonly

    def BeforeNewBatch(
        self, batchFolder: str, batchFile: str, auditTrail: bool
    ) -> None: ...
    def TranslateMethodToLocalPath(
        self, methodPath: str, revisionNumber: str
    ) -> str: ...
    def AfterNewBatch(self, error: bool) -> None: ...
    def AfterOpenBatch(self, error: bool) -> None: ...
    def UploadMethod(self, pathName: str, revisionNumber: str) -> None: ...
    def CheckoutBatch(self, batchFolder: str, batchFile: str) -> None: ...
    def Dispose(self) -> None: ...
    def AfterSaveBatchAs(self, batchHashCode: str, hasError: bool) -> None: ...
    def BeforeClose(self) -> None: ...
    def PrepareLibrary(self, libraryPath: str, revisionNumber: str) -> None: ...
    def GetSampleFileNames(self, batchFolder: str) -> List[str]: ...
    def MethodExists(self, methodPath: str) -> bool: ...
    def BatchFileExists(self, batchFolder: str, batchFile: str) -> bool: ...
    def AfterSaveBatch(self, batchHashCode: str, hasError: bool) -> None: ...
    def UndoCheckoutBatch(self, batchFolder: str, batchFile: str) -> None: ...
    def BeforeOpenBatch(
        self, batchFolder: str, batchFile: str, readOnly: bool, revisionNumber: str
    ) -> None: ...
    def GetBatchFiles(self, folder: str) -> List[str]: ...
    def GetLatestMethodRevisionNumber(self, methodPath: str) -> str: ...
    def GetSampleInfo(self, samplePath: str) -> Dict[str, Any]: ...
    def LibraryExists(self, libraryPath: str) -> bool: ...
    def TranslateBatchToLocalPath(self, batchFile: str, revisionNumber: str) -> str: ...
    def GetMethodHistory(self, pathName: str) -> Iterable[IRevisionHistory]: ...
    def BeforeSaveBatchAs(self, batchFolder: str, batchFile: str) -> None: ...
    def GetLatestLibraryRevisionNumber(self, libraryPath: str) -> str: ...
    def GetBatchFileInfos(self, folder: str) -> List[IFileInfo]: ...
    def IsMethodFolder(self, methodPath: str) -> bool: ...
    def AfterClose(self, hasError: bool) -> None: ...
    def UploadLibrary(self, libraryPath: str, revisionNumber: str) -> None: ...
    def IsBatchCheckedoutByCurrentUser(
        self, batchFolder: str, batchFile: str
    ) -> bool: ...
    def BeforeSaveBatch(self) -> None: ...
    def AfterCloseMethod(self, methodPath: str) -> None: ...
    def PrepareMethod(self, methodPath: str, revisionNumber: str) -> None: ...
    def SampleFileExists(self, samplePath: str) -> bool: ...
    def GetBatchFilePath(self, batchFolder: str, batchFile: str) -> str: ...
    def PrepareSamples(self, samples: List[str]) -> None: ...
    def PrepareBatch(
        self, batchFolder: str, batchFile: str, progress: System.Action[int, int, str]
    ) -> None: ...
    def GetLatestBatchRevisionNumber(self, batchFolder: str, batchFile: str) -> str: ...

    Progress: System.EventHandler[ProgressEventArgs]  # Event

class CommandPermission(
    IReportCompliance, ICommandPermission, System.IDisposable
):  # Class
    CommandConfigurationKey: str = ...  # static # readonly
    CommandConfigurationKey_3x: str = ...  # static # readonly
    PrivilegeGroupPrefix_5x: str = ...  # static # readonly
    PrivilegePrefix_5x: str = ...  # static # readonly
    RolePrefix_5x: str = ...  # static # readonly

    CommandReason: str
    IsInCommandGroup: bool  # readonly
    Reporting: bool
    UserValidated: bool  # readonly
    UserValidationExecuted: bool

    def UserValidationRequiredCore(self, commandName: str) -> bool: ...
    @overload
    def CheckPreCommandCondition(self, command: IComplianceCommand) -> None: ...
    @overload
    def CheckPreCommandCondition(self, commandName: str) -> None: ...
    def BeginCommandGroup(self) -> None: ...
    def CommandReasonRequiredCore(self, commandName: str) -> bool: ...
    @overload
    def DemandPermission(self, commandName: str) -> None: ...
    @overload
    def DemandPermission(self, command: IComplianceCommand) -> None: ...
    def EndCommandGroup(self) -> None: ...
    def CommandReasonRequired(self, commandName: str) -> bool: ...
    @overload
    def HasPermission(self, commandName: str) -> bool: ...
    @overload
    def HasPermission(self, command: IComplianceCommand) -> bool: ...
    def ValidateUser(
        self, user: str, password: System.Security.SecureString
    ) -> None: ...
    def Dispose(self) -> None: ...
    def UserValidationRequired(self, commandName: str) -> bool: ...

    CommandGroupEnded: System.EventHandler  # Event
    CommandGroupStarted: System.EventHandler  # Event

class ComplianceECM(System.IDisposable, ILogonECM, IComplianceUI, ICompliance):  # Class
    def __init__(self) -> None: ...

    AuditTrail: IAuditTrail  # readonly
    BatchFileService: IBatchFileService  # readonly
    CommandPermission: ICommandPermission  # readonly
    Compliance: ICompliance  # readonly
    CurrentCommand: IComplianceCommand  # readonly
    DataStorage: IDataStorage  # readonly
    DisplayName: str  # readonly
    IsActive: bool  # readonly
    IsLocal: bool  # readonly
    LogonInfo: str  # readonly
    LogonRequired: bool  # readonly
    Name: str  # readonly
    ReportFileService: IReportFileService  # readonly
    Server: str  # readonly
    UnknownsFileService: IUnknownsFileService  # readonly
    UserName: str  # readonly
    Version: str  # readonly

    def CreateFileDialog(self, mode: FileDialogMode) -> IFileDialog: ...
    def SetupUpdateActivity(self) -> None: ...
    def CommandStart(self, command: IComplianceCommand) -> None: ...
    def GetUI(self) -> T: ...
    def LogonXml(self, xml: str) -> None: ...
    def CreateLogonDialog(self) -> ILogonDialog: ...
    def Dispose(self) -> None: ...
    @overload
    def Connect(self, compliance: ICompliance) -> None: ...
    @overload
    def Connect(self, token: str) -> None: ...
    def CreateMethodDialog(self, mode: FileDialogMode) -> IMethodDialog: ...
    def InitQuantCommandPermission(self) -> None: ...
    def CheckConnection(self) -> None: ...
    def CreateBatchDialog(self, mode: FileDialogMode) -> IBatchDialog: ...
    def CreateFileAndFolderDialog(
        self, mode: FileDialogMode
    ) -> IFileAndFolderDialog: ...
    def GetECM(self) -> Any: ...
    def CreateUnknownsFileDialog(self, mode: FileDialogMode) -> IUnknownsFileDialog: ...
    def CreateLibraryDialog(self, mode: FileDialogMode) -> ILibraryDialog: ...
    def Logon(
        self,
        server: str,
        domain: str,
        user: str,
        password: System.Security.SecureString,
        accountName: str,
    ) -> None: ...
    def GetToken(self) -> str: ...
    def CreateComplianceConfigurationEdit(self) -> IComplianceConfigurationEdit: ...
    def ValidateUser(
        self, username: str, password: System.Security.SecureString
    ) -> None: ...
    def CreateSampleFileDialog(self) -> ISampleFileDialog: ...
    def GetService(self) -> T: ...
    def CommandEnd(self, command: IComplianceCommand) -> None: ...
    def Impersonate(self) -> IImpersonationContext: ...
    def CreateFolderDialog(self) -> IFolderDialog: ...

class DataStorage(System.IDisposable, IDataStorage):  # Class
    def __init__(
        self,
        compliance: Agilent.MassSpectrometry.DataAnalysis.Quantitative.DataStorageECM.ComplianceECM,
    ) -> None: ...

    InitialRevisionNumber: str  # readonly
    IsRevisionSupported: bool  # readonly
    OpenFolderSupported: bool  # readonly
    PathSeparator: str  # readonly

    def GetLatestRevisionNumber(self, path: str) -> str: ...
    @overload
    def UploadFile(self, pathName: str) -> None: ...
    @overload
    def UploadFile(self, pathName: str, revisionNumber: str) -> None: ...
    def Combine(self, paths: List[str]) -> str: ...
    @overload
    def DownloadFile(self, pathName: str) -> None: ...
    @overload
    def DownloadFile(self, pathName: str, revisionNumber: str) -> None: ...
    def GetFiles(self, folder: str, searchPattern: str) -> List[str]: ...
    def GetFolderPathName(self, pathName: str) -> str: ...
    def GetFileName(self, pathName: str) -> str: ...
    def GetHistory(self, pathName: str) -> Iterable[IRevisionHistory]: ...
    def GetNextRevisionNumber(self, path: str) -> str: ...
    def InitFolders(self) -> None: ...
    @overload
    def TranslateToLocalPath(self, path: str) -> str: ...
    @overload
    def TranslateToLocalPath(self, path: str, revisionNumber: str) -> str: ...
    @staticmethod
    def ExtractZippedFolder(zipFilePath: str, destinationFolder: str) -> None: ...
    @staticmethod
    def GetSingleTopFolder(zarchive: System.IO.Compression.ZipArchive) -> str: ...
    def FileExists(self, path: str) -> bool: ...
    def GetFileInfos(self, folder: str, searchPattern: str) -> List[IFileInfo]: ...
    def OpenFolder(self, folderPath: str) -> None: ...
    def Dispose(self) -> None: ...
    @staticmethod
    def IsMustangFile(
        zipFilePath: str, zarchive: System.IO.Compression.ZipArchive
    ) -> bool: ...
    def FolderExists(self, path: str) -> bool: ...
    def GetFolders(self, folder: str, searchPattern: str) -> List[str]: ...

class ImpersonateContext(System.IDisposable, IImpersonationContext):  # Class
    def Dispose(self) -> None: ...

class ReportFileService(IReportFileService, System.IDisposable):  # Class
    def DownloadFolderToWorkArea(self, path: str) -> None: ...
    def OpenFile(self, path: str) -> None: ...
    def DownloadFileToWorkArea(self, path: str) -> None: ...
    def UploadFileFromWorkArea(self, path: str) -> None: ...
    def GetDefaultOutputFolder(self, batchFolder: str, batchFile: str) -> str: ...
    def Print(self, path: str, printer: str) -> None: ...
    def TranslateToWorkPath(self, path: str) -> str: ...
    def DownloadFileAndUnzipToWorkArea(self, path: str) -> None: ...
    def Dispose(self) -> None: ...

class RevisionHistory(IRevisionHistory):  # Class
    def __init__(self) -> None: ...

    Date: Optional[System.DateTime]
    Reason: str
    RevisionNumber: str
    User: str

class UnknownsFileService(System.IDisposable, IUnknownsFileService):  # Class
    def GetAnalysisFilePath(self, batchFolder: str, analysisFile: str) -> str: ...
    def GetLatestAnalysisRevision(self, batchFolder: str, analysisFile: str) -> str: ...
    def AnalysisFileExists(self, batchFolder: str, analysisFile: str) -> bool: ...
    def TranslateAnalysisToLocalPath(self, path: str, revisionNumber: str) -> str: ...
    def DownloadAnalysisFile(
        self, batchFolder: str, analysisFile: str, revisionNumber: str
    ) -> None: ...
    def CheckoutAnalysis(self, batchFolder: str, analysisFile: str) -> None: ...
    def GetAnalysisFileInfos(self, folder: str) -> List[IFileInfo]: ...
    def UploadAnalysisFile(
        self, batchFolder: str, analysisFile: str, revisionNumber: str
    ) -> None: ...
    def UndoCheckoutAnalysis(self, batchFolder: str, analysisFile: str) -> None: ...
    def IsAnalysisCheckedoutByCurrentUser(
        self, batchFolder: str, analysisFile: str
    ) -> bool: ...
    def Dispose(self) -> None: ...
    def GetAnalysisFiles(self, folder: str) -> List[str]: ...

class Utilities:  # Class
    ZipExtension: str = ...  # static # readonly

    @staticmethod
    def RemoveZipExtension(path: str) -> str: ...
