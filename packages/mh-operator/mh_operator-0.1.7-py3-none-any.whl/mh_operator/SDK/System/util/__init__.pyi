# -*- coding: utf-8 -*-
import typing

# Import specific members from typing used in hints
from typing import (
    Any,
    Callable,
    Dict,
    FrozenSet,
    Generic,
    Iterable,
    Iterator,
    List,
    Mapping,
    Optional,
    Sequence,
    Set,
    Tuple,
    TypeVar,
    Union,
    overload,
)

import datetime
from enum import Enum

from mh_operator.SDK import Agilent, System

from . import collections, zlib

# Discovered Generic TypeVars:
T = TypeVar("T")

# Stubs for namespace: System.util

class FilterStream(System.IDisposable, System.IO.Stream):  # Class
    def __init__(self, s: System.IO.Stream) -> None: ...

    CanRead: bool  # readonly
    CanSeek: bool  # readonly
    CanWrite: bool  # readonly
    Length: int  # readonly
    Position: int

    def Read(self, buffer: List[int], offset: int, count: int) -> int: ...
    def Write(self, buffer: List[int], offset: int, count: int) -> None: ...
    def Flush(self) -> None: ...
    def WriteByte(self, value_: int) -> None: ...
    def ReadByte(self) -> int: ...
    def SetLength(self, value_: int) -> None: ...
    def Close(self) -> None: ...
    def Seek(self, offset: int, origin: System.IO.SeekOrigin) -> int: ...

class ListIterator(Generic[T]):  # Class
    def __init__(self, col: List[T]) -> None: ...
    def Next(self) -> T: ...
    def Remove(self) -> None: ...
    def Previous(self) -> T: ...
    def HasNext(self) -> bool: ...

class Properties:  # Class
    def __init__(self) -> None: ...

    Count: int  # readonly
    def __getitem__(self, key: str) -> str: ...
    def __setitem__(self, key: str, value_: str) -> None: ...
    Keys: Dict.KeyCollection[str, str]  # readonly

    def GetEnumerator(self) -> Dict.Enumerator[str, str]: ...
    def Load(self, inStream: System.IO.Stream) -> None: ...
    def Add(self, key: str, value_: str) -> None: ...
    def AddAll(self, col: System.util.Properties) -> None: ...
    def ContainsKey(self, key: str) -> bool: ...
    def Clear(self) -> None: ...
    def Remove(self, key: str) -> str: ...

class PushbackStream(System.IDisposable, System.util.FilterStream):  # Class
    def __init__(self, s: System.IO.Stream) -> None: ...
    def Read(self, buffer: List[int], offset: int, count: int) -> int: ...
    def ReadByte(self) -> int: ...
    def Unread(self, b: int) -> None: ...

class RectangleJ:  # Class
    @overload
    def __init__(self, x: float, y: float, width: float, height: float) -> None: ...
    @overload
    def __init__(self, rect: iTextSharp.text.Rectangle) -> None: ...

    OUT_BOTTOM: int = ...  # static # readonly
    OUT_LEFT: int = ...  # static # readonly
    OUT_RIGHT: int = ...  # static # readonly
    OUT_TOP: int = ...  # static # readonly

    Height: float
    Width: float
    X: float
    Y: float

    def Intersection(self, r: System.util.RectangleJ) -> System.util.RectangleJ: ...
    def Add(self, rect: System.util.RectangleJ) -> None: ...
    def Outcode(self, x: float, y: float) -> int: ...
    def IsEmpty(self) -> bool: ...
    def IntersectsLine(self, x1: float, y1: float, x2: float, y2: float) -> bool: ...

class StringTokenizer:  # Class
    @overload
    def __init__(self, str: str) -> None: ...
    @overload
    def __init__(self, str: str, delim: str) -> None: ...
    @overload
    def __init__(self, str: str, delim: str, retDelims: bool) -> None: ...
    def HasMoreTokens(self) -> bool: ...
    @overload
    def NextToken(self, delim: str) -> str: ...
    @overload
    def NextToken(self) -> str: ...
    def CountTokens(self) -> int: ...

class Util:  # Class
    @staticmethod
    def CompareToIgnoreCase(s1: str, s2: str) -> int: ...
    @staticmethod
    def GetStandartEnUSLocale() -> System.Globalization.CultureInfo: ...
    @staticmethod
    def GetArrayHashCode(a: List[T]) -> int: ...
    @staticmethod
    def Max(array: List[T]) -> T: ...
    @staticmethod
    def EqualsIgnoreCase(s1: str, s2: str) -> bool: ...
    @staticmethod
    def AreEqual(
        s1: System.Collections.Generic.Stack[T], s2: System.Collections.Generic.Stack[T]
    ) -> bool: ...
    @staticmethod
    def ArraysAreEqual(a: List[T], b: List[T]) -> bool: ...
    @staticmethod
    def USR(op1: int, op2: int) -> int: ...
    @staticmethod
    def Min(array: List[T]) -> T: ...
    @staticmethod
    def compare(f1: float, f2: float) -> int: ...
