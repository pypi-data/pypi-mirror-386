    Pts = vtkPoints()
    Pts.InsertNextPoint(0.05, 0.0, 0.0)
    Pts.InsertNextPoint(0.05, 1.0, 0.0)
    Pts.InsertNextPoint(0.5, 0.0, 0.0)
    Pts.InsertNextPoint(0.5, 1.0, 0.0)
    Pts.InsertNextPoint(0.95, 0.0, 0.0)
--
    points = vtkPoints()
    triangles = vtkCellArray()

    # Build the meshgrid manually.
    count = 0
    for i in range(size - 1):
--
    points = vtkPoints()
    for i in range(maxloop):
        p1 = [2 + i * dist, 16, -1]
        p2 = [2 + i * dist, 16, 6]

        # Outputs (we need only pos which is the x, y, z position
--
    inputPoints = vtk.vtkPoints()
    rng = vtk.vtkMinimalStandardRandomSequence()
    rng.SetSeed(8775070)
    for i in range(0, 10):
        rng.Next()
        x = rng.GetRangeValue(0.0, 1.0)
--
    points = vtkPoints()
    for z in range(0, nk * sk, sk):
        for y in range(0, nj * sj, sj):
            for x in range(0, ni * si, si):
                points.InsertNextPoint((x, y, z))

--
    points = vtkPoints()
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(0, 0, 1)

    ug = vtkUnstructuredGrid()
    ug.SetPoints(points)
--
    points = vtkPoints()
    gridSize = 10
    seed = 0
    randomSequence = vtkMinimalStandardRandomSequence()
    randomSequence.Initialize(seed)
    for x in range(gridSize):
--
    points = vtkPoints()

    grid_size = 10
    for x in range(grid_size):
        for y in range(grid_size):
            points.InsertNextPoint(x, y, int((x + y) / (y + 1)))
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 1, 0)
    points.InsertNextPoint(2, 2, 0)

    polydata = vtkPolyData()
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 1, 1)
    points.InsertNextPoint(2, 2, 2)

    polydata = vtkPolyData()
--
    sourcePoints = vtkPoints()
    sourceVertices = vtkCellArray()

    sp_id = sourcePoints.InsertNextPoint(1.0, 0.1, 0.0)
    sourceVertices.InsertNextCell(1)
    sourceVertices.InsertCellPoint(sp_id)
--
    targetPoints = vtkPoints()
    targetVertices = vtkCellArray()

    tp_id = targetPoints.InsertNextPoint(1.0, 0.0, 0.0)
    targetVertices.InsertNextCell(1)
    targetVertices.InsertCellPoint(tp_id)
--
    points = vtkPoints()
    gridSize = 10
    seed = 0
    randomSequence = vtkMinimalStandardRandomSequence()
    randomSequence.Initialize(seed)
    for x in range(0, gridSize):
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 1, 1)
    points.InsertNextPoint(2, 2, 2)

    polydata = vtkPolyData()
--
    points = vtkPoints()

    points.InsertNextPoint(0.0, 0.0, 1.0)
    points.InsertNextPoint(1.0, 0.0, 1.0)
    points.InsertNextPoint(1.5, 0.5, 1.0)
    points.InsertNextPoint(1.0, 1.0, 1.0)
--
    points = vtkPoints()
    points.InsertNextPoint(0.0, 0.0, 0.0)
    points.InsertNextPoint(1.0, 0.0, 0.0)
    points.InsertNextPoint(1.0, 1.0, 0.0)
    points.InsertNextPoint(0.0, 1.0, 0.0)
    points.InsertNextPoint(0.0, 0.0, 1.0)
--
    points = vtkPoints()
    points.InsertNextPoint(11, 10, 10)
    points.InsertNextPoint(13, 10, 10)
    points.InsertNextPoint(14, 12, 10)
    points.InsertNextPoint(12, 14, 10)
    points.InsertNextPoint(10, 12, 10)
--
    points = vtkPoints()
    points.InsertNextPoint(1.21412, 0, 1.58931)
    points.InsertNextPoint(0.375185, 1.1547, 1.58931)
    points.InsertNextPoint(-0.982247, 0.713644, 1.58931)
    points.InsertNextPoint(-0.982247, -0.713644, 1.58931)
    points.InsertNextPoint(0.375185, -1.1547, 1.58931)
--
    points = vtkPoints()

    p = [
        [1.0, 1.0, 0.0],
        [-1.0, 1.0, 0.0],
        [-1.0, -1.0, 0.0],
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 0, 0)
    points.InsertNextPoint(1, 1, 0)
    points.InsertNextPoint(0, 1, 1)

--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 0, 0)
    points.InsertNextPoint(0, 1, 0)
    points.InsertNextPoint(1, 1, 0)
    points.InsertNextPoint(0, 0, 1)
--
    points = vtkPoints()

    points.InsertNextPoint(0, 1, 0)
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(0, .5, .5)
    points.InsertNextPoint(1, 1, 0)
--
    points = vtkPoints()
    points.SetNumberOfPoints(source.GetOutput().GetNumberOfPoints())
    rng = vtkMinimalStandardRandomSequence()
    rng.SetSeed(5070)  # for testing
    for i in range(0, points.GetNumberOfPoints()):
        perturbation = [0.0] * 3
--
    pts = vtkPoints()
    pts.InsertNextPoint(origin)
    pts.InsertNextPoint(p0)
    pts.InsertNextPoint(p1)

    # Add the points to the polydata container
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 0, 0)
    points.InsertNextPoint(1, 1, 0)
    points.InsertNextPoint(0, 1, 0)
    points.InsertNextPoint(0, 0, 1)
--
    points = vtkPoints()
    polys = vtkCellArray()
    scalars = vtkFloatArray()

    # Load the point, cell, and data attributes.
    for i, xi in enumerate(x):
--
    points = vtkPoints()
    idx = 0
    while angle <= 2.0 * vtkMath.Pi() + (vtkMath.Pi() / 60.0):
        points.InsertNextPoint(r1 * math.cos(angle) + centerX,
                               r2 * math.sin(angle) + centerY,
                               0.0)
--
    points = vtkPoints()
    idx = 0
    while angle <= 2.0 * vtkMath.Pi() + (vtkMath.Pi() / 60.0):
        points.InsertNextPoint(r1 * math.cos(angle) + centerX,
                               r2 * math.sin(angle) + centerY,
                               0.0)
--
    points = vtkPoints()

    # Create a hexahedron from the points.
    hexahedron = vtkHexahedron()

    for i in range(0, len(pointCoordinates)):
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)

    vertex = vtkVertex()
    for i in range(0, number_of_vertices):
        vertex.GetPointIds().SetId(i, i)
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 0, 0)
    points.InsertNextPoint(0, 1, 0)
    points.InsertNextPoint(0, 0, 1)
    points.InsertNextPoint(1, 0, 0.4)
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(0.5, 0.5, 0)

    line = vtkLine()
    for i in range(0, number_of_vertices):
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0.5, 0)
    points.InsertNextPoint(0.5, 0, 0)
    points.InsertNextPoint(1, 0.3, 0)
    points.InsertNextPoint(1.5, 0.4, 0)
    points.InsertNextPoint(2.0, 0.4, 0)
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(0.5, 0.5, 0)
    points.InsertNextPoint(.2, 1, 0)

    triangle = vtkTriangle()
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, -.1, 0)
    points.InsertNextPoint(0.5, 1, 0)
    points.InsertNextPoint(2.0, -0.1, 0)
    points.InsertNextPoint(1.5, 0.8, 0)
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, -0.1, 0)
    points.InsertNextPoint(0.8, 0.5, 0)
    points.InsertNextPoint(1, 1, 0)
    points.InsertNextPoint(0.6, 1.2, 0)
--
    points = vtkPoints()
    # points.InsertNextPoint(0, 0, 0)
    # points.InsertNextPoint(1, 0, 0)
    # points.InsertNextPoint(1, 1, 0)
    # points.InsertNextPoint(0, 1, 1)

--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 0, 0)
    points.InsertNextPoint(0, 1, 0)
    points.InsertNextPoint(1, 1, 0)
    points.InsertNextPoint(0, 0, 1)
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 0, 0)
    points.InsertNextPoint(1, 1, 0)
    points.InsertNextPoint(0, 1, 0)
    points.InsertNextPoint(0, 0, 1)
--
    points = vtkPoints()

    # points.InsertNextPoint(0, 1, 0)
    # points.InsertNextPoint(0, 0, 0)
    # points.InsertNextPoint(0, 0.5, 0.5)
    # points.InsertNextPoint(1, 1, 0)
--
    points = vtkPoints()

    # p0 = [1.0, 1.0, 0.0]
    # p1 = [-1.0, 1.0, 0.0]
    # p2 = [-1.0, -1.0, 0.0]
    # p3 = [1.0, -1.0, 0.0]
--
    points = vtkPoints()
    points.InsertNextPoint(origin)
    points.InsertNextPoint(p0)
    points.InsertNextPoint(p1)
    points.InsertNextPoint(p2)
    points.InsertNextPoint(p3)
--
    spline_points = vtkPoints()
    rng = vtkMinimalStandardRandomSequence()
    rng.SetSeed(8775070)
    for p in range(0, 10):
        xyz = [None] * 3
        for idx in range(0, len(xyz)):
--
    box = vtkPoints()

    box.SetNumberOfPoints(8)

    xMin = bounds[0]
    xMax = bounds[1]
--
    points = vtkPoints()
    p = [1.0, 2.0, 3.0]

    # Create the topology of the point (a vertex)
    vertices = vtkCellArray()
    # We need an an array of point id's for InsertNextCell.
--
    points = vtkPoints()
    points.InsertNextPoint(0.0, 0.0, 0.0)
    points.InsertNextPoint(1.0, 0.0, 0.0)
    points.InsertNextPoint(1.0, 1.0, 0.0)
    points.InsertNextPoint(0.0, 1.0, 0.0)

--
    points = vtkPoints()
    points.InsertNextPoint(0.0, 0.0, 0.0)
    points.InsertNextPoint(1.0, 0.0, 0.0)
    points.InsertNextPoint(1.0, 1.0, 0.0)
    points.InsertNextPoint(0.0, 1.0, 0.0)

--
    points = vtkPoints()
    points.InsertNextPoint(-1.0, -1.0, -1.0)
    points.InsertNextPoint(1.0, -1.0, -1.0)
    points.InsertNextPoint(1.0, 1.0, -1.0)
    points.InsertNextPoint(-1.0, 1.0, -1.0)
    points.InsertNextPoint(-1.0, -1.0, 1.0)
--
    points = vtkPoints()
    points.SetNumberOfPoints(6)
    c = math.cos(math.pi / 6)  # helper variable
    points.SetPoint(0, 0.0, -1.0, 0.0)
    points.SetPoint(1, c, -0.5, 0.0)
    points.SetPoint(2, c, 0.5, 0.0)
--
    points = vtkPoints()
    points.InsertNextPoint(origin)
    points.InsertNextPoint(p0)
    points.InsertNextPoint(p1)
    points.InsertNextPoint(p2)
    points.InsertNextPoint(p3)
--
    points = vtkPoints()

    p0 = [1.0, 1.0, 1.0]
    p1 = [-1.0, 1.0, 1.0]
    p2 = [-1.0, -1.0, 1.0]
    p3 = [1.0, -1.0, 1.0]
--
    points = vtkPoints()
    points.InsertNextPoint(p0)
    points.InsertNextPoint(p1)
    points.InsertNextPoint(p2)
    points.InsertNextPoint(p3)

--
    points = vtkPoints()

    pcoords = aHexahedron.GetParametricCoords()
    rng = vtkMinimalStandardRandomSequence()
    points.SetNumberOfPoints(aHexahedron.GetNumberOfPoints())
    rng.SetSeed(5070)  # for testing
--
    points = vtkPoints()

    pcoords = aHexahedron.GetParametricCoords()
    rng = vtkMinimalStandardRandomSequence()
    points.SetNumberOfPoints(aHexahedron.GetNumberOfPoints())
    rng.SetSeed(5070)  # for testing
--
    points = vtkPoints()

    pcoords = aTetra.GetParametricCoords()
    rng = vtkMinimalStandardRandomSequence()
    points.SetNumberOfPoints(aTetra.GetNumberOfPoints())
    rng.SetSeed(5070)  # for testing
--
    points = vtkPoints()

    pcoords = aTetra.GetParametricCoords()
    rng = vtkMinimalStandardRandomSequence()
    points.SetNumberOfPoints(aTetra.GetNumberOfPoints())
    rng.SetSeed(5070)  # for testing
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 0, 0)
    points.InsertNextPoint(1, 1, 0)
    points.InsertNextPoint(0, 1, 1)

--
    points = vtkPoints()
    points.InsertNextPoint(1.0, 0.0, 0.0)
    points.InsertNextPoint(0.0, 0.0, 0.0)
    points.InsertNextPoint(0.0, 1.0, 0.0)

    triangle = vtkTriangle()
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(0, 1, 0)
    points.InsertNextPoint(1, 0, 0)
    points.InsertNextPoint(1.5, 1, 0)

--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)

    vertex = vtkVertex()
    vertex.GetPointIds().SetId(0, 0)

--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 0, 0)
    points.InsertNextPoint(2, 0, 0)

    graph.SetPoints(points)
--
    points = vtkPoints()
    points.InsertNextPoint(0.0, 0.0, 0.0)
    points.InsertNextPoint(1.0, 0.0, 0.0)
    points.InsertNextPoint(0.0, 1.0, 0.0)
    points.InsertNextPoint(0.0, 0.0, 1.0)

--
    Points = vtkPoints()
    Points.InsertNextPoint(0, 1, 0)
    Points.InsertNextPoint(0, 0, 0)
    Points.InsertNextPoint(1, 1, 0)
    Points.InsertNextPoint(1, 0, 0)
    Points.InsertNextPoint(2, 1, 0)
--
    points = vtkPoints()
    points.InsertNextPoint(0.0, 0.0, 0.0)
    points.InsertNextPoint(1.0, 0.0, 0.0)
    points.InsertNextPoint(0.0, 1.0, 0.0)

    # Add the coordinates of the points to the graph
--
    points = vtkPoints()
    points.InsertNextPoint(0.0, 0.0, 0.0)
    points.InsertNextPoint(1.0, 0.0, 0.0)

    # Add the coordinates of the points to the graph
    g1.SetPoints(points)
--
    points = vtkPoints()
    points.InsertNextPoint(10, 10, 0)
    points.InsertNextPoint(100, 100, 0)
    points.InsertNextPoint(200, 200, 0)

    polydata = vtkPolyData()
--
    points = vtkPoints()
    points.SetData(numpy_support.numpy_to_vtk(xyz))
    poly_data.SetPoints(points)

    # Set an index
    idx = numpy_support.numpy_to_vtk(elev)
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 0, 0)
    points.InsertNextPoint(0, 1, 0)
    points.InsertNextPoint(0, 0, 1)
    points.InsertNextPoint(1, 0, .4)
--
    points = vtkPoints()
    points.InsertNextPoint(0, .5, 0)
    points.InsertNextPoint(.5, 0, 0)
    points.InsertNextPoint(1, .3, 0)
    points.InsertNextPoint(1.5, .4, 0)
    points.InsertNextPoint(2.0, .4, 0)
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(.5, 1, 0)
    points.InsertNextPoint(1, -.1, 0)
    points.InsertNextPoint(1.5, .8, 0)
    points.InsertNextPoint(2.0, -.1, 0)
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, -.1, 0)
    points.InsertNextPoint(.8, .5, 0)
    points.InsertNextPoint(1, 1, 0)
    points.InsertNextPoint(.6, 1.2, 0)
--
    Points = vtkPoints()
    Triangles = vtkCellArray()
    Triangle = vtkTriangle()

    Points.InsertNextPoint(1.0, 0.0, 0.0)
    Points.InsertNextPoint(0.0, 0.0, 0.0)
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 0, 0)
    points.InsertNextPoint(0, 1, 0)
    points.InsertNextPoint(0, 0, 1)
    points.InsertNextPoint(1, 0, .4)
--
    points = vtkPoints()
    points.InsertNextPoint(0, .5, 0)
    points.InsertNextPoint(.5, 0, 0)
    points.InsertNextPoint(1, .3, 0)
    points.InsertNextPoint(1.5, .4, 0)
    points.InsertNextPoint(2.0, .4, 0)
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(.5, 1, 0)
    points.InsertNextPoint(1, -.1, 0)
    points.InsertNextPoint(1.5, .8, 0)
    points.InsertNextPoint(2.0, -.1, 0)
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, -.1, 0)
    points.InsertNextPoint(.8, .5, 0)
    points.InsertNextPoint(1, 1, 0)
    points.InsertNextPoint(.6, 1.2, 0)
--
    points = vtkPoints()
    GridSize = 20;
    xx = 0.0
    yy = 0.0
    zz = 0.0
    rng = vtkMinimalStandardRandomSequence()
--
    pts = vtkPoints()
    pts.SetNumberOfPoints(6)
    pts.SetPoint(0,
                 bounds[0] - 0.1 * (bounds[1] - bounds[0]),
                 (bounds[3] + bounds[2]) / 2.0,
                 (bounds[5] + bounds[4]) / 2.0)
--
    points = vtkPoints()
    points.InsertPoint(0, 0.01, 0.0, 0.0)
    points.InsertPoint(1, 1.5, 0.0, 0.0)
    points.InsertPoint(2, 1.5, 0.0, 3.5)
    points.InsertPoint(3, 1.25, 0.0, 3.75)
    points.InsertPoint(4, 0.75, 0.0, 4.00)
--
    points = vtkPoints()
    lines = vtkCellArray()
    for pt in pts:
        pt_id = points.InsertNextPoint(pt)
        if pt_id < len(pts) - 1:
            line = vtkLine()
--
    points = vtkPoints()
    randomSequence = vtkMinimalStandardRandomSequence()
    randomSequence.SetSeed(1)
    for i in range(0, 50):
        p1 = randomSequence.GetValue()
        randomSequence.Next()
--
        newPts = vtkPoints()
        newScalars = vtkFloatArray()
        xyz = list(zip(res[keys[1]], res[keys[2]], res[keys[3]]))
        for i in range(0, res[keys[0]][0]):
            # print(xyz[i])
            newPts.InsertPoint(i, xyz[i])
--
    points = vtkPoints()
    points.InsertPoint(0, 1.0, 0.0, 0.0)
    points.InsertPoint(1, 1.0732, 0.0, -0.1768)
    points.InsertPoint(2, 1.25, 0.0, -0.25)
    points.InsertPoint(3, 1.4268, 0.0, -0.1768)
    points.InsertPoint(4, 1.5, 0.0, 0.00)
--
    best_points = vtkPoints()
    best_distance = best_bounding_box(
        "X",
        target,
        source,
        target_landmarks,
--
    Points = vtkPoints()
    Triangles = vtkCellArray()

    Points.InsertNextPoint(1.0, 0.0, 0.0)
    Points.InsertNextPoint(0.0, 0.0, 0.0)
    Points.InsertNextPoint(0.0, 1.0, 0.0)
--
    points = vtkPoints()
    for i in range(0, x_res):
        x = x_min + i * dx
        for j in range(0, y_res):
            y = y_min + j * dy
            points.InsertNextPoint(x, y, 0)
--
    points = vtkPoints()
    step = 0.1
    for x in np.arange(-2, 2, step):
        for y in np.arange(-2, 2, step):
            for z in np.arange(-2, 2, step):
                points.InsertNextPoint(x, y, z)
--
    points = vtkPoints()
    points.InsertNextPoint(origin)
    points.InsertNextPoint(p0)
    points.InsertNextPoint(p1)
    points.InsertNextPoint(p2)
    points.InsertNextPoint(p3)
--
    points = vtkPoints()
    points.InsertPoint(0, 0, 0, 1)
    points.InsertPoint(1, 1, 0, 0)
    points.InsertPoint(2, 0, 1, 0)
    points.InsertPoint(3, 1, 1, 1)

--
    points = vtkPoints()
    triangles = vtkCellArray()

    # Build the meshgrid manually
    count = 0
    for i in range(size - 1):
--
    Points = vtkPoints()
    Triangles = vtkCellArray()

    Points.InsertNextPoint(1.0, 0.0, 0.0)
    Points.InsertNextPoint(0.0, 0.0, 0.0)
    Points.InsertNextPoint(0.0, 1.0, 0.0)
--
    Points = vtkPoints()
    Vertices = vtkCellArray()

    id = Points.InsertNextPoint(1.0, 0.0, 0.0)
    Vertices.InsertNextCell(1)
    Vertices.InsertCellPoint(id)
--
    Points = vtkPoints()
    Points.InsertNextPoint(1.0, 0.0, 0.0)
    Points.InsertNextPoint(0.0, 0.0, 0.0)
    Points.InsertNextPoint(0.0, 1.0, 0.0)

    polydata = vtkPolyData()
--
    Points = vtkPoints()
    Vertices = vtkCellArray()

    id = Points.InsertNextPoint(1.0, 0.0, 0.0)
    Vertices.InsertNextCell(1)
    Vertices.InsertCellPoint(id)
--
    points = vtkPoints()
    points.InsertNextPoint(0.0, 0.0, 0.0)
    points.InsertNextPoint(1.0, 0.0, 0.0)
    points.InsertNextPoint(2.0, 0.0, 0.0)
    points.InsertNextPoint(3.0, 0.0, 0.0)
    points.InsertNextPoint(4.0, 0.0, 0.0)
--
    points = vtkPoints()
    points.SetNumberOfPoints(4)
    points.InsertPoint(0, 1, 1, 0)
    points.InsertPoint(1, 0, 1, 0)
    points.InsertPoint(2, 0, 0, 0)
    points.InsertPoint(3, 1, 0, 0)
--
    points = vtkPoints()

    grid_size = 8
    counter = 0
    pt_idx = 0
    # Create a 5x5 grid of points
--
    points = vtkPoints()
    points.Allocate(dims[0] * dims[1] * dims[2])

    deltaZ = 2.0 / (dims[2] - 1)
    deltaRad = (rMax - rMin) / (dims[1] - 1)
    x = [0.0] * 3
--
    points = vtkPoints()
    points.SetNumberOfPoints(2)
    points.SetPoint(0, pts[:3])
    points.SetPoint(1, pts[3:])

    nrms = [0.0] * 6
--
    points = vtkPoints()
    for i in range(0, len(x)):
        points.InsertPoint(i, x[i])

    ugrid = vtkUnstructuredGrid()
    ugrid.Allocate(100)
--
    points = vtkPoints()
    hexa = vtkHexahedron()
    for i, pointCoord in enumerate(pointCoords):
        points.InsertNextPoint(pointCoord)
        hexa.GetPointIds().SetId(i, i)

--
    newPts = vtkPoints()
    newPts.SetNumberOfPoints(numPts)

    derivs = vtkDoubleArray()
    derivs.SetNumberOfTuples(numPts)

--
        Points = vtkPoints()
        Points.InsertNextPoint(0, 0, 0)
        Points.InsertNextPoint(1, 0, 0)
        Points.InsertNextPoint(1, 1, 0)
        Points.InsertNextPoint(0, 1, 0)
        Points.InsertNextPoint(0, 0, 1)
--
    points = vtkPoints()
    norms = vtkFloatArray()

    norms.SetNumberOfComponents(3)
    points.InsertPoint(0, 0.0, 0.0, 0.0)
    norms.InsertTuple3(0, 0.0, 0.0, 1.0)
--
    pts = vtkPoints()
    verts = vtkCellArray()
    norms = vtkDoubleArray()
    scalars = vtkDoubleArray()

    x = [0.0] * 3
--
    fp = vtkPoints()
    fp.InsertNextPoint(0, 1, 0)
    fp.InsertNextPoint(8, 1, 0)
    fp.InsertNextPoint(8, 2, 0)
    fp.InsertNextPoint(10, 0.01, 0)
    fp.InsertNextPoint(8, -2, 0)
--
    fp2 = vtkPoints()
    fp2.InsertNextPoint(0, 1, 0)
    fp2.InsertNextPoint(8, 1, 0)
    fp2.InsertNextPoint(8, 2, 0)
    fp2.InsertNextPoint(10, 0.01, 0)
    ca2.InsertNextCell(4)
--
    pts = vtkPoints()
    pts.InsertNextPoint(0, 1, 0)
    pts.InsertNextPoint(8, 1, 0)
    pts.InsertNextPoint(8, 2, 0)
    pts.InsertNextPoint(10, 0, 0)
    pts.InsertNextPoint(8, -2, 0)
--
    pts2 = vtkPoints()
    pts2.InsertNextPoint(0, 1, 0)
    pts2.InsertNextPoint(8, 1, 0)
    pts2.InsertNextPoint(8, 2, 0)
    pts2.InsertNextPoint(10, 0.01, 0)
    ca2.InsertNextCell(4)
--
    points = vtkPoints()
    for i in range(0, x_res):
        x = x_min + i * dx
        for j in range(0, y_res):
            y = y_min + j * dy
            points.InsertNextPoint(x, y, 0)
--
    points = vtkPoints()
    for i in range(0, x_res):
        x = x_min + i * dx
        for j in range(0, y_res):
            y = y_min + j * dy
            points.InsertNextPoint(x, y, 0)
--
        temp = vtkPoints()
        # The first point of the previous vtkPoints is the first point of the next vtkPoints.
        temp.InsertNextPoint(*points.GetPoint(0))

        # Iterate over 'edges' in the vtkPoints
        for i in range(1, points.GetNumberOfPoints()):
--
    points = vtkPoints()
    for i in range(4):
        points.InsertNextPoint(cos(2.0 * pi * i / 3), sin(2 * pi * i / 3.0), 0.0)

    outline_pd = as_polyline(points, LEVEL)
    # You have already gone through the trouble of putting the points in the
--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(5, 0, 0)
    points.InsertNextPoint(10, 0, 0)

    # Combine into a polydata.
--
    points = vtkPoints()

    num_pts = 21
    for i in range(0, num_pts):
        angle = 2.0 * math.pi * i / 20.0
        points.InsertPoint(i, 0.1 * math.cos(angle),
