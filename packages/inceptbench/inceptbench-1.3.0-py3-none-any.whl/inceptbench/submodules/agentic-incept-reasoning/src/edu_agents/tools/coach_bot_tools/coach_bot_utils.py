"""
Common utilities for coach-bot tool integrations.

This module provides shared functionality for all coach-bot tool wrappers,
including dynamic schema generation, standardized logging, path setup,
and image upload handling.
"""

from __future__ import annotations

import logging
import os
import sys
from typing import Any, Callable, Dict, Optional, Type

from utils.supabase_utils import upload_image_to_supabase

# Standard logger for all coach-bot tools
logger = logging.getLogger("coach_bot_tools")

# Coach-bot path constant
COACH_BOT_PATH = os.path.join(
    os.path.dirname(__file__), 
    "../coach-bot-external-content-generators/src"
)

def setup_coach_bot_imports() -> None:
    """
    Add the coach-bot external content generators to the Python path.
    
    This centralizes the path setup that was previously duplicated
    across all 44 coach-bot tool wrapper files.
    """
    if COACH_BOT_PATH not in sys.path:
        sys.path.insert(0, COACH_BOT_PATH)


def transform_pydantic_to_openai_schema(pydantic_schema: Dict[str, Any]) -> Dict[str, Any]:
    """
    Transform a Pydantic JSON schema to OpenAI function calling parameter format.
    
    This is an enhanced version of the schema transformer that handles
    complex schemas with references, nested objects, and edge cases.
    
    Args:
        pydantic_schema: The schema generated by model.model_json_schema()
    
    Returns:
        OpenAI-compatible parameters object
    """
    # Start with the basic structure
    openai_params = {
        "type": "object",
        "properties": {},
        "required": pydantic_schema.get("required", [])
    }
    
    # Handle array types (like AngleList)
    if pydantic_schema.get("type") == "array":
        items_schema = pydantic_schema.get("items", {})
        
        # Handle references in array items
        if "$ref" in items_schema:
            ref_path = items_schema["$ref"]
            if ref_path.startswith("#/$defs/"):
                def_name = ref_path.replace("#/$defs/", "")
                defs = pydantic_schema.get("$defs", {})
                if def_name in defs:
                    items_schema = transform_pydantic_to_openai_schema(defs[def_name])
        
        result = {
            "type": "array",
            "items": items_schema,
        }
        
        # Add constraints if present
        if "minItems" in pydantic_schema:
            result["minItems"] = pydantic_schema["minItems"]
        if "maxItems" in pydantic_schema:
            result["maxItems"] = pydantic_schema["maxItems"]
            
        return result
    
    # Process properties
    properties = pydantic_schema.get("properties", {})
    for prop_name, prop_schema in properties.items():
        # Copy the property schema, removing Pydantic-specific fields
        clean_prop = {k: v for k, v in prop_schema.items() if k not in ["title"]}
        
        # Handle references to definitions
        if "$ref" in prop_schema:
            ref_path = prop_schema["$ref"]
            if ref_path.startswith("#/$defs/"):
                def_name = ref_path.replace("#/$defs/", "")
                defs = pydantic_schema.get("$defs", {})
                if def_name in defs:
                    # Get the referenced definition and clean it
                    ref_def = defs[def_name]
                    clean_prop = {k: v for k, v in ref_def.items() if k not in ["title"]}
                    # Preserve original description if it exists
                    if "description" in prop_schema:
                        clean_prop["description"] = prop_schema["description"]
        
        # Handle Union types (anyOf, oneOf)
        if "anyOf" in prop_schema:
            # For now, we'll take the first type in the union
            # This can be enhanced later for more complex Union handling
            clean_prop = prop_schema["anyOf"][0].copy()
            clean_prop.pop("title", None)
        
        openai_params["properties"][prop_name] = clean_prop
    
    return openai_params


def create_dynamic_tool_spec(
    name: str,
    description: str,
    pydantic_model: Type,
    parameter_wrapper_name: Optional[str] = None,
    custom_descriptions: Optional[Dict[str, str]] = None
) -> Dict[str, Any]:
    """
    Create an OpenAI tool specification from a Pydantic model dynamically.
    
    Args:
        name: The function name for the tool
        description: Human-readable description of what the tool does
        pydantic_model: The Pydantic model class to generate parameters from
        parameter_wrapper_name: If provided, wrap parameters in an object with this name
        custom_descriptions: Override descriptions for specific parameters
        
    Returns:
        OpenAI-compatible tool specification dictionary
    """
    # Generate parameter schema from Pydantic model
    pydantic_schema = pydantic_model.model_json_schema()
    parameters = transform_pydantic_to_openai_schema(pydantic_schema)
    
    # CRITICAL FIX: Handle StimulusDescriptionList (root array models)
    # OpenAI function calling requires parameters to be an object, not an array
    if parameters.get("type") == "array":
        logger.debug(f"Detected root array model for {name}, wrapping in 'root' property")
        parameters = {
            "type": "object",
            "properties": {
                "root": parameters
            },
            "required": ["root"]
        }
    
    # Apply custom descriptions if provided
    if custom_descriptions:
        for param_name, custom_desc in custom_descriptions.items():
            if param_name in parameters.get("properties", {}):
                parameters["properties"][param_name]["description"] = custom_desc
    
    # Wrap parameters if needed (for tools that take a wrapper object)
    if parameter_wrapper_name:
        parameters = {
            "type": "object",
            "properties": {
                parameter_wrapper_name: {
                    **parameters,
                    "description": f"Parameters for {name}"
                }
            },
            "required": [parameter_wrapper_name]
        }
    
    spec = {
        "type": "function",
        "name": name,
        "description": description,
        "parameters": parameters
    }
    
    return spec


def log_tool_generation(tool_name: str, **kwargs) -> None:
    """
    Standardized logging for tool generation across all coach-bot tools.
    
    Args:
        tool_name: Name of the tool being used
        **kwargs: Additional parameters to log
    """
    # Format parameters for logging
    param_parts = []
    for key, value in kwargs.items():
        if isinstance(value, (list, dict)):
            param_parts.append(f"{key}={len(value)} items")
        elif isinstance(value, str) and len(value) > 50:
            param_parts.append(f"{key}={value[:47]}...")
        else:
            param_parts.append(f"{key}={value}")
    
    param_str = ", ".join(param_parts) if param_parts else "no parameters"
    logger.info(f"Generating {tool_name}: {param_str}")


def create_tool_wrapper(
    drawing_function: Callable,
    model_class: Type,
    tool_name: str,
    description: str,
    parameter_wrapper_name: Optional[str] = None,
    custom_descriptions: Optional[Dict[str, str]] = None
) -> tuple[dict, Callable]:
    """
    Generic factory for creating coach-bot tool wrappers.
    
    This creates both the dynamic tool specification and the wrapper function
    for simple cases where the pattern is straightforward.
    
    Args:
        drawing_function: The coach-bot drawing function to wrap
        model_class: Pydantic model class for parameter validation
        tool_name: Name of the tool function
        description: Description for the tool specification
        parameter_wrapper_name: Optional parameter wrapper object name
        custom_descriptions: Custom parameter descriptions
        
    Returns:
        Tuple of (tool_spec, callable_wrapper)
    """
    # Create dynamic tool specification
    spec = create_dynamic_tool_spec(
        name=tool_name,
        description=description,
        pydantic_model=model_class,
        parameter_wrapper_name=parameter_wrapper_name,
        custom_descriptions=custom_descriptions
    )
    
    def wrapper_function(**kwargs) -> str:
        """Auto-generated wrapper function."""
        # Log the tool generation
        log_tool_generation(tool_name, **kwargs)
        
        # Create model instance from parameters
        if parameter_wrapper_name and parameter_wrapper_name in kwargs:
            model_data = model_class(**kwargs[parameter_wrapper_name])
        else:
            model_data = model_class(**kwargs)
        
        # Generate the image using the drawing function
        image_file_path = drawing_function(model_data)
        
        # Upload and return URL
        return upload_coach_bot_image(image_file_path)
    
    # Set function name and docstring dynamically
    wrapper_function.__name__ = tool_name
    wrapper_function.__doc__ = f"Auto-generated wrapper for {tool_name}."
    
    return spec, wrapper_function


def upload_coach_bot_image(image_file_path: str, content_type: str = "image/webp") -> str:
    """
    Upload a coach-bot generated image file to Supabase and clean up the temporary file.
    
    Parameters
    ----------
    image_file_path : str
        Path to the generated image file
    content_type : str, default "image/webp"
        The MIME content type of the image
        
    Returns
    -------
    str
        The public URL of the uploaded image
        
    Raises
    ------
    FileNotFoundError
        If the image file doesn't exist
    """
    try:
        # Read the generated image file
        with open(image_file_path, 'rb') as f:
            image_bytes = f.read()
        
        # Upload the image to Supabase
        public_url = upload_image_to_supabase(
            image_bytes=image_bytes,
            content_type=content_type,
            bucket_name="incept-images"
        )
        
        return public_url
        
    finally:
        # Clean up the temporary file
        try:
            if os.path.exists(image_file_path):
                os.remove(image_file_path)
        except Exception as e:
            logger.warning(
                f"Could not remove temporary file {image_file_path}: {e}"
            )

