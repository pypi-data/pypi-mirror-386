// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use crate::extension_generated::*;
use crate::geometry_generated::*;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_COLUMN_TYPE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_COLUMN_TYPE: u8 = 14;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COLUMN_TYPE: [ColumnType; 15] = [
    ColumnType::Byte,
    ColumnType::UByte,
    ColumnType::Bool,
    ColumnType::Short,
    ColumnType::UShort,
    ColumnType::Int,
    ColumnType::UInt,
    ColumnType::Long,
    ColumnType::ULong,
    ColumnType::Float,
    ColumnType::Double,
    ColumnType::String,
    ColumnType::Json,
    ColumnType::DateTime,
    ColumnType::Binary,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ColumnType(pub u8);
#[allow(non_upper_case_globals)]
impl ColumnType {
    pub const Byte: Self = Self(0);
    pub const UByte: Self = Self(1);
    pub const Bool: Self = Self(2);
    pub const Short: Self = Self(3);
    pub const UShort: Self = Self(4);
    pub const Int: Self = Self(5);
    pub const UInt: Self = Self(6);
    pub const Long: Self = Self(7);
    pub const ULong: Self = Self(8);
    pub const Float: Self = Self(9);
    pub const Double: Self = Self(10);
    pub const String: Self = Self(11);
    pub const Json: Self = Self(12);
    pub const DateTime: Self = Self(13);
    pub const Binary: Self = Self(14);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 14;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::Byte,
        Self::UByte,
        Self::Bool,
        Self::Short,
        Self::UShort,
        Self::Int,
        Self::UInt,
        Self::Long,
        Self::ULong,
        Self::Float,
        Self::Double,
        Self::String,
        Self::Json,
        Self::DateTime,
        Self::Binary,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Byte => Some("Byte"),
            Self::UByte => Some("UByte"),
            Self::Bool => Some("Bool"),
            Self::Short => Some("Short"),
            Self::UShort => Some("UShort"),
            Self::Int => Some("Int"),
            Self::UInt => Some("UInt"),
            Self::Long => Some("Long"),
            Self::ULong => Some("ULong"),
            Self::Float => Some("Float"),
            Self::Double => Some("Double"),
            Self::String => Some("String"),
            Self::Json => Some("Json"),
            Self::DateTime => Some("DateTime"),
            Self::Binary => Some("Binary"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ColumnType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ColumnType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ColumnType {
    type Output = ColumnType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ColumnType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ColumnType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ColumnType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_TEXTURE_FORMAT: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_TEXTURE_FORMAT: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TEXTURE_FORMAT: [TextureFormat; 2] = [TextureFormat::PNG, TextureFormat::JPG];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TextureFormat(pub u8);
#[allow(non_upper_case_globals)]
impl TextureFormat {
    pub const PNG: Self = Self(0);
    pub const JPG: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::PNG, Self::JPG];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PNG => Some("PNG"),
            Self::JPG => Some("JPG"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for TextureFormat {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for TextureFormat {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for TextureFormat {
    type Output = TextureFormat;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TextureFormat {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for TextureFormat {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for TextureFormat {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_WRAP_MODE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_WRAP_MODE: u8 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_WRAP_MODE: [WrapMode; 5] = [
    WrapMode::None,
    WrapMode::Wrap,
    WrapMode::Mirror,
    WrapMode::Clamp,
    WrapMode::Border,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct WrapMode(pub u8);
#[allow(non_upper_case_globals)]
impl WrapMode {
    pub const None: Self = Self(0);
    pub const Wrap: Self = Self(1);
    pub const Mirror: Self = Self(2);
    pub const Clamp: Self = Self(3);
    pub const Border: Self = Self(4);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::None,
        Self::Wrap,
        Self::Mirror,
        Self::Clamp,
        Self::Border,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::None => Some("None"),
            Self::Wrap => Some("Wrap"),
            Self::Mirror => Some("Mirror"),
            Self::Clamp => Some("Clamp"),
            Self::Border => Some("Border"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for WrapMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for WrapMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for WrapMode {
    type Output = WrapMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for WrapMode {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for WrapMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for WrapMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_TEXTURE_TYPE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_TEXTURE_TYPE: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TEXTURE_TYPE: [TextureType; 3] = [
    TextureType::Unknown,
    TextureType::Specific,
    TextureType::Typical,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TextureType(pub u8);
#[allow(non_upper_case_globals)]
impl TextureType {
    pub const Unknown: Self = Self(0);
    pub const Specific: Self = Self(1);
    pub const Typical: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Unknown, Self::Specific, Self::Typical];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Unknown => Some("Unknown"),
            Self::Specific => Some("Specific"),
            Self::Typical => Some("Typical"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for TextureType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for TextureType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for TextureType {
    type Output = TextureType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TextureType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for TextureType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for TextureType {}
// struct Vector, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Default)]
pub struct Vector(pub [u8; 24]);
impl core::fmt::Debug for Vector {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vector")
            .field("x", &self.x())
            .field("y", &self.y())
            .field("z", &self.z())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Vector {}
impl<'a> flatbuffers::Follow<'a> for Vector {
    type Inner = &'a Vector;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Vector>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vector {
    type Inner = &'a Vector;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Vector>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Vector {
    type Output = Vector;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vector as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vector {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Vector {
    #[allow(clippy::too_many_arguments)]
    pub fn new(x: f64, y: f64, z: f64) -> Self {
        let mut s = Self([0; 24]);
        s.set_x(x);
        s.set_y(y);
        s.set_z(z);
        s
    }

    pub fn x(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_x(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn y(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_y(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn z(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[16..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_z(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[16..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }
}

// struct Transform, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Transform(pub [u8; 48]);
impl Default for Transform {
    fn default() -> Self {
        Self([0; 48])
    }
}
impl core::fmt::Debug for Transform {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Transform")
            .field("scale", &self.scale())
            .field("translate", &self.translate())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Transform {}
impl<'a> flatbuffers::Follow<'a> for Transform {
    type Inner = &'a Transform;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Transform>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Transform {
    type Inner = &'a Transform;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Transform>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Transform {
    type Output = Transform;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src =
            ::core::slice::from_raw_parts(self as *const Transform as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Transform {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Transform {
    #[allow(clippy::too_many_arguments)]
    pub fn new(scale: &Vector, translate: &Vector) -> Self {
        let mut s = Self([0; 48]);
        s.set_scale(scale);
        s.set_translate(translate);
        s
    }

    pub fn scale(&self) -> &Vector {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid struct in this slot
        unsafe { &*(self.0[0..].as_ptr() as *const Vector) }
    }

    #[allow(clippy::identity_op)]
    pub fn set_scale(&mut self, x: &Vector) {
        self.0[0..0 + 24].copy_from_slice(&x.0)
    }

    pub fn translate(&self) -> &Vector {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid struct in this slot
        unsafe { &*(self.0[24..].as_ptr() as *const Vector) }
    }

    #[allow(clippy::identity_op)]
    pub fn set_translate(&mut self, x: &Vector) {
        self.0[24..24 + 24].copy_from_slice(&x.0)
    }
}

// struct GeographicalExtent, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct GeographicalExtent(pub [u8; 48]);
impl Default for GeographicalExtent {
    fn default() -> Self {
        Self([0; 48])
    }
}
impl core::fmt::Debug for GeographicalExtent {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GeographicalExtent")
            .field("min", &self.min())
            .field("max", &self.max())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for GeographicalExtent {}
impl<'a> flatbuffers::Follow<'a> for GeographicalExtent {
    type Inner = &'a GeographicalExtent;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a GeographicalExtent>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a GeographicalExtent {
    type Inner = &'a GeographicalExtent;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<GeographicalExtent>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for GeographicalExtent {
    type Output = GeographicalExtent;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const GeographicalExtent as *const u8,
            Self::size(),
        );
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for GeographicalExtent {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> GeographicalExtent {
    #[allow(clippy::too_many_arguments)]
    pub fn new(min: &Vector, max: &Vector) -> Self {
        let mut s = Self([0; 48]);
        s.set_min(min);
        s.set_max(max);
        s
    }

    pub fn min(&self) -> &Vector {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid struct in this slot
        unsafe { &*(self.0[0..].as_ptr() as *const Vector) }
    }

    #[allow(clippy::identity_op)]
    pub fn set_min(&mut self, x: &Vector) {
        self.0[0..0 + 24].copy_from_slice(&x.0)
    }

    pub fn max(&self) -> &Vector {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid struct in this slot
        unsafe { &*(self.0[24..].as_ptr() as *const Vector) }
    }

    #[allow(clippy::identity_op)]
    pub fn set_max(&mut self, x: &Vector) {
        self.0[24..24 + 24].copy_from_slice(&x.0)
    }
}

// struct AttributeIndex, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Default)]
pub struct AttributeIndex(pub [u8; 16]);
impl core::fmt::Debug for AttributeIndex {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AttributeIndex")
            .field("index", &self.index())
            .field("length", &self.length())
            .field("branching_factor", &self.branching_factor())
            .field("num_unique_items", &self.num_unique_items())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for AttributeIndex {}
impl<'a> flatbuffers::Follow<'a> for AttributeIndex {
    type Inner = &'a AttributeIndex;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a AttributeIndex>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a AttributeIndex {
    type Inner = &'a AttributeIndex;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<AttributeIndex>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for AttributeIndex {
    type Output = AttributeIndex;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src =
            ::core::slice::from_raw_parts(self as *const AttributeIndex as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for AttributeIndex {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> AttributeIndex {
    #[allow(clippy::too_many_arguments)]
    pub fn new(index: u16, length: u32, branching_factor: u16, num_unique_items: u32) -> Self {
        let mut s = Self([0; 16]);
        s.set_index(index);
        s.set_length(length);
        s.set_branching_factor(branching_factor);
        s.set_num_unique_items(num_unique_items);
        s
    }

    pub fn index(&self) -> u16 {
        let mut mem = core::mem::MaybeUninit::<<u16 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_index(&mut self, x: u16) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn length(&self) -> u32 {
        let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[4..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_length(&mut self, x: u32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[4..].as_mut_ptr(),
                core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn branching_factor(&self) -> u16 {
        let mut mem = core::mem::MaybeUninit::<<u16 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_branching_factor(&mut self, x: u16) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn num_unique_items(&self) -> u32 {
        let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[12..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_num_unique_items(&mut self, x: u32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[12..].as_mut_ptr(),
                core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
            );
        }
    }
}

// struct Vec2, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Default)]
pub struct Vec2(pub [u8; 16]);
impl core::fmt::Debug for Vec2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vec2")
            .field("u", &self.u())
            .field("v", &self.v())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Vec2 {}
impl<'a> flatbuffers::Follow<'a> for Vec2 {
    type Inner = &'a Vec2;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Vec2>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vec2 {
    type Inner = &'a Vec2;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Vec2>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Vec2 {
    type Output = Vec2;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vec2 as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vec2 {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Vec2 {
    #[allow(clippy::too_many_arguments)]
    pub fn new(u: f64, v: f64) -> Self {
        let mut s = Self([0; 16]);
        s.set_u(u);
        s.set_v(v);
        s
    }

    pub fn u(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_u(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn v(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_v(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }
}

// struct DoubleVertex, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Default)]
pub struct DoubleVertex(pub [u8; 24]);
impl core::fmt::Debug for DoubleVertex {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DoubleVertex")
            .field("x", &self.x())
            .field("y", &self.y())
            .field("z", &self.z())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for DoubleVertex {}
impl<'a> flatbuffers::Follow<'a> for DoubleVertex {
    type Inner = &'a DoubleVertex;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a DoubleVertex>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a DoubleVertex {
    type Inner = &'a DoubleVertex;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<DoubleVertex>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for DoubleVertex {
    type Output = DoubleVertex;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src =
            ::core::slice::from_raw_parts(self as *const DoubleVertex as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for DoubleVertex {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> DoubleVertex {
    #[allow(clippy::too_many_arguments)]
    pub fn new(x: f64, y: f64, z: f64) -> Self {
        let mut s = Self([0; 24]);
        s.set_x(x);
        s.set_y(y);
        s.set_z(z);
        s
    }

    pub fn x(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_x(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn y(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_y(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn z(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[16..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_z(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[16..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }
}

pub enum ColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Column<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Column<'a> {
    type Inner = Column<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Column<'a> {
    pub const VT_INDEX: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
    pub const VT_TITLE: flatbuffers::VOffsetT = 10;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 12;
    pub const VT_PRECISION: flatbuffers::VOffsetT = 14;
    pub const VT_SCALE: flatbuffers::VOffsetT = 16;
    pub const VT_NULLABLE: flatbuffers::VOffsetT = 18;
    pub const VT_UNIQUE: flatbuffers::VOffsetT = 20;
    pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 22;
    pub const VT_METADATA: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Column { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ColumnArgs<'args>,
    ) -> flatbuffers::WIPOffset<Column<'bldr>> {
        let mut builder = ColumnBuilder::new(_fbb);
        if let Some(x) = args.metadata {
            builder.add_metadata(x);
        }
        builder.add_scale(args.scale);
        builder.add_precision(args.precision);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_index(args.index);
        builder.add_primary_key(args.primary_key);
        builder.add_unique(args.unique);
        builder.add_nullable(args.nullable);
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn index(&self) -> u16 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u16>(Column::VT_INDEX, Some(0)).unwrap() }
    }
    #[inline]
    pub fn name(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_NAME, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> ColumnType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ColumnType>(Column::VT_TYPE_, Some(ColumnType::Byte))
                .unwrap()
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_TITLE, None)
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_DESCRIPTION, None)
        }
    }
    #[inline]
    pub fn precision(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(Column::VT_PRECISION, Some(-1))
                .unwrap()
        }
    }
    #[inline]
    pub fn scale(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(Column::VT_SCALE, Some(-1)).unwrap() }
    }
    #[inline]
    pub fn nullable(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(Column::VT_NULLABLE, Some(true))
                .unwrap()
        }
    }
    #[inline]
    pub fn unique(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(Column::VT_UNIQUE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn primary_key(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(Column::VT_PRIMARY_KEY, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn metadata(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_METADATA, None)
        }
    }
}

impl flatbuffers::Verifiable for Column<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<u16>("index", Self::VT_INDEX, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
            .visit_field::<ColumnType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<i32>("precision", Self::VT_PRECISION, false)?
            .visit_field::<i32>("scale", Self::VT_SCALE, false)?
            .visit_field::<bool>("nullable", Self::VT_NULLABLE, false)?
            .visit_field::<bool>("unique", Self::VT_UNIQUE, false)?
            .visit_field::<bool>("primary_key", Self::VT_PRIMARY_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "metadata",
                Self::VT_METADATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ColumnArgs<'a> {
    pub index: u16,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: ColumnType,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub precision: i32,
    pub scale: i32,
    pub nullable: bool,
    pub unique: bool,
    pub primary_key: bool,
    pub metadata: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl Default for ColumnArgs<'_> {
    #[inline]
    fn default() -> Self {
        ColumnArgs {
            index: 0,
            name: None, // required field
            type_: ColumnType::Byte,
            title: None,
            description: None,
            precision: -1,
            scale: -1,
            nullable: true,
            unique: false,
            primary_key: false,
            metadata: None,
        }
    }
}

pub struct ColumnBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ColumnBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_index(&mut self, index: u16) {
        self.fbb_.push_slot::<u16>(Column::VT_INDEX, index, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_NAME, name);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: ColumnType) {
        self.fbb_
            .push_slot::<ColumnType>(Column::VT_TYPE_, type_, ColumnType::Byte);
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_TITLE, title);
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_DESCRIPTION, description);
    }
    #[inline]
    pub fn add_precision(&mut self, precision: i32) {
        self.fbb_
            .push_slot::<i32>(Column::VT_PRECISION, precision, -1);
    }
    #[inline]
    pub fn add_scale(&mut self, scale: i32) {
        self.fbb_.push_slot::<i32>(Column::VT_SCALE, scale, -1);
    }
    #[inline]
    pub fn add_nullable(&mut self, nullable: bool) {
        self.fbb_
            .push_slot::<bool>(Column::VT_NULLABLE, nullable, true);
    }
    #[inline]
    pub fn add_unique(&mut self, unique: bool) {
        self.fbb_
            .push_slot::<bool>(Column::VT_UNIQUE, unique, false);
    }
    #[inline]
    pub fn add_primary_key(&mut self, primary_key: bool) {
        self.fbb_
            .push_slot::<bool>(Column::VT_PRIMARY_KEY, primary_key, false);
    }
    #[inline]
    pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_METADATA, metadata);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ColumnBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ColumnBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Column<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Column::VT_NAME, "name");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Column<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Column");
        ds.field("index", &self.index());
        ds.field("name", &self.name());
        ds.field("type_", &self.type_());
        ds.field("title", &self.title());
        ds.field("description", &self.description());
        ds.field("precision", &self.precision());
        ds.field("scale", &self.scale());
        ds.field("nullable", &self.nullable());
        ds.field("unique", &self.unique());
        ds.field("primary_key", &self.primary_key());
        ds.field("metadata", &self.metadata());
        ds.finish()
    }
}
pub enum ReferenceSystemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReferenceSystem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReferenceSystem<'a> {
    type Inner = ReferenceSystem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReferenceSystem<'a> {
    pub const VT_AUTHORITY: flatbuffers::VOffsetT = 4;
    pub const VT_VERSION: flatbuffers::VOffsetT = 6;
    pub const VT_CODE: flatbuffers::VOffsetT = 8;
    pub const VT_CODE_STRING: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReferenceSystem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ReferenceSystemArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReferenceSystem<'bldr>> {
        let mut builder = ReferenceSystemBuilder::new(_fbb);
        if let Some(x) = args.code_string {
            builder.add_code_string(x);
        }
        builder.add_code(args.code);
        builder.add_version(args.version);
        if let Some(x) = args.authority {
            builder.add_authority(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn authority(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReferenceSystem::VT_AUTHORITY, None)
        }
    }
    #[inline]
    pub fn version(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(ReferenceSystem::VT_VERSION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn code(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(ReferenceSystem::VT_CODE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn code_string(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReferenceSystem::VT_CODE_STRING, None)
        }
    }
}

impl flatbuffers::Verifiable for ReferenceSystem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "authority",
                Self::VT_AUTHORITY,
                false,
            )?
            .visit_field::<i32>("version", Self::VT_VERSION, false)?
            .visit_field::<i32>("code", Self::VT_CODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "code_string",
                Self::VT_CODE_STRING,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ReferenceSystemArgs<'a> {
    pub authority: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: i32,
    pub code: i32,
    pub code_string: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl Default for ReferenceSystemArgs<'_> {
    #[inline]
    fn default() -> Self {
        ReferenceSystemArgs {
            authority: None,
            version: 0,
            code: 0,
            code_string: None,
        }
    }
}

pub struct ReferenceSystemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReferenceSystemBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_authority(&mut self, authority: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReferenceSystem::VT_AUTHORITY,
            authority,
        );
    }
    #[inline]
    pub fn add_version(&mut self, version: i32) {
        self.fbb_
            .push_slot::<i32>(ReferenceSystem::VT_VERSION, version, 0);
    }
    #[inline]
    pub fn add_code(&mut self, code: i32) {
        self.fbb_
            .push_slot::<i32>(ReferenceSystem::VT_CODE, code, 0);
    }
    #[inline]
    pub fn add_code_string(&mut self, code_string: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReferenceSystem::VT_CODE_STRING,
            code_string,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ReferenceSystemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ReferenceSystemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReferenceSystem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReferenceSystem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReferenceSystem");
        ds.field("authority", &self.authority());
        ds.field("version", &self.version());
        ds.field("code", &self.code());
        ds.field("code_string", &self.code_string());
        ds.finish()
    }
}
pub enum MaterialOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Material<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Material<'a> {
    type Inner = Material<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Material<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_AMBIENT_INTENSITY: flatbuffers::VOffsetT = 6;
    pub const VT_DIFFUSE_COLOR: flatbuffers::VOffsetT = 8;
    pub const VT_EMISSIVE_COLOR: flatbuffers::VOffsetT = 10;
    pub const VT_SPECULAR_COLOR: flatbuffers::VOffsetT = 12;
    pub const VT_SHININESS: flatbuffers::VOffsetT = 14;
    pub const VT_TRANSPARENCY: flatbuffers::VOffsetT = 16;
    pub const VT_IS_SMOOTH: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Material { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MaterialArgs<'args>,
    ) -> flatbuffers::WIPOffset<Material<'bldr>> {
        let mut builder = MaterialBuilder::new(_fbb);
        if let Some(x) = args.transparency {
            builder.add_transparency(x);
        }
        if let Some(x) = args.shininess {
            builder.add_shininess(x);
        }
        if let Some(x) = args.ambient_intensity {
            builder.add_ambient_intensity(x);
        }
        if let Some(x) = args.specular_color {
            builder.add_specular_color(x);
        }
        if let Some(x) = args.emissive_color {
            builder.add_emissive_color(x);
        }
        if let Some(x) = args.diffuse_color {
            builder.add_diffuse_color(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.is_smooth {
            builder.add_is_smooth(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Material::VT_NAME, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn ambient_intensity(&self) -> Option<f64> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f64>(Material::VT_AMBIENT_INTENSITY, None) }
    }
    #[inline]
    pub fn diffuse_color(&self) -> Option<flatbuffers::Vector<'a, f64>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(
                    Material::VT_DIFFUSE_COLOR,
                    None,
                )
        }
    }
    #[inline]
    pub fn emissive_color(&self) -> Option<flatbuffers::Vector<'a, f64>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(
                    Material::VT_EMISSIVE_COLOR,
                    None,
                )
        }
    }
    #[inline]
    pub fn specular_color(&self) -> Option<flatbuffers::Vector<'a, f64>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(
                    Material::VT_SPECULAR_COLOR,
                    None,
                )
        }
    }
    #[inline]
    pub fn shininess(&self) -> Option<f64> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f64>(Material::VT_SHININESS, None) }
    }
    #[inline]
    pub fn transparency(&self) -> Option<f64> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f64>(Material::VT_TRANSPARENCY, None) }
    }
    #[inline]
    pub fn is_smooth(&self) -> Option<bool> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<bool>(Material::VT_IS_SMOOTH, None) }
    }
}

impl flatbuffers::Verifiable for Material<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
            .visit_field::<f64>("ambient_intensity", Self::VT_AMBIENT_INTENSITY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(
                "diffuse_color",
                Self::VT_DIFFUSE_COLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(
                "emissive_color",
                Self::VT_EMISSIVE_COLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(
                "specular_color",
                Self::VT_SPECULAR_COLOR,
                false,
            )?
            .visit_field::<f64>("shininess", Self::VT_SHININESS, false)?
            .visit_field::<f64>("transparency", Self::VT_TRANSPARENCY, false)?
            .visit_field::<bool>("is_smooth", Self::VT_IS_SMOOTH, false)?
            .finish();
        Ok(())
    }
}
pub struct MaterialArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ambient_intensity: Option<f64>,
    pub diffuse_color: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub emissive_color: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub specular_color: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub shininess: Option<f64>,
    pub transparency: Option<f64>,
    pub is_smooth: Option<bool>,
}
impl Default for MaterialArgs<'_> {
    #[inline]
    fn default() -> Self {
        MaterialArgs {
            name: None, // required field
            ambient_intensity: None,
            diffuse_color: None,
            emissive_color: None,
            specular_color: None,
            shininess: None,
            transparency: None,
            is_smooth: None,
        }
    }
}

pub struct MaterialBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MaterialBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_NAME, name);
    }
    #[inline]
    pub fn add_ambient_intensity(&mut self, ambient_intensity: f64) {
        self.fbb_
            .push_slot_always::<f64>(Material::VT_AMBIENT_INTENSITY, ambient_intensity);
    }
    #[inline]
    pub fn add_diffuse_color(
        &mut self,
        diffuse_color: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f64>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Material::VT_DIFFUSE_COLOR,
            diffuse_color,
        );
    }
    #[inline]
    pub fn add_emissive_color(
        &mut self,
        emissive_color: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f64>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Material::VT_EMISSIVE_COLOR,
            emissive_color,
        );
    }
    #[inline]
    pub fn add_specular_color(
        &mut self,
        specular_color: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f64>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Material::VT_SPECULAR_COLOR,
            specular_color,
        );
    }
    #[inline]
    pub fn add_shininess(&mut self, shininess: f64) {
        self.fbb_
            .push_slot_always::<f64>(Material::VT_SHININESS, shininess);
    }
    #[inline]
    pub fn add_transparency(&mut self, transparency: f64) {
        self.fbb_
            .push_slot_always::<f64>(Material::VT_TRANSPARENCY, transparency);
    }
    #[inline]
    pub fn add_is_smooth(&mut self, is_smooth: bool) {
        self.fbb_
            .push_slot_always::<bool>(Material::VT_IS_SMOOTH, is_smooth);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MaterialBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MaterialBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Material<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Material::VT_NAME, "name");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Material<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Material");
        ds.field("name", &self.name());
        ds.field("ambient_intensity", &self.ambient_intensity());
        ds.field("diffuse_color", &self.diffuse_color());
        ds.field("emissive_color", &self.emissive_color());
        ds.field("specular_color", &self.specular_color());
        ds.field("shininess", &self.shininess());
        ds.field("transparency", &self.transparency());
        ds.field("is_smooth", &self.is_smooth());
        ds.finish()
    }
}
pub enum TextureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Texture<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Texture<'a> {
    type Inner = Texture<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Texture<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_IMAGE: flatbuffers::VOffsetT = 6;
    pub const VT_WRAP_MODE: flatbuffers::VOffsetT = 8;
    pub const VT_TEXTURE_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_BORDER_COLOR: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Texture { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TextureArgs<'args>,
    ) -> flatbuffers::WIPOffset<Texture<'bldr>> {
        let mut builder = TextureBuilder::new(_fbb);
        if let Some(x) = args.border_color {
            builder.add_border_color(x);
        }
        if let Some(x) = args.image {
            builder.add_image(x);
        }
        if let Some(x) = args.texture_type {
            builder.add_texture_type(x);
        }
        if let Some(x) = args.wrap_mode {
            builder.add_wrap_mode(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> TextureFormat {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<TextureFormat>(Texture::VT_TYPE_, Some(TextureFormat::PNG))
                .unwrap()
        }
    }
    #[inline]
    pub fn image(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Texture::VT_IMAGE, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn wrap_mode(&self) -> Option<WrapMode> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<WrapMode>(Texture::VT_WRAP_MODE, None) }
    }
    #[inline]
    pub fn texture_type(&self) -> Option<TextureType> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<TextureType>(Texture::VT_TEXTURE_TYPE, None) }
    }
    #[inline]
    pub fn border_color(&self) -> Option<flatbuffers::Vector<'a, f64>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(
                    Texture::VT_BORDER_COLOR,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for Texture<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<TextureFormat>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, true)?
            .visit_field::<WrapMode>("wrap_mode", Self::VT_WRAP_MODE, false)?
            .visit_field::<TextureType>("texture_type", Self::VT_TEXTURE_TYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(
                "border_color",
                Self::VT_BORDER_COLOR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct TextureArgs<'a> {
    pub type_: TextureFormat,
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
    pub wrap_mode: Option<WrapMode>,
    pub texture_type: Option<TextureType>,
    pub border_color: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl Default for TextureArgs<'_> {
    #[inline]
    fn default() -> Self {
        TextureArgs {
            type_: TextureFormat::PNG,
            image: None, // required field
            wrap_mode: None,
            texture_type: None,
            border_color: None,
        }
    }
}

pub struct TextureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextureBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_type_(&mut self, type_: TextureFormat) {
        self.fbb_
            .push_slot::<TextureFormat>(Texture::VT_TYPE_, type_, TextureFormat::PNG);
    }
    #[inline]
    pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Texture::VT_IMAGE, image);
    }
    #[inline]
    pub fn add_wrap_mode(&mut self, wrap_mode: WrapMode) {
        self.fbb_
            .push_slot_always::<WrapMode>(Texture::VT_WRAP_MODE, wrap_mode);
    }
    #[inline]
    pub fn add_texture_type(&mut self, texture_type: TextureType) {
        self.fbb_
            .push_slot_always::<TextureType>(Texture::VT_TEXTURE_TYPE, texture_type);
    }
    #[inline]
    pub fn add_border_color(
        &mut self,
        border_color: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f64>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Texture::VT_BORDER_COLOR, border_color);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TextureBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TextureBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Texture<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Texture::VT_IMAGE, "image");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Texture<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Texture");
        ds.field("type_", &self.type_());
        ds.field("image", &self.image());
        ds.field("wrap_mode", &self.wrap_mode());
        ds.field("texture_type", &self.texture_type());
        ds.field("border_color", &self.border_color());
        ds.finish()
    }
}
pub enum AppearanceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Appearance<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Appearance<'a> {
    type Inner = Appearance<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Appearance<'a> {
    pub const VT_MATERIALS: flatbuffers::VOffsetT = 4;
    pub const VT_TEXTURES: flatbuffers::VOffsetT = 6;
    pub const VT_VERTICES_TEXTURE: flatbuffers::VOffsetT = 8;
    pub const VT_DEFAULT_THEME_TEXTURE: flatbuffers::VOffsetT = 10;
    pub const VT_DEFAULT_THEME_MATERIAL: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Appearance { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args AppearanceArgs<'args>,
    ) -> flatbuffers::WIPOffset<Appearance<'bldr>> {
        let mut builder = AppearanceBuilder::new(_fbb);
        if let Some(x) = args.default_theme_material {
            builder.add_default_theme_material(x);
        }
        if let Some(x) = args.default_theme_texture {
            builder.add_default_theme_texture(x);
        }
        if let Some(x) = args.vertices_texture {
            builder.add_vertices_texture(x);
        }
        if let Some(x) = args.textures {
            builder.add_textures(x);
        }
        if let Some(x) = args.materials {
            builder.add_materials(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn materials(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Material<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Material>>,
            >>(Appearance::VT_MATERIALS, None)
        }
    }
    #[inline]
    pub fn textures(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Texture<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Texture>>,
            >>(Appearance::VT_TEXTURES, None)
        }
    }
    #[inline]
    pub fn vertices_texture(&self) -> Option<flatbuffers::Vector<'a, Vec2>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vec2>>>(
                    Appearance::VT_VERTICES_TEXTURE,
                    None,
                )
        }
    }
    #[inline]
    pub fn default_theme_texture(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                Appearance::VT_DEFAULT_THEME_TEXTURE,
                None,
            )
        }
    }
    #[inline]
    pub fn default_theme_material(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                Appearance::VT_DEFAULT_THEME_MATERIAL,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for Appearance<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Material>>,
            >>("materials", Self::VT_MATERIALS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Texture>>,
            >>("textures", Self::VT_TEXTURES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vec2>>>(
                "vertices_texture",
                Self::VT_VERTICES_TEXTURE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "default_theme_texture",
                Self::VT_DEFAULT_THEME_TEXTURE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "default_theme_material",
                Self::VT_DEFAULT_THEME_MATERIAL,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct AppearanceArgs<'a> {
    pub materials: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Material<'a>>>>,
    >,
    pub textures: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Texture<'a>>>>,
    >,
    pub vertices_texture: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vec2>>>,
    pub default_theme_texture: Option<flatbuffers::WIPOffset<&'a str>>,
    pub default_theme_material: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl Default for AppearanceArgs<'_> {
    #[inline]
    fn default() -> Self {
        AppearanceArgs {
            materials: None,
            textures: None,
            vertices_texture: None,
            default_theme_texture: None,
            default_theme_material: None,
        }
    }
}

pub struct AppearanceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AppearanceBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_materials(
        &mut self,
        materials: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Material<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Appearance::VT_MATERIALS, materials);
    }
    #[inline]
    pub fn add_textures(
        &mut self,
        textures: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Texture<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Appearance::VT_TEXTURES, textures);
    }
    #[inline]
    pub fn add_vertices_texture(
        &mut self,
        vertices_texture: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Vec2>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Appearance::VT_VERTICES_TEXTURE,
            vertices_texture,
        );
    }
    #[inline]
    pub fn add_default_theme_texture(
        &mut self,
        default_theme_texture: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Appearance::VT_DEFAULT_THEME_TEXTURE,
            default_theme_texture,
        );
    }
    #[inline]
    pub fn add_default_theme_material(
        &mut self,
        default_theme_material: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Appearance::VT_DEFAULT_THEME_MATERIAL,
            default_theme_material,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> AppearanceBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        AppearanceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Appearance<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Appearance<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Appearance");
        ds.field("materials", &self.materials());
        ds.field("textures", &self.textures());
        ds.field("vertices_texture", &self.vertices_texture());
        ds.field("default_theme_texture", &self.default_theme_texture());
        ds.field("default_theme_material", &self.default_theme_material());
        ds.finish()
    }
}
pub enum HeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Header<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Header<'a> {
    type Inner = Header<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Header<'a> {
    pub const VT_TRANSFORM: flatbuffers::VOffsetT = 4;
    pub const VT_APPEARANCE: flatbuffers::VOffsetT = 6;
    pub const VT_COLUMNS: flatbuffers::VOffsetT = 8;
    pub const VT_SEMANTIC_COLUMNS: flatbuffers::VOffsetT = 10;
    pub const VT_FEATURES_COUNT: flatbuffers::VOffsetT = 12;
    pub const VT_INDEX_NODE_SIZE: flatbuffers::VOffsetT = 14;
    pub const VT_ATTRIBUTE_INDEX: flatbuffers::VOffsetT = 16;
    pub const VT_GEOGRAPHICAL_EXTENT: flatbuffers::VOffsetT = 18;
    pub const VT_REFERENCE_SYSTEM: flatbuffers::VOffsetT = 20;
    pub const VT_IDENTIFIER: flatbuffers::VOffsetT = 22;
    pub const VT_REFERENCE_DATE: flatbuffers::VOffsetT = 24;
    pub const VT_TITLE: flatbuffers::VOffsetT = 26;
    pub const VT_TEMPLATES: flatbuffers::VOffsetT = 28;
    pub const VT_TEMPLATES_VERTICES: flatbuffers::VOffsetT = 30;
    pub const VT_EXTENSIONS: flatbuffers::VOffsetT = 32;
    pub const VT_POC_CONTACT_NAME: flatbuffers::VOffsetT = 34;
    pub const VT_POC_CONTACT_TYPE: flatbuffers::VOffsetT = 36;
    pub const VT_POC_ROLE: flatbuffers::VOffsetT = 38;
    pub const VT_POC_PHONE: flatbuffers::VOffsetT = 40;
    pub const VT_POC_EMAIL: flatbuffers::VOffsetT = 42;
    pub const VT_POC_WEBSITE: flatbuffers::VOffsetT = 44;
    pub const VT_POC_ADDRESS_THOROUGHFARE_NUMBER: flatbuffers::VOffsetT = 46;
    pub const VT_POC_ADDRESS_THOROUGHFARE_NAME: flatbuffers::VOffsetT = 48;
    pub const VT_POC_ADDRESS_LOCALITY: flatbuffers::VOffsetT = 50;
    pub const VT_POC_ADDRESS_POSTCODE: flatbuffers::VOffsetT = 52;
    pub const VT_POC_ADDRESS_COUNTRY: flatbuffers::VOffsetT = 54;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 56;
    pub const VT_VERSION: flatbuffers::VOffsetT = 58;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Header { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args HeaderArgs<'args>,
    ) -> flatbuffers::WIPOffset<Header<'bldr>> {
        let mut builder = HeaderBuilder::new(_fbb);
        builder.add_features_count(args.features_count);
        if let Some(x) = args.version {
            builder.add_version(x);
        }
        if let Some(x) = args.attributes {
            builder.add_attributes(x);
        }
        if let Some(x) = args.poc_address_country {
            builder.add_poc_address_country(x);
        }
        if let Some(x) = args.poc_address_postcode {
            builder.add_poc_address_postcode(x);
        }
        if let Some(x) = args.poc_address_locality {
            builder.add_poc_address_locality(x);
        }
        if let Some(x) = args.poc_address_thoroughfare_name {
            builder.add_poc_address_thoroughfare_name(x);
        }
        if let Some(x) = args.poc_address_thoroughfare_number {
            builder.add_poc_address_thoroughfare_number(x);
        }
        if let Some(x) = args.poc_website {
            builder.add_poc_website(x);
        }
        if let Some(x) = args.poc_email {
            builder.add_poc_email(x);
        }
        if let Some(x) = args.poc_phone {
            builder.add_poc_phone(x);
        }
        if let Some(x) = args.poc_role {
            builder.add_poc_role(x);
        }
        if let Some(x) = args.poc_contact_type {
            builder.add_poc_contact_type(x);
        }
        if let Some(x) = args.poc_contact_name {
            builder.add_poc_contact_name(x);
        }
        if let Some(x) = args.extensions {
            builder.add_extensions(x);
        }
        if let Some(x) = args.templates_vertices {
            builder.add_templates_vertices(x);
        }
        if let Some(x) = args.templates {
            builder.add_templates(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        if let Some(x) = args.reference_date {
            builder.add_reference_date(x);
        }
        if let Some(x) = args.identifier {
            builder.add_identifier(x);
        }
        if let Some(x) = args.reference_system {
            builder.add_reference_system(x);
        }
        if let Some(x) = args.geographical_extent {
            builder.add_geographical_extent(x);
        }
        if let Some(x) = args.attribute_index {
            builder.add_attribute_index(x);
        }
        if let Some(x) = args.semantic_columns {
            builder.add_semantic_columns(x);
        }
        if let Some(x) = args.columns {
            builder.add_columns(x);
        }
        if let Some(x) = args.appearance {
            builder.add_appearance(x);
        }
        if let Some(x) = args.transform {
            builder.add_transform(x);
        }
        builder.add_index_node_size(args.index_node_size);
        builder.finish()
    }

    #[inline]
    pub fn transform(&self) -> Option<&'a Transform> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<Transform>(Header::VT_TRANSFORM, None) }
    }
    #[inline]
    pub fn appearance(&self) -> Option<Appearance<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Appearance>>(Header::VT_APPEARANCE, None)
        }
    }
    #[inline]
    pub fn columns(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column>>,
            >>(Header::VT_COLUMNS, None)
        }
    }
    #[inline]
    pub fn semantic_columns(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column>>,
            >>(Header::VT_SEMANTIC_COLUMNS, None)
        }
    }
    #[inline]
    pub fn features_count(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(Header::VT_FEATURES_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn index_node_size(&self) -> u16 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u16>(Header::VT_INDEX_NODE_SIZE, Some(16))
                .unwrap()
        }
    }
    #[inline]
    pub fn attribute_index(&self) -> Option<flatbuffers::Vector<'a, AttributeIndex>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, AttributeIndex>>>(
                    Header::VT_ATTRIBUTE_INDEX,
                    None,
                )
        }
    }
    #[inline]
    pub fn geographical_extent(&self) -> Option<&'a GeographicalExtent> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<GeographicalExtent>(Header::VT_GEOGRAPHICAL_EXTENT, None)
        }
    }
    #[inline]
    pub fn reference_system(&self) -> Option<ReferenceSystem<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<ReferenceSystem>>(
                    Header::VT_REFERENCE_SYSTEM,
                    None,
                )
        }
    }
    #[inline]
    pub fn identifier(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_IDENTIFIER, None)
        }
    }
    #[inline]
    pub fn reference_date(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_REFERENCE_DATE, None)
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_TITLE, None)
        }
    }
    #[inline]
    pub fn templates(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry>>,
            >>(Header::VT_TEMPLATES, None)
        }
    }
    #[inline]
    pub fn templates_vertices(&self) -> Option<flatbuffers::Vector<'a, DoubleVertex>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, DoubleVertex>>>(
                    Header::VT_TEMPLATES_VERTICES,
                    None,
                )
        }
    }
    #[inline]
    pub fn extensions(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Extension<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Extension>>,
            >>(Header::VT_EXTENSIONS, None)
        }
    }
    #[inline]
    pub fn poc_contact_name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_POC_CONTACT_NAME, None)
        }
    }
    #[inline]
    pub fn poc_contact_type(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_POC_CONTACT_TYPE, None)
        }
    }
    #[inline]
    pub fn poc_role(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_POC_ROLE, None)
        }
    }
    #[inline]
    pub fn poc_phone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_POC_PHONE, None)
        }
    }
    #[inline]
    pub fn poc_email(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_POC_EMAIL, None)
        }
    }
    #[inline]
    pub fn poc_website(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_POC_WEBSITE, None)
        }
    }
    #[inline]
    pub fn poc_address_thoroughfare_number(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                Header::VT_POC_ADDRESS_THOROUGHFARE_NUMBER,
                None,
            )
        }
    }
    #[inline]
    pub fn poc_address_thoroughfare_name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                Header::VT_POC_ADDRESS_THOROUGHFARE_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn poc_address_locality(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_POC_ADDRESS_LOCALITY, None)
        }
    }
    #[inline]
    pub fn poc_address_postcode(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_POC_ADDRESS_POSTCODE, None)
        }
    }
    #[inline]
    pub fn poc_address_country(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_POC_ADDRESS_COUNTRY, None)
        }
    }
    #[inline]
    pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Header::VT_ATTRIBUTES,
                    None,
                )
        }
    }
    #[inline]
    pub fn version(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_VERSION, None)
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Header<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<Transform>("transform", Self::VT_TRANSFORM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<Appearance>>(
                "appearance",
                Self::VT_APPEARANCE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Column>>,
            >>("columns", Self::VT_COLUMNS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Column>>,
            >>("semantic_columns", Self::VT_SEMANTIC_COLUMNS, false)?
            .visit_field::<u64>("features_count", Self::VT_FEATURES_COUNT, false)?
            .visit_field::<u16>("index_node_size", Self::VT_INDEX_NODE_SIZE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, AttributeIndex>>>(
                "attribute_index",
                Self::VT_ATTRIBUTE_INDEX,
                false,
            )?
            .visit_field::<GeographicalExtent>(
                "geographical_extent",
                Self::VT_GEOGRAPHICAL_EXTENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<ReferenceSystem>>(
                "reference_system",
                Self::VT_REFERENCE_SYSTEM,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "identifier",
                Self::VT_IDENTIFIER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "reference_date",
                Self::VT_REFERENCE_DATE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Geometry>>,
            >>("templates", Self::VT_TEMPLATES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, DoubleVertex>>>(
                "templates_vertices",
                Self::VT_TEMPLATES_VERTICES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Extension>>,
            >>("extensions", Self::VT_EXTENSIONS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "poc_contact_name",
                Self::VT_POC_CONTACT_NAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "poc_contact_type",
                Self::VT_POC_CONTACT_TYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "poc_role",
                Self::VT_POC_ROLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "poc_phone",
                Self::VT_POC_PHONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "poc_email",
                Self::VT_POC_EMAIL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "poc_website",
                Self::VT_POC_WEBSITE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "poc_address_thoroughfare_number",
                Self::VT_POC_ADDRESS_THOROUGHFARE_NUMBER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "poc_address_thoroughfare_name",
                Self::VT_POC_ADDRESS_THOROUGHFARE_NAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "poc_address_locality",
                Self::VT_POC_ADDRESS_LOCALITY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "poc_address_postcode",
                Self::VT_POC_ADDRESS_POSTCODE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "poc_address_country",
                Self::VT_POC_ADDRESS_COUNTRY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "attributes",
                Self::VT_ATTRIBUTES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, true)?
            .finish();
        Ok(())
    }
}
pub struct HeaderArgs<'a> {
    pub transform: Option<&'a Transform>,
    pub appearance: Option<flatbuffers::WIPOffset<Appearance<'a>>>,
    pub columns: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>>,
    >,
    pub semantic_columns: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>>,
    >,
    pub features_count: u64,
    pub index_node_size: u16,
    pub attribute_index: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, AttributeIndex>>>,
    pub geographical_extent: Option<&'a GeographicalExtent>,
    pub reference_system: Option<flatbuffers::WIPOffset<ReferenceSystem<'a>>>,
    pub identifier: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reference_date: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub templates: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry<'a>>>>,
    >,
    pub templates_vertices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, DoubleVertex>>>,
    pub extensions: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Extension<'a>>>,
        >,
    >,
    pub poc_contact_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub poc_contact_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub poc_role: Option<flatbuffers::WIPOffset<&'a str>>,
    pub poc_phone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub poc_email: Option<flatbuffers::WIPOffset<&'a str>>,
    pub poc_website: Option<flatbuffers::WIPOffset<&'a str>>,
    pub poc_address_thoroughfare_number: Option<flatbuffers::WIPOffset<&'a str>>,
    pub poc_address_thoroughfare_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub poc_address_locality: Option<flatbuffers::WIPOffset<&'a str>>,
    pub poc_address_postcode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub poc_address_country: Option<flatbuffers::WIPOffset<&'a str>>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl Default for HeaderArgs<'_> {
    #[inline]
    fn default() -> Self {
        HeaderArgs {
            transform: None,
            appearance: None,
            columns: None,
            semantic_columns: None,
            features_count: 0,
            index_node_size: 16,
            attribute_index: None,
            geographical_extent: None,
            reference_system: None,
            identifier: None,
            reference_date: None,
            title: None,
            templates: None,
            templates_vertices: None,
            extensions: None,
            poc_contact_name: None,
            poc_contact_type: None,
            poc_role: None,
            poc_phone: None,
            poc_email: None,
            poc_website: None,
            poc_address_thoroughfare_number: None,
            poc_address_thoroughfare_name: None,
            poc_address_locality: None,
            poc_address_postcode: None,
            poc_address_country: None,
            attributes: None,
            version: None, // required field
        }
    }
}

pub struct HeaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HeaderBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_transform(&mut self, transform: &Transform) {
        self.fbb_
            .push_slot_always::<&Transform>(Header::VT_TRANSFORM, transform);
    }
    #[inline]
    pub fn add_appearance(&mut self, appearance: flatbuffers::WIPOffset<Appearance<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Appearance>>(
                Header::VT_APPEARANCE,
                appearance,
            );
    }
    #[inline]
    pub fn add_columns(
        &mut self,
        columns: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Column<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_COLUMNS, columns);
    }
    #[inline]
    pub fn add_semantic_columns(
        &mut self,
        semantic_columns: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Column<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Header::VT_SEMANTIC_COLUMNS,
            semantic_columns,
        );
    }
    #[inline]
    pub fn add_features_count(&mut self, features_count: u64) {
        self.fbb_
            .push_slot::<u64>(Header::VT_FEATURES_COUNT, features_count, 0);
    }
    #[inline]
    pub fn add_index_node_size(&mut self, index_node_size: u16) {
        self.fbb_
            .push_slot::<u16>(Header::VT_INDEX_NODE_SIZE, index_node_size, 16);
    }
    #[inline]
    pub fn add_attribute_index(
        &mut self,
        attribute_index: flatbuffers::WIPOffset<flatbuffers::Vector<'b, AttributeIndex>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Header::VT_ATTRIBUTE_INDEX,
            attribute_index,
        );
    }
    #[inline]
    pub fn add_geographical_extent(&mut self, geographical_extent: &GeographicalExtent) {
        self.fbb_.push_slot_always::<&GeographicalExtent>(
            Header::VT_GEOGRAPHICAL_EXTENT,
            geographical_extent,
        );
    }
    #[inline]
    pub fn add_reference_system(
        &mut self,
        reference_system: flatbuffers::WIPOffset<ReferenceSystem<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<ReferenceSystem>>(
                Header::VT_REFERENCE_SYSTEM,
                reference_system,
            );
    }
    #[inline]
    pub fn add_identifier(&mut self, identifier: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_IDENTIFIER, identifier);
    }
    #[inline]
    pub fn add_reference_date(&mut self, reference_date: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Header::VT_REFERENCE_DATE,
            reference_date,
        );
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_TITLE, title);
    }
    #[inline]
    pub fn add_templates(
        &mut self,
        templates: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Geometry<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_TEMPLATES, templates);
    }
    #[inline]
    pub fn add_templates_vertices(
        &mut self,
        templates_vertices: flatbuffers::WIPOffset<flatbuffers::Vector<'b, DoubleVertex>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Header::VT_TEMPLATES_VERTICES,
            templates_vertices,
        );
    }
    #[inline]
    pub fn add_extensions(
        &mut self,
        extensions: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Extension<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_EXTENSIONS, extensions);
    }
    #[inline]
    pub fn add_poc_contact_name(&mut self, poc_contact_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Header::VT_POC_CONTACT_NAME,
            poc_contact_name,
        );
    }
    #[inline]
    pub fn add_poc_contact_type(&mut self, poc_contact_type: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Header::VT_POC_CONTACT_TYPE,
            poc_contact_type,
        );
    }
    #[inline]
    pub fn add_poc_role(&mut self, poc_role: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_POC_ROLE, poc_role);
    }
    #[inline]
    pub fn add_poc_phone(&mut self, poc_phone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_POC_PHONE, poc_phone);
    }
    #[inline]
    pub fn add_poc_email(&mut self, poc_email: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_POC_EMAIL, poc_email);
    }
    #[inline]
    pub fn add_poc_website(&mut self, poc_website: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_POC_WEBSITE, poc_website);
    }
    #[inline]
    pub fn add_poc_address_thoroughfare_number(
        &mut self,
        poc_address_thoroughfare_number: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Header::VT_POC_ADDRESS_THOROUGHFARE_NUMBER,
            poc_address_thoroughfare_number,
        );
    }
    #[inline]
    pub fn add_poc_address_thoroughfare_name(
        &mut self,
        poc_address_thoroughfare_name: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Header::VT_POC_ADDRESS_THOROUGHFARE_NAME,
            poc_address_thoroughfare_name,
        );
    }
    #[inline]
    pub fn add_poc_address_locality(
        &mut self,
        poc_address_locality: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Header::VT_POC_ADDRESS_LOCALITY,
            poc_address_locality,
        );
    }
    #[inline]
    pub fn add_poc_address_postcode(
        &mut self,
        poc_address_postcode: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Header::VT_POC_ADDRESS_POSTCODE,
            poc_address_postcode,
        );
    }
    #[inline]
    pub fn add_poc_address_country(
        &mut self,
        poc_address_country: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Header::VT_POC_ADDRESS_COUNTRY,
            poc_address_country,
        );
    }
    #[inline]
    pub fn add_attributes(
        &mut self,
        attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_ATTRIBUTES, attributes);
    }
    #[inline]
    pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_VERSION, version);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HeaderBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        HeaderBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Header::VT_VERSION, "version");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Header<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Header");
        ds.field("transform", &self.transform());
        ds.field("appearance", &self.appearance());
        ds.field("columns", &self.columns());
        ds.field("semantic_columns", &self.semantic_columns());
        ds.field("features_count", &self.features_count());
        ds.field("index_node_size", &self.index_node_size());
        ds.field("attribute_index", &self.attribute_index());
        ds.field("geographical_extent", &self.geographical_extent());
        ds.field("reference_system", &self.reference_system());
        ds.field("identifier", &self.identifier());
        ds.field("reference_date", &self.reference_date());
        ds.field("title", &self.title());
        ds.field("templates", &self.templates());
        ds.field("templates_vertices", &self.templates_vertices());
        ds.field("extensions", &self.extensions());
        ds.field("poc_contact_name", &self.poc_contact_name());
        ds.field("poc_contact_type", &self.poc_contact_type());
        ds.field("poc_role", &self.poc_role());
        ds.field("poc_phone", &self.poc_phone());
        ds.field("poc_email", &self.poc_email());
        ds.field("poc_website", &self.poc_website());
        ds.field(
            "poc_address_thoroughfare_number",
            &self.poc_address_thoroughfare_number(),
        );
        ds.field(
            "poc_address_thoroughfare_name",
            &self.poc_address_thoroughfare_name(),
        );
        ds.field("poc_address_locality", &self.poc_address_locality());
        ds.field("poc_address_postcode", &self.poc_address_postcode());
        ds.field("poc_address_country", &self.poc_address_country());
        ds.field("attributes", &self.attributes());
        ds.field("version", &self.version());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Header`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_header_unchecked`.
pub fn root_as_header(buf: &[u8]) -> Result<Header, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<Header>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Header` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_header_unchecked`.
pub fn size_prefixed_root_as_header(buf: &[u8]) -> Result<Header, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<Header>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Header` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_header_unchecked`.
pub fn root_as_header_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Header<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<Header<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Header` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_header_unchecked`.
pub fn size_prefixed_root_as_header_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Header<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<Header<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Header and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Header`.
pub unsafe fn root_as_header_unchecked(buf: &[u8]) -> Header {
    flatbuffers::root_unchecked::<Header>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Header and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Header`.
pub unsafe fn size_prefixed_root_as_header_unchecked(buf: &[u8]) -> Header {
    flatbuffers::size_prefixed_root_unchecked::<Header>(buf)
}
#[inline]
pub fn finish_header_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Header<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_header_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Header<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
