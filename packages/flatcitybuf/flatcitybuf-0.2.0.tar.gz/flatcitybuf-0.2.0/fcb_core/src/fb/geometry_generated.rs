// automatically generated by the FlatBuffers compiler, do not modify

// @generated

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_SEMANTIC_SURFACE_TYPE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_SEMANTIC_SURFACE_TYPE: u8 = 18;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SEMANTIC_SURFACE_TYPE: [SemanticSurfaceType; 19] = [
    SemanticSurfaceType::RoofSurface,
    SemanticSurfaceType::GroundSurface,
    SemanticSurfaceType::WallSurface,
    SemanticSurfaceType::ClosureSurface,
    SemanticSurfaceType::OuterCeilingSurface,
    SemanticSurfaceType::OuterFloorSurface,
    SemanticSurfaceType::Window,
    SemanticSurfaceType::Door,
    SemanticSurfaceType::InteriorWallSurface,
    SemanticSurfaceType::CeilingSurface,
    SemanticSurfaceType::FloorSurface,
    SemanticSurfaceType::WaterSurface,
    SemanticSurfaceType::WaterGroundSurface,
    SemanticSurfaceType::WaterClosureSurface,
    SemanticSurfaceType::TrafficArea,
    SemanticSurfaceType::AuxiliaryTrafficArea,
    SemanticSurfaceType::TransportationMarking,
    SemanticSurfaceType::TransportationHole,
    SemanticSurfaceType::ExtraSemanticSurface,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SemanticSurfaceType(pub u8);
#[allow(non_upper_case_globals)]
impl SemanticSurfaceType {
    pub const RoofSurface: Self = Self(0);
    pub const GroundSurface: Self = Self(1);
    pub const WallSurface: Self = Self(2);
    pub const ClosureSurface: Self = Self(3);
    pub const OuterCeilingSurface: Self = Self(4);
    pub const OuterFloorSurface: Self = Self(5);
    pub const Window: Self = Self(6);
    pub const Door: Self = Self(7);
    pub const InteriorWallSurface: Self = Self(8);
    pub const CeilingSurface: Self = Self(9);
    pub const FloorSurface: Self = Self(10);
    pub const WaterSurface: Self = Self(11);
    pub const WaterGroundSurface: Self = Self(12);
    pub const WaterClosureSurface: Self = Self(13);
    pub const TrafficArea: Self = Self(14);
    pub const AuxiliaryTrafficArea: Self = Self(15);
    pub const TransportationMarking: Self = Self(16);
    pub const TransportationHole: Self = Self(17);
    pub const ExtraSemanticSurface: Self = Self(18);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 18;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::RoofSurface,
        Self::GroundSurface,
        Self::WallSurface,
        Self::ClosureSurface,
        Self::OuterCeilingSurface,
        Self::OuterFloorSurface,
        Self::Window,
        Self::Door,
        Self::InteriorWallSurface,
        Self::CeilingSurface,
        Self::FloorSurface,
        Self::WaterSurface,
        Self::WaterGroundSurface,
        Self::WaterClosureSurface,
        Self::TrafficArea,
        Self::AuxiliaryTrafficArea,
        Self::TransportationMarking,
        Self::TransportationHole,
        Self::ExtraSemanticSurface,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::RoofSurface => Some("RoofSurface"),
            Self::GroundSurface => Some("GroundSurface"),
            Self::WallSurface => Some("WallSurface"),
            Self::ClosureSurface => Some("ClosureSurface"),
            Self::OuterCeilingSurface => Some("OuterCeilingSurface"),
            Self::OuterFloorSurface => Some("OuterFloorSurface"),
            Self::Window => Some("Window"),
            Self::Door => Some("Door"),
            Self::InteriorWallSurface => Some("InteriorWallSurface"),
            Self::CeilingSurface => Some("CeilingSurface"),
            Self::FloorSurface => Some("FloorSurface"),
            Self::WaterSurface => Some("WaterSurface"),
            Self::WaterGroundSurface => Some("WaterGroundSurface"),
            Self::WaterClosureSurface => Some("WaterClosureSurface"),
            Self::TrafficArea => Some("TrafficArea"),
            Self::AuxiliaryTrafficArea => Some("AuxiliaryTrafficArea"),
            Self::TransportationMarking => Some("TransportationMarking"),
            Self::TransportationHole => Some("TransportationHole"),
            Self::ExtraSemanticSurface => Some("ExtraSemanticSurface"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for SemanticSurfaceType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for SemanticSurfaceType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for SemanticSurfaceType {
    type Output = SemanticSurfaceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SemanticSurfaceType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for SemanticSurfaceType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for SemanticSurfaceType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_GEOMETRY_TYPE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_GEOMETRY_TYPE: u8 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GEOMETRY_TYPE: [GeometryType; 8] = [
    GeometryType::MultiPoint,
    GeometryType::MultiLineString,
    GeometryType::MultiSurface,
    GeometryType::CompositeSurface,
    GeometryType::Solid,
    GeometryType::MultiSolid,
    GeometryType::CompositeSolid,
    GeometryType::GeometryInstance,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GeometryType(pub u8);
#[allow(non_upper_case_globals)]
impl GeometryType {
    pub const MultiPoint: Self = Self(0);
    pub const MultiLineString: Self = Self(1);
    pub const MultiSurface: Self = Self(2);
    pub const CompositeSurface: Self = Self(3);
    pub const Solid: Self = Self(4);
    pub const MultiSolid: Self = Self(5);
    pub const CompositeSolid: Self = Self(6);
    pub const GeometryInstance: Self = Self(7);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::MultiPoint,
        Self::MultiLineString,
        Self::MultiSurface,
        Self::CompositeSurface,
        Self::Solid,
        Self::MultiSolid,
        Self::CompositeSolid,
        Self::GeometryInstance,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MultiPoint => Some("MultiPoint"),
            Self::MultiLineString => Some("MultiLineString"),
            Self::MultiSurface => Some("MultiSurface"),
            Self::CompositeSurface => Some("CompositeSurface"),
            Self::Solid => Some("Solid"),
            Self::MultiSolid => Some("MultiSolid"),
            Self::CompositeSolid => Some("CompositeSolid"),
            Self::GeometryInstance => Some("GeometryInstance"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for GeometryType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for GeometryType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for GeometryType {
    type Output = GeometryType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GeometryType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for GeometryType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for GeometryType {}
// struct TransformationMatrix, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct TransformationMatrix(pub [u8; 128]);
impl Default for TransformationMatrix {
    fn default() -> Self {
        Self([0; 128])
    }
}
impl core::fmt::Debug for TransformationMatrix {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TransformationMatrix")
            .field("m00", &self.m00())
            .field("m01", &self.m01())
            .field("m02", &self.m02())
            .field("m03", &self.m03())
            .field("m10", &self.m10())
            .field("m11", &self.m11())
            .field("m12", &self.m12())
            .field("m13", &self.m13())
            .field("m20", &self.m20())
            .field("m21", &self.m21())
            .field("m22", &self.m22())
            .field("m23", &self.m23())
            .field("m30", &self.m30())
            .field("m31", &self.m31())
            .field("m32", &self.m32())
            .field("m33", &self.m33())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for TransformationMatrix {}
impl<'a> flatbuffers::Follow<'a> for TransformationMatrix {
    type Inner = &'a TransformationMatrix;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a TransformationMatrix>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a TransformationMatrix {
    type Inner = &'a TransformationMatrix;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<TransformationMatrix>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for TransformationMatrix {
    type Output = TransformationMatrix;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const TransformationMatrix as *const u8,
            Self::size(),
        );
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for TransformationMatrix {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> TransformationMatrix {
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        m00: f64,
        m01: f64,
        m02: f64,
        m03: f64,
        m10: f64,
        m11: f64,
        m12: f64,
        m13: f64,
        m20: f64,
        m21: f64,
        m22: f64,
        m23: f64,
        m30: f64,
        m31: f64,
        m32: f64,
        m33: f64,
    ) -> Self {
        let mut s = Self([0; 128]);
        s.set_m00(m00);
        s.set_m01(m01);
        s.set_m02(m02);
        s.set_m03(m03);
        s.set_m10(m10);
        s.set_m11(m11);
        s.set_m12(m12);
        s.set_m13(m13);
        s.set_m20(m20);
        s.set_m21(m21);
        s.set_m22(m22);
        s.set_m23(m23);
        s.set_m30(m30);
        s.set_m31(m31);
        s.set_m32(m32);
        s.set_m33(m33);
        s
    }

    pub fn m00(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m00(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m01(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m01(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m02(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[16..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m02(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[16..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m03(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[24..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m03(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[24..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m10(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[32..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m10(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[32..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m11(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[40..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m11(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[40..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m12(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[48..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m12(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[48..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m13(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[56..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m13(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[56..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m20(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[64..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m20(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[64..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m21(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[72..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m21(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[72..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m22(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[80..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m22(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[80..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m23(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[88..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m23(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[88..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m30(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[96..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m30(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[96..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m31(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[104..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m31(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[104..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m32(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[112..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m32(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[112..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn m33(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[120..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_m33(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[120..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }
}

pub enum MaterialMappingOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MaterialMapping<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MaterialMapping<'a> {
    type Inner = MaterialMapping<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MaterialMapping<'a> {
    pub const VT_THEME: flatbuffers::VOffsetT = 4;
    pub const VT_SOLIDS: flatbuffers::VOffsetT = 6;
    pub const VT_SHELLS: flatbuffers::VOffsetT = 8;
    pub const VT_VERTICES: flatbuffers::VOffsetT = 10;
    pub const VT_VALUE: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MaterialMapping { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MaterialMappingArgs<'args>,
    ) -> flatbuffers::WIPOffset<MaterialMapping<'bldr>> {
        let mut builder = MaterialMappingBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.vertices {
            builder.add_vertices(x);
        }
        if let Some(x) = args.shells {
            builder.add_shells(x);
        }
        if let Some(x) = args.solids {
            builder.add_solids(x);
        }
        if let Some(x) = args.theme {
            builder.add_theme(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn theme(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(MaterialMapping::VT_THEME, None)
        }
    }
    #[inline]
    pub fn solids(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    MaterialMapping::VT_SOLIDS,
                    None,
                )
        }
    }
    #[inline]
    pub fn shells(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    MaterialMapping::VT_SHELLS,
                    None,
                )
        }
    }
    #[inline]
    pub fn vertices(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    MaterialMapping::VT_VERTICES,
                    None,
                )
        }
    }
    #[inline]
    pub fn value(&self) -> Option<u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u32>(MaterialMapping::VT_VALUE, None) }
    }
}

impl flatbuffers::Verifiable for MaterialMapping<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("theme", Self::VT_THEME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "solids",
                Self::VT_SOLIDS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "shells",
                Self::VT_SHELLS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "vertices",
                Self::VT_VERTICES,
                false,
            )?
            .visit_field::<u32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct MaterialMappingArgs<'a> {
    pub theme: Option<flatbuffers::WIPOffset<&'a str>>,
    pub solids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub shells: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub vertices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub value: Option<u32>,
}
impl Default for MaterialMappingArgs<'_> {
    #[inline]
    fn default() -> Self {
        MaterialMappingArgs {
            theme: None,
            solids: None,
            shells: None,
            vertices: None,
            value: None,
        }
    }
}

pub struct MaterialMappingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MaterialMappingBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_theme(&mut self, theme: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MaterialMapping::VT_THEME, theme);
    }
    #[inline]
    pub fn add_solids(&mut self, solids: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MaterialMapping::VT_SOLIDS, solids);
    }
    #[inline]
    pub fn add_shells(&mut self, shells: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MaterialMapping::VT_SHELLS, shells);
    }
    #[inline]
    pub fn add_vertices(&mut self, vertices: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MaterialMapping::VT_VERTICES, vertices);
    }
    #[inline]
    pub fn add_value(&mut self, value: u32) {
        self.fbb_
            .push_slot_always::<u32>(MaterialMapping::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MaterialMappingBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MaterialMappingBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MaterialMapping<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MaterialMapping<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MaterialMapping");
        ds.field("theme", &self.theme());
        ds.field("solids", &self.solids());
        ds.field("shells", &self.shells());
        ds.field("vertices", &self.vertices());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum TextureMappingOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TextureMapping<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TextureMapping<'a> {
    type Inner = TextureMapping<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TextureMapping<'a> {
    pub const VT_THEME: flatbuffers::VOffsetT = 4;
    pub const VT_SOLIDS: flatbuffers::VOffsetT = 6;
    pub const VT_SHELLS: flatbuffers::VOffsetT = 8;
    pub const VT_SURFACES: flatbuffers::VOffsetT = 10;
    pub const VT_STRINGS: flatbuffers::VOffsetT = 12;
    pub const VT_VERTICES: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TextureMapping { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TextureMappingArgs<'args>,
    ) -> flatbuffers::WIPOffset<TextureMapping<'bldr>> {
        let mut builder = TextureMappingBuilder::new(_fbb);
        if let Some(x) = args.vertices {
            builder.add_vertices(x);
        }
        if let Some(x) = args.strings {
            builder.add_strings(x);
        }
        if let Some(x) = args.surfaces {
            builder.add_surfaces(x);
        }
        if let Some(x) = args.shells {
            builder.add_shells(x);
        }
        if let Some(x) = args.solids {
            builder.add_solids(x);
        }
        if let Some(x) = args.theme {
            builder.add_theme(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn theme(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TextureMapping::VT_THEME, None)
        }
    }
    #[inline]
    pub fn solids(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    TextureMapping::VT_SOLIDS,
                    None,
                )
        }
    }
    #[inline]
    pub fn shells(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    TextureMapping::VT_SHELLS,
                    None,
                )
        }
    }
    #[inline]
    pub fn surfaces(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    TextureMapping::VT_SURFACES,
                    None,
                )
        }
    }
    #[inline]
    pub fn strings(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    TextureMapping::VT_STRINGS,
                    None,
                )
        }
    }
    #[inline]
    pub fn vertices(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    TextureMapping::VT_VERTICES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for TextureMapping<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("theme", Self::VT_THEME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "solids",
                Self::VT_SOLIDS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "shells",
                Self::VT_SHELLS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "surfaces",
                Self::VT_SURFACES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "strings",
                Self::VT_STRINGS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "vertices",
                Self::VT_VERTICES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct TextureMappingArgs<'a> {
    pub theme: Option<flatbuffers::WIPOffset<&'a str>>,
    pub solids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub shells: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub surfaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub strings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub vertices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl Default for TextureMappingArgs<'_> {
    #[inline]
    fn default() -> Self {
        TextureMappingArgs {
            theme: None,
            solids: None,
            shells: None,
            surfaces: None,
            strings: None,
            vertices: None,
        }
    }
}

pub struct TextureMappingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextureMappingBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_theme(&mut self, theme: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TextureMapping::VT_THEME, theme);
    }
    #[inline]
    pub fn add_solids(&mut self, solids: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TextureMapping::VT_SOLIDS, solids);
    }
    #[inline]
    pub fn add_shells(&mut self, shells: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TextureMapping::VT_SHELLS, shells);
    }
    #[inline]
    pub fn add_surfaces(&mut self, surfaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TextureMapping::VT_SURFACES, surfaces);
    }
    #[inline]
    pub fn add_strings(&mut self, strings: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TextureMapping::VT_STRINGS, strings);
    }
    #[inline]
    pub fn add_vertices(&mut self, vertices: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TextureMapping::VT_VERTICES, vertices);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> TextureMappingBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TextureMappingBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TextureMapping<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TextureMapping<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TextureMapping");
        ds.field("theme", &self.theme());
        ds.field("solids", &self.solids());
        ds.field("shells", &self.shells());
        ds.field("surfaces", &self.surfaces());
        ds.field("strings", &self.strings());
        ds.field("vertices", &self.vertices());
        ds.finish()
    }
}
pub enum GeometryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Geometry<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Geometry<'a> {
    type Inner = Geometry<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Geometry<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_LOD: flatbuffers::VOffsetT = 6;
    pub const VT_SOLIDS: flatbuffers::VOffsetT = 8;
    pub const VT_SHELLS: flatbuffers::VOffsetT = 10;
    pub const VT_SURFACES: flatbuffers::VOffsetT = 12;
    pub const VT_STRINGS: flatbuffers::VOffsetT = 14;
    pub const VT_BOUNDARIES: flatbuffers::VOffsetT = 16;
    pub const VT_SEMANTICS: flatbuffers::VOffsetT = 18;
    pub const VT_SEMANTICS_OBJECTS: flatbuffers::VOffsetT = 20;
    pub const VT_MATERIAL: flatbuffers::VOffsetT = 22;
    pub const VT_TEXTURE: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Geometry { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args GeometryArgs<'args>,
    ) -> flatbuffers::WIPOffset<Geometry<'bldr>> {
        let mut builder = GeometryBuilder::new(_fbb);
        if let Some(x) = args.texture {
            builder.add_texture(x);
        }
        if let Some(x) = args.material {
            builder.add_material(x);
        }
        if let Some(x) = args.semantics_objects {
            builder.add_semantics_objects(x);
        }
        if let Some(x) = args.semantics {
            builder.add_semantics(x);
        }
        if let Some(x) = args.boundaries {
            builder.add_boundaries(x);
        }
        if let Some(x) = args.strings {
            builder.add_strings(x);
        }
        if let Some(x) = args.surfaces {
            builder.add_surfaces(x);
        }
        if let Some(x) = args.shells {
            builder.add_shells(x);
        }
        if let Some(x) = args.solids {
            builder.add_solids(x);
        }
        if let Some(x) = args.lod {
            builder.add_lod(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> GeometryType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<GeometryType>(Geometry::VT_TYPE_, Some(GeometryType::MultiPoint))
                .unwrap()
        }
    }
    #[inline]
    pub fn lod(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Geometry::VT_LOD, None)
        }
    }
    #[inline]
    pub fn solids(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Geometry::VT_SOLIDS,
                    None,
                )
        }
    }
    #[inline]
    pub fn shells(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Geometry::VT_SHELLS,
                    None,
                )
        }
    }
    #[inline]
    pub fn surfaces(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Geometry::VT_SURFACES,
                    None,
                )
        }
    }
    #[inline]
    pub fn strings(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Geometry::VT_STRINGS,
                    None,
                )
        }
    }
    #[inline]
    pub fn boundaries(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Geometry::VT_BOUNDARIES,
                    None,
                )
        }
    }
    #[inline]
    pub fn semantics(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Geometry::VT_SEMANTICS,
                    None,
                )
        }
    }
    #[inline]
    pub fn semantics_objects(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject>>,
            >>(Geometry::VT_SEMANTICS_OBJECTS, None)
        }
    }
    #[inline]
    pub fn material(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialMapping<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialMapping>>,
            >>(Geometry::VT_MATERIAL, None)
        }
    }
    #[inline]
    pub fn texture(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TextureMapping<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TextureMapping>>,
            >>(Geometry::VT_TEXTURE, None)
        }
    }
}

impl flatbuffers::Verifiable for Geometry<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<GeometryType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lod", Self::VT_LOD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "solids",
                Self::VT_SOLIDS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "shells",
                Self::VT_SHELLS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "surfaces",
                Self::VT_SURFACES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "strings",
                Self::VT_STRINGS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "boundaries",
                Self::VT_BOUNDARIES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "semantics",
                Self::VT_SEMANTICS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SemanticObject>>,
            >>("semantics_objects", Self::VT_SEMANTICS_OBJECTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MaterialMapping>>,
            >>("material", Self::VT_MATERIAL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TextureMapping>>,
            >>("texture", Self::VT_TEXTURE, false)?
            .finish();
        Ok(())
    }
}
pub struct GeometryArgs<'a> {
    pub type_: GeometryType,
    pub lod: Option<flatbuffers::WIPOffset<&'a str>>,
    pub solids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub shells: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub surfaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub strings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub boundaries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub semantics: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub semantics_objects: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject<'a>>>,
        >,
    >,
    pub material: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialMapping<'a>>>,
        >,
    >,
    pub texture: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TextureMapping<'a>>>,
        >,
    >,
}
impl Default for GeometryArgs<'_> {
    #[inline]
    fn default() -> Self {
        GeometryArgs {
            type_: GeometryType::MultiPoint,
            lod: None,
            solids: None,
            shells: None,
            surfaces: None,
            strings: None,
            boundaries: None,
            semantics: None,
            semantics_objects: None,
            material: None,
            texture: None,
        }
    }
}

pub struct GeometryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GeometryBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_type_(&mut self, type_: GeometryType) {
        self.fbb_
            .push_slot::<GeometryType>(Geometry::VT_TYPE_, type_, GeometryType::MultiPoint);
    }
    #[inline]
    pub fn add_lod(&mut self, lod: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_LOD, lod);
    }
    #[inline]
    pub fn add_solids(&mut self, solids: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SOLIDS, solids);
    }
    #[inline]
    pub fn add_shells(&mut self, shells: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SHELLS, shells);
    }
    #[inline]
    pub fn add_surfaces(&mut self, surfaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SURFACES, surfaces);
    }
    #[inline]
    pub fn add_strings(&mut self, strings: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_STRINGS, strings);
    }
    #[inline]
    pub fn add_boundaries(
        &mut self,
        boundaries: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_BOUNDARIES, boundaries);
    }
    #[inline]
    pub fn add_semantics(
        &mut self,
        semantics: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SEMANTICS, semantics);
    }
    #[inline]
    pub fn add_semantics_objects(
        &mut self,
        semantics_objects: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SemanticObject<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Geometry::VT_SEMANTICS_OBJECTS,
            semantics_objects,
        );
    }
    #[inline]
    pub fn add_material(
        &mut self,
        material: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MaterialMapping<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_MATERIAL, material);
    }
    #[inline]
    pub fn add_texture(
        &mut self,
        texture: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TextureMapping<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_TEXTURE, texture);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GeometryBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        GeometryBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Geometry<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Geometry<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Geometry");
        ds.field("type_", &self.type_());
        ds.field("lod", &self.lod());
        ds.field("solids", &self.solids());
        ds.field("shells", &self.shells());
        ds.field("surfaces", &self.surfaces());
        ds.field("strings", &self.strings());
        ds.field("boundaries", &self.boundaries());
        ds.field("semantics", &self.semantics());
        ds.field("semantics_objects", &self.semantics_objects());
        ds.field("material", &self.material());
        ds.field("texture", &self.texture());
        ds.finish()
    }
}
pub enum SemanticObjectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SemanticObject<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SemanticObject<'a> {
    type Inner = SemanticObject<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SemanticObject<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 6;
    pub const VT_CHILDREN: flatbuffers::VOffsetT = 8;
    pub const VT_PARENT: flatbuffers::VOffsetT = 10;
    pub const VT_EXTENSION_TYPE: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SemanticObject { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SemanticObjectArgs<'args>,
    ) -> flatbuffers::WIPOffset<SemanticObject<'bldr>> {
        let mut builder = SemanticObjectBuilder::new(_fbb);
        if let Some(x) = args.extension_type {
            builder.add_extension_type(x);
        }
        if let Some(x) = args.parent {
            builder.add_parent(x);
        }
        if let Some(x) = args.children {
            builder.add_children(x);
        }
        if let Some(x) = args.attributes {
            builder.add_attributes(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> SemanticSurfaceType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<SemanticSurfaceType>(
                    SemanticObject::VT_TYPE_,
                    Some(SemanticSurfaceType::RoofSurface),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    SemanticObject::VT_ATTRIBUTES,
                    None,
                )
        }
    }
    #[inline]
    pub fn children(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    SemanticObject::VT_CHILDREN,
                    None,
                )
        }
    }
    #[inline]
    pub fn parent(&self) -> Option<u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u32>(SemanticObject::VT_PARENT, None) }
    }
    #[inline]
    pub fn extension_type(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SemanticObject::VT_EXTENSION_TYPE, None)
        }
    }
}

impl flatbuffers::Verifiable for SemanticObject<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<SemanticSurfaceType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "attributes",
                Self::VT_ATTRIBUTES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "children",
                Self::VT_CHILDREN,
                false,
            )?
            .visit_field::<u32>("parent", Self::VT_PARENT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "extension_type",
                Self::VT_EXTENSION_TYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct SemanticObjectArgs<'a> {
    pub type_: SemanticSurfaceType,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub parent: Option<u32>,
    pub extension_type: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl Default for SemanticObjectArgs<'_> {
    #[inline]
    fn default() -> Self {
        SemanticObjectArgs {
            type_: SemanticSurfaceType::RoofSurface,
            attributes: None,
            children: None,
            parent: None,
            extension_type: None,
        }
    }
}

pub struct SemanticObjectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SemanticObjectBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_type_(&mut self, type_: SemanticSurfaceType) {
        self.fbb_.push_slot::<SemanticSurfaceType>(
            SemanticObject::VT_TYPE_,
            type_,
            SemanticSurfaceType::RoofSurface,
        );
    }
    #[inline]
    pub fn add_attributes(
        &mut self,
        attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SemanticObject::VT_ATTRIBUTES,
            attributes,
        );
    }
    #[inline]
    pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SemanticObject::VT_CHILDREN, children);
    }
    #[inline]
    pub fn add_parent(&mut self, parent: u32) {
        self.fbb_
            .push_slot_always::<u32>(SemanticObject::VT_PARENT, parent);
    }
    #[inline]
    pub fn add_extension_type(&mut self, extension_type: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SemanticObject::VT_EXTENSION_TYPE,
            extension_type,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SemanticObjectBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SemanticObjectBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SemanticObject<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SemanticObject<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SemanticObject");
        ds.field("type_", &self.type_());
        ds.field("attributes", &self.attributes());
        ds.field("children", &self.children());
        ds.field("parent", &self.parent());
        ds.field("extension_type", &self.extension_type());
        ds.finish()
    }
}
pub enum GeometryInstanceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GeometryInstance<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GeometryInstance<'a> {
    type Inner = GeometryInstance<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> GeometryInstance<'a> {
    pub const VT_TRANSFORMATION: flatbuffers::VOffsetT = 4;
    pub const VT_TEMPLATE: flatbuffers::VOffsetT = 6;
    pub const VT_BOUNDARIES: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GeometryInstance { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args GeometryInstanceArgs<'args>,
    ) -> flatbuffers::WIPOffset<GeometryInstance<'bldr>> {
        let mut builder = GeometryInstanceBuilder::new(_fbb);
        if let Some(x) = args.boundaries {
            builder.add_boundaries(x);
        }
        builder.add_template(args.template);
        if let Some(x) = args.transformation {
            builder.add_transformation(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn transformation(&self) -> Option<&'a TransformationMatrix> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<TransformationMatrix>(GeometryInstance::VT_TRANSFORMATION, None)
        }
    }
    #[inline]
    pub fn template(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u32>(GeometryInstance::VT_TEMPLATE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn boundaries(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    GeometryInstance::VT_BOUNDARIES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for GeometryInstance<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<TransformationMatrix>("transformation", Self::VT_TRANSFORMATION, false)?
            .visit_field::<u32>("template", Self::VT_TEMPLATE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "boundaries",
                Self::VT_BOUNDARIES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct GeometryInstanceArgs<'a> {
    pub transformation: Option<&'a TransformationMatrix>,
    pub template: u32,
    pub boundaries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl Default for GeometryInstanceArgs<'_> {
    #[inline]
    fn default() -> Self {
        GeometryInstanceArgs {
            transformation: None,
            template: 0,
            boundaries: None,
        }
    }
}

pub struct GeometryInstanceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GeometryInstanceBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_transformation(&mut self, transformation: &TransformationMatrix) {
        self.fbb_.push_slot_always::<&TransformationMatrix>(
            GeometryInstance::VT_TRANSFORMATION,
            transformation,
        );
    }
    #[inline]
    pub fn add_template(&mut self, template: u32) {
        self.fbb_
            .push_slot::<u32>(GeometryInstance::VT_TEMPLATE, template, 0);
    }
    #[inline]
    pub fn add_boundaries(
        &mut self,
        boundaries: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            GeometryInstance::VT_BOUNDARIES,
            boundaries,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> GeometryInstanceBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        GeometryInstanceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GeometryInstance<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GeometryInstance<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GeometryInstance");
        ds.field("transformation", &self.transformation());
        ds.field("template", &self.template());
        ds.field("boundaries", &self.boundaries());
        ds.finish()
    }
}
