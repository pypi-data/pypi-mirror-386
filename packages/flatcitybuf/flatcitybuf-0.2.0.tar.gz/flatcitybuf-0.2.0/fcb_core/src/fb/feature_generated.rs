// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use crate::geometry_generated::*;
use crate::header_generated::*;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_CITY_OBJECT_TYPE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_CITY_OBJECT_TYPE: u8 = 33;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CITY_OBJECT_TYPE: [CityObjectType; 34] = [
    CityObjectType::Bridge,
    CityObjectType::BridgePart,
    CityObjectType::BridgeInstallation,
    CityObjectType::BridgeConstructiveElement,
    CityObjectType::BridgeRoom,
    CityObjectType::BridgeFurniture,
    CityObjectType::Building,
    CityObjectType::BuildingPart,
    CityObjectType::BuildingInstallation,
    CityObjectType::BuildingConstructiveElement,
    CityObjectType::BuildingFurniture,
    CityObjectType::BuildingStorey,
    CityObjectType::BuildingRoom,
    CityObjectType::BuildingUnit,
    CityObjectType::CityFurniture,
    CityObjectType::CityObjectGroup,
    CityObjectType::GenericCityObject,
    CityObjectType::LandUse,
    CityObjectType::OtherConstruction,
    CityObjectType::PlantCover,
    CityObjectType::SolitaryVegetationObject,
    CityObjectType::TINRelief,
    CityObjectType::Road,
    CityObjectType::Railway,
    CityObjectType::Waterway,
    CityObjectType::TransportSquare,
    CityObjectType::Tunnel,
    CityObjectType::TunnelPart,
    CityObjectType::TunnelInstallation,
    CityObjectType::TunnelConstructiveElement,
    CityObjectType::TunnelHollowSpace,
    CityObjectType::TunnelFurniture,
    CityObjectType::WaterBody,
    CityObjectType::ExtensionObject,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CityObjectType(pub u8);
#[allow(non_upper_case_globals)]
impl CityObjectType {
    pub const Bridge: Self = Self(0);
    pub const BridgePart: Self = Self(1);
    pub const BridgeInstallation: Self = Self(2);
    pub const BridgeConstructiveElement: Self = Self(3);
    pub const BridgeRoom: Self = Self(4);
    pub const BridgeFurniture: Self = Self(5);
    pub const Building: Self = Self(6);
    pub const BuildingPart: Self = Self(7);
    pub const BuildingInstallation: Self = Self(8);
    pub const BuildingConstructiveElement: Self = Self(9);
    pub const BuildingFurniture: Self = Self(10);
    pub const BuildingStorey: Self = Self(11);
    pub const BuildingRoom: Self = Self(12);
    pub const BuildingUnit: Self = Self(13);
    pub const CityFurniture: Self = Self(14);
    pub const CityObjectGroup: Self = Self(15);
    pub const GenericCityObject: Self = Self(16);
    pub const LandUse: Self = Self(17);
    pub const OtherConstruction: Self = Self(18);
    pub const PlantCover: Self = Self(19);
    pub const SolitaryVegetationObject: Self = Self(20);
    pub const TINRelief: Self = Self(21);
    pub const Road: Self = Self(22);
    pub const Railway: Self = Self(23);
    pub const Waterway: Self = Self(24);
    pub const TransportSquare: Self = Self(25);
    pub const Tunnel: Self = Self(26);
    pub const TunnelPart: Self = Self(27);
    pub const TunnelInstallation: Self = Self(28);
    pub const TunnelConstructiveElement: Self = Self(29);
    pub const TunnelHollowSpace: Self = Self(30);
    pub const TunnelFurniture: Self = Self(31);
    pub const WaterBody: Self = Self(32);
    pub const ExtensionObject: Self = Self(33);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 33;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::Bridge,
        Self::BridgePart,
        Self::BridgeInstallation,
        Self::BridgeConstructiveElement,
        Self::BridgeRoom,
        Self::BridgeFurniture,
        Self::Building,
        Self::BuildingPart,
        Self::BuildingInstallation,
        Self::BuildingConstructiveElement,
        Self::BuildingFurniture,
        Self::BuildingStorey,
        Self::BuildingRoom,
        Self::BuildingUnit,
        Self::CityFurniture,
        Self::CityObjectGroup,
        Self::GenericCityObject,
        Self::LandUse,
        Self::OtherConstruction,
        Self::PlantCover,
        Self::SolitaryVegetationObject,
        Self::TINRelief,
        Self::Road,
        Self::Railway,
        Self::Waterway,
        Self::TransportSquare,
        Self::Tunnel,
        Self::TunnelPart,
        Self::TunnelInstallation,
        Self::TunnelConstructiveElement,
        Self::TunnelHollowSpace,
        Self::TunnelFurniture,
        Self::WaterBody,
        Self::ExtensionObject,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Bridge => Some("Bridge"),
            Self::BridgePart => Some("BridgePart"),
            Self::BridgeInstallation => Some("BridgeInstallation"),
            Self::BridgeConstructiveElement => Some("BridgeConstructiveElement"),
            Self::BridgeRoom => Some("BridgeRoom"),
            Self::BridgeFurniture => Some("BridgeFurniture"),
            Self::Building => Some("Building"),
            Self::BuildingPart => Some("BuildingPart"),
            Self::BuildingInstallation => Some("BuildingInstallation"),
            Self::BuildingConstructiveElement => Some("BuildingConstructiveElement"),
            Self::BuildingFurniture => Some("BuildingFurniture"),
            Self::BuildingStorey => Some("BuildingStorey"),
            Self::BuildingRoom => Some("BuildingRoom"),
            Self::BuildingUnit => Some("BuildingUnit"),
            Self::CityFurniture => Some("CityFurniture"),
            Self::CityObjectGroup => Some("CityObjectGroup"),
            Self::GenericCityObject => Some("GenericCityObject"),
            Self::LandUse => Some("LandUse"),
            Self::OtherConstruction => Some("OtherConstruction"),
            Self::PlantCover => Some("PlantCover"),
            Self::SolitaryVegetationObject => Some("SolitaryVegetationObject"),
            Self::TINRelief => Some("TINRelief"),
            Self::Road => Some("Road"),
            Self::Railway => Some("Railway"),
            Self::Waterway => Some("Waterway"),
            Self::TransportSquare => Some("TransportSquare"),
            Self::Tunnel => Some("Tunnel"),
            Self::TunnelPart => Some("TunnelPart"),
            Self::TunnelInstallation => Some("TunnelInstallation"),
            Self::TunnelConstructiveElement => Some("TunnelConstructiveElement"),
            Self::TunnelHollowSpace => Some("TunnelHollowSpace"),
            Self::TunnelFurniture => Some("TunnelFurniture"),
            Self::WaterBody => Some("WaterBody"),
            Self::ExtensionObject => Some("ExtensionObject"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for CityObjectType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for CityObjectType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for CityObjectType {
    type Output = CityObjectType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CityObjectType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for CityObjectType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for CityObjectType {}
// struct Vertex, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Default)]
pub struct Vertex(pub [u8; 12]);
impl core::fmt::Debug for Vertex {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vertex")
            .field("x", &self.x())
            .field("y", &self.y())
            .field("z", &self.z())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Vertex {}
impl<'a> flatbuffers::Follow<'a> for Vertex {
    type Inner = &'a Vertex;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Vertex>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vertex {
    type Inner = &'a Vertex;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Vertex>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Vertex {
    type Output = Vertex;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vertex as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vertex {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Vertex {
    #[allow(clippy::too_many_arguments)]
    pub fn new(x: i32, y: i32, z: i32) -> Self {
        let mut s = Self([0; 12]);
        s.set_x(x);
        s.set_y(y);
        s.set_z(z);
        s
    }

    pub fn x(&self) -> i32 {
        let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_x(&mut self, x: i32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn y(&self) -> i32 {
        let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[4..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_y(&mut self, x: i32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[4..].as_mut_ptr(),
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn z(&self) -> i32 {
        let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_z(&mut self, x: i32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
        }
    }
}

pub enum CityFeatureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CityFeature<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CityFeature<'a> {
    type Inner = CityFeature<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> CityFeature<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OBJECTS: flatbuffers::VOffsetT = 6;
    pub const VT_VERTICES: flatbuffers::VOffsetT = 8;
    pub const VT_APPEARANCE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CityFeature { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args CityFeatureArgs<'args>,
    ) -> flatbuffers::WIPOffset<CityFeature<'bldr>> {
        let mut builder = CityFeatureBuilder::new(_fbb);
        if let Some(x) = args.appearance {
            builder.add_appearance(x);
        }
        if let Some(x) = args.vertices {
            builder.add_vertices(x);
        }
        if let Some(x) = args.objects {
            builder.add_objects(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(CityFeature::VT_ID, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &CityFeature) -> bool {
        self.id() < o.id()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.id();
        key.cmp(val)
    }
    #[inline]
    pub fn objects(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject>>,
            >>(CityFeature::VT_OBJECTS, None)
        }
    }
    #[inline]
    pub fn vertices(&self) -> Option<flatbuffers::Vector<'a, Vertex>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vertex>>>(
                    CityFeature::VT_VERTICES,
                    None,
                )
        }
    }
    #[inline]
    pub fn appearance(&self) -> Option<Appearance<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Appearance>>(CityFeature::VT_APPEARANCE, None)
        }
    }
}

impl flatbuffers::Verifiable for CityFeature<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CityObject>>,
            >>("objects", Self::VT_OBJECTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vertex>>>(
                "vertices",
                Self::VT_VERTICES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<Appearance>>(
                "appearance",
                Self::VT_APPEARANCE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct CityFeatureArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objects: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject<'a>>>,
        >,
    >,
    pub vertices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vertex>>>,
    pub appearance: Option<flatbuffers::WIPOffset<Appearance<'a>>>,
}
impl Default for CityFeatureArgs<'_> {
    #[inline]
    fn default() -> Self {
        CityFeatureArgs {
            id: None, // required field
            objects: None,
            vertices: None,
            appearance: None,
        }
    }
}

pub struct CityFeatureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CityFeatureBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityFeature::VT_ID, id);
    }
    #[inline]
    pub fn add_objects(
        &mut self,
        objects: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CityObject<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityFeature::VT_OBJECTS, objects);
    }
    #[inline]
    pub fn add_vertices(
        &mut self,
        vertices: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Vertex>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityFeature::VT_VERTICES, vertices);
    }
    #[inline]
    pub fn add_appearance(&mut self, appearance: flatbuffers::WIPOffset<Appearance<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Appearance>>(
                CityFeature::VT_APPEARANCE,
                appearance,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> CityFeatureBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        CityFeatureBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CityFeature<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, CityFeature::VT_ID, "id");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for CityFeature<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("CityFeature");
        ds.field("id", &self.id());
        ds.field("objects", &self.objects());
        ds.field("vertices", &self.vertices());
        ds.field("appearance", &self.appearance());
        ds.finish()
    }
}
pub enum CityObjectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CityObject<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CityObject<'a> {
    type Inner = CityObject<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> CityObject<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_EXTENSION_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ID: flatbuffers::VOffsetT = 8;
    pub const VT_GEOGRAPHICAL_EXTENT: flatbuffers::VOffsetT = 10;
    pub const VT_GEOMETRY: flatbuffers::VOffsetT = 12;
    pub const VT_GEOMETRY_INSTANCES: flatbuffers::VOffsetT = 14;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 16;
    pub const VT_COLUMNS: flatbuffers::VOffsetT = 18;
    pub const VT_CHILDREN: flatbuffers::VOffsetT = 20;
    pub const VT_CHILDREN_ROLES: flatbuffers::VOffsetT = 22;
    pub const VT_PARENTS: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CityObject { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args CityObjectArgs<'args>,
    ) -> flatbuffers::WIPOffset<CityObject<'bldr>> {
        let mut builder = CityObjectBuilder::new(_fbb);
        if let Some(x) = args.parents {
            builder.add_parents(x);
        }
        if let Some(x) = args.children_roles {
            builder.add_children_roles(x);
        }
        if let Some(x) = args.children {
            builder.add_children(x);
        }
        if let Some(x) = args.columns {
            builder.add_columns(x);
        }
        if let Some(x) = args.attributes {
            builder.add_attributes(x);
        }
        if let Some(x) = args.geometry_instances {
            builder.add_geometry_instances(x);
        }
        if let Some(x) = args.geometry {
            builder.add_geometry(x);
        }
        if let Some(x) = args.geographical_extent {
            builder.add_geographical_extent(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        if let Some(x) = args.extension_type {
            builder.add_extension_type(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> CityObjectType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<CityObjectType>(CityObject::VT_TYPE_, Some(CityObjectType::Bridge))
                .unwrap()
        }
    }
    #[inline]
    pub fn extension_type(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(CityObject::VT_EXTENSION_TYPE, None)
        }
    }
    #[inline]
    pub fn id(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(CityObject::VT_ID, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &CityObject) -> bool {
        self.id() < o.id()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.id();
        key.cmp(val)
    }
    #[inline]
    pub fn geographical_extent(&self) -> Option<&'a GeographicalExtent> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<GeographicalExtent>(CityObject::VT_GEOGRAPHICAL_EXTENT, None)
        }
    }
    #[inline]
    pub fn geometry(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry>>,
            >>(CityObject::VT_GEOMETRY, None)
        }
    }
    #[inline]
    pub fn geometry_instances(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GeometryInstance<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GeometryInstance>>,
            >>(CityObject::VT_GEOMETRY_INSTANCES, None)
        }
    }
    #[inline]
    pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    CityObject::VT_ATTRIBUTES,
                    None,
                )
        }
    }
    #[inline]
    pub fn columns(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column>>,
            >>(CityObject::VT_COLUMNS, None)
        }
    }
    #[inline]
    pub fn children(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(CityObject::VT_CHILDREN, None)
        }
    }
    #[inline]
    pub fn children_roles(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(CityObject::VT_CHILDREN_ROLES, None)
        }
    }
    #[inline]
    pub fn parents(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(CityObject::VT_PARENTS, None)
        }
    }
}

impl flatbuffers::Verifiable for CityObject<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<CityObjectType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "extension_type",
                Self::VT_EXTENSION_TYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
            .visit_field::<GeographicalExtent>(
                "geographical_extent",
                Self::VT_GEOGRAPHICAL_EXTENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Geometry>>,
            >>("geometry", Self::VT_GEOMETRY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GeometryInstance>>,
            >>("geometry_instances", Self::VT_GEOMETRY_INSTANCES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "attributes",
                Self::VT_ATTRIBUTES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Column>>,
            >>("columns", Self::VT_COLUMNS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("children", Self::VT_CHILDREN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("children_roles", Self::VT_CHILDREN_ROLES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("parents", Self::VT_PARENTS, false)?
            .finish();
        Ok(())
    }
}
pub struct CityObjectArgs<'a> {
    pub type_: CityObjectType,
    pub extension_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub geographical_extent: Option<&'a GeographicalExtent>,
    pub geometry: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry<'a>>>>,
    >,
    pub geometry_instances: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GeometryInstance<'a>>>,
        >,
    >,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub columns: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>>,
    >,
    pub children: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub children_roles: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub parents: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl Default for CityObjectArgs<'_> {
    #[inline]
    fn default() -> Self {
        CityObjectArgs {
            type_: CityObjectType::Bridge,
            extension_type: None,
            id: None, // required field
            geographical_extent: None,
            geometry: None,
            geometry_instances: None,
            attributes: None,
            columns: None,
            children: None,
            children_roles: None,
            parents: None,
        }
    }
}

pub struct CityObjectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CityObjectBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_type_(&mut self, type_: CityObjectType) {
        self.fbb_
            .push_slot::<CityObjectType>(CityObject::VT_TYPE_, type_, CityObjectType::Bridge);
    }
    #[inline]
    pub fn add_extension_type(&mut self, extension_type: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            CityObject::VT_EXTENSION_TYPE,
            extension_type,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_ID, id);
    }
    #[inline]
    pub fn add_geographical_extent(&mut self, geographical_extent: &GeographicalExtent) {
        self.fbb_.push_slot_always::<&GeographicalExtent>(
            CityObject::VT_GEOGRAPHICAL_EXTENT,
            geographical_extent,
        );
    }
    #[inline]
    pub fn add_geometry(
        &mut self,
        geometry: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Geometry<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_GEOMETRY, geometry);
    }
    #[inline]
    pub fn add_geometry_instances(
        &mut self,
        geometry_instances: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<GeometryInstance<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            CityObject::VT_GEOMETRY_INSTANCES,
            geometry_instances,
        );
    }
    #[inline]
    pub fn add_attributes(
        &mut self,
        attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_ATTRIBUTES, attributes);
    }
    #[inline]
    pub fn add_columns(
        &mut self,
        columns: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Column<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_COLUMNS, columns);
    }
    #[inline]
    pub fn add_children(
        &mut self,
        children: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_CHILDREN, children);
    }
    #[inline]
    pub fn add_children_roles(
        &mut self,
        children_roles: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            CityObject::VT_CHILDREN_ROLES,
            children_roles,
        );
    }
    #[inline]
    pub fn add_parents(
        &mut self,
        parents: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_PARENTS, parents);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> CityObjectBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        CityObjectBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CityObject<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, CityObject::VT_ID, "id");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for CityObject<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("CityObject");
        ds.field("type_", &self.type_());
        ds.field("extension_type", &self.extension_type());
        ds.field("id", &self.id());
        ds.field("geographical_extent", &self.geographical_extent());
        ds.field("geometry", &self.geometry());
        ds.field("geometry_instances", &self.geometry_instances());
        ds.field("attributes", &self.attributes());
        ds.field("columns", &self.columns());
        ds.field("children", &self.children());
        ds.field("children_roles", &self.children_roles());
        ds.field("parents", &self.parents());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `CityFeature`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_feature_unchecked`.
pub fn root_as_city_feature(buf: &[u8]) -> Result<CityFeature, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<CityFeature>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `CityFeature` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_city_feature_unchecked`.
pub fn size_prefixed_root_as_city_feature(
    buf: &[u8],
) -> Result<CityFeature, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<CityFeature>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `CityFeature` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_feature_unchecked`.
pub fn root_as_city_feature_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<CityFeature<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<CityFeature<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `CityFeature` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_feature_unchecked`.
pub fn size_prefixed_root_as_city_feature_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<CityFeature<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<CityFeature<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a CityFeature and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `CityFeature`.
pub unsafe fn root_as_city_feature_unchecked(buf: &[u8]) -> CityFeature {
    flatbuffers::root_unchecked::<CityFeature>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed CityFeature and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `CityFeature`.
pub unsafe fn size_prefixed_root_as_city_feature_unchecked(buf: &[u8]) -> CityFeature {
    flatbuffers::size_prefixed_root_unchecked::<CityFeature>(buf)
}
#[inline]
pub fn finish_city_feature_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<CityFeature<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_city_feature_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<CityFeature<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
