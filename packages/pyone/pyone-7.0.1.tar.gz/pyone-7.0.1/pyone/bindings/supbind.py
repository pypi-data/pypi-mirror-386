#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Oct 22 18:05:18 2025 by generateDS.py version 2.44.3.
# Python 3.10.12 (main, Aug 15 2025, 14:32:43) [GCC 11.4.0]
#
# Command line options:
#   ('-q', '')
#   ('-f', '')
#   ('-o', 'pyone/bindings/supbind.py')
#   ('-s', 'pyone/bindings/__init__.py')
#   ('--super', 'supbind')
#   ('--external-encoding', 'utf-8')
#   ('--silence', '')
#
# Command line arguments:
#   ../../../share/doc/xsd/index.xsd
#
# Command line:
#   /home/one/init-build-jenkins.HlmuEq/one/src/oca/python/bin/generateDS -q -f -o "pyone/bindings/supbind.py" -s "pyone/bindings/__init__.py" --super="supbind" --external-encoding="utf-8" --silence ../../../share/doc/xsd/index.xsd
#
# Current working directory (os.getcwd()):
#   python
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile('(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            value = ('%.15f' % float(input_data)).rstrip('0')
            if value.endswith('.'):
                value += '0'
            return value
    
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            input_data = input_data.strip()
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'{.*}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    s1 = s1.replace('\n', '&#10;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Start enum classes
#
class BACKENDType(str, Enum):
    MYSQL='mysql'
    SQLITE='sqlite'


class MODEType(str, Enum):
    STANDALONE='STANDALONE'
    MASTER='MASTER'
    SLAVE='SLAVE'


class TYPEType(str, Enum):
    IN='IN'
    OUT='OUT'


#
# Start data representation classes
#
class HISTORY_RECORDS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, HISTORY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if HISTORY is None:
            self.HISTORY = []
        else:
            self.HISTORY = HISTORY
        self.HISTORY_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HISTORY_RECORDS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HISTORY_RECORDS.subclass:
            return HISTORY_RECORDS.subclass(*args_, **kwargs_)
        else:
            return HISTORY_RECORDS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HISTORY(self):
        return self.HISTORY
    def set_HISTORY(self, HISTORY):
        self.HISTORY = HISTORY
    def add_HISTORY(self, value):
        self.HISTORY.append(value)
    def insert_HISTORY_at(self, index, value):
        self.HISTORY.insert(index, value)
    def replace_HISTORY_at(self, index, value):
        self.HISTORY[index] = value
    def has__content(self):
        if (
            self.HISTORY
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HISTORY_RECORDS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HISTORY_RECORDS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HISTORY_RECORDS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HISTORY_RECORDS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HISTORY_RECORDS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HISTORY_RECORDS'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HISTORY_RECORDS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HISTORY_ in self.HISTORY:
            namespaceprefix_ = self.HISTORY_nsprefix_ + ':' if (UseCapturedNS_ and self.HISTORY_nsprefix_) else ''
            HISTORY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HISTORY', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HISTORY':
            obj_ = HISTORY.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HISTORY.append(obj_)
            obj_.original_tagname_ = 'HISTORY'
# end class HISTORY_RECORDS


class HISTORY(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OID=None, SEQ=None, HOSTNAME=None, HID=None, CID=None, STIME=None, ETIME=None, VM_MAD=None, TM_MAD=None, DS_ID=None, PLAN_ID=None, ACTION_ID=None, PSTIME=None, PETIME=None, RSTIME=None, RETIME=None, ESTIME=None, EETIME=None, ACTION=None, UID=None, GID=None, REQUEST_ID=None, VM=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OID = OID
        self.OID_nsprefix_ = None
        self.SEQ = SEQ
        self.SEQ_nsprefix_ = None
        self.HOSTNAME = HOSTNAME
        self.HOSTNAME_nsprefix_ = None
        self.HID = HID
        self.HID_nsprefix_ = None
        self.CID = CID
        self.CID_nsprefix_ = None
        self.STIME = STIME
        self.STIME_nsprefix_ = None
        self.ETIME = ETIME
        self.ETIME_nsprefix_ = None
        self.VM_MAD = VM_MAD
        self.VM_MAD_nsprefix_ = None
        self.TM_MAD = TM_MAD
        self.TM_MAD_nsprefix_ = None
        self.DS_ID = DS_ID
        self.DS_ID_nsprefix_ = None
        self.PLAN_ID = PLAN_ID
        self.PLAN_ID_nsprefix_ = None
        self.ACTION_ID = ACTION_ID
        self.ACTION_ID_nsprefix_ = None
        self.PSTIME = PSTIME
        self.PSTIME_nsprefix_ = None
        self.PETIME = PETIME
        self.PETIME_nsprefix_ = None
        self.RSTIME = RSTIME
        self.RSTIME_nsprefix_ = None
        self.RETIME = RETIME
        self.RETIME_nsprefix_ = None
        self.ESTIME = ESTIME
        self.ESTIME_nsprefix_ = None
        self.EETIME = EETIME
        self.EETIME_nsprefix_ = None
        self.ACTION = ACTION
        self.ACTION_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.REQUEST_ID = REQUEST_ID
        self.REQUEST_ID_nsprefix_ = None
        self.VM = VM
        self.VM_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HISTORY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HISTORY.subclass:
            return HISTORY.subclass(*args_, **kwargs_)
        else:
            return HISTORY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OID(self):
        return self.OID
    def set_OID(self, OID):
        self.OID = OID
    def get_SEQ(self):
        return self.SEQ
    def set_SEQ(self, SEQ):
        self.SEQ = SEQ
    def get_HOSTNAME(self):
        return self.HOSTNAME
    def set_HOSTNAME(self, HOSTNAME):
        self.HOSTNAME = HOSTNAME
    def get_HID(self):
        return self.HID
    def set_HID(self, HID):
        self.HID = HID
    def get_CID(self):
        return self.CID
    def set_CID(self, CID):
        self.CID = CID
    def get_STIME(self):
        return self.STIME
    def set_STIME(self, STIME):
        self.STIME = STIME
    def get_ETIME(self):
        return self.ETIME
    def set_ETIME(self, ETIME):
        self.ETIME = ETIME
    def get_VM_MAD(self):
        return self.VM_MAD
    def set_VM_MAD(self, VM_MAD):
        self.VM_MAD = VM_MAD
    def get_TM_MAD(self):
        return self.TM_MAD
    def set_TM_MAD(self, TM_MAD):
        self.TM_MAD = TM_MAD
    def get_DS_ID(self):
        return self.DS_ID
    def set_DS_ID(self, DS_ID):
        self.DS_ID = DS_ID
    def get_PLAN_ID(self):
        return self.PLAN_ID
    def set_PLAN_ID(self, PLAN_ID):
        self.PLAN_ID = PLAN_ID
    def get_ACTION_ID(self):
        return self.ACTION_ID
    def set_ACTION_ID(self, ACTION_ID):
        self.ACTION_ID = ACTION_ID
    def get_PSTIME(self):
        return self.PSTIME
    def set_PSTIME(self, PSTIME):
        self.PSTIME = PSTIME
    def get_PETIME(self):
        return self.PETIME
    def set_PETIME(self, PETIME):
        self.PETIME = PETIME
    def get_RSTIME(self):
        return self.RSTIME
    def set_RSTIME(self, RSTIME):
        self.RSTIME = RSTIME
    def get_RETIME(self):
        return self.RETIME
    def set_RETIME(self, RETIME):
        self.RETIME = RETIME
    def get_ESTIME(self):
        return self.ESTIME
    def set_ESTIME(self, ESTIME):
        self.ESTIME = ESTIME
    def get_EETIME(self):
        return self.EETIME
    def set_EETIME(self, EETIME):
        self.EETIME = EETIME
    def get_ACTION(self):
        return self.ACTION
    def set_ACTION(self, ACTION):
        self.ACTION = ACTION
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_REQUEST_ID(self):
        return self.REQUEST_ID
    def set_REQUEST_ID(self, REQUEST_ID):
        self.REQUEST_ID = REQUEST_ID
    def get_VM(self):
        return self.VM
    def set_VM(self, VM):
        self.VM = VM
    def has__content(self):
        if (
            self.OID is not None or
            self.SEQ is not None or
            self.HOSTNAME is not None or
            self.HID is not None or
            self.CID is not None or
            self.STIME is not None or
            self.ETIME is not None or
            self.VM_MAD is not None or
            self.TM_MAD is not None or
            self.DS_ID is not None or
            self.PLAN_ID is not None or
            self.ACTION_ID is not None or
            self.PSTIME is not None or
            self.PETIME is not None or
            self.RSTIME is not None or
            self.RETIME is not None or
            self.ESTIME is not None or
            self.EETIME is not None or
            self.ACTION is not None or
            self.UID is not None or
            self.GID is not None or
            self.REQUEST_ID is not None or
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HISTORY', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HISTORY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HISTORY':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HISTORY')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HISTORY', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HISTORY'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HISTORY', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OID is not None:
            namespaceprefix_ = self.OID_nsprefix_ + ':' if (UseCapturedNS_ and self.OID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOID>%s</%sOID>%s' % (namespaceprefix_ , self.gds_format_integer(self.OID, input_name='OID'), namespaceprefix_ , eol_))
        if self.SEQ is not None:
            namespaceprefix_ = self.SEQ_nsprefix_ + ':' if (UseCapturedNS_ and self.SEQ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSEQ>%s</%sSEQ>%s' % (namespaceprefix_ , self.gds_format_integer(self.SEQ, input_name='SEQ'), namespaceprefix_ , eol_))
        if self.HOSTNAME is not None:
            namespaceprefix_ = self.HOSTNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.HOSTNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHOSTNAME>%s</%sHOSTNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.HOSTNAME), input_name='HOSTNAME')), namespaceprefix_ , eol_))
        if self.HID is not None:
            namespaceprefix_ = self.HID_nsprefix_ + ':' if (UseCapturedNS_ and self.HID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHID>%s</%sHID>%s' % (namespaceprefix_ , self.gds_format_integer(self.HID, input_name='HID'), namespaceprefix_ , eol_))
        if self.CID is not None:
            namespaceprefix_ = self.CID_nsprefix_ + ':' if (UseCapturedNS_ and self.CID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCID>%s</%sCID>%s' % (namespaceprefix_ , self.gds_format_integer(self.CID, input_name='CID'), namespaceprefix_ , eol_))
        if self.STIME is not None:
            namespaceprefix_ = self.STIME_nsprefix_ + ':' if (UseCapturedNS_ and self.STIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTIME>%s</%sSTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.STIME, input_name='STIME'), namespaceprefix_ , eol_))
        if self.ETIME is not None:
            namespaceprefix_ = self.ETIME_nsprefix_ + ':' if (UseCapturedNS_ and self.ETIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sETIME>%s</%sETIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.ETIME, input_name='ETIME'), namespaceprefix_ , eol_))
        if self.VM_MAD is not None:
            namespaceprefix_ = self.VM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM_MAD>%s</%sVM_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VM_MAD), input_name='VM_MAD')), namespaceprefix_ , eol_))
        if self.TM_MAD is not None:
            namespaceprefix_ = self.TM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.TM_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTM_MAD>%s</%sTM_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TM_MAD), input_name='TM_MAD')), namespaceprefix_ , eol_))
        if self.DS_ID is not None:
            namespaceprefix_ = self.DS_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.DS_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDS_ID>%s</%sDS_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.DS_ID, input_name='DS_ID'), namespaceprefix_ , eol_))
        if self.PLAN_ID is not None:
            namespaceprefix_ = self.PLAN_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.PLAN_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPLAN_ID>%s</%sPLAN_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.PLAN_ID, input_name='PLAN_ID'), namespaceprefix_ , eol_))
        if self.ACTION_ID is not None:
            namespaceprefix_ = self.ACTION_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTION_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACTION_ID>%s</%sACTION_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ACTION_ID, input_name='ACTION_ID'), namespaceprefix_ , eol_))
        if self.PSTIME is not None:
            namespaceprefix_ = self.PSTIME_nsprefix_ + ':' if (UseCapturedNS_ and self.PSTIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPSTIME>%s</%sPSTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.PSTIME, input_name='PSTIME'), namespaceprefix_ , eol_))
        if self.PETIME is not None:
            namespaceprefix_ = self.PETIME_nsprefix_ + ':' if (UseCapturedNS_ and self.PETIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPETIME>%s</%sPETIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.PETIME, input_name='PETIME'), namespaceprefix_ , eol_))
        if self.RSTIME is not None:
            namespaceprefix_ = self.RSTIME_nsprefix_ + ':' if (UseCapturedNS_ and self.RSTIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRSTIME>%s</%sRSTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.RSTIME, input_name='RSTIME'), namespaceprefix_ , eol_))
        if self.RETIME is not None:
            namespaceprefix_ = self.RETIME_nsprefix_ + ':' if (UseCapturedNS_ and self.RETIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRETIME>%s</%sRETIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.RETIME, input_name='RETIME'), namespaceprefix_ , eol_))
        if self.ESTIME is not None:
            namespaceprefix_ = self.ESTIME_nsprefix_ + ':' if (UseCapturedNS_ and self.ESTIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sESTIME>%s</%sESTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.ESTIME, input_name='ESTIME'), namespaceprefix_ , eol_))
        if self.EETIME is not None:
            namespaceprefix_ = self.EETIME_nsprefix_ + ':' if (UseCapturedNS_ and self.EETIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEETIME>%s</%sEETIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.EETIME, input_name='EETIME'), namespaceprefix_ , eol_))
        if self.ACTION is not None:
            namespaceprefix_ = self.ACTION_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACTION>%s</%sACTION>%s' % (namespaceprefix_ , self.gds_format_integer(self.ACTION, input_name='ACTION'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.REQUEST_ID is not None:
            namespaceprefix_ = self.REQUEST_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.REQUEST_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREQUEST_ID>%s</%sREQUEST_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.REQUEST_ID), input_name='REQUEST_ID')), namespaceprefix_ , eol_))
        if self.VM is not None:
            namespaceprefix_ = self.VM_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_nsprefix_) else ''
            self.VM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OID')
            ival_ = self.gds_validate_integer(ival_, node, 'OID')
            self.OID = ival_
            self.OID_nsprefix_ = child_.prefix
        elif nodeName_ == 'SEQ' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SEQ')
            ival_ = self.gds_validate_integer(ival_, node, 'SEQ')
            self.SEQ = ival_
            self.SEQ_nsprefix_ = child_.prefix
        elif nodeName_ == 'HOSTNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'HOSTNAME')
            value_ = self.gds_validate_string(value_, node, 'HOSTNAME')
            self.HOSTNAME = value_
            self.HOSTNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'HID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'HID')
            ival_ = self.gds_validate_integer(ival_, node, 'HID')
            self.HID = ival_
            self.HID_nsprefix_ = child_.prefix
        elif nodeName_ == 'CID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CID')
            ival_ = self.gds_validate_integer(ival_, node, 'CID')
            self.CID = ival_
            self.CID_nsprefix_ = child_.prefix
        elif nodeName_ == 'STIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STIME')
            ival_ = self.gds_validate_integer(ival_, node, 'STIME')
            self.STIME = ival_
            self.STIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'ETIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ETIME')
            ival_ = self.gds_validate_integer(ival_, node, 'ETIME')
            self.ETIME = ival_
            self.ETIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'VM_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VM_MAD')
            value_ = self.gds_validate_string(value_, node, 'VM_MAD')
            self.VM_MAD = value_
            self.VM_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'TM_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TM_MAD')
            value_ = self.gds_validate_string(value_, node, 'TM_MAD')
            self.TM_MAD = value_
            self.TM_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'DS_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DS_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'DS_ID')
            self.DS_ID = ival_
            self.DS_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'PLAN_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PLAN_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'PLAN_ID')
            self.PLAN_ID = ival_
            self.PLAN_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'ACTION_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ACTION_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ACTION_ID')
            self.ACTION_ID = ival_
            self.ACTION_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'PSTIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PSTIME')
            ival_ = self.gds_validate_integer(ival_, node, 'PSTIME')
            self.PSTIME = ival_
            self.PSTIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PETIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PETIME')
            ival_ = self.gds_validate_integer(ival_, node, 'PETIME')
            self.PETIME = ival_
            self.PETIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'RSTIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RSTIME')
            ival_ = self.gds_validate_integer(ival_, node, 'RSTIME')
            self.RSTIME = ival_
            self.RSTIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'RETIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RETIME')
            ival_ = self.gds_validate_integer(ival_, node, 'RETIME')
            self.RETIME = ival_
            self.RETIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'ESTIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ESTIME')
            ival_ = self.gds_validate_integer(ival_, node, 'ESTIME')
            self.ESTIME = ival_
            self.ESTIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'EETIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'EETIME')
            ival_ = self.gds_validate_integer(ival_, node, 'EETIME')
            self.EETIME = ival_
            self.EETIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'ACTION' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ACTION')
            ival_ = self.gds_validate_integer(ival_, node, 'ACTION')
            self.ACTION = ival_
            self.ACTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'REQUEST_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'REQUEST_ID')
            value_ = self.gds_validate_string(value_, node, 'REQUEST_ID')
            self.REQUEST_ID = value_
            self.REQUEST_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'VM':
            obj_ = VMType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class HISTORY


class ACL_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ACL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ACL is None:
            self.ACL = []
        else:
            self.ACL = ACL
        self.ACL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACL_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACL_POOL.subclass:
            return ACL_POOL.subclass(*args_, **kwargs_)
        else:
            return ACL_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ACL(self):
        return self.ACL
    def set_ACL(self, ACL):
        self.ACL = ACL
    def add_ACL(self, value):
        self.ACL.append(value)
    def insert_ACL_at(self, index, value):
        self.ACL.insert(index, value)
    def replace_ACL_at(self, index, value):
        self.ACL[index] = value
    def has__content(self):
        if (
            self.ACL
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ACL_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ACL_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ACL_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ACL_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ACL_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ACL_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ACL_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ACL_ in self.ACL:
            namespaceprefix_ = self.ACL_nsprefix_ + ':' if (UseCapturedNS_ and self.ACL_nsprefix_) else ''
            ACL_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ACL', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ACL':
            obj_ = ACLType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ACL.append(obj_)
            obj_.original_tagname_ = 'ACL'
# end class ACL_POOL


class CALL_INFO(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, RESULT=None, PARAMETERS=None, EXTRA=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.RESULT = RESULT
        self.RESULT_nsprefix_ = None
        self.PARAMETERS = PARAMETERS
        self.PARAMETERS_nsprefix_ = None
        self.EXTRA = EXTRA
        self.EXTRA_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CALL_INFO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CALL_INFO.subclass:
            return CALL_INFO.subclass(*args_, **kwargs_)
        else:
            return CALL_INFO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RESULT(self):
        return self.RESULT
    def set_RESULT(self, RESULT):
        self.RESULT = RESULT
    def get_PARAMETERS(self):
        return self.PARAMETERS
    def set_PARAMETERS(self, PARAMETERS):
        self.PARAMETERS = PARAMETERS
    def get_EXTRA(self):
        return self.EXTRA
    def set_EXTRA(self, EXTRA):
        self.EXTRA = EXTRA
    def has__content(self):
        if (
            self.RESULT is not None or
            self.PARAMETERS is not None or
            self.EXTRA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CALL_INFO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CALL_INFO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CALL_INFO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CALL_INFO')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CALL_INFO', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CALL_INFO'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CALL_INFO', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RESULT is not None:
            namespaceprefix_ = self.RESULT_nsprefix_ + ':' if (UseCapturedNS_ and self.RESULT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRESULT>%s</%sRESULT>%s' % (namespaceprefix_ , self.gds_format_integer(self.RESULT, input_name='RESULT'), namespaceprefix_ , eol_))
        if self.PARAMETERS is not None:
            namespaceprefix_ = self.PARAMETERS_nsprefix_ + ':' if (UseCapturedNS_ and self.PARAMETERS_nsprefix_) else ''
            self.PARAMETERS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PARAMETERS', pretty_print=pretty_print)
        if self.EXTRA is not None:
            namespaceprefix_ = self.EXTRA_nsprefix_ + ':' if (UseCapturedNS_ and self.EXTRA_nsprefix_) else ''
            self.EXTRA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EXTRA', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RESULT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RESULT')
            ival_ = self.gds_validate_integer(ival_, node, 'RESULT')
            self.RESULT = ival_
            self.RESULT_nsprefix_ = child_.prefix
        elif nodeName_ == 'PARAMETERS':
            obj_ = PARAMETERSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PARAMETERS = obj_
            obj_.original_tagname_ = 'PARAMETERS'
        elif nodeName_ == 'EXTRA':
            obj_ = EXTRAType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EXTRA = obj_
            obj_.original_tagname_ = 'EXTRA'
# end class CALL_INFO


class BACKUPJOB_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BACKUPJOB=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if BACKUPJOB is None:
            self.BACKUPJOB = []
        else:
            self.BACKUPJOB = BACKUPJOB
        self.BACKUPJOB_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BACKUPJOB_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BACKUPJOB_POOL.subclass:
            return BACKUPJOB_POOL.subclass(*args_, **kwargs_)
        else:
            return BACKUPJOB_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BACKUPJOB(self):
        return self.BACKUPJOB
    def set_BACKUPJOB(self, BACKUPJOB):
        self.BACKUPJOB = BACKUPJOB
    def add_BACKUPJOB(self, value):
        self.BACKUPJOB.append(value)
    def insert_BACKUPJOB_at(self, index, value):
        self.BACKUPJOB.insert(index, value)
    def replace_BACKUPJOB_at(self, index, value):
        self.BACKUPJOB[index] = value
    def has__content(self):
        if (
            self.BACKUPJOB
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUPJOB_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BACKUPJOB_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BACKUPJOB_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BACKUPJOB_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BACKUPJOB_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BACKUPJOB_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUPJOB_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BACKUPJOB_ in self.BACKUPJOB:
            namespaceprefix_ = self.BACKUPJOB_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUPJOB_nsprefix_) else ''
            BACKUPJOB_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BACKUPJOB', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BACKUPJOB':
            obj_ = BACKUPJOB.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BACKUPJOB.append(obj_)
            obj_.original_tagname_ = 'BACKUPJOB'
# end class BACKUPJOB_POOL


class BACKUPJOB(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, LOCK=None, PERMISSIONS=None, PRIORITY=None, LAST_BACKUP_TIME=None, LAST_BACKUP_DURATION=None, SCHED_ACTIONS=None, UPDATED_VMS=None, OUTDATED_VMS=None, BACKING_UP_VMS=None, ERROR_VMS=None, TEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.LOCK = LOCK
        self.LOCK_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.PRIORITY = PRIORITY
        self.PRIORITY_nsprefix_ = None
        self.LAST_BACKUP_TIME = LAST_BACKUP_TIME
        self.LAST_BACKUP_TIME_nsprefix_ = None
        self.LAST_BACKUP_DURATION = LAST_BACKUP_DURATION
        self.LAST_BACKUP_DURATION_nsprefix_ = None
        self.SCHED_ACTIONS = SCHED_ACTIONS
        self.SCHED_ACTIONS_nsprefix_ = None
        self.UPDATED_VMS = UPDATED_VMS
        self.UPDATED_VMS_nsprefix_ = None
        self.OUTDATED_VMS = OUTDATED_VMS
        self.OUTDATED_VMS_nsprefix_ = None
        self.BACKING_UP_VMS = BACKING_UP_VMS
        self.BACKING_UP_VMS_nsprefix_ = None
        self.ERROR_VMS = ERROR_VMS
        self.ERROR_VMS_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BACKUPJOB)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BACKUPJOB.subclass:
            return BACKUPJOB.subclass(*args_, **kwargs_)
        else:
            return BACKUPJOB(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_LOCK(self):
        return self.LOCK
    def set_LOCK(self, LOCK):
        self.LOCK = LOCK
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_PRIORITY(self):
        return self.PRIORITY
    def set_PRIORITY(self, PRIORITY):
        self.PRIORITY = PRIORITY
    def get_LAST_BACKUP_TIME(self):
        return self.LAST_BACKUP_TIME
    def set_LAST_BACKUP_TIME(self, LAST_BACKUP_TIME):
        self.LAST_BACKUP_TIME = LAST_BACKUP_TIME
    def get_LAST_BACKUP_DURATION(self):
        return self.LAST_BACKUP_DURATION
    def set_LAST_BACKUP_DURATION(self, LAST_BACKUP_DURATION):
        self.LAST_BACKUP_DURATION = LAST_BACKUP_DURATION
    def get_SCHED_ACTIONS(self):
        return self.SCHED_ACTIONS
    def set_SCHED_ACTIONS(self, SCHED_ACTIONS):
        self.SCHED_ACTIONS = SCHED_ACTIONS
    def get_UPDATED_VMS(self):
        return self.UPDATED_VMS
    def set_UPDATED_VMS(self, UPDATED_VMS):
        self.UPDATED_VMS = UPDATED_VMS
    def get_OUTDATED_VMS(self):
        return self.OUTDATED_VMS
    def set_OUTDATED_VMS(self, OUTDATED_VMS):
        self.OUTDATED_VMS = OUTDATED_VMS
    def get_BACKING_UP_VMS(self):
        return self.BACKING_UP_VMS
    def set_BACKING_UP_VMS(self, BACKING_UP_VMS):
        self.BACKING_UP_VMS = BACKING_UP_VMS
    def get_ERROR_VMS(self):
        return self.ERROR_VMS
    def set_ERROR_VMS(self, ERROR_VMS):
        self.ERROR_VMS = ERROR_VMS
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.LOCK is not None or
            self.PERMISSIONS is not None or
            self.PRIORITY is not None or
            self.LAST_BACKUP_TIME is not None or
            self.LAST_BACKUP_DURATION is not None or
            self.SCHED_ACTIONS is not None or
            self.UPDATED_VMS is not None or
            self.OUTDATED_VMS is not None or
            self.BACKING_UP_VMS is not None or
            self.ERROR_VMS is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUPJOB', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BACKUPJOB')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BACKUPJOB':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BACKUPJOB')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BACKUPJOB', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BACKUPJOB'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUPJOB', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.LOCK is not None:
            namespaceprefix_ = self.LOCK_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCK_nsprefix_) else ''
            self.LOCK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOCK', pretty_print=pretty_print)
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.PRIORITY is not None:
            namespaceprefix_ = self.PRIORITY_nsprefix_ + ':' if (UseCapturedNS_ and self.PRIORITY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPRIORITY>%s</%sPRIORITY>%s' % (namespaceprefix_ , self.gds_format_integer(self.PRIORITY, input_name='PRIORITY'), namespaceprefix_ , eol_))
        if self.LAST_BACKUP_TIME is not None:
            namespaceprefix_ = self.LAST_BACKUP_TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_BACKUP_TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_BACKUP_TIME>%s</%sLAST_BACKUP_TIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.LAST_BACKUP_TIME, input_name='LAST_BACKUP_TIME'), namespaceprefix_ , eol_))
        if self.LAST_BACKUP_DURATION is not None:
            namespaceprefix_ = self.LAST_BACKUP_DURATION_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_BACKUP_DURATION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_BACKUP_DURATION>%s</%sLAST_BACKUP_DURATION>%s' % (namespaceprefix_ , self.gds_format_integer(self.LAST_BACKUP_DURATION, input_name='LAST_BACKUP_DURATION'), namespaceprefix_ , eol_))
        if self.SCHED_ACTIONS is not None:
            namespaceprefix_ = self.SCHED_ACTIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_ACTIONS_nsprefix_) else ''
            self.SCHED_ACTIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SCHED_ACTIONS', pretty_print=pretty_print)
        if self.UPDATED_VMS is not None:
            namespaceprefix_ = self.UPDATED_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.UPDATED_VMS_nsprefix_) else ''
            self.UPDATED_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UPDATED_VMS', pretty_print=pretty_print)
        if self.OUTDATED_VMS is not None:
            namespaceprefix_ = self.OUTDATED_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.OUTDATED_VMS_nsprefix_) else ''
            self.OUTDATED_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OUTDATED_VMS', pretty_print=pretty_print)
        if self.BACKING_UP_VMS is not None:
            namespaceprefix_ = self.BACKING_UP_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKING_UP_VMS_nsprefix_) else ''
            self.BACKING_UP_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BACKING_UP_VMS', pretty_print=pretty_print)
        if self.ERROR_VMS is not None:
            namespaceprefix_ = self.ERROR_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.ERROR_VMS_nsprefix_) else ''
            self.ERROR_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ERROR_VMS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            self.TEMPLATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEMPLATE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOCK':
            obj_ = LOCK.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOCK = obj_
            obj_.original_tagname_ = 'LOCK'
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'PRIORITY' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PRIORITY')
            ival_ = self.gds_validate_integer(ival_, node, 'PRIORITY')
            self.PRIORITY = ival_
            self.PRIORITY_nsprefix_ = child_.prefix
        elif nodeName_ == 'LAST_BACKUP_TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LAST_BACKUP_TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'LAST_BACKUP_TIME')
            self.LAST_BACKUP_TIME = ival_
            self.LAST_BACKUP_TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'LAST_BACKUP_DURATION' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LAST_BACKUP_DURATION')
            ival_ = self.gds_validate_integer(ival_, node, 'LAST_BACKUP_DURATION')
            self.LAST_BACKUP_DURATION = ival_
            self.LAST_BACKUP_DURATION_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHED_ACTIONS':
            obj_ = IDS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SCHED_ACTIONS = obj_
            obj_.original_tagname_ = 'SCHED_ACTIONS'
        elif nodeName_ == 'UPDATED_VMS':
            obj_ = IDS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UPDATED_VMS = obj_
            obj_.original_tagname_ = 'UPDATED_VMS'
        elif nodeName_ == 'OUTDATED_VMS':
            obj_ = IDS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OUTDATED_VMS = obj_
            obj_.original_tagname_ = 'OUTDATED_VMS'
        elif nodeName_ == 'BACKING_UP_VMS':
            obj_ = IDS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BACKING_UP_VMS = obj_
            obj_.original_tagname_ = 'BACKING_UP_VMS'
        elif nodeName_ == 'ERROR_VMS':
            obj_ = IDS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ERROR_VMS = obj_
            obj_.original_tagname_ = 'ERROR_VMS'
        elif nodeName_ == 'TEMPLATE':
            obj_ = TEMPLATEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEMPLATE = obj_
            obj_.original_tagname_ = 'TEMPLATE'
# end class BACKUPJOB


class LOCK(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LOCKED=None, OWNER=None, TIME=None, REQ_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LOCKED = LOCKED
        self.LOCKED_nsprefix_ = None
        self.OWNER = OWNER
        self.OWNER_nsprefix_ = None
        self.TIME = TIME
        self.TIME_nsprefix_ = None
        self.REQ_ID = REQ_ID
        self.REQ_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOCK)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOCK.subclass:
            return LOCK.subclass(*args_, **kwargs_)
        else:
            return LOCK(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LOCKED(self):
        return self.LOCKED
    def set_LOCKED(self, LOCKED):
        self.LOCKED = LOCKED
    def get_OWNER(self):
        return self.OWNER
    def set_OWNER(self, OWNER):
        self.OWNER = OWNER
    def get_TIME(self):
        return self.TIME
    def set_TIME(self, TIME):
        self.TIME = TIME
    def get_REQ_ID(self):
        return self.REQ_ID
    def set_REQ_ID(self, REQ_ID):
        self.REQ_ID = REQ_ID
    def has__content(self):
        if (
            self.LOCKED is not None or
            self.OWNER is not None or
            self.TIME is not None or
            self.REQ_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCK', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOCK')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LOCK':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LOCK')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LOCK', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LOCK'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCK', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LOCKED is not None:
            namespaceprefix_ = self.LOCKED_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCKED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOCKED>%s</%sLOCKED>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOCKED, input_name='LOCKED'), namespaceprefix_ , eol_))
        if self.OWNER is not None:
            namespaceprefix_ = self.OWNER_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER>%s</%sOWNER>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER, input_name='OWNER'), namespaceprefix_ , eol_))
        if self.TIME is not None:
            namespaceprefix_ = self.TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIME>%s</%sTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIME, input_name='TIME'), namespaceprefix_ , eol_))
        if self.REQ_ID is not None:
            namespaceprefix_ = self.REQ_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.REQ_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREQ_ID>%s</%sREQ_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.REQ_ID, input_name='REQ_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LOCKED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOCKED')
            ival_ = self.gds_validate_integer(ival_, node, 'LOCKED')
            self.LOCKED = ival_
            self.LOCKED_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER')
            self.OWNER = ival_
            self.OWNER_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'TIME')
            self.TIME = ival_
            self.TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'REQ_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REQ_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'REQ_ID')
            self.REQ_ID = ival_
            self.REQ_ID_nsprefix_ = child_.prefix
# end class LOCK


class PERMISSIONS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONS.subclass:
            return PERMISSIONS.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONS'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONS


class IDS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IDS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IDS.subclass:
            return IDS.subclass(*args_, **kwargs_)
        else:
            return IDS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IDS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IDS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IDS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IDS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IDS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IDS'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IDS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class IDS


class SCHED_ACTION(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, PARENT_ID=None, TYPE=None, ACTION=None, ARGS=None, TIME=None, REPEAT=None, DAYS=None, END_TYPE=None, END_VALUE=None, DONE=None, MESSAGE=None, WARNING=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.PARENT_ID = PARENT_ID
        self.PARENT_ID_nsprefix_ = None
        self.TYPE = TYPE
        self.TYPE_nsprefix_ = None
        self.ACTION = ACTION
        self.ACTION_nsprefix_ = None
        self.ARGS = ARGS
        self.ARGS_nsprefix_ = None
        self.TIME = TIME
        self.TIME_nsprefix_ = None
        self.REPEAT = REPEAT
        self.REPEAT_nsprefix_ = None
        self.DAYS = DAYS
        self.DAYS_nsprefix_ = None
        self.END_TYPE = END_TYPE
        self.END_TYPE_nsprefix_ = None
        self.END_VALUE = END_VALUE
        self.END_VALUE_nsprefix_ = None
        self.DONE = DONE
        self.DONE_nsprefix_ = None
        self.MESSAGE = MESSAGE
        self.MESSAGE_nsprefix_ = None
        self.WARNING = WARNING
        self.WARNING_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SCHED_ACTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SCHED_ACTION.subclass:
            return SCHED_ACTION.subclass(*args_, **kwargs_)
        else:
            return SCHED_ACTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_PARENT_ID(self):
        return self.PARENT_ID
    def set_PARENT_ID(self, PARENT_ID):
        self.PARENT_ID = PARENT_ID
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_ACTION(self):
        return self.ACTION
    def set_ACTION(self, ACTION):
        self.ACTION = ACTION
    def get_ARGS(self):
        return self.ARGS
    def set_ARGS(self, ARGS):
        self.ARGS = ARGS
    def get_TIME(self):
        return self.TIME
    def set_TIME(self, TIME):
        self.TIME = TIME
    def get_REPEAT(self):
        return self.REPEAT
    def set_REPEAT(self, REPEAT):
        self.REPEAT = REPEAT
    def get_DAYS(self):
        return self.DAYS
    def set_DAYS(self, DAYS):
        self.DAYS = DAYS
    def get_END_TYPE(self):
        return self.END_TYPE
    def set_END_TYPE(self, END_TYPE):
        self.END_TYPE = END_TYPE
    def get_END_VALUE(self):
        return self.END_VALUE
    def set_END_VALUE(self, END_VALUE):
        self.END_VALUE = END_VALUE
    def get_DONE(self):
        return self.DONE
    def set_DONE(self, DONE):
        self.DONE = DONE
    def get_MESSAGE(self):
        return self.MESSAGE
    def set_MESSAGE(self, MESSAGE):
        self.MESSAGE = MESSAGE
    def get_WARNING(self):
        return self.WARNING
    def set_WARNING(self, WARNING):
        self.WARNING = WARNING
    def has__content(self):
        if (
            self.ID is not None or
            self.PARENT_ID is not None or
            self.TYPE is not None or
            self.ACTION is not None or
            self.ARGS is not None or
            self.TIME is not None or
            self.REPEAT is not None or
            self.DAYS is not None or
            self.END_TYPE is not None or
            self.END_VALUE is not None or
            self.DONE is not None or
            self.MESSAGE is not None or
            self.WARNING is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SCHED_ACTION', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SCHED_ACTION')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SCHED_ACTION':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SCHED_ACTION')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SCHED_ACTION', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SCHED_ACTION'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SCHED_ACTION', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.PARENT_ID is not None:
            namespaceprefix_ = self.PARENT_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.PARENT_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPARENT_ID>%s</%sPARENT_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.PARENT_ID, input_name='PARENT_ID'), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), namespaceprefix_ , eol_))
        if self.ACTION is not None:
            namespaceprefix_ = self.ACTION_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACTION>%s</%sACTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ACTION), input_name='ACTION')), namespaceprefix_ , eol_))
        if self.ARGS is not None:
            namespaceprefix_ = self.ARGS_nsprefix_ + ':' if (UseCapturedNS_ and self.ARGS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sARGS>%s</%sARGS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ARGS), input_name='ARGS')), namespaceprefix_ , eol_))
        if self.TIME is not None:
            namespaceprefix_ = self.TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIME>%s</%sTIME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TIME), input_name='TIME')), namespaceprefix_ , eol_))
        if self.REPEAT is not None:
            namespaceprefix_ = self.REPEAT_nsprefix_ + ':' if (UseCapturedNS_ and self.REPEAT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREPEAT>%s</%sREPEAT>%s' % (namespaceprefix_ , self.gds_format_integer(self.REPEAT, input_name='REPEAT'), namespaceprefix_ , eol_))
        if self.DAYS is not None:
            namespaceprefix_ = self.DAYS_nsprefix_ + ':' if (UseCapturedNS_ and self.DAYS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDAYS>%s</%sDAYS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DAYS), input_name='DAYS')), namespaceprefix_ , eol_))
        if self.END_TYPE is not None:
            namespaceprefix_ = self.END_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.END_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEND_TYPE>%s</%sEND_TYPE>%s' % (namespaceprefix_ , self.gds_format_integer(self.END_TYPE, input_name='END_TYPE'), namespaceprefix_ , eol_))
        if self.END_VALUE is not None:
            namespaceprefix_ = self.END_VALUE_nsprefix_ + ':' if (UseCapturedNS_ and self.END_VALUE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEND_VALUE>%s</%sEND_VALUE>%s' % (namespaceprefix_ , self.gds_format_integer(self.END_VALUE, input_name='END_VALUE'), namespaceprefix_ , eol_))
        if self.DONE is not None:
            namespaceprefix_ = self.DONE_nsprefix_ + ':' if (UseCapturedNS_ and self.DONE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDONE>%s</%sDONE>%s' % (namespaceprefix_ , self.gds_format_integer(self.DONE, input_name='DONE'), namespaceprefix_ , eol_))
        if self.MESSAGE is not None:
            namespaceprefix_ = self.MESSAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.MESSAGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMESSAGE>%s</%sMESSAGE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MESSAGE), input_name='MESSAGE')), namespaceprefix_ , eol_))
        if self.WARNING is not None:
            namespaceprefix_ = self.WARNING_nsprefix_ + ':' if (UseCapturedNS_ and self.WARNING_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWARNING>%s</%sWARNING>%s' % (namespaceprefix_ , self.gds_format_integer(self.WARNING, input_name='WARNING'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'PARENT_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PARENT_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'PARENT_ID')
            self.PARENT_ID = ival_
            self.PARENT_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TYPE')
            value_ = self.gds_validate_string(value_, node, 'TYPE')
            self.TYPE = value_
            self.TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'ACTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ACTION')
            value_ = self.gds_validate_string(value_, node, 'ACTION')
            self.ACTION = value_
            self.ACTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'ARGS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ARGS')
            value_ = self.gds_validate_string(value_, node, 'ARGS')
            self.ARGS = value_
            self.ARGS_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TIME')
            value_ = self.gds_validate_string(value_, node, 'TIME')
            self.TIME = value_
            self.TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'REPEAT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REPEAT')
            ival_ = self.gds_validate_integer(ival_, node, 'REPEAT')
            self.REPEAT = ival_
            self.REPEAT_nsprefix_ = child_.prefix
        elif nodeName_ == 'DAYS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DAYS')
            value_ = self.gds_validate_string(value_, node, 'DAYS')
            self.DAYS = value_
            self.DAYS_nsprefix_ = child_.prefix
        elif nodeName_ == 'END_TYPE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'END_TYPE')
            ival_ = self.gds_validate_integer(ival_, node, 'END_TYPE')
            self.END_TYPE = ival_
            self.END_TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'END_VALUE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'END_VALUE')
            ival_ = self.gds_validate_integer(ival_, node, 'END_VALUE')
            self.END_VALUE = ival_
            self.END_VALUE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DONE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DONE')
            ival_ = self.gds_validate_integer(ival_, node, 'DONE')
            self.DONE = ival_
            self.DONE_nsprefix_ = child_.prefix
        elif nodeName_ == 'MESSAGE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MESSAGE')
            value_ = self.gds_validate_string(value_, node, 'MESSAGE')
            self.MESSAGE = value_
            self.MESSAGE_nsprefix_ = child_.prefix
        elif nodeName_ == 'WARNING' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'WARNING')
            ival_ = self.gds_validate_integer(ival_, node, 'WARNING')
            self.WARNING = ival_
            self.WARNING_nsprefix_ = child_.prefix
# end class SCHED_ACTION


class DATASTORE_QUOTA(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATASTORE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DATASTORE is None:
            self.DATASTORE = []
        else:
            self.DATASTORE = DATASTORE
        self.DATASTORE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE_QUOTA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE_QUOTA.subclass:
            return DATASTORE_QUOTA.subclass(*args_, **kwargs_)
        else:
            return DATASTORE_QUOTA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATASTORE(self):
        return self.DATASTORE
    def set_DATASTORE(self, DATASTORE):
        self.DATASTORE = DATASTORE
    def add_DATASTORE(self, value):
        self.DATASTORE.append(value)
    def insert_DATASTORE_at(self, index, value):
        self.DATASTORE.insert(index, value)
    def replace_DATASTORE_at(self, index, value):
        self.DATASTORE[index] = value
    def has__content(self):
        if (
            self.DATASTORE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORE_QUOTA', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE_QUOTA')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATASTORE_QUOTA':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATASTORE_QUOTA')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATASTORE_QUOTA', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATASTORE_QUOTA'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORE_QUOTA', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASTORE_ in self.DATASTORE:
            namespaceprefix_ = self.DATASTORE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_nsprefix_) else ''
            DATASTORE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATASTORE':
            obj_ = DATASTOREType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORE.append(obj_)
            obj_.original_tagname_ = 'DATASTORE'
# end class DATASTORE_QUOTA


class NETWORK_QUOTA(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NETWORK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if NETWORK is None:
            self.NETWORK = []
        else:
            self.NETWORK = NETWORK
        self.NETWORK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORK_QUOTA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORK_QUOTA.subclass:
            return NETWORK_QUOTA.subclass(*args_, **kwargs_)
        else:
            return NETWORK_QUOTA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NETWORK(self):
        return self.NETWORK
    def set_NETWORK(self, NETWORK):
        self.NETWORK = NETWORK
    def add_NETWORK(self, value):
        self.NETWORK.append(value)
    def insert_NETWORK_at(self, index, value):
        self.NETWORK.insert(index, value)
    def replace_NETWORK_at(self, index, value):
        self.NETWORK[index] = value
    def has__content(self):
        if (
            self.NETWORK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NETWORK_QUOTA', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORK_QUOTA')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NETWORK_QUOTA':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NETWORK_QUOTA')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NETWORK_QUOTA', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NETWORK_QUOTA'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NETWORK_QUOTA', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NETWORK_ in self.NETWORK:
            namespaceprefix_ = self.NETWORK_nsprefix_ + ':' if (UseCapturedNS_ and self.NETWORK_nsprefix_) else ''
            NETWORK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NETWORK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NETWORK':
            obj_ = NETWORKType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NETWORK.append(obj_)
            obj_.original_tagname_ = 'NETWORK'
# end class NETWORK_QUOTA


class VM_QUOTA(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VM=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if VM is None:
            self.VM = []
        else:
            self.VM = VM
        self.VM_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_QUOTA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_QUOTA.subclass:
            return VM_QUOTA.subclass(*args_, **kwargs_)
        else:
            return VM_QUOTA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VM(self):
        return self.VM
    def set_VM(self, VM):
        self.VM = VM
    def add_VM(self, value):
        self.VM.append(value)
    def insert_VM_at(self, index, value):
        self.VM.insert(index, value)
    def replace_VM_at(self, index, value):
        self.VM[index] = value
    def has__content(self):
        if (
            self.VM
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_QUOTA', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_QUOTA')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VM_QUOTA':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VM_QUOTA')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VM_QUOTA', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VM_QUOTA'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_QUOTA', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VM_ in self.VM:
            namespaceprefix_ = self.VM_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_nsprefix_) else ''
            VM_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VM':
            obj_ = VMType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM.append(obj_)
            obj_.original_tagname_ = 'VM'
# end class VM_QUOTA


class IMAGE_QUOTA(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IMAGE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if IMAGE is None:
            self.IMAGE = []
        else:
            self.IMAGE = IMAGE
        self.IMAGE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_QUOTA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_QUOTA.subclass:
            return IMAGE_QUOTA.subclass(*args_, **kwargs_)
        else:
            return IMAGE_QUOTA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IMAGE(self):
        return self.IMAGE
    def set_IMAGE(self, IMAGE):
        self.IMAGE = IMAGE
    def add_IMAGE(self, value):
        self.IMAGE.append(value)
    def insert_IMAGE_at(self, index, value):
        self.IMAGE.insert(index, value)
    def replace_IMAGE_at(self, index, value):
        self.IMAGE[index] = value
    def has__content(self):
        if (
            self.IMAGE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IMAGE_QUOTA', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_QUOTA')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IMAGE_QUOTA':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGE_QUOTA')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IMAGE_QUOTA', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IMAGE_QUOTA'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IMAGE_QUOTA', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_ in self.IMAGE:
            namespaceprefix_ = self.IMAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_nsprefix_) else ''
            IMAGE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IMAGE':
            obj_ = IMAGEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE.append(obj_)
            obj_.original_tagname_ = 'IMAGE'
# end class IMAGE_QUOTA


class CLUSTER_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CLUSTER=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CLUSTER is None:
            self.CLUSTER = []
        else:
            self.CLUSTER = CLUSTER
        self.CLUSTER_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTER_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTER_POOL.subclass:
            return CLUSTER_POOL.subclass(*args_, **kwargs_)
        else:
            return CLUSTER_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CLUSTER(self):
        return self.CLUSTER
    def set_CLUSTER(self, CLUSTER):
        self.CLUSTER = CLUSTER
    def add_CLUSTER(self, value):
        self.CLUSTER.append(value)
    def insert_CLUSTER_at(self, index, value):
        self.CLUSTER.insert(index, value)
    def replace_CLUSTER_at(self, index, value):
        self.CLUSTER[index] = value
    def has__content(self):
        if (
            self.CLUSTER
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTER_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTER_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CLUSTER_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CLUSTER_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CLUSTER_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CLUSTER_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTER_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CLUSTER_ in self.CLUSTER:
            namespaceprefix_ = self.CLUSTER_nsprefix_ + ':' if (UseCapturedNS_ and self.CLUSTER_nsprefix_) else ''
            CLUSTER_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CLUSTER', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CLUSTER':
            obj_ = CLUSTER.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CLUSTER.append(obj_)
            obj_.original_tagname_ = 'CLUSTER'
# end class CLUSTER_POOL


class CLUSTER(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, NAME=None, HOSTS=None, DATASTORES=None, VNETS=None, TEMPLATE=None, PLAN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.HOSTS = HOSTS
        self.HOSTS_nsprefix_ = None
        self.DATASTORES = DATASTORES
        self.DATASTORES_nsprefix_ = None
        self.VNETS = VNETS
        self.VNETS_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.PLAN = PLAN
        self.PLAN_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTER.subclass:
            return CLUSTER.subclass(*args_, **kwargs_)
        else:
            return CLUSTER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_HOSTS(self):
        return self.HOSTS
    def set_HOSTS(self, HOSTS):
        self.HOSTS = HOSTS
    def get_DATASTORES(self):
        return self.DATASTORES
    def set_DATASTORES(self, DATASTORES):
        self.DATASTORES = DATASTORES
    def get_VNETS(self):
        return self.VNETS
    def set_VNETS(self, VNETS):
        self.VNETS = VNETS
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_PLAN(self):
        return self.PLAN
    def set_PLAN(self, PLAN):
        self.PLAN = PLAN
    def has__content(self):
        if (
            self.ID is not None or
            self.NAME is not None or
            self.HOSTS is not None or
            self.DATASTORES is not None or
            self.VNETS is not None or
            self.TEMPLATE is not None or
            self.PLAN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTER', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTER')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CLUSTER':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CLUSTER')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CLUSTER', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CLUSTER'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTER', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.HOSTS is not None:
            namespaceprefix_ = self.HOSTS_nsprefix_ + ':' if (UseCapturedNS_ and self.HOSTS_nsprefix_) else ''
            self.HOSTS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HOSTS', pretty_print=pretty_print)
        if self.DATASTORES is not None:
            namespaceprefix_ = self.DATASTORES_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORES_nsprefix_) else ''
            self.DATASTORES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORES', pretty_print=pretty_print)
        if self.VNETS is not None:
            namespaceprefix_ = self.VNETS_nsprefix_ + ':' if (UseCapturedNS_ and self.VNETS_nsprefix_) else ''
            self.VNETS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VNETS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
        if self.PLAN is not None:
            namespaceprefix_ = self.PLAN_nsprefix_ + ':' if (UseCapturedNS_ and self.PLAN_nsprefix_) else ''
            self.PLAN.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PLAN', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'HOSTS':
            obj_ = HOSTSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HOSTS = obj_
            obj_.original_tagname_ = 'HOSTS'
        elif nodeName_ == 'DATASTORES':
            obj_ = DATASTORESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORES = obj_
            obj_.original_tagname_ = 'DATASTORES'
        elif nodeName_ == 'VNETS':
            obj_ = VNETSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VNETS = obj_
            obj_.original_tagname_ = 'VNETS'
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PLAN':
            obj_ = PLANType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PLAN = obj_
            obj_.original_tagname_ = 'PLAN'
# end class CLUSTER


class DATASTORE_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATASTORE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DATASTORE is None:
            self.DATASTORE = []
        else:
            self.DATASTORE = DATASTORE
        self.DATASTORE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE_POOL.subclass:
            return DATASTORE_POOL.subclass(*args_, **kwargs_)
        else:
            return DATASTORE_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATASTORE(self):
        return self.DATASTORE
    def set_DATASTORE(self, DATASTORE):
        self.DATASTORE = DATASTORE
    def add_DATASTORE(self, value):
        self.DATASTORE.append(value)
    def insert_DATASTORE_at(self, index, value):
        self.DATASTORE.insert(index, value)
    def replace_DATASTORE_at(self, index, value):
        self.DATASTORE[index] = value
    def has__content(self):
        if (
            self.DATASTORE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORE_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATASTORE_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATASTORE_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATASTORE_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATASTORE_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORE_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASTORE_ in self.DATASTORE:
            namespaceprefix_ = self.DATASTORE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_nsprefix_) else ''
            DATASTORE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATASTORE':
            obj_ = DATASTORE.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORE.append(obj_)
            obj_.original_tagname_ = 'DATASTORE'
# end class DATASTORE_POOL


class DATASTORE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, DS_MAD=None, TM_MAD=None, BASE_PATH=None, TYPE=None, DISK_TYPE=None, STATE=None, CLUSTERS=None, TOTAL_MB=None, FREE_MB=None, USED_MB=None, IMAGES=None, TEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.DS_MAD = DS_MAD
        self.DS_MAD_nsprefix_ = None
        self.TM_MAD = TM_MAD
        self.TM_MAD_nsprefix_ = None
        self.BASE_PATH = BASE_PATH
        self.BASE_PATH_nsprefix_ = None
        self.TYPE = TYPE
        self.TYPE_nsprefix_ = None
        self.DISK_TYPE = DISK_TYPE
        self.DISK_TYPE_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.CLUSTERS = CLUSTERS
        self.CLUSTERS_nsprefix_ = None
        self.TOTAL_MB = TOTAL_MB
        self.TOTAL_MB_nsprefix_ = None
        self.FREE_MB = FREE_MB
        self.FREE_MB_nsprefix_ = None
        self.USED_MB = USED_MB
        self.USED_MB_nsprefix_ = None
        self.IMAGES = IMAGES
        self.IMAGES_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE.subclass:
            return DATASTORE.subclass(*args_, **kwargs_)
        else:
            return DATASTORE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_DS_MAD(self):
        return self.DS_MAD
    def set_DS_MAD(self, DS_MAD):
        self.DS_MAD = DS_MAD
    def get_TM_MAD(self):
        return self.TM_MAD
    def set_TM_MAD(self, TM_MAD):
        self.TM_MAD = TM_MAD
    def get_BASE_PATH(self):
        return self.BASE_PATH
    def set_BASE_PATH(self, BASE_PATH):
        self.BASE_PATH = BASE_PATH
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_DISK_TYPE(self):
        return self.DISK_TYPE
    def set_DISK_TYPE(self, DISK_TYPE):
        self.DISK_TYPE = DISK_TYPE
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_CLUSTERS(self):
        return self.CLUSTERS
    def set_CLUSTERS(self, CLUSTERS):
        self.CLUSTERS = CLUSTERS
    def get_TOTAL_MB(self):
        return self.TOTAL_MB
    def set_TOTAL_MB(self, TOTAL_MB):
        self.TOTAL_MB = TOTAL_MB
    def get_FREE_MB(self):
        return self.FREE_MB
    def set_FREE_MB(self, FREE_MB):
        self.FREE_MB = FREE_MB
    def get_USED_MB(self):
        return self.USED_MB
    def set_USED_MB(self, USED_MB):
        self.USED_MB = USED_MB
    def get_IMAGES(self):
        return self.IMAGES
    def set_IMAGES(self, IMAGES):
        self.IMAGES = IMAGES
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.DS_MAD is not None or
            self.TM_MAD is not None or
            self.BASE_PATH is not None or
            self.TYPE is not None or
            self.DISK_TYPE is not None or
            self.STATE is not None or
            self.CLUSTERS is not None or
            self.TOTAL_MB is not None or
            self.FREE_MB is not None or
            self.USED_MB is not None or
            self.IMAGES is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATASTORE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATASTORE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATASTORE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATASTORE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.DS_MAD is not None:
            namespaceprefix_ = self.DS_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.DS_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDS_MAD>%s</%sDS_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DS_MAD), input_name='DS_MAD')), namespaceprefix_ , eol_))
        if self.TM_MAD is not None:
            namespaceprefix_ = self.TM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.TM_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTM_MAD>%s</%sTM_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TM_MAD), input_name='TM_MAD')), namespaceprefix_ , eol_))
        if self.BASE_PATH is not None:
            namespaceprefix_ = self.BASE_PATH_nsprefix_ + ':' if (UseCapturedNS_ and self.BASE_PATH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBASE_PATH>%s</%sBASE_PATH>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BASE_PATH), input_name='BASE_PATH')), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_format_integer(self.TYPE, input_name='TYPE'), namespaceprefix_ , eol_))
        if self.DISK_TYPE is not None:
            namespaceprefix_ = self.DISK_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISK_TYPE>%s</%sDISK_TYPE>%s' % (namespaceprefix_ , self.gds_format_integer(self.DISK_TYPE, input_name='DISK_TYPE'), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.CLUSTERS is not None:
            namespaceprefix_ = self.CLUSTERS_nsprefix_ + ':' if (UseCapturedNS_ and self.CLUSTERS_nsprefix_) else ''
            self.CLUSTERS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CLUSTERS', pretty_print=pretty_print)
        if self.TOTAL_MB is not None:
            namespaceprefix_ = self.TOTAL_MB_nsprefix_ + ':' if (UseCapturedNS_ and self.TOTAL_MB_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTOTAL_MB>%s</%sTOTAL_MB>%s' % (namespaceprefix_ , self.gds_format_integer(self.TOTAL_MB, input_name='TOTAL_MB'), namespaceprefix_ , eol_))
        if self.FREE_MB is not None:
            namespaceprefix_ = self.FREE_MB_nsprefix_ + ':' if (UseCapturedNS_ and self.FREE_MB_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFREE_MB>%s</%sFREE_MB>%s' % (namespaceprefix_ , self.gds_format_integer(self.FREE_MB, input_name='FREE_MB'), namespaceprefix_ , eol_))
        if self.USED_MB is not None:
            namespaceprefix_ = self.USED_MB_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_MB_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED_MB>%s</%sUSED_MB>%s' % (namespaceprefix_ , self.gds_format_integer(self.USED_MB, input_name='USED_MB'), namespaceprefix_ , eol_))
        if self.IMAGES is not None:
            namespaceprefix_ = self.IMAGES_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGES_nsprefix_) else ''
            self.IMAGES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGES', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'DS_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DS_MAD')
            value_ = self.gds_validate_string(value_, node, 'DS_MAD')
            self.DS_MAD = value_
            self.DS_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'TM_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TM_MAD')
            value_ = self.gds_validate_string(value_, node, 'TM_MAD')
            self.TM_MAD = value_
            self.TM_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'BASE_PATH':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BASE_PATH')
            value_ = self.gds_validate_string(value_, node, 'BASE_PATH')
            self.BASE_PATH = value_
            self.BASE_PATH_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TYPE')
            ival_ = self.gds_validate_integer(ival_, node, 'TYPE')
            self.TYPE = ival_
            self.TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISK_TYPE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DISK_TYPE')
            ival_ = self.gds_validate_integer(ival_, node, 'DISK_TYPE')
            self.DISK_TYPE = ival_
            self.DISK_TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'CLUSTERS':
            obj_ = CLUSTERSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CLUSTERS = obj_
            obj_.original_tagname_ = 'CLUSTERS'
        elif nodeName_ == 'TOTAL_MB' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TOTAL_MB')
            ival_ = self.gds_validate_integer(ival_, node, 'TOTAL_MB')
            self.TOTAL_MB = ival_
            self.TOTAL_MB_nsprefix_ = child_.prefix
        elif nodeName_ == 'FREE_MB' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'FREE_MB')
            ival_ = self.gds_validate_integer(ival_, node, 'FREE_MB')
            self.FREE_MB = ival_
            self.FREE_MB_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED_MB' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'USED_MB')
            ival_ = self.gds_validate_integer(ival_, node, 'USED_MB')
            self.USED_MB = ival_
            self.USED_MB_nsprefix_ = child_.prefix
        elif nodeName_ == 'IMAGES':
            obj_ = IMAGESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGES = obj_
            obj_.original_tagname_ = 'IMAGES'
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
# end class DATASTORE


class TEMPLATE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEMPLATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEMPLATE.subclass:
            return TEMPLATE.subclass(*args_, **kwargs_)
        else:
            return TEMPLATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TEMPLATE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEMPLATE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEMPLATE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEMPLATE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEMPLATE', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEMPLATE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TEMPLATE', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TEMPLATE


class DOCUMENT_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DOCUMENT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DOCUMENT is None:
            self.DOCUMENT = []
        else:
            self.DOCUMENT = DOCUMENT
        self.DOCUMENT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DOCUMENT_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DOCUMENT_POOL.subclass:
            return DOCUMENT_POOL.subclass(*args_, **kwargs_)
        else:
            return DOCUMENT_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DOCUMENT(self):
        return self.DOCUMENT
    def set_DOCUMENT(self, DOCUMENT):
        self.DOCUMENT = DOCUMENT
    def add_DOCUMENT(self, value):
        self.DOCUMENT.append(value)
    def insert_DOCUMENT_at(self, index, value):
        self.DOCUMENT.insert(index, value)
    def replace_DOCUMENT_at(self, index, value):
        self.DOCUMENT[index] = value
    def has__content(self):
        if (
            self.DOCUMENT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DOCUMENT_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DOCUMENT_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DOCUMENT_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DOCUMENT_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DOCUMENT_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DOCUMENT_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DOCUMENT_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DOCUMENT_ in self.DOCUMENT:
            namespaceprefix_ = self.DOCUMENT_nsprefix_ + ':' if (UseCapturedNS_ and self.DOCUMENT_nsprefix_) else ''
            DOCUMENT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DOCUMENT', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DOCUMENT':
            obj_ = DOCUMENT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DOCUMENT.append(obj_)
            obj_.original_tagname_ = 'DOCUMENT'
# end class DOCUMENT_POOL


class DOCUMENT(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, TYPE=None, PERMISSIONS=None, LOCK=None, TEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.TYPE = TYPE
        self.TYPE_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.LOCK = LOCK
        self.LOCK_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DOCUMENT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DOCUMENT.subclass:
            return DOCUMENT.subclass(*args_, **kwargs_)
        else:
            return DOCUMENT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_LOCK(self):
        return self.LOCK
    def set_LOCK(self, LOCK):
        self.LOCK = LOCK
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.TYPE is not None or
            self.PERMISSIONS is not None or
            self.LOCK is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DOCUMENT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DOCUMENT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DOCUMENT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DOCUMENT')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DOCUMENT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DOCUMENT'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DOCUMENT', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), namespaceprefix_ , eol_))
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.LOCK is not None:
            namespaceprefix_ = self.LOCK_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCK_nsprefix_) else ''
            self.LOCK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOCK', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TYPE')
            value_ = self.gds_validate_string(value_, node, 'TYPE')
            self.TYPE = value_
            self.TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'LOCK':
            obj_ = LOCKType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOCK = obj_
            obj_.original_tagname_ = 'LOCK'
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
# end class DOCUMENT


class GROUP_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, GROUP=None, QUOTAS=None, DEFAULT_GROUP_QUOTAS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if GROUP is None:
            self.GROUP = []
        else:
            self.GROUP = GROUP
        self.GROUP_nsprefix_ = None
        if QUOTAS is None:
            self.QUOTAS = []
        else:
            self.QUOTAS = QUOTAS
        self.QUOTAS_nsprefix_ = None
        self.DEFAULT_GROUP_QUOTAS = DEFAULT_GROUP_QUOTAS
        self.DEFAULT_GROUP_QUOTAS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GROUP_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GROUP_POOL.subclass:
            return GROUP_POOL.subclass(*args_, **kwargs_)
        else:
            return GROUP_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GROUP(self):
        return self.GROUP
    def set_GROUP(self, GROUP):
        self.GROUP = GROUP
    def add_GROUP(self, value):
        self.GROUP.append(value)
    def insert_GROUP_at(self, index, value):
        self.GROUP.insert(index, value)
    def replace_GROUP_at(self, index, value):
        self.GROUP[index] = value
    def get_QUOTAS(self):
        return self.QUOTAS
    def set_QUOTAS(self, QUOTAS):
        self.QUOTAS = QUOTAS
    def add_QUOTAS(self, value):
        self.QUOTAS.append(value)
    def insert_QUOTAS_at(self, index, value):
        self.QUOTAS.insert(index, value)
    def replace_QUOTAS_at(self, index, value):
        self.QUOTAS[index] = value
    def get_DEFAULT_GROUP_QUOTAS(self):
        return self.DEFAULT_GROUP_QUOTAS
    def set_DEFAULT_GROUP_QUOTAS(self, DEFAULT_GROUP_QUOTAS):
        self.DEFAULT_GROUP_QUOTAS = DEFAULT_GROUP_QUOTAS
    def has__content(self):
        if (
            self.GROUP or
            self.QUOTAS or
            self.DEFAULT_GROUP_QUOTAS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='GROUP_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GROUP_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GROUP_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GROUP_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GROUP_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GROUP_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='GROUP_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GROUP_ in self.GROUP:
            namespaceprefix_ = self.GROUP_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_nsprefix_) else ''
            GROUP_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GROUP', pretty_print=pretty_print)
        for QUOTAS_ in self.QUOTAS:
            namespaceprefix_ = self.QUOTAS_nsprefix_ + ':' if (UseCapturedNS_ and self.QUOTAS_nsprefix_) else ''
            QUOTAS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='QUOTAS', pretty_print=pretty_print)
        if self.DEFAULT_GROUP_QUOTAS is not None:
            namespaceprefix_ = self.DEFAULT_GROUP_QUOTAS_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_GROUP_QUOTAS_nsprefix_) else ''
            self.DEFAULT_GROUP_QUOTAS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DEFAULT_GROUP_QUOTAS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GROUP':
            obj_ = GROUPType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GROUP.append(obj_)
            obj_.original_tagname_ = 'GROUP'
        elif nodeName_ == 'QUOTAS':
            obj_ = QUOTASType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.QUOTAS.append(obj_)
            obj_.original_tagname_ = 'QUOTAS'
        elif nodeName_ == 'DEFAULT_GROUP_QUOTAS':
            obj_ = DEFAULT_GROUP_QUOTASType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DEFAULT_GROUP_QUOTAS = obj_
            obj_.original_tagname_ = 'DEFAULT_GROUP_QUOTAS'
# end class GROUP_POOL


class GROUP(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, NAME=None, TEMPLATE=None, USERS=None, ADMINS=None, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None, DEFAULT_GROUP_QUOTAS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.USERS = USERS
        self.USERS_nsprefix_ = None
        self.ADMINS = ADMINS
        self.ADMINS_nsprefix_ = None
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.DATASTORE_QUOTA_nsprefix_ = None
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.NETWORK_QUOTA_nsprefix_ = None
        self.VM_QUOTA = VM_QUOTA
        self.VM_QUOTA_nsprefix_ = None
        self.IMAGE_QUOTA = IMAGE_QUOTA
        self.IMAGE_QUOTA_nsprefix_ = None
        self.DEFAULT_GROUP_QUOTAS = DEFAULT_GROUP_QUOTAS
        self.DEFAULT_GROUP_QUOTAS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GROUP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GROUP.subclass:
            return GROUP.subclass(*args_, **kwargs_)
        else:
            return GROUP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_USERS(self):
        return self.USERS
    def set_USERS(self, USERS):
        self.USERS = USERS
    def get_ADMINS(self):
        return self.ADMINS
    def set_ADMINS(self, ADMINS):
        self.ADMINS = ADMINS
    def get_DATASTORE_QUOTA(self):
        return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA):
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self):
        return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA):
        self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self):
        return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA):
        self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self):
        return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA):
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def get_DEFAULT_GROUP_QUOTAS(self):
        return self.DEFAULT_GROUP_QUOTAS
    def set_DEFAULT_GROUP_QUOTAS(self, DEFAULT_GROUP_QUOTAS):
        self.DEFAULT_GROUP_QUOTAS = DEFAULT_GROUP_QUOTAS
    def has__content(self):
        if (
            self.ID is not None or
            self.NAME is not None or
            self.TEMPLATE is not None or
            self.USERS is not None or
            self.ADMINS is not None or
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None or
            self.DEFAULT_GROUP_QUOTAS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='GROUP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GROUP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GROUP':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GROUP')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GROUP', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GROUP'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='GROUP', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
        if self.USERS is not None:
            namespaceprefix_ = self.USERS_nsprefix_ + ':' if (UseCapturedNS_ and self.USERS_nsprefix_) else ''
            self.USERS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='USERS', pretty_print=pretty_print)
        if self.ADMINS is not None:
            namespaceprefix_ = self.ADMINS_nsprefix_ + ':' if (UseCapturedNS_ and self.ADMINS_nsprefix_) else ''
            self.ADMINS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ADMINS', pretty_print=pretty_print)
        if self.DATASTORE_QUOTA is not None:
            namespaceprefix_ = self.DATASTORE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_QUOTA_nsprefix_) else ''
            self.DATASTORE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            namespaceprefix_ = self.NETWORK_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.NETWORK_QUOTA_nsprefix_) else ''
            self.NETWORK_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            namespaceprefix_ = self.VM_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_QUOTA_nsprefix_) else ''
            self.VM_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            namespaceprefix_ = self.IMAGE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_QUOTA_nsprefix_) else ''
            self.IMAGE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_QUOTA', pretty_print=pretty_print)
        if self.DEFAULT_GROUP_QUOTAS is not None:
            namespaceprefix_ = self.DEFAULT_GROUP_QUOTAS_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_GROUP_QUOTAS_nsprefix_) else ''
            self.DEFAULT_GROUP_QUOTAS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DEFAULT_GROUP_QUOTAS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'USERS':
            obj_ = USERSType5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.USERS = obj_
            obj_.original_tagname_ = 'USERS'
        elif nodeName_ == 'ADMINS':
            obj_ = ADMINSType6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ADMINS = obj_
            obj_.original_tagname_ = 'ADMINS'
        elif nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
        elif nodeName_ == 'DEFAULT_GROUP_QUOTAS':
            obj_ = DEFAULT_GROUP_QUOTASType7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DEFAULT_GROUP_QUOTAS = obj_
            obj_.original_tagname_ = 'DEFAULT_GROUP_QUOTAS'
# end class GROUP


class HOOK_MESSAGE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, HOOK_TYPE=None, CALL=None, CALL_INFO=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.HOOK_TYPE = HOOK_TYPE
        self.HOOK_TYPE_nsprefix_ = None
        self.CALL = CALL
        self.CALL_nsprefix_ = None
        if CALL_INFO is None:
            self.CALL_INFO = []
        else:
            self.CALL_INFO = CALL_INFO
        self.CALL_INFO_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOOK_MESSAGE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOOK_MESSAGE.subclass:
            return HOOK_MESSAGE.subclass(*args_, **kwargs_)
        else:
            return HOOK_MESSAGE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HOOK_TYPE(self):
        return self.HOOK_TYPE
    def set_HOOK_TYPE(self, HOOK_TYPE):
        self.HOOK_TYPE = HOOK_TYPE
    def get_CALL(self):
        return self.CALL
    def set_CALL(self, CALL):
        self.CALL = CALL
    def get_CALL_INFO(self):
        return self.CALL_INFO
    def set_CALL_INFO(self, CALL_INFO):
        self.CALL_INFO = CALL_INFO
    def add_CALL_INFO(self, value):
        self.CALL_INFO.append(value)
    def insert_CALL_INFO_at(self, index, value):
        self.CALL_INFO.insert(index, value)
    def replace_CALL_INFO_at(self, index, value):
        self.CALL_INFO[index] = value
    def has__content(self):
        if (
            self.HOOK_TYPE is not None or
            self.CALL is not None or
            self.CALL_INFO
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOOK_MESSAGE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOOK_MESSAGE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HOOK_MESSAGE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HOOK_MESSAGE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HOOK_MESSAGE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HOOK_MESSAGE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOOK_MESSAGE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HOOK_TYPE is not None:
            namespaceprefix_ = self.HOOK_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.HOOK_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHOOK_TYPE>%s</%sHOOK_TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.HOOK_TYPE), input_name='HOOK_TYPE')), namespaceprefix_ , eol_))
        if self.CALL is not None:
            namespaceprefix_ = self.CALL_nsprefix_ + ':' if (UseCapturedNS_ and self.CALL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCALL>%s</%sCALL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CALL), input_name='CALL')), namespaceprefix_ , eol_))
        for CALL_INFO_ in self.CALL_INFO:
            namespaceprefix_ = self.CALL_INFO_nsprefix_ + ':' if (UseCapturedNS_ and self.CALL_INFO_nsprefix_) else ''
            CALL_INFO_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CALL_INFO', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HOOK_TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'HOOK_TYPE')
            value_ = self.gds_validate_string(value_, node, 'HOOK_TYPE')
            self.HOOK_TYPE = value_
            self.HOOK_TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'CALL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CALL')
            value_ = self.gds_validate_string(value_, node, 'CALL')
            self.CALL = value_
            self.CALL_nsprefix_ = child_.prefix
        elif nodeName_ == 'CALL_INFO':
            obj_ = CALL_INFO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CALL_INFO.append(obj_)
            obj_.original_tagname_ = 'CALL_INFO'
# end class HOOK_MESSAGE


class HOOK_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, HOOK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if HOOK is None:
            self.HOOK = []
        else:
            self.HOOK = HOOK
        self.HOOK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOOK_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOOK_POOL.subclass:
            return HOOK_POOL.subclass(*args_, **kwargs_)
        else:
            return HOOK_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HOOK(self):
        return self.HOOK
    def set_HOOK(self, HOOK):
        self.HOOK = HOOK
    def add_HOOK(self, value):
        self.HOOK.append(value)
    def insert_HOOK_at(self, index, value):
        self.HOOK.insert(index, value)
    def replace_HOOK_at(self, index, value):
        self.HOOK[index] = value
    def has__content(self):
        if (
            self.HOOK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOOK_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOOK_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HOOK_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HOOK_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HOOK_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HOOK_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOOK_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HOOK_ in self.HOOK:
            namespaceprefix_ = self.HOOK_nsprefix_ + ':' if (UseCapturedNS_ and self.HOOK_nsprefix_) else ''
            HOOK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HOOK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HOOK':
            obj_ = HOOK.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HOOK.append(obj_)
            obj_.original_tagname_ = 'HOOK'
# end class HOOK_POOL


class HOOK(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, NAME=None, TYPE=None, TEMPLATE=None, HOOKLOG=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.TYPE = TYPE
        self.TYPE_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.HOOKLOG = HOOKLOG
        self.HOOKLOG_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOOK)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOOK.subclass:
            return HOOK.subclass(*args_, **kwargs_)
        else:
            return HOOK(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_HOOKLOG(self):
        return self.HOOKLOG
    def set_HOOKLOG(self, HOOKLOG):
        self.HOOKLOG = HOOKLOG
    def has__content(self):
        if (
            self.ID is not None or
            self.NAME is not None or
            self.TYPE is not None or
            self.TEMPLATE is not None or
            self.HOOKLOG is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOOK', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOOK')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HOOK':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HOOK')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HOOK', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HOOK'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOOK', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), namespaceprefix_ , eol_))
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            self.TEMPLATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEMPLATE', pretty_print=pretty_print)
        if self.HOOKLOG is not None:
            namespaceprefix_ = self.HOOKLOG_nsprefix_ + ':' if (UseCapturedNS_ and self.HOOKLOG_nsprefix_) else ''
            self.HOOKLOG.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HOOKLOG', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TYPE')
            value_ = self.gds_validate_string(value_, node, 'TYPE')
            self.TYPE = value_
            self.TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'TEMPLATE':
            obj_ = TEMPLATEType10.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEMPLATE = obj_
            obj_.original_tagname_ = 'TEMPLATE'
        elif nodeName_ == 'HOOKLOG':
            obj_ = HOOKLOGType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HOOKLOG = obj_
            obj_.original_tagname_ = 'HOOKLOG'
# end class HOOK


class HOST_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, HOST=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if HOST is None:
            self.HOST = []
        else:
            self.HOST = HOST
        self.HOST_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOST_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOST_POOL.subclass:
            return HOST_POOL.subclass(*args_, **kwargs_)
        else:
            return HOST_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HOST(self):
        return self.HOST
    def set_HOST(self, HOST):
        self.HOST = HOST
    def add_HOST(self, value):
        self.HOST.append(value)
    def insert_HOST_at(self, index, value):
        self.HOST.insert(index, value)
    def replace_HOST_at(self, index, value):
        self.HOST[index] = value
    def has__content(self):
        if (
            self.HOST
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOST_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOST_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HOST_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HOST_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HOST_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HOST_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOST_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HOST_ in self.HOST:
            namespaceprefix_ = self.HOST_nsprefix_ + ':' if (UseCapturedNS_ and self.HOST_nsprefix_) else ''
            HOST_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HOST', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HOST':
            obj_ = HOST.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HOST.append(obj_)
            obj_.original_tagname_ = 'HOST'
# end class HOST_POOL


class HOST(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, NAME=None, STATE=None, PREV_STATE=None, IM_MAD=None, VM_MAD=None, CLUSTER_ID=None, CLUSTER=None, HOST_SHARE=None, VMS=None, TEMPLATE=None, MONITORING=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.PREV_STATE = PREV_STATE
        self.PREV_STATE_nsprefix_ = None
        self.IM_MAD = IM_MAD
        self.IM_MAD_nsprefix_ = None
        self.VM_MAD = VM_MAD
        self.VM_MAD_nsprefix_ = None
        self.CLUSTER_ID = CLUSTER_ID
        self.CLUSTER_ID_nsprefix_ = None
        self.CLUSTER = CLUSTER
        self.CLUSTER_nsprefix_ = None
        self.HOST_SHARE = HOST_SHARE
        self.HOST_SHARE_nsprefix_ = None
        self.VMS = VMS
        self.VMS_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.MONITORING = MONITORING
        self.MONITORING_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOST)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOST.subclass:
            return HOST.subclass(*args_, **kwargs_)
        else:
            return HOST(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_PREV_STATE(self):
        return self.PREV_STATE
    def set_PREV_STATE(self, PREV_STATE):
        self.PREV_STATE = PREV_STATE
    def get_IM_MAD(self):
        return self.IM_MAD
    def set_IM_MAD(self, IM_MAD):
        self.IM_MAD = IM_MAD
    def get_VM_MAD(self):
        return self.VM_MAD
    def set_VM_MAD(self, VM_MAD):
        self.VM_MAD = VM_MAD
    def get_CLUSTER_ID(self):
        return self.CLUSTER_ID
    def set_CLUSTER_ID(self, CLUSTER_ID):
        self.CLUSTER_ID = CLUSTER_ID
    def get_CLUSTER(self):
        return self.CLUSTER
    def set_CLUSTER(self, CLUSTER):
        self.CLUSTER = CLUSTER
    def get_HOST_SHARE(self):
        return self.HOST_SHARE
    def set_HOST_SHARE(self, HOST_SHARE):
        self.HOST_SHARE = HOST_SHARE
    def get_VMS(self):
        return self.VMS
    def set_VMS(self, VMS):
        self.VMS = VMS
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_MONITORING(self):
        return self.MONITORING
    def set_MONITORING(self, MONITORING):
        self.MONITORING = MONITORING
    def has__content(self):
        if (
            self.ID is not None or
            self.NAME is not None or
            self.STATE is not None or
            self.PREV_STATE is not None or
            self.IM_MAD is not None or
            self.VM_MAD is not None or
            self.CLUSTER_ID is not None or
            self.CLUSTER is not None or
            self.HOST_SHARE is not None or
            self.VMS is not None or
            self.TEMPLATE is not None or
            self.MONITORING is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOST', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOST')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HOST':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HOST')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HOST', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HOST'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOST', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.PREV_STATE is not None:
            namespaceprefix_ = self.PREV_STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.PREV_STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREV_STATE>%s</%sPREV_STATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.PREV_STATE, input_name='PREV_STATE'), namespaceprefix_ , eol_))
        if self.IM_MAD is not None:
            namespaceprefix_ = self.IM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.IM_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIM_MAD>%s</%sIM_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IM_MAD), input_name='IM_MAD')), namespaceprefix_ , eol_))
        if self.VM_MAD is not None:
            namespaceprefix_ = self.VM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM_MAD>%s</%sVM_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VM_MAD), input_name='VM_MAD')), namespaceprefix_ , eol_))
        if self.CLUSTER_ID is not None:
            namespaceprefix_ = self.CLUSTER_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.CLUSTER_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLUSTER_ID>%s</%sCLUSTER_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.CLUSTER_ID, input_name='CLUSTER_ID'), namespaceprefix_ , eol_))
        if self.CLUSTER is not None:
            namespaceprefix_ = self.CLUSTER_nsprefix_ + ':' if (UseCapturedNS_ and self.CLUSTER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLUSTER>%s</%sCLUSTER>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CLUSTER), input_name='CLUSTER')), namespaceprefix_ , eol_))
        if self.HOST_SHARE is not None:
            namespaceprefix_ = self.HOST_SHARE_nsprefix_ + ':' if (UseCapturedNS_ and self.HOST_SHARE_nsprefix_) else ''
            self.HOST_SHARE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HOST_SHARE', pretty_print=pretty_print)
        if self.VMS is not None:
            namespaceprefix_ = self.VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_nsprefix_) else ''
            self.VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VMS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
        if self.MONITORING is not None:
            namespaceprefix_ = self.MONITORING_nsprefix_ + ':' if (UseCapturedNS_ and self.MONITORING_nsprefix_) else ''
            self.MONITORING.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MONITORING', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PREV_STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PREV_STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'PREV_STATE')
            self.PREV_STATE = ival_
            self.PREV_STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'IM_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IM_MAD')
            value_ = self.gds_validate_string(value_, node, 'IM_MAD')
            self.IM_MAD = value_
            self.IM_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'VM_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VM_MAD')
            value_ = self.gds_validate_string(value_, node, 'VM_MAD')
            self.VM_MAD = value_
            self.VM_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'CLUSTER_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CLUSTER_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'CLUSTER_ID')
            self.CLUSTER_ID = ival_
            self.CLUSTER_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'CLUSTER':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CLUSTER')
            value_ = self.gds_validate_string(value_, node, 'CLUSTER')
            self.CLUSTER = value_
            self.CLUSTER_nsprefix_ = child_.prefix
        elif nodeName_ == 'HOST_SHARE':
            obj_ = HOST_SHAREType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HOST_SHARE = obj_
            obj_.original_tagname_ = 'HOST_SHARE'
        elif nodeName_ == 'VMS':
            obj_ = VMSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VMS = obj_
            obj_.original_tagname_ = 'VMS'
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'MONITORING':
            obj_ = MONITORINGType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MONITORING = obj_
            obj_.original_tagname_ = 'MONITORING'
# end class HOST


class IMAGE_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IMAGE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if IMAGE is None:
            self.IMAGE = []
        else:
            self.IMAGE = IMAGE
        self.IMAGE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_POOL.subclass:
            return IMAGE_POOL.subclass(*args_, **kwargs_)
        else:
            return IMAGE_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IMAGE(self):
        return self.IMAGE
    def set_IMAGE(self, IMAGE):
        self.IMAGE = IMAGE
    def add_IMAGE(self, value):
        self.IMAGE.append(value)
    def insert_IMAGE_at(self, index, value):
        self.IMAGE.insert(index, value)
    def replace_IMAGE_at(self, index, value):
        self.IMAGE[index] = value
    def has__content(self):
        if (
            self.IMAGE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IMAGE_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IMAGE_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGE_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IMAGE_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IMAGE_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IMAGE_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_ in self.IMAGE:
            namespaceprefix_ = self.IMAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_nsprefix_) else ''
            IMAGE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IMAGE':
            obj_ = IMAGE.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE.append(obj_)
            obj_.original_tagname_ = 'IMAGE'
# end class IMAGE_POOL


class IMAGE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, LOCK=None, PERMISSIONS=None, TYPE=None, DISK_TYPE=None, PERSISTENT=None, REGTIME=None, MODTIME=None, SOURCE=None, PATH=None, FORMAT=None, FS=None, SIZE=None, STATE=None, PREV_STATE=None, RUNNING_VMS=None, CLONING_OPS=None, CLONING_ID=None, TARGET_SNAPSHOT=None, DATASTORE_ID=None, DATASTORE=None, VMS=None, CLONES=None, APP_CLONES=None, TEMPLATE=None, SNAPSHOTS=None, BACKUP_INCREMENTS=None, BACKUP_DISK_IDS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.LOCK = LOCK
        self.LOCK_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.TYPE = TYPE
        self.TYPE_nsprefix_ = None
        self.DISK_TYPE = DISK_TYPE
        self.DISK_TYPE_nsprefix_ = None
        self.PERSISTENT = PERSISTENT
        self.PERSISTENT_nsprefix_ = None
        self.REGTIME = REGTIME
        self.REGTIME_nsprefix_ = None
        self.MODTIME = MODTIME
        self.MODTIME_nsprefix_ = None
        self.SOURCE = SOURCE
        self.SOURCE_nsprefix_ = None
        self.PATH = PATH
        self.PATH_nsprefix_ = None
        self.FORMAT = FORMAT
        self.FORMAT_nsprefix_ = None
        self.FS = FS
        self.FS_nsprefix_ = None
        self.SIZE = SIZE
        self.SIZE_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.PREV_STATE = PREV_STATE
        self.PREV_STATE_nsprefix_ = None
        self.RUNNING_VMS = RUNNING_VMS
        self.RUNNING_VMS_nsprefix_ = None
        self.CLONING_OPS = CLONING_OPS
        self.CLONING_OPS_nsprefix_ = None
        self.CLONING_ID = CLONING_ID
        self.CLONING_ID_nsprefix_ = None
        self.TARGET_SNAPSHOT = TARGET_SNAPSHOT
        self.TARGET_SNAPSHOT_nsprefix_ = None
        self.DATASTORE_ID = DATASTORE_ID
        self.DATASTORE_ID_nsprefix_ = None
        self.DATASTORE = DATASTORE
        self.DATASTORE_nsprefix_ = None
        self.VMS = VMS
        self.VMS_nsprefix_ = None
        self.CLONES = CLONES
        self.CLONES_nsprefix_ = None
        self.APP_CLONES = APP_CLONES
        self.APP_CLONES_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.SNAPSHOTS = SNAPSHOTS
        self.SNAPSHOTS_nsprefix_ = None
        self.BACKUP_INCREMENTS = BACKUP_INCREMENTS
        self.BACKUP_INCREMENTS_nsprefix_ = None
        self.BACKUP_DISK_IDS = BACKUP_DISK_IDS
        self.BACKUP_DISK_IDS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE.subclass:
            return IMAGE.subclass(*args_, **kwargs_)
        else:
            return IMAGE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_LOCK(self):
        return self.LOCK
    def set_LOCK(self, LOCK):
        self.LOCK = LOCK
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_DISK_TYPE(self):
        return self.DISK_TYPE
    def set_DISK_TYPE(self, DISK_TYPE):
        self.DISK_TYPE = DISK_TYPE
    def get_PERSISTENT(self):
        return self.PERSISTENT
    def set_PERSISTENT(self, PERSISTENT):
        self.PERSISTENT = PERSISTENT
    def get_REGTIME(self):
        return self.REGTIME
    def set_REGTIME(self, REGTIME):
        self.REGTIME = REGTIME
    def get_MODTIME(self):
        return self.MODTIME
    def set_MODTIME(self, MODTIME):
        self.MODTIME = MODTIME
    def get_SOURCE(self):
        return self.SOURCE
    def set_SOURCE(self, SOURCE):
        self.SOURCE = SOURCE
    def get_PATH(self):
        return self.PATH
    def set_PATH(self, PATH):
        self.PATH = PATH
    def get_FORMAT(self):
        return self.FORMAT
    def set_FORMAT(self, FORMAT):
        self.FORMAT = FORMAT
    def get_FS(self):
        return self.FS
    def set_FS(self, FS):
        self.FS = FS
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_PREV_STATE(self):
        return self.PREV_STATE
    def set_PREV_STATE(self, PREV_STATE):
        self.PREV_STATE = PREV_STATE
    def get_RUNNING_VMS(self):
        return self.RUNNING_VMS
    def set_RUNNING_VMS(self, RUNNING_VMS):
        self.RUNNING_VMS = RUNNING_VMS
    def get_CLONING_OPS(self):
        return self.CLONING_OPS
    def set_CLONING_OPS(self, CLONING_OPS):
        self.CLONING_OPS = CLONING_OPS
    def get_CLONING_ID(self):
        return self.CLONING_ID
    def set_CLONING_ID(self, CLONING_ID):
        self.CLONING_ID = CLONING_ID
    def get_TARGET_SNAPSHOT(self):
        return self.TARGET_SNAPSHOT
    def set_TARGET_SNAPSHOT(self, TARGET_SNAPSHOT):
        self.TARGET_SNAPSHOT = TARGET_SNAPSHOT
    def get_DATASTORE_ID(self):
        return self.DATASTORE_ID
    def set_DATASTORE_ID(self, DATASTORE_ID):
        self.DATASTORE_ID = DATASTORE_ID
    def get_DATASTORE(self):
        return self.DATASTORE
    def set_DATASTORE(self, DATASTORE):
        self.DATASTORE = DATASTORE
    def get_VMS(self):
        return self.VMS
    def set_VMS(self, VMS):
        self.VMS = VMS
    def get_CLONES(self):
        return self.CLONES
    def set_CLONES(self, CLONES):
        self.CLONES = CLONES
    def get_APP_CLONES(self):
        return self.APP_CLONES
    def set_APP_CLONES(self, APP_CLONES):
        self.APP_CLONES = APP_CLONES
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_SNAPSHOTS(self):
        return self.SNAPSHOTS
    def set_SNAPSHOTS(self, SNAPSHOTS):
        self.SNAPSHOTS = SNAPSHOTS
    def get_BACKUP_INCREMENTS(self):
        return self.BACKUP_INCREMENTS
    def set_BACKUP_INCREMENTS(self, BACKUP_INCREMENTS):
        self.BACKUP_INCREMENTS = BACKUP_INCREMENTS
    def get_BACKUP_DISK_IDS(self):
        return self.BACKUP_DISK_IDS
    def set_BACKUP_DISK_IDS(self, BACKUP_DISK_IDS):
        self.BACKUP_DISK_IDS = BACKUP_DISK_IDS
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.LOCK is not None or
            self.PERMISSIONS is not None or
            self.TYPE is not None or
            self.DISK_TYPE is not None or
            self.PERSISTENT is not None or
            self.REGTIME is not None or
            self.MODTIME is not None or
            self.SOURCE is not None or
            self.PATH is not None or
            self.FORMAT is not None or
            self.FS is not None or
            self.SIZE is not None or
            self.STATE is not None or
            self.PREV_STATE is not None or
            self.RUNNING_VMS is not None or
            self.CLONING_OPS is not None or
            self.CLONING_ID is not None or
            self.TARGET_SNAPSHOT is not None or
            self.DATASTORE_ID is not None or
            self.DATASTORE is not None or
            self.VMS is not None or
            self.CLONES is not None or
            self.APP_CLONES is not None or
            self.TEMPLATE is not None or
            self.SNAPSHOTS is not None or
            self.BACKUP_INCREMENTS is not None or
            self.BACKUP_DISK_IDS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IMAGE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IMAGE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IMAGE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IMAGE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IMAGE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.LOCK is not None:
            namespaceprefix_ = self.LOCK_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCK_nsprefix_) else ''
            self.LOCK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOCK', pretty_print=pretty_print)
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_format_integer(self.TYPE, input_name='TYPE'), namespaceprefix_ , eol_))
        if self.DISK_TYPE is not None:
            namespaceprefix_ = self.DISK_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISK_TYPE>%s</%sDISK_TYPE>%s' % (namespaceprefix_ , self.gds_format_integer(self.DISK_TYPE, input_name='DISK_TYPE'), namespaceprefix_ , eol_))
        if self.PERSISTENT is not None:
            namespaceprefix_ = self.PERSISTENT_nsprefix_ + ':' if (UseCapturedNS_ and self.PERSISTENT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPERSISTENT>%s</%sPERSISTENT>%s' % (namespaceprefix_ , self.gds_format_integer(self.PERSISTENT, input_name='PERSISTENT'), namespaceprefix_ , eol_))
        if self.REGTIME is not None:
            namespaceprefix_ = self.REGTIME_nsprefix_ + ':' if (UseCapturedNS_ and self.REGTIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREGTIME>%s</%sREGTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.REGTIME, input_name='REGTIME'), namespaceprefix_ , eol_))
        if self.MODTIME is not None:
            namespaceprefix_ = self.MODTIME_nsprefix_ + ':' if (UseCapturedNS_ and self.MODTIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMODTIME>%s</%sMODTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.MODTIME, input_name='MODTIME'), namespaceprefix_ , eol_))
        if self.SOURCE is not None:
            namespaceprefix_ = self.SOURCE_nsprefix_ + ':' if (UseCapturedNS_ and self.SOURCE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSOURCE>%s</%sSOURCE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SOURCE), input_name='SOURCE')), namespaceprefix_ , eol_))
        if self.PATH is not None:
            namespaceprefix_ = self.PATH_nsprefix_ + ':' if (UseCapturedNS_ and self.PATH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPATH>%s</%sPATH>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PATH), input_name='PATH')), namespaceprefix_ , eol_))
        if self.FORMAT is not None:
            namespaceprefix_ = self.FORMAT_nsprefix_ + ':' if (UseCapturedNS_ and self.FORMAT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFORMAT>%s</%sFORMAT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FORMAT), input_name='FORMAT')), namespaceprefix_ , eol_))
        if self.FS is not None:
            namespaceprefix_ = self.FS_nsprefix_ + ':' if (UseCapturedNS_ and self.FS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFS>%s</%sFS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FS), input_name='FS')), namespaceprefix_ , eol_))
        if self.SIZE is not None:
            namespaceprefix_ = self.SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE>%s</%sSIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.SIZE, input_name='SIZE'), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.PREV_STATE is not None:
            namespaceprefix_ = self.PREV_STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.PREV_STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREV_STATE>%s</%sPREV_STATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.PREV_STATE, input_name='PREV_STATE'), namespaceprefix_ , eol_))
        if self.RUNNING_VMS is not None:
            namespaceprefix_ = self.RUNNING_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_VMS>%s</%sRUNNING_VMS>%s' % (namespaceprefix_ , self.gds_format_integer(self.RUNNING_VMS, input_name='RUNNING_VMS'), namespaceprefix_ , eol_))
        if self.CLONING_OPS is not None:
            namespaceprefix_ = self.CLONING_OPS_nsprefix_ + ':' if (UseCapturedNS_ and self.CLONING_OPS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLONING_OPS>%s</%sCLONING_OPS>%s' % (namespaceprefix_ , self.gds_format_integer(self.CLONING_OPS, input_name='CLONING_OPS'), namespaceprefix_ , eol_))
        if self.CLONING_ID is not None:
            namespaceprefix_ = self.CLONING_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.CLONING_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLONING_ID>%s</%sCLONING_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.CLONING_ID, input_name='CLONING_ID'), namespaceprefix_ , eol_))
        if self.TARGET_SNAPSHOT is not None:
            namespaceprefix_ = self.TARGET_SNAPSHOT_nsprefix_ + ':' if (UseCapturedNS_ and self.TARGET_SNAPSHOT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTARGET_SNAPSHOT>%s</%sTARGET_SNAPSHOT>%s' % (namespaceprefix_ , self.gds_format_integer(self.TARGET_SNAPSHOT, input_name='TARGET_SNAPSHOT'), namespaceprefix_ , eol_))
        if self.DATASTORE_ID is not None:
            namespaceprefix_ = self.DATASTORE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATASTORE_ID>%s</%sDATASTORE_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.DATASTORE_ID, input_name='DATASTORE_ID'), namespaceprefix_ , eol_))
        if self.DATASTORE is not None:
            namespaceprefix_ = self.DATASTORE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATASTORE>%s</%sDATASTORE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DATASTORE), input_name='DATASTORE')), namespaceprefix_ , eol_))
        if self.VMS is not None:
            namespaceprefix_ = self.VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_nsprefix_) else ''
            self.VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VMS', pretty_print=pretty_print)
        if self.CLONES is not None:
            namespaceprefix_ = self.CLONES_nsprefix_ + ':' if (UseCapturedNS_ and self.CLONES_nsprefix_) else ''
            self.CLONES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CLONES', pretty_print=pretty_print)
        if self.APP_CLONES is not None:
            namespaceprefix_ = self.APP_CLONES_nsprefix_ + ':' if (UseCapturedNS_ and self.APP_CLONES_nsprefix_) else ''
            self.APP_CLONES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='APP_CLONES', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            self.TEMPLATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEMPLATE', pretty_print=pretty_print)
        if self.SNAPSHOTS is not None:
            namespaceprefix_ = self.SNAPSHOTS_nsprefix_ + ':' if (UseCapturedNS_ and self.SNAPSHOTS_nsprefix_) else ''
            self.SNAPSHOTS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SNAPSHOTS', pretty_print=pretty_print)
        if self.BACKUP_INCREMENTS is not None:
            namespaceprefix_ = self.BACKUP_INCREMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUP_INCREMENTS_nsprefix_) else ''
            self.BACKUP_INCREMENTS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BACKUP_INCREMENTS', pretty_print=pretty_print)
        if self.BACKUP_DISK_IDS is not None:
            namespaceprefix_ = self.BACKUP_DISK_IDS_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUP_DISK_IDS_nsprefix_) else ''
            self.BACKUP_DISK_IDS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BACKUP_DISK_IDS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOCK':
            obj_ = LOCKType14.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOCK = obj_
            obj_.original_tagname_ = 'LOCK'
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType15.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'TYPE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TYPE')
            ival_ = self.gds_validate_integer(ival_, node, 'TYPE')
            self.TYPE = ival_
            self.TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISK_TYPE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DISK_TYPE')
            ival_ = self.gds_validate_integer(ival_, node, 'DISK_TYPE')
            self.DISK_TYPE = ival_
            self.DISK_TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PERSISTENT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PERSISTENT')
            ival_ = self.gds_validate_integer(ival_, node, 'PERSISTENT')
            self.PERSISTENT = ival_
            self.PERSISTENT_nsprefix_ = child_.prefix
        elif nodeName_ == 'REGTIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REGTIME')
            ival_ = self.gds_validate_integer(ival_, node, 'REGTIME')
            self.REGTIME = ival_
            self.REGTIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'MODTIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MODTIME')
            ival_ = self.gds_validate_integer(ival_, node, 'MODTIME')
            self.MODTIME = ival_
            self.MODTIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'SOURCE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SOURCE')
            value_ = self.gds_validate_string(value_, node, 'SOURCE')
            self.SOURCE = value_
            self.SOURCE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PATH':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PATH')
            value_ = self.gds_validate_string(value_, node, 'PATH')
            self.PATH = value_
            self.PATH_nsprefix_ = child_.prefix
        elif nodeName_ == 'FORMAT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FORMAT')
            value_ = self.gds_validate_string(value_, node, 'FORMAT')
            self.FORMAT = value_
            self.FORMAT_nsprefix_ = child_.prefix
        elif nodeName_ == 'FS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FS')
            value_ = self.gds_validate_string(value_, node, 'FS')
            self.FS = value_
            self.FS_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
            self.SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PREV_STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PREV_STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'PREV_STATE')
            self.PREV_STATE = ival_
            self.PREV_STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_VMS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RUNNING_VMS')
            ival_ = self.gds_validate_integer(ival_, node, 'RUNNING_VMS')
            self.RUNNING_VMS = ival_
            self.RUNNING_VMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'CLONING_OPS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CLONING_OPS')
            ival_ = self.gds_validate_integer(ival_, node, 'CLONING_OPS')
            self.CLONING_OPS = ival_
            self.CLONING_OPS_nsprefix_ = child_.prefix
        elif nodeName_ == 'CLONING_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CLONING_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'CLONING_ID')
            self.CLONING_ID = ival_
            self.CLONING_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'TARGET_SNAPSHOT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TARGET_SNAPSHOT')
            ival_ = self.gds_validate_integer(ival_, node, 'TARGET_SNAPSHOT')
            self.TARGET_SNAPSHOT = ival_
            self.TARGET_SNAPSHOT_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATASTORE_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DATASTORE_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'DATASTORE_ID')
            self.DATASTORE_ID = ival_
            self.DATASTORE_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATASTORE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DATASTORE')
            value_ = self.gds_validate_string(value_, node, 'DATASTORE')
            self.DATASTORE = value_
            self.DATASTORE_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMS':
            obj_ = IDS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VMS = obj_
            obj_.original_tagname_ = 'VMS'
        elif nodeName_ == 'CLONES':
            obj_ = IDS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CLONES = obj_
            obj_.original_tagname_ = 'CLONES'
        elif nodeName_ == 'APP_CLONES':
            obj_ = IDS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.APP_CLONES = obj_
            obj_.original_tagname_ = 'APP_CLONES'
        elif nodeName_ == 'TEMPLATE':
            obj_ = TEMPLATEType16.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEMPLATE = obj_
            obj_.original_tagname_ = 'TEMPLATE'
        elif nodeName_ == 'SNAPSHOTS':
            obj_ = SNAPSHOTSType17.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SNAPSHOTS = obj_
            obj_.original_tagname_ = 'SNAPSHOTS'
        elif nodeName_ == 'BACKUP_INCREMENTS':
            obj_ = BACKUP_INCREMENTSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BACKUP_INCREMENTS = obj_
            obj_.original_tagname_ = 'BACKUP_INCREMENTS'
        elif nodeName_ == 'BACKUP_DISK_IDS':
            obj_ = IDS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BACKUP_DISK_IDS = obj_
            obj_.original_tagname_ = 'BACKUP_DISK_IDS'
# end class IMAGE


class MARKETPLACEAPP_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, MARKETPLACEAPP=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if MARKETPLACEAPP is None:
            self.MARKETPLACEAPP = []
        else:
            self.MARKETPLACEAPP = MARKETPLACEAPP
        self.MARKETPLACEAPP_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MARKETPLACEAPP_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MARKETPLACEAPP_POOL.subclass:
            return MARKETPLACEAPP_POOL.subclass(*args_, **kwargs_)
        else:
            return MARKETPLACEAPP_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MARKETPLACEAPP(self):
        return self.MARKETPLACEAPP
    def set_MARKETPLACEAPP(self, MARKETPLACEAPP):
        self.MARKETPLACEAPP = MARKETPLACEAPP
    def add_MARKETPLACEAPP(self, value):
        self.MARKETPLACEAPP.append(value)
    def insert_MARKETPLACEAPP_at(self, index, value):
        self.MARKETPLACEAPP.insert(index, value)
    def replace_MARKETPLACEAPP_at(self, index, value):
        self.MARKETPLACEAPP[index] = value
    def has__content(self):
        if (
            self.MARKETPLACEAPP
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKETPLACEAPP_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MARKETPLACEAPP_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MARKETPLACEAPP_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MARKETPLACEAPP_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MARKETPLACEAPP_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MARKETPLACEAPP_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKETPLACEAPP_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MARKETPLACEAPP_ in self.MARKETPLACEAPP:
            namespaceprefix_ = self.MARKETPLACEAPP_nsprefix_ + ':' if (UseCapturedNS_ and self.MARKETPLACEAPP_nsprefix_) else ''
            MARKETPLACEAPP_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MARKETPLACEAPP', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MARKETPLACEAPP':
            obj_ = MARKETPLACEAPP.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MARKETPLACEAPP.append(obj_)
            obj_.original_tagname_ = 'MARKETPLACEAPP'
# end class MARKETPLACEAPP_POOL


class MARKETPLACEAPP(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, LOCK=None, REGTIME=None, NAME=None, ZONE_ID=None, ORIGIN_ID=None, SOURCE=None, MD5=None, SIZE=None, DESCRIPTION=None, VERSION=None, FORMAT=None, APPTEMPLATE64=None, MARKETPLACE_ID=None, MARKETPLACE=None, STATE=None, TYPE=None, PERMISSIONS=None, TEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.LOCK = LOCK
        self.LOCK_nsprefix_ = None
        self.REGTIME = REGTIME
        self.REGTIME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.ZONE_ID = ZONE_ID
        self.ZONE_ID_nsprefix_ = None
        self.ORIGIN_ID = ORIGIN_ID
        self.ORIGIN_ID_nsprefix_ = None
        self.SOURCE = SOURCE
        self.SOURCE_nsprefix_ = None
        self.MD5 = MD5
        self.MD5_nsprefix_ = None
        self.SIZE = SIZE
        self.SIZE_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        self.VERSION = VERSION
        self.VERSION_nsprefix_ = None
        self.FORMAT = FORMAT
        self.FORMAT_nsprefix_ = None
        self.APPTEMPLATE64 = APPTEMPLATE64
        self.APPTEMPLATE64_nsprefix_ = None
        self.MARKETPLACE_ID = MARKETPLACE_ID
        self.MARKETPLACE_ID_nsprefix_ = None
        self.MARKETPLACE = MARKETPLACE
        self.MARKETPLACE_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.TYPE = TYPE
        self.TYPE_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MARKETPLACEAPP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MARKETPLACEAPP.subclass:
            return MARKETPLACEAPP.subclass(*args_, **kwargs_)
        else:
            return MARKETPLACEAPP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_LOCK(self):
        return self.LOCK
    def set_LOCK(self, LOCK):
        self.LOCK = LOCK
    def get_REGTIME(self):
        return self.REGTIME
    def set_REGTIME(self, REGTIME):
        self.REGTIME = REGTIME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_ZONE_ID(self):
        return self.ZONE_ID
    def set_ZONE_ID(self, ZONE_ID):
        self.ZONE_ID = ZONE_ID
    def get_ORIGIN_ID(self):
        return self.ORIGIN_ID
    def set_ORIGIN_ID(self, ORIGIN_ID):
        self.ORIGIN_ID = ORIGIN_ID
    def get_SOURCE(self):
        return self.SOURCE
    def set_SOURCE(self, SOURCE):
        self.SOURCE = SOURCE
    def get_MD5(self):
        return self.MD5
    def set_MD5(self, MD5):
        self.MD5 = MD5
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_VERSION(self):
        return self.VERSION
    def set_VERSION(self, VERSION):
        self.VERSION = VERSION
    def get_FORMAT(self):
        return self.FORMAT
    def set_FORMAT(self, FORMAT):
        self.FORMAT = FORMAT
    def get_APPTEMPLATE64(self):
        return self.APPTEMPLATE64
    def set_APPTEMPLATE64(self, APPTEMPLATE64):
        self.APPTEMPLATE64 = APPTEMPLATE64
    def get_MARKETPLACE_ID(self):
        return self.MARKETPLACE_ID
    def set_MARKETPLACE_ID(self, MARKETPLACE_ID):
        self.MARKETPLACE_ID = MARKETPLACE_ID
    def get_MARKETPLACE(self):
        return self.MARKETPLACE
    def set_MARKETPLACE(self, MARKETPLACE):
        self.MARKETPLACE = MARKETPLACE
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.LOCK is not None or
            self.REGTIME is not None or
            self.NAME is not None or
            self.ZONE_ID is not None or
            self.ORIGIN_ID is not None or
            self.SOURCE is not None or
            self.MD5 is not None or
            self.SIZE is not None or
            self.DESCRIPTION is not None or
            self.VERSION is not None or
            self.FORMAT is not None or
            self.APPTEMPLATE64 is not None or
            self.MARKETPLACE_ID is not None or
            self.MARKETPLACE is not None or
            self.STATE is not None or
            self.TYPE is not None or
            self.PERMISSIONS is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKETPLACEAPP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MARKETPLACEAPP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MARKETPLACEAPP':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MARKETPLACEAPP')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MARKETPLACEAPP', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MARKETPLACEAPP'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKETPLACEAPP', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.LOCK is not None:
            namespaceprefix_ = self.LOCK_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCK_nsprefix_) else ''
            self.LOCK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOCK', pretty_print=pretty_print)
        if self.REGTIME is not None:
            namespaceprefix_ = self.REGTIME_nsprefix_ + ':' if (UseCapturedNS_ and self.REGTIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREGTIME>%s</%sREGTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.REGTIME, input_name='REGTIME'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.ZONE_ID is not None:
            namespaceprefix_ = self.ZONE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ZONE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZONE_ID>%s</%sZONE_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ZONE_ID), input_name='ZONE_ID')), namespaceprefix_ , eol_))
        if self.ORIGIN_ID is not None:
            namespaceprefix_ = self.ORIGIN_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ORIGIN_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sORIGIN_ID>%s</%sORIGIN_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ORIGIN_ID), input_name='ORIGIN_ID')), namespaceprefix_ , eol_))
        if self.SOURCE is not None:
            namespaceprefix_ = self.SOURCE_nsprefix_ + ':' if (UseCapturedNS_ and self.SOURCE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSOURCE>%s</%sSOURCE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SOURCE), input_name='SOURCE')), namespaceprefix_ , eol_))
        if self.MD5 is not None:
            namespaceprefix_ = self.MD5_nsprefix_ + ':' if (UseCapturedNS_ and self.MD5_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMD5>%s</%sMD5>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MD5), input_name='MD5')), namespaceprefix_ , eol_))
        if self.SIZE is not None:
            namespaceprefix_ = self.SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE>%s</%sSIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.SIZE, input_name='SIZE'), namespaceprefix_ , eol_))
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        if self.VERSION is not None:
            namespaceprefix_ = self.VERSION_nsprefix_ + ':' if (UseCapturedNS_ and self.VERSION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVERSION>%s</%sVERSION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VERSION), input_name='VERSION')), namespaceprefix_ , eol_))
        if self.FORMAT is not None:
            namespaceprefix_ = self.FORMAT_nsprefix_ + ':' if (UseCapturedNS_ and self.FORMAT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFORMAT>%s</%sFORMAT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FORMAT), input_name='FORMAT')), namespaceprefix_ , eol_))
        if self.APPTEMPLATE64 is not None:
            namespaceprefix_ = self.APPTEMPLATE64_nsprefix_ + ':' if (UseCapturedNS_ and self.APPTEMPLATE64_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAPPTEMPLATE64>%s</%sAPPTEMPLATE64>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.APPTEMPLATE64), input_name='APPTEMPLATE64')), namespaceprefix_ , eol_))
        if self.MARKETPLACE_ID is not None:
            namespaceprefix_ = self.MARKETPLACE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.MARKETPLACE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMARKETPLACE_ID>%s</%sMARKETPLACE_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.MARKETPLACE_ID, input_name='MARKETPLACE_ID'), namespaceprefix_ , eol_))
        if self.MARKETPLACE is not None:
            namespaceprefix_ = self.MARKETPLACE_nsprefix_ + ':' if (UseCapturedNS_ and self.MARKETPLACE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMARKETPLACE>%s</%sMARKETPLACE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MARKETPLACE), input_name='MARKETPLACE')), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_format_integer(self.TYPE, input_name='TYPE'), namespaceprefix_ , eol_))
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOCK':
            obj_ = LOCKType19.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOCK = obj_
            obj_.original_tagname_ = 'LOCK'
        elif nodeName_ == 'REGTIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REGTIME')
            ival_ = self.gds_validate_integer(ival_, node, 'REGTIME')
            self.REGTIME = ival_
            self.REGTIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'ZONE_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ZONE_ID')
            value_ = self.gds_validate_string(value_, node, 'ZONE_ID')
            self.ZONE_ID = value_
            self.ZONE_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'ORIGIN_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ORIGIN_ID')
            value_ = self.gds_validate_string(value_, node, 'ORIGIN_ID')
            self.ORIGIN_ID = value_
            self.ORIGIN_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'SOURCE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SOURCE')
            value_ = self.gds_validate_string(value_, node, 'SOURCE')
            self.SOURCE = value_
            self.SOURCE_nsprefix_ = child_.prefix
        elif nodeName_ == 'MD5':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MD5')
            value_ = self.gds_validate_string(value_, node, 'MD5')
            self.MD5 = value_
            self.MD5_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
            self.SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'VERSION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VERSION')
            value_ = self.gds_validate_string(value_, node, 'VERSION')
            self.VERSION = value_
            self.VERSION_nsprefix_ = child_.prefix
        elif nodeName_ == 'FORMAT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FORMAT')
            value_ = self.gds_validate_string(value_, node, 'FORMAT')
            self.FORMAT = value_
            self.FORMAT_nsprefix_ = child_.prefix
        elif nodeName_ == 'APPTEMPLATE64':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'APPTEMPLATE64')
            value_ = self.gds_validate_string(value_, node, 'APPTEMPLATE64')
            self.APPTEMPLATE64 = value_
            self.APPTEMPLATE64_nsprefix_ = child_.prefix
        elif nodeName_ == 'MARKETPLACE_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MARKETPLACE_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'MARKETPLACE_ID')
            self.MARKETPLACE_ID = ival_
            self.MARKETPLACE_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'MARKETPLACE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MARKETPLACE')
            value_ = self.gds_validate_string(value_, node, 'MARKETPLACE')
            self.MARKETPLACE = value_
            self.MARKETPLACE_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TYPE')
            ival_ = self.gds_validate_integer(ival_, node, 'TYPE')
            self.TYPE = ival_
            self.TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType20.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
# end class MARKETPLACEAPP


class MARKETPLACE_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, MARKETPLACE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if MARKETPLACE is None:
            self.MARKETPLACE = []
        else:
            self.MARKETPLACE = MARKETPLACE
        self.MARKETPLACE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MARKETPLACE_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MARKETPLACE_POOL.subclass:
            return MARKETPLACE_POOL.subclass(*args_, **kwargs_)
        else:
            return MARKETPLACE_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MARKETPLACE(self):
        return self.MARKETPLACE
    def set_MARKETPLACE(self, MARKETPLACE):
        self.MARKETPLACE = MARKETPLACE
    def add_MARKETPLACE(self, value):
        self.MARKETPLACE.append(value)
    def insert_MARKETPLACE_at(self, index, value):
        self.MARKETPLACE.insert(index, value)
    def replace_MARKETPLACE_at(self, index, value):
        self.MARKETPLACE[index] = value
    def has__content(self):
        if (
            self.MARKETPLACE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKETPLACE_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MARKETPLACE_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MARKETPLACE_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MARKETPLACE_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MARKETPLACE_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MARKETPLACE_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKETPLACE_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MARKETPLACE_ in self.MARKETPLACE:
            namespaceprefix_ = self.MARKETPLACE_nsprefix_ + ':' if (UseCapturedNS_ and self.MARKETPLACE_nsprefix_) else ''
            MARKETPLACE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MARKETPLACE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MARKETPLACE':
            obj_ = MARKETPLACE.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MARKETPLACE.append(obj_)
            obj_.original_tagname_ = 'MARKETPLACE'
# end class MARKETPLACE_POOL


class MARKETPLACE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, STATE=None, MARKET_MAD=None, ZONE_ID=None, TOTAL_MB=None, FREE_MB=None, USED_MB=None, MARKETPLACEAPPS=None, PERMISSIONS=None, TEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.MARKET_MAD = MARKET_MAD
        self.MARKET_MAD_nsprefix_ = None
        self.ZONE_ID = ZONE_ID
        self.ZONE_ID_nsprefix_ = None
        self.TOTAL_MB = TOTAL_MB
        self.TOTAL_MB_nsprefix_ = None
        self.FREE_MB = FREE_MB
        self.FREE_MB_nsprefix_ = None
        self.USED_MB = USED_MB
        self.USED_MB_nsprefix_ = None
        self.MARKETPLACEAPPS = MARKETPLACEAPPS
        self.MARKETPLACEAPPS_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MARKETPLACE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MARKETPLACE.subclass:
            return MARKETPLACE.subclass(*args_, **kwargs_)
        else:
            return MARKETPLACE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_MARKET_MAD(self):
        return self.MARKET_MAD
    def set_MARKET_MAD(self, MARKET_MAD):
        self.MARKET_MAD = MARKET_MAD
    def get_ZONE_ID(self):
        return self.ZONE_ID
    def set_ZONE_ID(self, ZONE_ID):
        self.ZONE_ID = ZONE_ID
    def get_TOTAL_MB(self):
        return self.TOTAL_MB
    def set_TOTAL_MB(self, TOTAL_MB):
        self.TOTAL_MB = TOTAL_MB
    def get_FREE_MB(self):
        return self.FREE_MB
    def set_FREE_MB(self, FREE_MB):
        self.FREE_MB = FREE_MB
    def get_USED_MB(self):
        return self.USED_MB
    def set_USED_MB(self, USED_MB):
        self.USED_MB = USED_MB
    def get_MARKETPLACEAPPS(self):
        return self.MARKETPLACEAPPS
    def set_MARKETPLACEAPPS(self, MARKETPLACEAPPS):
        self.MARKETPLACEAPPS = MARKETPLACEAPPS
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.STATE is not None or
            self.MARKET_MAD is not None or
            self.ZONE_ID is not None or
            self.TOTAL_MB is not None or
            self.FREE_MB is not None or
            self.USED_MB is not None or
            self.MARKETPLACEAPPS is not None or
            self.PERMISSIONS is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKETPLACE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MARKETPLACE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MARKETPLACE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MARKETPLACE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MARKETPLACE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MARKETPLACE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKETPLACE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.MARKET_MAD is not None:
            namespaceprefix_ = self.MARKET_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.MARKET_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMARKET_MAD>%s</%sMARKET_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MARKET_MAD), input_name='MARKET_MAD')), namespaceprefix_ , eol_))
        if self.ZONE_ID is not None:
            namespaceprefix_ = self.ZONE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ZONE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZONE_ID>%s</%sZONE_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ZONE_ID), input_name='ZONE_ID')), namespaceprefix_ , eol_))
        if self.TOTAL_MB is not None:
            namespaceprefix_ = self.TOTAL_MB_nsprefix_ + ':' if (UseCapturedNS_ and self.TOTAL_MB_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTOTAL_MB>%s</%sTOTAL_MB>%s' % (namespaceprefix_ , self.gds_format_integer(self.TOTAL_MB, input_name='TOTAL_MB'), namespaceprefix_ , eol_))
        if self.FREE_MB is not None:
            namespaceprefix_ = self.FREE_MB_nsprefix_ + ':' if (UseCapturedNS_ and self.FREE_MB_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFREE_MB>%s</%sFREE_MB>%s' % (namespaceprefix_ , self.gds_format_integer(self.FREE_MB, input_name='FREE_MB'), namespaceprefix_ , eol_))
        if self.USED_MB is not None:
            namespaceprefix_ = self.USED_MB_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_MB_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED_MB>%s</%sUSED_MB>%s' % (namespaceprefix_ , self.gds_format_integer(self.USED_MB, input_name='USED_MB'), namespaceprefix_ , eol_))
        if self.MARKETPLACEAPPS is not None:
            namespaceprefix_ = self.MARKETPLACEAPPS_nsprefix_ + ':' if (UseCapturedNS_ and self.MARKETPLACEAPPS_nsprefix_) else ''
            self.MARKETPLACEAPPS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MARKETPLACEAPPS', pretty_print=pretty_print)
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'MARKET_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MARKET_MAD')
            value_ = self.gds_validate_string(value_, node, 'MARKET_MAD')
            self.MARKET_MAD = value_
            self.MARKET_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'ZONE_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ZONE_ID')
            value_ = self.gds_validate_string(value_, node, 'ZONE_ID')
            self.ZONE_ID = value_
            self.ZONE_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'TOTAL_MB' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TOTAL_MB')
            ival_ = self.gds_validate_integer(ival_, node, 'TOTAL_MB')
            self.TOTAL_MB = ival_
            self.TOTAL_MB_nsprefix_ = child_.prefix
        elif nodeName_ == 'FREE_MB' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'FREE_MB')
            ival_ = self.gds_validate_integer(ival_, node, 'FREE_MB')
            self.FREE_MB = ival_
            self.FREE_MB_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED_MB' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'USED_MB')
            ival_ = self.gds_validate_integer(ival_, node, 'USED_MB')
            self.USED_MB = ival_
            self.USED_MB_nsprefix_ = child_.prefix
        elif nodeName_ == 'MARKETPLACEAPPS':
            obj_ = MARKETPLACEAPPSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MARKETPLACEAPPS = obj_
            obj_.original_tagname_ = 'MARKETPLACEAPPS'
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType21.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
# end class MARKETPLACE


class MONITORING_DATA(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, MONITORING=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if MONITORING is None:
            self.MONITORING = []
        else:
            self.MONITORING = MONITORING
        self.MONITORING_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MONITORING_DATA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MONITORING_DATA.subclass:
            return MONITORING_DATA.subclass(*args_, **kwargs_)
        else:
            return MONITORING_DATA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MONITORING(self):
        return self.MONITORING
    def set_MONITORING(self, MONITORING):
        self.MONITORING = MONITORING
    def add_MONITORING(self, value):
        self.MONITORING.append(value)
    def insert_MONITORING_at(self, index, value):
        self.MONITORING.insert(index, value)
    def replace_MONITORING_at(self, index, value):
        self.MONITORING[index] = value
    def has__content(self):
        if (
            self.MONITORING
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MONITORING_DATA', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MONITORING_DATA')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MONITORING_DATA':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MONITORING_DATA')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MONITORING_DATA', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MONITORING_DATA'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MONITORING_DATA', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MONITORING_ in self.MONITORING:
            namespaceprefix_ = self.MONITORING_nsprefix_ + ':' if (UseCapturedNS_ and self.MONITORING_nsprefix_) else ''
            MONITORING_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MONITORING', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MONITORING':
            obj_ = MONITORINGType22.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MONITORING.append(obj_)
            obj_.original_tagname_ = 'MONITORING'
# end class MONITORING_DATA


class OPENNEBULA_CONFIGURATION(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ACTION_TIMEOUT=None, API_LIST_ORDER=None, AUTH_MAD=None, AUTH_MAD_CONF=None, CLUSTER_ENCRYPTED_ATTR=None, COLD_MIGRATE_MODE=None, CONTEXT_ALLOW_ETH_UPDATES=None, CONTEXT_RESTRICTED_DIRS=None, CONTEXT_SAFE_DIRS=None, DATASTORE_CAPACITY_CHECK=None, DATASTORE_ENCRYPTED_ATTR=None, DATASTORE_LOCATION=None, DATASTORE_MAD=None, DB=None, DEFAULT_AUTH=None, DEFAULT_CDROM_DEVICE_PREFIX=None, DEFAULT_COST=None, DEFAULT_DEVICE_PREFIX=None, DEFAULT_IMAGE_PERSISTENT=None, DEFAULT_IMAGE_PERSISTENT_NEW=None, DEFAULT_IMAGE_TYPE=None, DEFAULT_UMASK=None, DEFAULT_VDC_CLUSTER_DATASTORE_ACL=None, DEFAULT_VDC_CLUSTER_HOST_ACL=None, DEFAULT_VDC_CLUSTER_NET_ACL=None, DEFAULT_VDC_DATASTORE_ACL=None, DEFAULT_VDC_HOST_ACL=None, DEFAULT_VDC_VNET_ACL=None, DOCUMENT_ENCRYPTED_ATTR=None, DRS_INTERVAL=None, DS_MAD_CONF=None, DS_MONITOR_VM_DISK=None, ENABLE_OTHER_PERMISSIONS=None, FEDERATION=None, GROUP_RESTRICTED_ATTR=None, HM_MAD=None, HOOK_LOG_CONF=None, HOST_ENCRYPTED_ATTR=None, IMAGE_ENCRYPTED_ATTR=None, IMAGE_RESTRICTED_ATTR=None, IM_MAD=None, INHERIT_DATASTORE_ATTR=None, INHERIT_IMAGE_ATTR=None, INHERIT_VNET_ATTR=None, IPAM_MAD=None, KEEPALIVE_MAX_CONN=None, KEEPALIVE_TIMEOUT=None, LISTEN_ADDRESS=None, LIVE_RESCHEDS=None, LOG=None, LOG_CALL_FORMAT=None, MAC_PREFIX=None, MANAGER_TIMER=None, MARKET_MAD=None, MARKET_MAD_CONF=None, MAX_ACTIONS_PER_CLUSTER=None, MAX_ACTIONS_PER_HOST=None, MAX_BACKUPS=None, MAX_BACKUPS_HOST=None, MAX_CONN=None, MAX_CONN_BACKLOG=None, MESSAGE_SIZE=None, MONITORING_INTERVAL_DATASTORE=None, MONITORING_INTERVAL_HOST=None, MONITORING_INTERVAL_MARKET=None, MONITORING_INTERVAL_VM=None, NETWORK_SIZE=None, ONE_KEY=None, PCI_PASSTHROUGH_BUS=None, PORT=None, RAFT=None, RPC_LOG=None, SCHED_MAD=None, SCHED_MAX_WND_LENGTH=None, SCHED_MAX_WND_TIME=None, SCHED_RETRY_TIME=None, SCRIPTS_REMOTE_DIR=None, SESSION_EXPIRATION_TIME=None, SHOWBACK_ONLY_RUNNING=None, TIMEOUT=None, TM_MAD=None, TM_MAD_CONF=None, USER_ENCRYPTED_ATTR=None, USER_RESTRICTED_ATTR=None, VLAN_IDS=None, VM_ADMIN_OPERATIONS=None, VM_ENCRYPTED_ATTR=None, VM_MAD=None, VM_MANAGE_OPERATIONS=None, VM_MONITORING_EXPIRATION_TIME=None, VM_RESTRICTED_ATTR=None, VM_SNAPSHOT_FACTOR=None, VM_SUBMIT_ON_HOLD=None, VM_USE_OPERATIONS=None, VNC_PORTS=None, VNET_ENCRYPTED_ATTR=None, VNET_RESTRICTED_ATTR=None, VN_MAD_CONF=None, VXLAN_IDS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ACTION_TIMEOUT = ACTION_TIMEOUT
        self.ACTION_TIMEOUT_nsprefix_ = None
        if API_LIST_ORDER is None:
            self.API_LIST_ORDER = []
        else:
            self.API_LIST_ORDER = API_LIST_ORDER
        self.API_LIST_ORDER_nsprefix_ = None
        if AUTH_MAD is None:
            self.AUTH_MAD = []
        else:
            self.AUTH_MAD = AUTH_MAD
        self.AUTH_MAD_nsprefix_ = None
        if AUTH_MAD_CONF is None:
            self.AUTH_MAD_CONF = []
        else:
            self.AUTH_MAD_CONF = AUTH_MAD_CONF
        self.AUTH_MAD_CONF_nsprefix_ = None
        if CLUSTER_ENCRYPTED_ATTR is None:
            self.CLUSTER_ENCRYPTED_ATTR = []
        else:
            self.CLUSTER_ENCRYPTED_ATTR = CLUSTER_ENCRYPTED_ATTR
        self.CLUSTER_ENCRYPTED_ATTR_nsprefix_ = None
        self.COLD_MIGRATE_MODE = COLD_MIGRATE_MODE
        self.COLD_MIGRATE_MODE_nsprefix_ = None
        self.CONTEXT_ALLOW_ETH_UPDATES = CONTEXT_ALLOW_ETH_UPDATES
        self.CONTEXT_ALLOW_ETH_UPDATES_nsprefix_ = None
        self.CONTEXT_RESTRICTED_DIRS = CONTEXT_RESTRICTED_DIRS
        self.CONTEXT_RESTRICTED_DIRS_nsprefix_ = None
        self.CONTEXT_SAFE_DIRS = CONTEXT_SAFE_DIRS
        self.CONTEXT_SAFE_DIRS_nsprefix_ = None
        if DATASTORE_CAPACITY_CHECK is None:
            self.DATASTORE_CAPACITY_CHECK = []
        else:
            self.DATASTORE_CAPACITY_CHECK = DATASTORE_CAPACITY_CHECK
        self.DATASTORE_CAPACITY_CHECK_nsprefix_ = None
        if DATASTORE_ENCRYPTED_ATTR is None:
            self.DATASTORE_ENCRYPTED_ATTR = []
        else:
            self.DATASTORE_ENCRYPTED_ATTR = DATASTORE_ENCRYPTED_ATTR
        self.DATASTORE_ENCRYPTED_ATTR_nsprefix_ = None
        if DATASTORE_LOCATION is None:
            self.DATASTORE_LOCATION = []
        else:
            self.DATASTORE_LOCATION = DATASTORE_LOCATION
        self.DATASTORE_LOCATION_nsprefix_ = None
        if DATASTORE_MAD is None:
            self.DATASTORE_MAD = []
        else:
            self.DATASTORE_MAD = DATASTORE_MAD
        self.DATASTORE_MAD_nsprefix_ = None
        self.DB = DB
        self.DB_nsprefix_ = None
        if DEFAULT_AUTH is None:
            self.DEFAULT_AUTH = []
        else:
            self.DEFAULT_AUTH = DEFAULT_AUTH
        self.DEFAULT_AUTH_nsprefix_ = None
        if DEFAULT_CDROM_DEVICE_PREFIX is None:
            self.DEFAULT_CDROM_DEVICE_PREFIX = []
        else:
            self.DEFAULT_CDROM_DEVICE_PREFIX = DEFAULT_CDROM_DEVICE_PREFIX
        self.DEFAULT_CDROM_DEVICE_PREFIX_nsprefix_ = None
        if DEFAULT_COST is None:
            self.DEFAULT_COST = []
        else:
            self.DEFAULT_COST = DEFAULT_COST
        self.DEFAULT_COST_nsprefix_ = None
        if DEFAULT_DEVICE_PREFIX is None:
            self.DEFAULT_DEVICE_PREFIX = []
        else:
            self.DEFAULT_DEVICE_PREFIX = DEFAULT_DEVICE_PREFIX
        self.DEFAULT_DEVICE_PREFIX_nsprefix_ = None
        if DEFAULT_IMAGE_PERSISTENT is None:
            self.DEFAULT_IMAGE_PERSISTENT = []
        else:
            self.DEFAULT_IMAGE_PERSISTENT = DEFAULT_IMAGE_PERSISTENT
        self.DEFAULT_IMAGE_PERSISTENT_nsprefix_ = None
        if DEFAULT_IMAGE_PERSISTENT_NEW is None:
            self.DEFAULT_IMAGE_PERSISTENT_NEW = []
        else:
            self.DEFAULT_IMAGE_PERSISTENT_NEW = DEFAULT_IMAGE_PERSISTENT_NEW
        self.DEFAULT_IMAGE_PERSISTENT_NEW_nsprefix_ = None
        if DEFAULT_IMAGE_TYPE is None:
            self.DEFAULT_IMAGE_TYPE = []
        else:
            self.DEFAULT_IMAGE_TYPE = DEFAULT_IMAGE_TYPE
        self.DEFAULT_IMAGE_TYPE_nsprefix_ = None
        if DEFAULT_UMASK is None:
            self.DEFAULT_UMASK = []
        else:
            self.DEFAULT_UMASK = DEFAULT_UMASK
        self.DEFAULT_UMASK_nsprefix_ = None
        if DEFAULT_VDC_CLUSTER_DATASTORE_ACL is None:
            self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL = []
        else:
            self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL = DEFAULT_VDC_CLUSTER_DATASTORE_ACL
        self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL_nsprefix_ = None
        if DEFAULT_VDC_CLUSTER_HOST_ACL is None:
            self.DEFAULT_VDC_CLUSTER_HOST_ACL = []
        else:
            self.DEFAULT_VDC_CLUSTER_HOST_ACL = DEFAULT_VDC_CLUSTER_HOST_ACL
        self.DEFAULT_VDC_CLUSTER_HOST_ACL_nsprefix_ = None
        if DEFAULT_VDC_CLUSTER_NET_ACL is None:
            self.DEFAULT_VDC_CLUSTER_NET_ACL = []
        else:
            self.DEFAULT_VDC_CLUSTER_NET_ACL = DEFAULT_VDC_CLUSTER_NET_ACL
        self.DEFAULT_VDC_CLUSTER_NET_ACL_nsprefix_ = None
        if DEFAULT_VDC_DATASTORE_ACL is None:
            self.DEFAULT_VDC_DATASTORE_ACL = []
        else:
            self.DEFAULT_VDC_DATASTORE_ACL = DEFAULT_VDC_DATASTORE_ACL
        self.DEFAULT_VDC_DATASTORE_ACL_nsprefix_ = None
        if DEFAULT_VDC_HOST_ACL is None:
            self.DEFAULT_VDC_HOST_ACL = []
        else:
            self.DEFAULT_VDC_HOST_ACL = DEFAULT_VDC_HOST_ACL
        self.DEFAULT_VDC_HOST_ACL_nsprefix_ = None
        if DEFAULT_VDC_VNET_ACL is None:
            self.DEFAULT_VDC_VNET_ACL = []
        else:
            self.DEFAULT_VDC_VNET_ACL = DEFAULT_VDC_VNET_ACL
        self.DEFAULT_VDC_VNET_ACL_nsprefix_ = None
        if DOCUMENT_ENCRYPTED_ATTR is None:
            self.DOCUMENT_ENCRYPTED_ATTR = []
        else:
            self.DOCUMENT_ENCRYPTED_ATTR = DOCUMENT_ENCRYPTED_ATTR
        self.DOCUMENT_ENCRYPTED_ATTR_nsprefix_ = None
        self.DRS_INTERVAL = DRS_INTERVAL
        self.DRS_INTERVAL_nsprefix_ = None
        if DS_MAD_CONF is None:
            self.DS_MAD_CONF = []
        else:
            self.DS_MAD_CONF = DS_MAD_CONF
        self.DS_MAD_CONF_nsprefix_ = None
        self.DS_MONITOR_VM_DISK = DS_MONITOR_VM_DISK
        self.DS_MONITOR_VM_DISK_nsprefix_ = None
        self.ENABLE_OTHER_PERMISSIONS = ENABLE_OTHER_PERMISSIONS
        self.validate_ENABLE_OTHER_PERMISSIONSType(self.ENABLE_OTHER_PERMISSIONS)
        self.ENABLE_OTHER_PERMISSIONS_nsprefix_ = None
        self.FEDERATION = FEDERATION
        self.FEDERATION_nsprefix_ = None
        if GROUP_RESTRICTED_ATTR is None:
            self.GROUP_RESTRICTED_ATTR = []
        else:
            self.GROUP_RESTRICTED_ATTR = GROUP_RESTRICTED_ATTR
        self.GROUP_RESTRICTED_ATTR_nsprefix_ = None
        self.HM_MAD = HM_MAD
        self.HM_MAD_nsprefix_ = None
        self.HOOK_LOG_CONF = HOOK_LOG_CONF
        self.HOOK_LOG_CONF_nsprefix_ = None
        if HOST_ENCRYPTED_ATTR is None:
            self.HOST_ENCRYPTED_ATTR = []
        else:
            self.HOST_ENCRYPTED_ATTR = HOST_ENCRYPTED_ATTR
        self.HOST_ENCRYPTED_ATTR_nsprefix_ = None
        if IMAGE_ENCRYPTED_ATTR is None:
            self.IMAGE_ENCRYPTED_ATTR = []
        else:
            self.IMAGE_ENCRYPTED_ATTR = IMAGE_ENCRYPTED_ATTR
        self.IMAGE_ENCRYPTED_ATTR_nsprefix_ = None
        if IMAGE_RESTRICTED_ATTR is None:
            self.IMAGE_RESTRICTED_ATTR = []
        else:
            self.IMAGE_RESTRICTED_ATTR = IMAGE_RESTRICTED_ATTR
        self.IMAGE_RESTRICTED_ATTR_nsprefix_ = None
        if IM_MAD is None:
            self.IM_MAD = []
        else:
            self.IM_MAD = IM_MAD
        self.IM_MAD_nsprefix_ = None
        if INHERIT_DATASTORE_ATTR is None:
            self.INHERIT_DATASTORE_ATTR = []
        else:
            self.INHERIT_DATASTORE_ATTR = INHERIT_DATASTORE_ATTR
        self.INHERIT_DATASTORE_ATTR_nsprefix_ = None
        if INHERIT_IMAGE_ATTR is None:
            self.INHERIT_IMAGE_ATTR = []
        else:
            self.INHERIT_IMAGE_ATTR = INHERIT_IMAGE_ATTR
        self.INHERIT_IMAGE_ATTR_nsprefix_ = None
        if INHERIT_VNET_ATTR is None:
            self.INHERIT_VNET_ATTR = []
        else:
            self.INHERIT_VNET_ATTR = INHERIT_VNET_ATTR
        self.INHERIT_VNET_ATTR_nsprefix_ = None
        if IPAM_MAD is None:
            self.IPAM_MAD = []
        else:
            self.IPAM_MAD = IPAM_MAD
        self.IPAM_MAD_nsprefix_ = None
        if KEEPALIVE_MAX_CONN is None:
            self.KEEPALIVE_MAX_CONN = []
        else:
            self.KEEPALIVE_MAX_CONN = KEEPALIVE_MAX_CONN
        self.KEEPALIVE_MAX_CONN_nsprefix_ = None
        if KEEPALIVE_TIMEOUT is None:
            self.KEEPALIVE_TIMEOUT = []
        else:
            self.KEEPALIVE_TIMEOUT = KEEPALIVE_TIMEOUT
        self.KEEPALIVE_TIMEOUT_nsprefix_ = None
        if LISTEN_ADDRESS is None:
            self.LISTEN_ADDRESS = []
        else:
            self.LISTEN_ADDRESS = LISTEN_ADDRESS
        self.LISTEN_ADDRESS_nsprefix_ = None
        self.LIVE_RESCHEDS = LIVE_RESCHEDS
        self.LIVE_RESCHEDS_nsprefix_ = None
        if LOG is None:
            self.LOG = []
        else:
            self.LOG = LOG
        self.LOG_nsprefix_ = None
        if LOG_CALL_FORMAT is None:
            self.LOG_CALL_FORMAT = []
        else:
            self.LOG_CALL_FORMAT = LOG_CALL_FORMAT
        self.LOG_CALL_FORMAT_nsprefix_ = None
        if MAC_PREFIX is None:
            self.MAC_PREFIX = []
        else:
            self.MAC_PREFIX = MAC_PREFIX
        self.MAC_PREFIX_nsprefix_ = None
        if MANAGER_TIMER is None:
            self.MANAGER_TIMER = []
        else:
            self.MANAGER_TIMER = MANAGER_TIMER
        self.MANAGER_TIMER_nsprefix_ = None
        if MARKET_MAD is None:
            self.MARKET_MAD = []
        else:
            self.MARKET_MAD = MARKET_MAD
        self.MARKET_MAD_nsprefix_ = None
        if MARKET_MAD_CONF is None:
            self.MARKET_MAD_CONF = []
        else:
            self.MARKET_MAD_CONF = MARKET_MAD_CONF
        self.MARKET_MAD_CONF_nsprefix_ = None
        self.MAX_ACTIONS_PER_CLUSTER = MAX_ACTIONS_PER_CLUSTER
        self.MAX_ACTIONS_PER_CLUSTER_nsprefix_ = None
        self.MAX_ACTIONS_PER_HOST = MAX_ACTIONS_PER_HOST
        self.MAX_ACTIONS_PER_HOST_nsprefix_ = None
        self.MAX_BACKUPS = MAX_BACKUPS
        self.MAX_BACKUPS_nsprefix_ = None
        self.MAX_BACKUPS_HOST = MAX_BACKUPS_HOST
        self.MAX_BACKUPS_HOST_nsprefix_ = None
        self.MAX_CONN = MAX_CONN
        self.MAX_CONN_nsprefix_ = None
        self.MAX_CONN_BACKLOG = MAX_CONN_BACKLOG
        self.MAX_CONN_BACKLOG_nsprefix_ = None
        self.MESSAGE_SIZE = MESSAGE_SIZE
        self.MESSAGE_SIZE_nsprefix_ = None
        self.MONITORING_INTERVAL_DATASTORE = MONITORING_INTERVAL_DATASTORE
        self.MONITORING_INTERVAL_DATASTORE_nsprefix_ = None
        self.MONITORING_INTERVAL_HOST = MONITORING_INTERVAL_HOST
        self.MONITORING_INTERVAL_HOST_nsprefix_ = None
        self.MONITORING_INTERVAL_MARKET = MONITORING_INTERVAL_MARKET
        self.MONITORING_INTERVAL_MARKET_nsprefix_ = None
        self.MONITORING_INTERVAL_VM = MONITORING_INTERVAL_VM
        self.MONITORING_INTERVAL_VM_nsprefix_ = None
        self.NETWORK_SIZE = NETWORK_SIZE
        self.NETWORK_SIZE_nsprefix_ = None
        if ONE_KEY is None:
            self.ONE_KEY = []
        else:
            self.ONE_KEY = ONE_KEY
        self.ONE_KEY_nsprefix_ = None
        self.PCI_PASSTHROUGH_BUS = PCI_PASSTHROUGH_BUS
        self.PCI_PASSTHROUGH_BUS_nsprefix_ = None
        self.PORT = PORT
        self.PORT_nsprefix_ = None
        self.RAFT = RAFT
        self.RAFT_nsprefix_ = None
        self.RPC_LOG = RPC_LOG
        self.RPC_LOG_nsprefix_ = None
        self.SCHED_MAD = SCHED_MAD
        self.SCHED_MAD_nsprefix_ = None
        self.SCHED_MAX_WND_LENGTH = SCHED_MAX_WND_LENGTH
        self.SCHED_MAX_WND_LENGTH_nsprefix_ = None
        self.SCHED_MAX_WND_TIME = SCHED_MAX_WND_TIME
        self.SCHED_MAX_WND_TIME_nsprefix_ = None
        self.SCHED_RETRY_TIME = SCHED_RETRY_TIME
        self.SCHED_RETRY_TIME_nsprefix_ = None
        self.SCRIPTS_REMOTE_DIR = SCRIPTS_REMOTE_DIR
        self.SCRIPTS_REMOTE_DIR_nsprefix_ = None
        self.SESSION_EXPIRATION_TIME = SESSION_EXPIRATION_TIME
        self.SESSION_EXPIRATION_TIME_nsprefix_ = None
        self.SHOWBACK_ONLY_RUNNING = SHOWBACK_ONLY_RUNNING
        self.SHOWBACK_ONLY_RUNNING_nsprefix_ = None
        self.TIMEOUT = TIMEOUT
        self.TIMEOUT_nsprefix_ = None
        if TM_MAD is None:
            self.TM_MAD = []
        else:
            self.TM_MAD = TM_MAD
        self.TM_MAD_nsprefix_ = None
        if TM_MAD_CONF is None:
            self.TM_MAD_CONF = []
        else:
            self.TM_MAD_CONF = TM_MAD_CONF
        self.TM_MAD_CONF_nsprefix_ = None
        if USER_ENCRYPTED_ATTR is None:
            self.USER_ENCRYPTED_ATTR = []
        else:
            self.USER_ENCRYPTED_ATTR = USER_ENCRYPTED_ATTR
        self.USER_ENCRYPTED_ATTR_nsprefix_ = None
        if USER_RESTRICTED_ATTR is None:
            self.USER_RESTRICTED_ATTR = []
        else:
            self.USER_RESTRICTED_ATTR = USER_RESTRICTED_ATTR
        self.USER_RESTRICTED_ATTR_nsprefix_ = None
        self.VLAN_IDS = VLAN_IDS
        self.VLAN_IDS_nsprefix_ = None
        self.VM_ADMIN_OPERATIONS = VM_ADMIN_OPERATIONS
        self.VM_ADMIN_OPERATIONS_nsprefix_ = None
        if VM_ENCRYPTED_ATTR is None:
            self.VM_ENCRYPTED_ATTR = []
        else:
            self.VM_ENCRYPTED_ATTR = VM_ENCRYPTED_ATTR
        self.VM_ENCRYPTED_ATTR_nsprefix_ = None
        if VM_MAD is None:
            self.VM_MAD = []
        else:
            self.VM_MAD = VM_MAD
        self.VM_MAD_nsprefix_ = None
        self.VM_MANAGE_OPERATIONS = VM_MANAGE_OPERATIONS
        self.VM_MANAGE_OPERATIONS_nsprefix_ = None
        if VM_MONITORING_EXPIRATION_TIME is None:
            self.VM_MONITORING_EXPIRATION_TIME = []
        else:
            self.VM_MONITORING_EXPIRATION_TIME = VM_MONITORING_EXPIRATION_TIME
        self.VM_MONITORING_EXPIRATION_TIME_nsprefix_ = None
        if VM_RESTRICTED_ATTR is None:
            self.VM_RESTRICTED_ATTR = []
        else:
            self.VM_RESTRICTED_ATTR = VM_RESTRICTED_ATTR
        self.VM_RESTRICTED_ATTR_nsprefix_ = None
        self.VM_SNAPSHOT_FACTOR = VM_SNAPSHOT_FACTOR
        self.VM_SNAPSHOT_FACTOR_nsprefix_ = None
        self.VM_SUBMIT_ON_HOLD = VM_SUBMIT_ON_HOLD
        self.validate_VM_SUBMIT_ON_HOLDType(self.VM_SUBMIT_ON_HOLD)
        self.VM_SUBMIT_ON_HOLD_nsprefix_ = None
        if VM_USE_OPERATIONS is None:
            self.VM_USE_OPERATIONS = []
        else:
            self.VM_USE_OPERATIONS = VM_USE_OPERATIONS
        self.VM_USE_OPERATIONS_nsprefix_ = None
        self.VNC_PORTS = VNC_PORTS
        self.VNC_PORTS_nsprefix_ = None
        if VNET_ENCRYPTED_ATTR is None:
            self.VNET_ENCRYPTED_ATTR = []
        else:
            self.VNET_ENCRYPTED_ATTR = VNET_ENCRYPTED_ATTR
        self.VNET_ENCRYPTED_ATTR_nsprefix_ = None
        if VNET_RESTRICTED_ATTR is None:
            self.VNET_RESTRICTED_ATTR = []
        else:
            self.VNET_RESTRICTED_ATTR = VNET_RESTRICTED_ATTR
        self.VNET_RESTRICTED_ATTR_nsprefix_ = None
        if VN_MAD_CONF is None:
            self.VN_MAD_CONF = []
        else:
            self.VN_MAD_CONF = VN_MAD_CONF
        self.VN_MAD_CONF_nsprefix_ = None
        self.VXLAN_IDS = VXLAN_IDS
        self.VXLAN_IDS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPENNEBULA_CONFIGURATION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPENNEBULA_CONFIGURATION.subclass:
            return OPENNEBULA_CONFIGURATION.subclass(*args_, **kwargs_)
        else:
            return OPENNEBULA_CONFIGURATION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ACTION_TIMEOUT(self):
        return self.ACTION_TIMEOUT
    def set_ACTION_TIMEOUT(self, ACTION_TIMEOUT):
        self.ACTION_TIMEOUT = ACTION_TIMEOUT
    def get_API_LIST_ORDER(self):
        return self.API_LIST_ORDER
    def set_API_LIST_ORDER(self, API_LIST_ORDER):
        self.API_LIST_ORDER = API_LIST_ORDER
    def add_API_LIST_ORDER(self, value):
        self.API_LIST_ORDER.append(value)
    def insert_API_LIST_ORDER_at(self, index, value):
        self.API_LIST_ORDER.insert(index, value)
    def replace_API_LIST_ORDER_at(self, index, value):
        self.API_LIST_ORDER[index] = value
    def get_AUTH_MAD(self):
        return self.AUTH_MAD
    def set_AUTH_MAD(self, AUTH_MAD):
        self.AUTH_MAD = AUTH_MAD
    def add_AUTH_MAD(self, value):
        self.AUTH_MAD.append(value)
    def insert_AUTH_MAD_at(self, index, value):
        self.AUTH_MAD.insert(index, value)
    def replace_AUTH_MAD_at(self, index, value):
        self.AUTH_MAD[index] = value
    def get_AUTH_MAD_CONF(self):
        return self.AUTH_MAD_CONF
    def set_AUTH_MAD_CONF(self, AUTH_MAD_CONF):
        self.AUTH_MAD_CONF = AUTH_MAD_CONF
    def add_AUTH_MAD_CONF(self, value):
        self.AUTH_MAD_CONF.append(value)
    def insert_AUTH_MAD_CONF_at(self, index, value):
        self.AUTH_MAD_CONF.insert(index, value)
    def replace_AUTH_MAD_CONF_at(self, index, value):
        self.AUTH_MAD_CONF[index] = value
    def get_CLUSTER_ENCRYPTED_ATTR(self):
        return self.CLUSTER_ENCRYPTED_ATTR
    def set_CLUSTER_ENCRYPTED_ATTR(self, CLUSTER_ENCRYPTED_ATTR):
        self.CLUSTER_ENCRYPTED_ATTR = CLUSTER_ENCRYPTED_ATTR
    def add_CLUSTER_ENCRYPTED_ATTR(self, value):
        self.CLUSTER_ENCRYPTED_ATTR.append(value)
    def insert_CLUSTER_ENCRYPTED_ATTR_at(self, index, value):
        self.CLUSTER_ENCRYPTED_ATTR.insert(index, value)
    def replace_CLUSTER_ENCRYPTED_ATTR_at(self, index, value):
        self.CLUSTER_ENCRYPTED_ATTR[index] = value
    def get_COLD_MIGRATE_MODE(self):
        return self.COLD_MIGRATE_MODE
    def set_COLD_MIGRATE_MODE(self, COLD_MIGRATE_MODE):
        self.COLD_MIGRATE_MODE = COLD_MIGRATE_MODE
    def get_CONTEXT_ALLOW_ETH_UPDATES(self):
        return self.CONTEXT_ALLOW_ETH_UPDATES
    def set_CONTEXT_ALLOW_ETH_UPDATES(self, CONTEXT_ALLOW_ETH_UPDATES):
        self.CONTEXT_ALLOW_ETH_UPDATES = CONTEXT_ALLOW_ETH_UPDATES
    def get_CONTEXT_RESTRICTED_DIRS(self):
        return self.CONTEXT_RESTRICTED_DIRS
    def set_CONTEXT_RESTRICTED_DIRS(self, CONTEXT_RESTRICTED_DIRS):
        self.CONTEXT_RESTRICTED_DIRS = CONTEXT_RESTRICTED_DIRS
    def get_CONTEXT_SAFE_DIRS(self):
        return self.CONTEXT_SAFE_DIRS
    def set_CONTEXT_SAFE_DIRS(self, CONTEXT_SAFE_DIRS):
        self.CONTEXT_SAFE_DIRS = CONTEXT_SAFE_DIRS
    def get_DATASTORE_CAPACITY_CHECK(self):
        return self.DATASTORE_CAPACITY_CHECK
    def set_DATASTORE_CAPACITY_CHECK(self, DATASTORE_CAPACITY_CHECK):
        self.DATASTORE_CAPACITY_CHECK = DATASTORE_CAPACITY_CHECK
    def add_DATASTORE_CAPACITY_CHECK(self, value):
        self.DATASTORE_CAPACITY_CHECK.append(value)
    def insert_DATASTORE_CAPACITY_CHECK_at(self, index, value):
        self.DATASTORE_CAPACITY_CHECK.insert(index, value)
    def replace_DATASTORE_CAPACITY_CHECK_at(self, index, value):
        self.DATASTORE_CAPACITY_CHECK[index] = value
    def get_DATASTORE_ENCRYPTED_ATTR(self):
        return self.DATASTORE_ENCRYPTED_ATTR
    def set_DATASTORE_ENCRYPTED_ATTR(self, DATASTORE_ENCRYPTED_ATTR):
        self.DATASTORE_ENCRYPTED_ATTR = DATASTORE_ENCRYPTED_ATTR
    def add_DATASTORE_ENCRYPTED_ATTR(self, value):
        self.DATASTORE_ENCRYPTED_ATTR.append(value)
    def insert_DATASTORE_ENCRYPTED_ATTR_at(self, index, value):
        self.DATASTORE_ENCRYPTED_ATTR.insert(index, value)
    def replace_DATASTORE_ENCRYPTED_ATTR_at(self, index, value):
        self.DATASTORE_ENCRYPTED_ATTR[index] = value
    def get_DATASTORE_LOCATION(self):
        return self.DATASTORE_LOCATION
    def set_DATASTORE_LOCATION(self, DATASTORE_LOCATION):
        self.DATASTORE_LOCATION = DATASTORE_LOCATION
    def add_DATASTORE_LOCATION(self, value):
        self.DATASTORE_LOCATION.append(value)
    def insert_DATASTORE_LOCATION_at(self, index, value):
        self.DATASTORE_LOCATION.insert(index, value)
    def replace_DATASTORE_LOCATION_at(self, index, value):
        self.DATASTORE_LOCATION[index] = value
    def get_DATASTORE_MAD(self):
        return self.DATASTORE_MAD
    def set_DATASTORE_MAD(self, DATASTORE_MAD):
        self.DATASTORE_MAD = DATASTORE_MAD
    def add_DATASTORE_MAD(self, value):
        self.DATASTORE_MAD.append(value)
    def insert_DATASTORE_MAD_at(self, index, value):
        self.DATASTORE_MAD.insert(index, value)
    def replace_DATASTORE_MAD_at(self, index, value):
        self.DATASTORE_MAD[index] = value
    def get_DB(self):
        return self.DB
    def set_DB(self, DB):
        self.DB = DB
    def get_DEFAULT_AUTH(self):
        return self.DEFAULT_AUTH
    def set_DEFAULT_AUTH(self, DEFAULT_AUTH):
        self.DEFAULT_AUTH = DEFAULT_AUTH
    def add_DEFAULT_AUTH(self, value):
        self.DEFAULT_AUTH.append(value)
    def insert_DEFAULT_AUTH_at(self, index, value):
        self.DEFAULT_AUTH.insert(index, value)
    def replace_DEFAULT_AUTH_at(self, index, value):
        self.DEFAULT_AUTH[index] = value
    def get_DEFAULT_CDROM_DEVICE_PREFIX(self):
        return self.DEFAULT_CDROM_DEVICE_PREFIX
    def set_DEFAULT_CDROM_DEVICE_PREFIX(self, DEFAULT_CDROM_DEVICE_PREFIX):
        self.DEFAULT_CDROM_DEVICE_PREFIX = DEFAULT_CDROM_DEVICE_PREFIX
    def add_DEFAULT_CDROM_DEVICE_PREFIX(self, value):
        self.DEFAULT_CDROM_DEVICE_PREFIX.append(value)
    def insert_DEFAULT_CDROM_DEVICE_PREFIX_at(self, index, value):
        self.DEFAULT_CDROM_DEVICE_PREFIX.insert(index, value)
    def replace_DEFAULT_CDROM_DEVICE_PREFIX_at(self, index, value):
        self.DEFAULT_CDROM_DEVICE_PREFIX[index] = value
    def get_DEFAULT_COST(self):
        return self.DEFAULT_COST
    def set_DEFAULT_COST(self, DEFAULT_COST):
        self.DEFAULT_COST = DEFAULT_COST
    def add_DEFAULT_COST(self, value):
        self.DEFAULT_COST.append(value)
    def insert_DEFAULT_COST_at(self, index, value):
        self.DEFAULT_COST.insert(index, value)
    def replace_DEFAULT_COST_at(self, index, value):
        self.DEFAULT_COST[index] = value
    def get_DEFAULT_DEVICE_PREFIX(self):
        return self.DEFAULT_DEVICE_PREFIX
    def set_DEFAULT_DEVICE_PREFIX(self, DEFAULT_DEVICE_PREFIX):
        self.DEFAULT_DEVICE_PREFIX = DEFAULT_DEVICE_PREFIX
    def add_DEFAULT_DEVICE_PREFIX(self, value):
        self.DEFAULT_DEVICE_PREFIX.append(value)
    def insert_DEFAULT_DEVICE_PREFIX_at(self, index, value):
        self.DEFAULT_DEVICE_PREFIX.insert(index, value)
    def replace_DEFAULT_DEVICE_PREFIX_at(self, index, value):
        self.DEFAULT_DEVICE_PREFIX[index] = value
    def get_DEFAULT_IMAGE_PERSISTENT(self):
        return self.DEFAULT_IMAGE_PERSISTENT
    def set_DEFAULT_IMAGE_PERSISTENT(self, DEFAULT_IMAGE_PERSISTENT):
        self.DEFAULT_IMAGE_PERSISTENT = DEFAULT_IMAGE_PERSISTENT
    def add_DEFAULT_IMAGE_PERSISTENT(self, value):
        self.DEFAULT_IMAGE_PERSISTENT.append(value)
    def insert_DEFAULT_IMAGE_PERSISTENT_at(self, index, value):
        self.DEFAULT_IMAGE_PERSISTENT.insert(index, value)
    def replace_DEFAULT_IMAGE_PERSISTENT_at(self, index, value):
        self.DEFAULT_IMAGE_PERSISTENT[index] = value
    def get_DEFAULT_IMAGE_PERSISTENT_NEW(self):
        return self.DEFAULT_IMAGE_PERSISTENT_NEW
    def set_DEFAULT_IMAGE_PERSISTENT_NEW(self, DEFAULT_IMAGE_PERSISTENT_NEW):
        self.DEFAULT_IMAGE_PERSISTENT_NEW = DEFAULT_IMAGE_PERSISTENT_NEW
    def add_DEFAULT_IMAGE_PERSISTENT_NEW(self, value):
        self.DEFAULT_IMAGE_PERSISTENT_NEW.append(value)
    def insert_DEFAULT_IMAGE_PERSISTENT_NEW_at(self, index, value):
        self.DEFAULT_IMAGE_PERSISTENT_NEW.insert(index, value)
    def replace_DEFAULT_IMAGE_PERSISTENT_NEW_at(self, index, value):
        self.DEFAULT_IMAGE_PERSISTENT_NEW[index] = value
    def get_DEFAULT_IMAGE_TYPE(self):
        return self.DEFAULT_IMAGE_TYPE
    def set_DEFAULT_IMAGE_TYPE(self, DEFAULT_IMAGE_TYPE):
        self.DEFAULT_IMAGE_TYPE = DEFAULT_IMAGE_TYPE
    def add_DEFAULT_IMAGE_TYPE(self, value):
        self.DEFAULT_IMAGE_TYPE.append(value)
    def insert_DEFAULT_IMAGE_TYPE_at(self, index, value):
        self.DEFAULT_IMAGE_TYPE.insert(index, value)
    def replace_DEFAULT_IMAGE_TYPE_at(self, index, value):
        self.DEFAULT_IMAGE_TYPE[index] = value
    def get_DEFAULT_UMASK(self):
        return self.DEFAULT_UMASK
    def set_DEFAULT_UMASK(self, DEFAULT_UMASK):
        self.DEFAULT_UMASK = DEFAULT_UMASK
    def add_DEFAULT_UMASK(self, value):
        self.DEFAULT_UMASK.append(value)
    def insert_DEFAULT_UMASK_at(self, index, value):
        self.DEFAULT_UMASK.insert(index, value)
    def replace_DEFAULT_UMASK_at(self, index, value):
        self.DEFAULT_UMASK[index] = value
    def get_DEFAULT_VDC_CLUSTER_DATASTORE_ACL(self):
        return self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL
    def set_DEFAULT_VDC_CLUSTER_DATASTORE_ACL(self, DEFAULT_VDC_CLUSTER_DATASTORE_ACL):
        self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL = DEFAULT_VDC_CLUSTER_DATASTORE_ACL
    def add_DEFAULT_VDC_CLUSTER_DATASTORE_ACL(self, value):
        self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL.append(value)
    def insert_DEFAULT_VDC_CLUSTER_DATASTORE_ACL_at(self, index, value):
        self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL.insert(index, value)
    def replace_DEFAULT_VDC_CLUSTER_DATASTORE_ACL_at(self, index, value):
        self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL[index] = value
    def get_DEFAULT_VDC_CLUSTER_HOST_ACL(self):
        return self.DEFAULT_VDC_CLUSTER_HOST_ACL
    def set_DEFAULT_VDC_CLUSTER_HOST_ACL(self, DEFAULT_VDC_CLUSTER_HOST_ACL):
        self.DEFAULT_VDC_CLUSTER_HOST_ACL = DEFAULT_VDC_CLUSTER_HOST_ACL
    def add_DEFAULT_VDC_CLUSTER_HOST_ACL(self, value):
        self.DEFAULT_VDC_CLUSTER_HOST_ACL.append(value)
    def insert_DEFAULT_VDC_CLUSTER_HOST_ACL_at(self, index, value):
        self.DEFAULT_VDC_CLUSTER_HOST_ACL.insert(index, value)
    def replace_DEFAULT_VDC_CLUSTER_HOST_ACL_at(self, index, value):
        self.DEFAULT_VDC_CLUSTER_HOST_ACL[index] = value
    def get_DEFAULT_VDC_CLUSTER_NET_ACL(self):
        return self.DEFAULT_VDC_CLUSTER_NET_ACL
    def set_DEFAULT_VDC_CLUSTER_NET_ACL(self, DEFAULT_VDC_CLUSTER_NET_ACL):
        self.DEFAULT_VDC_CLUSTER_NET_ACL = DEFAULT_VDC_CLUSTER_NET_ACL
    def add_DEFAULT_VDC_CLUSTER_NET_ACL(self, value):
        self.DEFAULT_VDC_CLUSTER_NET_ACL.append(value)
    def insert_DEFAULT_VDC_CLUSTER_NET_ACL_at(self, index, value):
        self.DEFAULT_VDC_CLUSTER_NET_ACL.insert(index, value)
    def replace_DEFAULT_VDC_CLUSTER_NET_ACL_at(self, index, value):
        self.DEFAULT_VDC_CLUSTER_NET_ACL[index] = value
    def get_DEFAULT_VDC_DATASTORE_ACL(self):
        return self.DEFAULT_VDC_DATASTORE_ACL
    def set_DEFAULT_VDC_DATASTORE_ACL(self, DEFAULT_VDC_DATASTORE_ACL):
        self.DEFAULT_VDC_DATASTORE_ACL = DEFAULT_VDC_DATASTORE_ACL
    def add_DEFAULT_VDC_DATASTORE_ACL(self, value):
        self.DEFAULT_VDC_DATASTORE_ACL.append(value)
    def insert_DEFAULT_VDC_DATASTORE_ACL_at(self, index, value):
        self.DEFAULT_VDC_DATASTORE_ACL.insert(index, value)
    def replace_DEFAULT_VDC_DATASTORE_ACL_at(self, index, value):
        self.DEFAULT_VDC_DATASTORE_ACL[index] = value
    def get_DEFAULT_VDC_HOST_ACL(self):
        return self.DEFAULT_VDC_HOST_ACL
    def set_DEFAULT_VDC_HOST_ACL(self, DEFAULT_VDC_HOST_ACL):
        self.DEFAULT_VDC_HOST_ACL = DEFAULT_VDC_HOST_ACL
    def add_DEFAULT_VDC_HOST_ACL(self, value):
        self.DEFAULT_VDC_HOST_ACL.append(value)
    def insert_DEFAULT_VDC_HOST_ACL_at(self, index, value):
        self.DEFAULT_VDC_HOST_ACL.insert(index, value)
    def replace_DEFAULT_VDC_HOST_ACL_at(self, index, value):
        self.DEFAULT_VDC_HOST_ACL[index] = value
    def get_DEFAULT_VDC_VNET_ACL(self):
        return self.DEFAULT_VDC_VNET_ACL
    def set_DEFAULT_VDC_VNET_ACL(self, DEFAULT_VDC_VNET_ACL):
        self.DEFAULT_VDC_VNET_ACL = DEFAULT_VDC_VNET_ACL
    def add_DEFAULT_VDC_VNET_ACL(self, value):
        self.DEFAULT_VDC_VNET_ACL.append(value)
    def insert_DEFAULT_VDC_VNET_ACL_at(self, index, value):
        self.DEFAULT_VDC_VNET_ACL.insert(index, value)
    def replace_DEFAULT_VDC_VNET_ACL_at(self, index, value):
        self.DEFAULT_VDC_VNET_ACL[index] = value
    def get_DOCUMENT_ENCRYPTED_ATTR(self):
        return self.DOCUMENT_ENCRYPTED_ATTR
    def set_DOCUMENT_ENCRYPTED_ATTR(self, DOCUMENT_ENCRYPTED_ATTR):
        self.DOCUMENT_ENCRYPTED_ATTR = DOCUMENT_ENCRYPTED_ATTR
    def add_DOCUMENT_ENCRYPTED_ATTR(self, value):
        self.DOCUMENT_ENCRYPTED_ATTR.append(value)
    def insert_DOCUMENT_ENCRYPTED_ATTR_at(self, index, value):
        self.DOCUMENT_ENCRYPTED_ATTR.insert(index, value)
    def replace_DOCUMENT_ENCRYPTED_ATTR_at(self, index, value):
        self.DOCUMENT_ENCRYPTED_ATTR[index] = value
    def get_DRS_INTERVAL(self):
        return self.DRS_INTERVAL
    def set_DRS_INTERVAL(self, DRS_INTERVAL):
        self.DRS_INTERVAL = DRS_INTERVAL
    def get_DS_MAD_CONF(self):
        return self.DS_MAD_CONF
    def set_DS_MAD_CONF(self, DS_MAD_CONF):
        self.DS_MAD_CONF = DS_MAD_CONF
    def add_DS_MAD_CONF(self, value):
        self.DS_MAD_CONF.append(value)
    def insert_DS_MAD_CONF_at(self, index, value):
        self.DS_MAD_CONF.insert(index, value)
    def replace_DS_MAD_CONF_at(self, index, value):
        self.DS_MAD_CONF[index] = value
    def get_DS_MONITOR_VM_DISK(self):
        return self.DS_MONITOR_VM_DISK
    def set_DS_MONITOR_VM_DISK(self, DS_MONITOR_VM_DISK):
        self.DS_MONITOR_VM_DISK = DS_MONITOR_VM_DISK
    def get_ENABLE_OTHER_PERMISSIONS(self):
        return self.ENABLE_OTHER_PERMISSIONS
    def set_ENABLE_OTHER_PERMISSIONS(self, ENABLE_OTHER_PERMISSIONS):
        self.ENABLE_OTHER_PERMISSIONS = ENABLE_OTHER_PERMISSIONS
    def get_FEDERATION(self):
        return self.FEDERATION
    def set_FEDERATION(self, FEDERATION):
        self.FEDERATION = FEDERATION
    def get_GROUP_RESTRICTED_ATTR(self):
        return self.GROUP_RESTRICTED_ATTR
    def set_GROUP_RESTRICTED_ATTR(self, GROUP_RESTRICTED_ATTR):
        self.GROUP_RESTRICTED_ATTR = GROUP_RESTRICTED_ATTR
    def add_GROUP_RESTRICTED_ATTR(self, value):
        self.GROUP_RESTRICTED_ATTR.append(value)
    def insert_GROUP_RESTRICTED_ATTR_at(self, index, value):
        self.GROUP_RESTRICTED_ATTR.insert(index, value)
    def replace_GROUP_RESTRICTED_ATTR_at(self, index, value):
        self.GROUP_RESTRICTED_ATTR[index] = value
    def get_HM_MAD(self):
        return self.HM_MAD
    def set_HM_MAD(self, HM_MAD):
        self.HM_MAD = HM_MAD
    def get_HOOK_LOG_CONF(self):
        return self.HOOK_LOG_CONF
    def set_HOOK_LOG_CONF(self, HOOK_LOG_CONF):
        self.HOOK_LOG_CONF = HOOK_LOG_CONF
    def get_HOST_ENCRYPTED_ATTR(self):
        return self.HOST_ENCRYPTED_ATTR
    def set_HOST_ENCRYPTED_ATTR(self, HOST_ENCRYPTED_ATTR):
        self.HOST_ENCRYPTED_ATTR = HOST_ENCRYPTED_ATTR
    def add_HOST_ENCRYPTED_ATTR(self, value):
        self.HOST_ENCRYPTED_ATTR.append(value)
    def insert_HOST_ENCRYPTED_ATTR_at(self, index, value):
        self.HOST_ENCRYPTED_ATTR.insert(index, value)
    def replace_HOST_ENCRYPTED_ATTR_at(self, index, value):
        self.HOST_ENCRYPTED_ATTR[index] = value
    def get_IMAGE_ENCRYPTED_ATTR(self):
        return self.IMAGE_ENCRYPTED_ATTR
    def set_IMAGE_ENCRYPTED_ATTR(self, IMAGE_ENCRYPTED_ATTR):
        self.IMAGE_ENCRYPTED_ATTR = IMAGE_ENCRYPTED_ATTR
    def add_IMAGE_ENCRYPTED_ATTR(self, value):
        self.IMAGE_ENCRYPTED_ATTR.append(value)
    def insert_IMAGE_ENCRYPTED_ATTR_at(self, index, value):
        self.IMAGE_ENCRYPTED_ATTR.insert(index, value)
    def replace_IMAGE_ENCRYPTED_ATTR_at(self, index, value):
        self.IMAGE_ENCRYPTED_ATTR[index] = value
    def get_IMAGE_RESTRICTED_ATTR(self):
        return self.IMAGE_RESTRICTED_ATTR
    def set_IMAGE_RESTRICTED_ATTR(self, IMAGE_RESTRICTED_ATTR):
        self.IMAGE_RESTRICTED_ATTR = IMAGE_RESTRICTED_ATTR
    def add_IMAGE_RESTRICTED_ATTR(self, value):
        self.IMAGE_RESTRICTED_ATTR.append(value)
    def insert_IMAGE_RESTRICTED_ATTR_at(self, index, value):
        self.IMAGE_RESTRICTED_ATTR.insert(index, value)
    def replace_IMAGE_RESTRICTED_ATTR_at(self, index, value):
        self.IMAGE_RESTRICTED_ATTR[index] = value
    def get_IM_MAD(self):
        return self.IM_MAD
    def set_IM_MAD(self, IM_MAD):
        self.IM_MAD = IM_MAD
    def add_IM_MAD(self, value):
        self.IM_MAD.append(value)
    def insert_IM_MAD_at(self, index, value):
        self.IM_MAD.insert(index, value)
    def replace_IM_MAD_at(self, index, value):
        self.IM_MAD[index] = value
    def get_INHERIT_DATASTORE_ATTR(self):
        return self.INHERIT_DATASTORE_ATTR
    def set_INHERIT_DATASTORE_ATTR(self, INHERIT_DATASTORE_ATTR):
        self.INHERIT_DATASTORE_ATTR = INHERIT_DATASTORE_ATTR
    def add_INHERIT_DATASTORE_ATTR(self, value):
        self.INHERIT_DATASTORE_ATTR.append(value)
    def insert_INHERIT_DATASTORE_ATTR_at(self, index, value):
        self.INHERIT_DATASTORE_ATTR.insert(index, value)
    def replace_INHERIT_DATASTORE_ATTR_at(self, index, value):
        self.INHERIT_DATASTORE_ATTR[index] = value
    def get_INHERIT_IMAGE_ATTR(self):
        return self.INHERIT_IMAGE_ATTR
    def set_INHERIT_IMAGE_ATTR(self, INHERIT_IMAGE_ATTR):
        self.INHERIT_IMAGE_ATTR = INHERIT_IMAGE_ATTR
    def add_INHERIT_IMAGE_ATTR(self, value):
        self.INHERIT_IMAGE_ATTR.append(value)
    def insert_INHERIT_IMAGE_ATTR_at(self, index, value):
        self.INHERIT_IMAGE_ATTR.insert(index, value)
    def replace_INHERIT_IMAGE_ATTR_at(self, index, value):
        self.INHERIT_IMAGE_ATTR[index] = value
    def get_INHERIT_VNET_ATTR(self):
        return self.INHERIT_VNET_ATTR
    def set_INHERIT_VNET_ATTR(self, INHERIT_VNET_ATTR):
        self.INHERIT_VNET_ATTR = INHERIT_VNET_ATTR
    def add_INHERIT_VNET_ATTR(self, value):
        self.INHERIT_VNET_ATTR.append(value)
    def insert_INHERIT_VNET_ATTR_at(self, index, value):
        self.INHERIT_VNET_ATTR.insert(index, value)
    def replace_INHERIT_VNET_ATTR_at(self, index, value):
        self.INHERIT_VNET_ATTR[index] = value
    def get_IPAM_MAD(self):
        return self.IPAM_MAD
    def set_IPAM_MAD(self, IPAM_MAD):
        self.IPAM_MAD = IPAM_MAD
    def add_IPAM_MAD(self, value):
        self.IPAM_MAD.append(value)
    def insert_IPAM_MAD_at(self, index, value):
        self.IPAM_MAD.insert(index, value)
    def replace_IPAM_MAD_at(self, index, value):
        self.IPAM_MAD[index] = value
    def get_KEEPALIVE_MAX_CONN(self):
        return self.KEEPALIVE_MAX_CONN
    def set_KEEPALIVE_MAX_CONN(self, KEEPALIVE_MAX_CONN):
        self.KEEPALIVE_MAX_CONN = KEEPALIVE_MAX_CONN
    def add_KEEPALIVE_MAX_CONN(self, value):
        self.KEEPALIVE_MAX_CONN.append(value)
    def insert_KEEPALIVE_MAX_CONN_at(self, index, value):
        self.KEEPALIVE_MAX_CONN.insert(index, value)
    def replace_KEEPALIVE_MAX_CONN_at(self, index, value):
        self.KEEPALIVE_MAX_CONN[index] = value
    def get_KEEPALIVE_TIMEOUT(self):
        return self.KEEPALIVE_TIMEOUT
    def set_KEEPALIVE_TIMEOUT(self, KEEPALIVE_TIMEOUT):
        self.KEEPALIVE_TIMEOUT = KEEPALIVE_TIMEOUT
    def add_KEEPALIVE_TIMEOUT(self, value):
        self.KEEPALIVE_TIMEOUT.append(value)
    def insert_KEEPALIVE_TIMEOUT_at(self, index, value):
        self.KEEPALIVE_TIMEOUT.insert(index, value)
    def replace_KEEPALIVE_TIMEOUT_at(self, index, value):
        self.KEEPALIVE_TIMEOUT[index] = value
    def get_LISTEN_ADDRESS(self):
        return self.LISTEN_ADDRESS
    def set_LISTEN_ADDRESS(self, LISTEN_ADDRESS):
        self.LISTEN_ADDRESS = LISTEN_ADDRESS
    def add_LISTEN_ADDRESS(self, value):
        self.LISTEN_ADDRESS.append(value)
    def insert_LISTEN_ADDRESS_at(self, index, value):
        self.LISTEN_ADDRESS.insert(index, value)
    def replace_LISTEN_ADDRESS_at(self, index, value):
        self.LISTEN_ADDRESS[index] = value
    def get_LIVE_RESCHEDS(self):
        return self.LIVE_RESCHEDS
    def set_LIVE_RESCHEDS(self, LIVE_RESCHEDS):
        self.LIVE_RESCHEDS = LIVE_RESCHEDS
    def get_LOG(self):
        return self.LOG
    def set_LOG(self, LOG):
        self.LOG = LOG
    def add_LOG(self, value):
        self.LOG.append(value)
    def insert_LOG_at(self, index, value):
        self.LOG.insert(index, value)
    def replace_LOG_at(self, index, value):
        self.LOG[index] = value
    def get_LOG_CALL_FORMAT(self):
        return self.LOG_CALL_FORMAT
    def set_LOG_CALL_FORMAT(self, LOG_CALL_FORMAT):
        self.LOG_CALL_FORMAT = LOG_CALL_FORMAT
    def add_LOG_CALL_FORMAT(self, value):
        self.LOG_CALL_FORMAT.append(value)
    def insert_LOG_CALL_FORMAT_at(self, index, value):
        self.LOG_CALL_FORMAT.insert(index, value)
    def replace_LOG_CALL_FORMAT_at(self, index, value):
        self.LOG_CALL_FORMAT[index] = value
    def get_MAC_PREFIX(self):
        return self.MAC_PREFIX
    def set_MAC_PREFIX(self, MAC_PREFIX):
        self.MAC_PREFIX = MAC_PREFIX
    def add_MAC_PREFIX(self, value):
        self.MAC_PREFIX.append(value)
    def insert_MAC_PREFIX_at(self, index, value):
        self.MAC_PREFIX.insert(index, value)
    def replace_MAC_PREFIX_at(self, index, value):
        self.MAC_PREFIX[index] = value
    def get_MANAGER_TIMER(self):
        return self.MANAGER_TIMER
    def set_MANAGER_TIMER(self, MANAGER_TIMER):
        self.MANAGER_TIMER = MANAGER_TIMER
    def add_MANAGER_TIMER(self, value):
        self.MANAGER_TIMER.append(value)
    def insert_MANAGER_TIMER_at(self, index, value):
        self.MANAGER_TIMER.insert(index, value)
    def replace_MANAGER_TIMER_at(self, index, value):
        self.MANAGER_TIMER[index] = value
    def get_MARKET_MAD(self):
        return self.MARKET_MAD
    def set_MARKET_MAD(self, MARKET_MAD):
        self.MARKET_MAD = MARKET_MAD
    def add_MARKET_MAD(self, value):
        self.MARKET_MAD.append(value)
    def insert_MARKET_MAD_at(self, index, value):
        self.MARKET_MAD.insert(index, value)
    def replace_MARKET_MAD_at(self, index, value):
        self.MARKET_MAD[index] = value
    def get_MARKET_MAD_CONF(self):
        return self.MARKET_MAD_CONF
    def set_MARKET_MAD_CONF(self, MARKET_MAD_CONF):
        self.MARKET_MAD_CONF = MARKET_MAD_CONF
    def add_MARKET_MAD_CONF(self, value):
        self.MARKET_MAD_CONF.append(value)
    def insert_MARKET_MAD_CONF_at(self, index, value):
        self.MARKET_MAD_CONF.insert(index, value)
    def replace_MARKET_MAD_CONF_at(self, index, value):
        self.MARKET_MAD_CONF[index] = value
    def get_MAX_ACTIONS_PER_CLUSTER(self):
        return self.MAX_ACTIONS_PER_CLUSTER
    def set_MAX_ACTIONS_PER_CLUSTER(self, MAX_ACTIONS_PER_CLUSTER):
        self.MAX_ACTIONS_PER_CLUSTER = MAX_ACTIONS_PER_CLUSTER
    def get_MAX_ACTIONS_PER_HOST(self):
        return self.MAX_ACTIONS_PER_HOST
    def set_MAX_ACTIONS_PER_HOST(self, MAX_ACTIONS_PER_HOST):
        self.MAX_ACTIONS_PER_HOST = MAX_ACTIONS_PER_HOST
    def get_MAX_BACKUPS(self):
        return self.MAX_BACKUPS
    def set_MAX_BACKUPS(self, MAX_BACKUPS):
        self.MAX_BACKUPS = MAX_BACKUPS
    def get_MAX_BACKUPS_HOST(self):
        return self.MAX_BACKUPS_HOST
    def set_MAX_BACKUPS_HOST(self, MAX_BACKUPS_HOST):
        self.MAX_BACKUPS_HOST = MAX_BACKUPS_HOST
    def get_MAX_CONN(self):
        return self.MAX_CONN
    def set_MAX_CONN(self, MAX_CONN):
        self.MAX_CONN = MAX_CONN
    def get_MAX_CONN_BACKLOG(self):
        return self.MAX_CONN_BACKLOG
    def set_MAX_CONN_BACKLOG(self, MAX_CONN_BACKLOG):
        self.MAX_CONN_BACKLOG = MAX_CONN_BACKLOG
    def get_MESSAGE_SIZE(self):
        return self.MESSAGE_SIZE
    def set_MESSAGE_SIZE(self, MESSAGE_SIZE):
        self.MESSAGE_SIZE = MESSAGE_SIZE
    def get_MONITORING_INTERVAL_DATASTORE(self):
        return self.MONITORING_INTERVAL_DATASTORE
    def set_MONITORING_INTERVAL_DATASTORE(self, MONITORING_INTERVAL_DATASTORE):
        self.MONITORING_INTERVAL_DATASTORE = MONITORING_INTERVAL_DATASTORE
    def get_MONITORING_INTERVAL_HOST(self):
        return self.MONITORING_INTERVAL_HOST
    def set_MONITORING_INTERVAL_HOST(self, MONITORING_INTERVAL_HOST):
        self.MONITORING_INTERVAL_HOST = MONITORING_INTERVAL_HOST
    def get_MONITORING_INTERVAL_MARKET(self):
        return self.MONITORING_INTERVAL_MARKET
    def set_MONITORING_INTERVAL_MARKET(self, MONITORING_INTERVAL_MARKET):
        self.MONITORING_INTERVAL_MARKET = MONITORING_INTERVAL_MARKET
    def get_MONITORING_INTERVAL_VM(self):
        return self.MONITORING_INTERVAL_VM
    def set_MONITORING_INTERVAL_VM(self, MONITORING_INTERVAL_VM):
        self.MONITORING_INTERVAL_VM = MONITORING_INTERVAL_VM
    def get_NETWORK_SIZE(self):
        return self.NETWORK_SIZE
    def set_NETWORK_SIZE(self, NETWORK_SIZE):
        self.NETWORK_SIZE = NETWORK_SIZE
    def get_ONE_KEY(self):
        return self.ONE_KEY
    def set_ONE_KEY(self, ONE_KEY):
        self.ONE_KEY = ONE_KEY
    def add_ONE_KEY(self, value):
        self.ONE_KEY.append(value)
    def insert_ONE_KEY_at(self, index, value):
        self.ONE_KEY.insert(index, value)
    def replace_ONE_KEY_at(self, index, value):
        self.ONE_KEY[index] = value
    def get_PCI_PASSTHROUGH_BUS(self):
        return self.PCI_PASSTHROUGH_BUS
    def set_PCI_PASSTHROUGH_BUS(self, PCI_PASSTHROUGH_BUS):
        self.PCI_PASSTHROUGH_BUS = PCI_PASSTHROUGH_BUS
    def get_PORT(self):
        return self.PORT
    def set_PORT(self, PORT):
        self.PORT = PORT
    def get_RAFT(self):
        return self.RAFT
    def set_RAFT(self, RAFT):
        self.RAFT = RAFT
    def get_RPC_LOG(self):
        return self.RPC_LOG
    def set_RPC_LOG(self, RPC_LOG):
        self.RPC_LOG = RPC_LOG
    def get_SCHED_MAD(self):
        return self.SCHED_MAD
    def set_SCHED_MAD(self, SCHED_MAD):
        self.SCHED_MAD = SCHED_MAD
    def get_SCHED_MAX_WND_LENGTH(self):
        return self.SCHED_MAX_WND_LENGTH
    def set_SCHED_MAX_WND_LENGTH(self, SCHED_MAX_WND_LENGTH):
        self.SCHED_MAX_WND_LENGTH = SCHED_MAX_WND_LENGTH
    def get_SCHED_MAX_WND_TIME(self):
        return self.SCHED_MAX_WND_TIME
    def set_SCHED_MAX_WND_TIME(self, SCHED_MAX_WND_TIME):
        self.SCHED_MAX_WND_TIME = SCHED_MAX_WND_TIME
    def get_SCHED_RETRY_TIME(self):
        return self.SCHED_RETRY_TIME
    def set_SCHED_RETRY_TIME(self, SCHED_RETRY_TIME):
        self.SCHED_RETRY_TIME = SCHED_RETRY_TIME
    def get_SCRIPTS_REMOTE_DIR(self):
        return self.SCRIPTS_REMOTE_DIR
    def set_SCRIPTS_REMOTE_DIR(self, SCRIPTS_REMOTE_DIR):
        self.SCRIPTS_REMOTE_DIR = SCRIPTS_REMOTE_DIR
    def get_SESSION_EXPIRATION_TIME(self):
        return self.SESSION_EXPIRATION_TIME
    def set_SESSION_EXPIRATION_TIME(self, SESSION_EXPIRATION_TIME):
        self.SESSION_EXPIRATION_TIME = SESSION_EXPIRATION_TIME
    def get_SHOWBACK_ONLY_RUNNING(self):
        return self.SHOWBACK_ONLY_RUNNING
    def set_SHOWBACK_ONLY_RUNNING(self, SHOWBACK_ONLY_RUNNING):
        self.SHOWBACK_ONLY_RUNNING = SHOWBACK_ONLY_RUNNING
    def get_TIMEOUT(self):
        return self.TIMEOUT
    def set_TIMEOUT(self, TIMEOUT):
        self.TIMEOUT = TIMEOUT
    def get_TM_MAD(self):
        return self.TM_MAD
    def set_TM_MAD(self, TM_MAD):
        self.TM_MAD = TM_MAD
    def add_TM_MAD(self, value):
        self.TM_MAD.append(value)
    def insert_TM_MAD_at(self, index, value):
        self.TM_MAD.insert(index, value)
    def replace_TM_MAD_at(self, index, value):
        self.TM_MAD[index] = value
    def get_TM_MAD_CONF(self):
        return self.TM_MAD_CONF
    def set_TM_MAD_CONF(self, TM_MAD_CONF):
        self.TM_MAD_CONF = TM_MAD_CONF
    def add_TM_MAD_CONF(self, value):
        self.TM_MAD_CONF.append(value)
    def insert_TM_MAD_CONF_at(self, index, value):
        self.TM_MAD_CONF.insert(index, value)
    def replace_TM_MAD_CONF_at(self, index, value):
        self.TM_MAD_CONF[index] = value
    def get_USER_ENCRYPTED_ATTR(self):
        return self.USER_ENCRYPTED_ATTR
    def set_USER_ENCRYPTED_ATTR(self, USER_ENCRYPTED_ATTR):
        self.USER_ENCRYPTED_ATTR = USER_ENCRYPTED_ATTR
    def add_USER_ENCRYPTED_ATTR(self, value):
        self.USER_ENCRYPTED_ATTR.append(value)
    def insert_USER_ENCRYPTED_ATTR_at(self, index, value):
        self.USER_ENCRYPTED_ATTR.insert(index, value)
    def replace_USER_ENCRYPTED_ATTR_at(self, index, value):
        self.USER_ENCRYPTED_ATTR[index] = value
    def get_USER_RESTRICTED_ATTR(self):
        return self.USER_RESTRICTED_ATTR
    def set_USER_RESTRICTED_ATTR(self, USER_RESTRICTED_ATTR):
        self.USER_RESTRICTED_ATTR = USER_RESTRICTED_ATTR
    def add_USER_RESTRICTED_ATTR(self, value):
        self.USER_RESTRICTED_ATTR.append(value)
    def insert_USER_RESTRICTED_ATTR_at(self, index, value):
        self.USER_RESTRICTED_ATTR.insert(index, value)
    def replace_USER_RESTRICTED_ATTR_at(self, index, value):
        self.USER_RESTRICTED_ATTR[index] = value
    def get_VLAN_IDS(self):
        return self.VLAN_IDS
    def set_VLAN_IDS(self, VLAN_IDS):
        self.VLAN_IDS = VLAN_IDS
    def get_VM_ADMIN_OPERATIONS(self):
        return self.VM_ADMIN_OPERATIONS
    def set_VM_ADMIN_OPERATIONS(self, VM_ADMIN_OPERATIONS):
        self.VM_ADMIN_OPERATIONS = VM_ADMIN_OPERATIONS
    def get_VM_ENCRYPTED_ATTR(self):
        return self.VM_ENCRYPTED_ATTR
    def set_VM_ENCRYPTED_ATTR(self, VM_ENCRYPTED_ATTR):
        self.VM_ENCRYPTED_ATTR = VM_ENCRYPTED_ATTR
    def add_VM_ENCRYPTED_ATTR(self, value):
        self.VM_ENCRYPTED_ATTR.append(value)
    def insert_VM_ENCRYPTED_ATTR_at(self, index, value):
        self.VM_ENCRYPTED_ATTR.insert(index, value)
    def replace_VM_ENCRYPTED_ATTR_at(self, index, value):
        self.VM_ENCRYPTED_ATTR[index] = value
    def get_VM_MAD(self):
        return self.VM_MAD
    def set_VM_MAD(self, VM_MAD):
        self.VM_MAD = VM_MAD
    def add_VM_MAD(self, value):
        self.VM_MAD.append(value)
    def insert_VM_MAD_at(self, index, value):
        self.VM_MAD.insert(index, value)
    def replace_VM_MAD_at(self, index, value):
        self.VM_MAD[index] = value
    def get_VM_MANAGE_OPERATIONS(self):
        return self.VM_MANAGE_OPERATIONS
    def set_VM_MANAGE_OPERATIONS(self, VM_MANAGE_OPERATIONS):
        self.VM_MANAGE_OPERATIONS = VM_MANAGE_OPERATIONS
    def get_VM_MONITORING_EXPIRATION_TIME(self):
        return self.VM_MONITORING_EXPIRATION_TIME
    def set_VM_MONITORING_EXPIRATION_TIME(self, VM_MONITORING_EXPIRATION_TIME):
        self.VM_MONITORING_EXPIRATION_TIME = VM_MONITORING_EXPIRATION_TIME
    def add_VM_MONITORING_EXPIRATION_TIME(self, value):
        self.VM_MONITORING_EXPIRATION_TIME.append(value)
    def insert_VM_MONITORING_EXPIRATION_TIME_at(self, index, value):
        self.VM_MONITORING_EXPIRATION_TIME.insert(index, value)
    def replace_VM_MONITORING_EXPIRATION_TIME_at(self, index, value):
        self.VM_MONITORING_EXPIRATION_TIME[index] = value
    def get_VM_RESTRICTED_ATTR(self):
        return self.VM_RESTRICTED_ATTR
    def set_VM_RESTRICTED_ATTR(self, VM_RESTRICTED_ATTR):
        self.VM_RESTRICTED_ATTR = VM_RESTRICTED_ATTR
    def add_VM_RESTRICTED_ATTR(self, value):
        self.VM_RESTRICTED_ATTR.append(value)
    def insert_VM_RESTRICTED_ATTR_at(self, index, value):
        self.VM_RESTRICTED_ATTR.insert(index, value)
    def replace_VM_RESTRICTED_ATTR_at(self, index, value):
        self.VM_RESTRICTED_ATTR[index] = value
    def get_VM_SNAPSHOT_FACTOR(self):
        return self.VM_SNAPSHOT_FACTOR
    def set_VM_SNAPSHOT_FACTOR(self, VM_SNAPSHOT_FACTOR):
        self.VM_SNAPSHOT_FACTOR = VM_SNAPSHOT_FACTOR
    def get_VM_SUBMIT_ON_HOLD(self):
        return self.VM_SUBMIT_ON_HOLD
    def set_VM_SUBMIT_ON_HOLD(self, VM_SUBMIT_ON_HOLD):
        self.VM_SUBMIT_ON_HOLD = VM_SUBMIT_ON_HOLD
    def get_VM_USE_OPERATIONS(self):
        return self.VM_USE_OPERATIONS
    def set_VM_USE_OPERATIONS(self, VM_USE_OPERATIONS):
        self.VM_USE_OPERATIONS = VM_USE_OPERATIONS
    def add_VM_USE_OPERATIONS(self, value):
        self.VM_USE_OPERATIONS.append(value)
    def insert_VM_USE_OPERATIONS_at(self, index, value):
        self.VM_USE_OPERATIONS.insert(index, value)
    def replace_VM_USE_OPERATIONS_at(self, index, value):
        self.VM_USE_OPERATIONS[index] = value
    def get_VNC_PORTS(self):
        return self.VNC_PORTS
    def set_VNC_PORTS(self, VNC_PORTS):
        self.VNC_PORTS = VNC_PORTS
    def get_VNET_ENCRYPTED_ATTR(self):
        return self.VNET_ENCRYPTED_ATTR
    def set_VNET_ENCRYPTED_ATTR(self, VNET_ENCRYPTED_ATTR):
        self.VNET_ENCRYPTED_ATTR = VNET_ENCRYPTED_ATTR
    def add_VNET_ENCRYPTED_ATTR(self, value):
        self.VNET_ENCRYPTED_ATTR.append(value)
    def insert_VNET_ENCRYPTED_ATTR_at(self, index, value):
        self.VNET_ENCRYPTED_ATTR.insert(index, value)
    def replace_VNET_ENCRYPTED_ATTR_at(self, index, value):
        self.VNET_ENCRYPTED_ATTR[index] = value
    def get_VNET_RESTRICTED_ATTR(self):
        return self.VNET_RESTRICTED_ATTR
    def set_VNET_RESTRICTED_ATTR(self, VNET_RESTRICTED_ATTR):
        self.VNET_RESTRICTED_ATTR = VNET_RESTRICTED_ATTR
    def add_VNET_RESTRICTED_ATTR(self, value):
        self.VNET_RESTRICTED_ATTR.append(value)
    def insert_VNET_RESTRICTED_ATTR_at(self, index, value):
        self.VNET_RESTRICTED_ATTR.insert(index, value)
    def replace_VNET_RESTRICTED_ATTR_at(self, index, value):
        self.VNET_RESTRICTED_ATTR[index] = value
    def get_VN_MAD_CONF(self):
        return self.VN_MAD_CONF
    def set_VN_MAD_CONF(self, VN_MAD_CONF):
        self.VN_MAD_CONF = VN_MAD_CONF
    def add_VN_MAD_CONF(self, value):
        self.VN_MAD_CONF.append(value)
    def insert_VN_MAD_CONF_at(self, index, value):
        self.VN_MAD_CONF.insert(index, value)
    def replace_VN_MAD_CONF_at(self, index, value):
        self.VN_MAD_CONF[index] = value
    def get_VXLAN_IDS(self):
        return self.VXLAN_IDS
    def set_VXLAN_IDS(self, VXLAN_IDS):
        self.VXLAN_IDS = VXLAN_IDS
    def validate_ENABLE_OTHER_PERMISSIONSType(self, value):
        result = True
        # Validate type ENABLE_OTHER_PERMISSIONSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_ENABLE_OTHER_PERMISSIONSType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ENABLE_OTHER_PERMISSIONSType_patterns_, ))
                result = False
        return result
    validate_ENABLE_OTHER_PERMISSIONSType_patterns_ = [['^([yY][eE][sS])$', '^([nN][oO])$']]
    def validate_VM_SUBMIT_ON_HOLDType(self, value):
        result = True
        # Validate type VM_SUBMIT_ON_HOLDType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_VM_SUBMIT_ON_HOLDType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VM_SUBMIT_ON_HOLDType_patterns_, ))
                result = False
        return result
    validate_VM_SUBMIT_ON_HOLDType_patterns_ = [['^([yY][eE][sS])$', '^([nN][oO])$']]
    def has__content(self):
        if (
            self.ACTION_TIMEOUT is not None or
            self.API_LIST_ORDER or
            self.AUTH_MAD or
            self.AUTH_MAD_CONF or
            self.CLUSTER_ENCRYPTED_ATTR or
            self.COLD_MIGRATE_MODE is not None or
            self.CONTEXT_ALLOW_ETH_UPDATES is not None or
            self.CONTEXT_RESTRICTED_DIRS is not None or
            self.CONTEXT_SAFE_DIRS is not None or
            self.DATASTORE_CAPACITY_CHECK or
            self.DATASTORE_ENCRYPTED_ATTR or
            self.DATASTORE_LOCATION or
            self.DATASTORE_MAD or
            self.DB is not None or
            self.DEFAULT_AUTH or
            self.DEFAULT_CDROM_DEVICE_PREFIX or
            self.DEFAULT_COST or
            self.DEFAULT_DEVICE_PREFIX or
            self.DEFAULT_IMAGE_PERSISTENT or
            self.DEFAULT_IMAGE_PERSISTENT_NEW or
            self.DEFAULT_IMAGE_TYPE or
            self.DEFAULT_UMASK or
            self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL or
            self.DEFAULT_VDC_CLUSTER_HOST_ACL or
            self.DEFAULT_VDC_CLUSTER_NET_ACL or
            self.DEFAULT_VDC_DATASTORE_ACL or
            self.DEFAULT_VDC_HOST_ACL or
            self.DEFAULT_VDC_VNET_ACL or
            self.DOCUMENT_ENCRYPTED_ATTR or
            self.DRS_INTERVAL is not None or
            self.DS_MAD_CONF or
            self.DS_MONITOR_VM_DISK is not None or
            self.ENABLE_OTHER_PERMISSIONS is not None or
            self.FEDERATION is not None or
            self.GROUP_RESTRICTED_ATTR or
            self.HM_MAD is not None or
            self.HOOK_LOG_CONF is not None or
            self.HOST_ENCRYPTED_ATTR or
            self.IMAGE_ENCRYPTED_ATTR or
            self.IMAGE_RESTRICTED_ATTR or
            self.IM_MAD or
            self.INHERIT_DATASTORE_ATTR or
            self.INHERIT_IMAGE_ATTR or
            self.INHERIT_VNET_ATTR or
            self.IPAM_MAD or
            self.KEEPALIVE_MAX_CONN or
            self.KEEPALIVE_TIMEOUT or
            self.LISTEN_ADDRESS or
            self.LIVE_RESCHEDS is not None or
            self.LOG or
            self.LOG_CALL_FORMAT or
            self.MAC_PREFIX or
            self.MANAGER_TIMER or
            self.MARKET_MAD or
            self.MARKET_MAD_CONF or
            self.MAX_ACTIONS_PER_CLUSTER is not None or
            self.MAX_ACTIONS_PER_HOST is not None or
            self.MAX_BACKUPS is not None or
            self.MAX_BACKUPS_HOST is not None or
            self.MAX_CONN is not None or
            self.MAX_CONN_BACKLOG is not None or
            self.MESSAGE_SIZE is not None or
            self.MONITORING_INTERVAL_DATASTORE is not None or
            self.MONITORING_INTERVAL_HOST is not None or
            self.MONITORING_INTERVAL_MARKET is not None or
            self.MONITORING_INTERVAL_VM is not None or
            self.NETWORK_SIZE is not None or
            self.ONE_KEY or
            self.PCI_PASSTHROUGH_BUS is not None or
            self.PORT is not None or
            self.RAFT is not None or
            self.RPC_LOG is not None or
            self.SCHED_MAD is not None or
            self.SCHED_MAX_WND_LENGTH is not None or
            self.SCHED_MAX_WND_TIME is not None or
            self.SCHED_RETRY_TIME is not None or
            self.SCRIPTS_REMOTE_DIR is not None or
            self.SESSION_EXPIRATION_TIME is not None or
            self.SHOWBACK_ONLY_RUNNING is not None or
            self.TIMEOUT is not None or
            self.TM_MAD or
            self.TM_MAD_CONF or
            self.USER_ENCRYPTED_ATTR or
            self.USER_RESTRICTED_ATTR or
            self.VLAN_IDS is not None or
            self.VM_ADMIN_OPERATIONS is not None or
            self.VM_ENCRYPTED_ATTR or
            self.VM_MAD or
            self.VM_MANAGE_OPERATIONS is not None or
            self.VM_MONITORING_EXPIRATION_TIME or
            self.VM_RESTRICTED_ATTR or
            self.VM_SNAPSHOT_FACTOR is not None or
            self.VM_SUBMIT_ON_HOLD is not None or
            self.VM_USE_OPERATIONS or
            self.VNC_PORTS is not None or
            self.VNET_ENCRYPTED_ATTR or
            self.VNET_RESTRICTED_ATTR or
            self.VN_MAD_CONF or
            self.VXLAN_IDS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='OPENNEBULA_CONFIGURATION', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPENNEBULA_CONFIGURATION')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OPENNEBULA_CONFIGURATION':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OPENNEBULA_CONFIGURATION')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OPENNEBULA_CONFIGURATION', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OPENNEBULA_CONFIGURATION'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='OPENNEBULA_CONFIGURATION', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ACTION_TIMEOUT is not None:
            namespaceprefix_ = self.ACTION_TIMEOUT_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTION_TIMEOUT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACTION_TIMEOUT>%s</%sACTION_TIMEOUT>%s' % (namespaceprefix_ , self.gds_format_integer(self.ACTION_TIMEOUT, input_name='ACTION_TIMEOUT'), namespaceprefix_ , eol_))
        for API_LIST_ORDER_ in self.API_LIST_ORDER:
            namespaceprefix_ = self.API_LIST_ORDER_nsprefix_ + ':' if (UseCapturedNS_ and self.API_LIST_ORDER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAPI_LIST_ORDER>%s</%sAPI_LIST_ORDER>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(API_LIST_ORDER_), input_name='API_LIST_ORDER')), namespaceprefix_ , eol_))
        for AUTH_MAD_ in self.AUTH_MAD:
            namespaceprefix_ = self.AUTH_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.AUTH_MAD_nsprefix_) else ''
            AUTH_MAD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AUTH_MAD', pretty_print=pretty_print)
        for AUTH_MAD_CONF_ in self.AUTH_MAD_CONF:
            namespaceprefix_ = self.AUTH_MAD_CONF_nsprefix_ + ':' if (UseCapturedNS_ and self.AUTH_MAD_CONF_nsprefix_) else ''
            AUTH_MAD_CONF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AUTH_MAD_CONF', pretty_print=pretty_print)
        for CLUSTER_ENCRYPTED_ATTR_ in self.CLUSTER_ENCRYPTED_ATTR:
            namespaceprefix_ = self.CLUSTER_ENCRYPTED_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.CLUSTER_ENCRYPTED_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLUSTER_ENCRYPTED_ATTR>%s</%sCLUSTER_ENCRYPTED_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(CLUSTER_ENCRYPTED_ATTR_), input_name='CLUSTER_ENCRYPTED_ATTR')), namespaceprefix_ , eol_))
        if self.COLD_MIGRATE_MODE is not None:
            namespaceprefix_ = self.COLD_MIGRATE_MODE_nsprefix_ + ':' if (UseCapturedNS_ and self.COLD_MIGRATE_MODE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOLD_MIGRATE_MODE>%s</%sCOLD_MIGRATE_MODE>%s' % (namespaceprefix_ , self.gds_format_integer(self.COLD_MIGRATE_MODE, input_name='COLD_MIGRATE_MODE'), namespaceprefix_ , eol_))
        if self.CONTEXT_ALLOW_ETH_UPDATES is not None:
            namespaceprefix_ = self.CONTEXT_ALLOW_ETH_UPDATES_nsprefix_ + ':' if (UseCapturedNS_ and self.CONTEXT_ALLOW_ETH_UPDATES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCONTEXT_ALLOW_ETH_UPDATES>%s</%sCONTEXT_ALLOW_ETH_UPDATES>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CONTEXT_ALLOW_ETH_UPDATES), input_name='CONTEXT_ALLOW_ETH_UPDATES')), namespaceprefix_ , eol_))
        if self.CONTEXT_RESTRICTED_DIRS is not None:
            namespaceprefix_ = self.CONTEXT_RESTRICTED_DIRS_nsprefix_ + ':' if (UseCapturedNS_ and self.CONTEXT_RESTRICTED_DIRS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCONTEXT_RESTRICTED_DIRS>%s</%sCONTEXT_RESTRICTED_DIRS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CONTEXT_RESTRICTED_DIRS), input_name='CONTEXT_RESTRICTED_DIRS')), namespaceprefix_ , eol_))
        if self.CONTEXT_SAFE_DIRS is not None:
            namespaceprefix_ = self.CONTEXT_SAFE_DIRS_nsprefix_ + ':' if (UseCapturedNS_ and self.CONTEXT_SAFE_DIRS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCONTEXT_SAFE_DIRS>%s</%sCONTEXT_SAFE_DIRS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CONTEXT_SAFE_DIRS), input_name='CONTEXT_SAFE_DIRS')), namespaceprefix_ , eol_))
        for DATASTORE_CAPACITY_CHECK_ in self.DATASTORE_CAPACITY_CHECK:
            namespaceprefix_ = self.DATASTORE_CAPACITY_CHECK_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_CAPACITY_CHECK_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATASTORE_CAPACITY_CHECK>%s</%sDATASTORE_CAPACITY_CHECK>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DATASTORE_CAPACITY_CHECK_), input_name='DATASTORE_CAPACITY_CHECK')), namespaceprefix_ , eol_))
        for DATASTORE_ENCRYPTED_ATTR_ in self.DATASTORE_ENCRYPTED_ATTR:
            namespaceprefix_ = self.DATASTORE_ENCRYPTED_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_ENCRYPTED_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATASTORE_ENCRYPTED_ATTR>%s</%sDATASTORE_ENCRYPTED_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DATASTORE_ENCRYPTED_ATTR_), input_name='DATASTORE_ENCRYPTED_ATTR')), namespaceprefix_ , eol_))
        for DATASTORE_LOCATION_ in self.DATASTORE_LOCATION:
            namespaceprefix_ = self.DATASTORE_LOCATION_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_LOCATION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATASTORE_LOCATION>%s</%sDATASTORE_LOCATION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DATASTORE_LOCATION_), input_name='DATASTORE_LOCATION')), namespaceprefix_ , eol_))
        for DATASTORE_MAD_ in self.DATASTORE_MAD:
            namespaceprefix_ = self.DATASTORE_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_MAD_nsprefix_) else ''
            DATASTORE_MAD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORE_MAD', pretty_print=pretty_print)
        if self.DB is not None:
            namespaceprefix_ = self.DB_nsprefix_ + ':' if (UseCapturedNS_ and self.DB_nsprefix_) else ''
            self.DB.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DB', pretty_print=pretty_print)
        for DEFAULT_AUTH_ in self.DEFAULT_AUTH:
            namespaceprefix_ = self.DEFAULT_AUTH_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_AUTH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT_AUTH>%s</%sDEFAULT_AUTH>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DEFAULT_AUTH_), input_name='DEFAULT_AUTH')), namespaceprefix_ , eol_))
        for DEFAULT_CDROM_DEVICE_PREFIX_ in self.DEFAULT_CDROM_DEVICE_PREFIX:
            namespaceprefix_ = self.DEFAULT_CDROM_DEVICE_PREFIX_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_CDROM_DEVICE_PREFIX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT_CDROM_DEVICE_PREFIX>%s</%sDEFAULT_CDROM_DEVICE_PREFIX>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DEFAULT_CDROM_DEVICE_PREFIX_), input_name='DEFAULT_CDROM_DEVICE_PREFIX')), namespaceprefix_ , eol_))
        for DEFAULT_COST_ in self.DEFAULT_COST:
            namespaceprefix_ = self.DEFAULT_COST_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_COST_nsprefix_) else ''
            DEFAULT_COST_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DEFAULT_COST', pretty_print=pretty_print)
        for DEFAULT_DEVICE_PREFIX_ in self.DEFAULT_DEVICE_PREFIX:
            namespaceprefix_ = self.DEFAULT_DEVICE_PREFIX_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_DEVICE_PREFIX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT_DEVICE_PREFIX>%s</%sDEFAULT_DEVICE_PREFIX>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DEFAULT_DEVICE_PREFIX_), input_name='DEFAULT_DEVICE_PREFIX')), namespaceprefix_ , eol_))
        for DEFAULT_IMAGE_PERSISTENT_ in self.DEFAULT_IMAGE_PERSISTENT:
            namespaceprefix_ = self.DEFAULT_IMAGE_PERSISTENT_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_IMAGE_PERSISTENT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT_IMAGE_PERSISTENT>%s</%sDEFAULT_IMAGE_PERSISTENT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DEFAULT_IMAGE_PERSISTENT_), input_name='DEFAULT_IMAGE_PERSISTENT')), namespaceprefix_ , eol_))
        for DEFAULT_IMAGE_PERSISTENT_NEW_ in self.DEFAULT_IMAGE_PERSISTENT_NEW:
            namespaceprefix_ = self.DEFAULT_IMAGE_PERSISTENT_NEW_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_IMAGE_PERSISTENT_NEW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT_IMAGE_PERSISTENT_NEW>%s</%sDEFAULT_IMAGE_PERSISTENT_NEW>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DEFAULT_IMAGE_PERSISTENT_NEW_), input_name='DEFAULT_IMAGE_PERSISTENT_NEW')), namespaceprefix_ , eol_))
        for DEFAULT_IMAGE_TYPE_ in self.DEFAULT_IMAGE_TYPE:
            namespaceprefix_ = self.DEFAULT_IMAGE_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_IMAGE_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT_IMAGE_TYPE>%s</%sDEFAULT_IMAGE_TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DEFAULT_IMAGE_TYPE_), input_name='DEFAULT_IMAGE_TYPE')), namespaceprefix_ , eol_))
        for DEFAULT_UMASK_ in self.DEFAULT_UMASK:
            namespaceprefix_ = self.DEFAULT_UMASK_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_UMASK_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT_UMASK>%s</%sDEFAULT_UMASK>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DEFAULT_UMASK_), input_name='DEFAULT_UMASK')), namespaceprefix_ , eol_))
        for DEFAULT_VDC_CLUSTER_DATASTORE_ACL_ in self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL:
            namespaceprefix_ = self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT_VDC_CLUSTER_DATASTORE_ACL>%s</%sDEFAULT_VDC_CLUSTER_DATASTORE_ACL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DEFAULT_VDC_CLUSTER_DATASTORE_ACL_), input_name='DEFAULT_VDC_CLUSTER_DATASTORE_ACL')), namespaceprefix_ , eol_))
        for DEFAULT_VDC_CLUSTER_HOST_ACL_ in self.DEFAULT_VDC_CLUSTER_HOST_ACL:
            namespaceprefix_ = self.DEFAULT_VDC_CLUSTER_HOST_ACL_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_VDC_CLUSTER_HOST_ACL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT_VDC_CLUSTER_HOST_ACL>%s</%sDEFAULT_VDC_CLUSTER_HOST_ACL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DEFAULT_VDC_CLUSTER_HOST_ACL_), input_name='DEFAULT_VDC_CLUSTER_HOST_ACL')), namespaceprefix_ , eol_))
        for DEFAULT_VDC_CLUSTER_NET_ACL_ in self.DEFAULT_VDC_CLUSTER_NET_ACL:
            namespaceprefix_ = self.DEFAULT_VDC_CLUSTER_NET_ACL_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_VDC_CLUSTER_NET_ACL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT_VDC_CLUSTER_NET_ACL>%s</%sDEFAULT_VDC_CLUSTER_NET_ACL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DEFAULT_VDC_CLUSTER_NET_ACL_), input_name='DEFAULT_VDC_CLUSTER_NET_ACL')), namespaceprefix_ , eol_))
        for DEFAULT_VDC_DATASTORE_ACL_ in self.DEFAULT_VDC_DATASTORE_ACL:
            namespaceprefix_ = self.DEFAULT_VDC_DATASTORE_ACL_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_VDC_DATASTORE_ACL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT_VDC_DATASTORE_ACL>%s</%sDEFAULT_VDC_DATASTORE_ACL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DEFAULT_VDC_DATASTORE_ACL_), input_name='DEFAULT_VDC_DATASTORE_ACL')), namespaceprefix_ , eol_))
        for DEFAULT_VDC_HOST_ACL_ in self.DEFAULT_VDC_HOST_ACL:
            namespaceprefix_ = self.DEFAULT_VDC_HOST_ACL_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_VDC_HOST_ACL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT_VDC_HOST_ACL>%s</%sDEFAULT_VDC_HOST_ACL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DEFAULT_VDC_HOST_ACL_), input_name='DEFAULT_VDC_HOST_ACL')), namespaceprefix_ , eol_))
        for DEFAULT_VDC_VNET_ACL_ in self.DEFAULT_VDC_VNET_ACL:
            namespaceprefix_ = self.DEFAULT_VDC_VNET_ACL_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_VDC_VNET_ACL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT_VDC_VNET_ACL>%s</%sDEFAULT_VDC_VNET_ACL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DEFAULT_VDC_VNET_ACL_), input_name='DEFAULT_VDC_VNET_ACL')), namespaceprefix_ , eol_))
        for DOCUMENT_ENCRYPTED_ATTR_ in self.DOCUMENT_ENCRYPTED_ATTR:
            namespaceprefix_ = self.DOCUMENT_ENCRYPTED_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.DOCUMENT_ENCRYPTED_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDOCUMENT_ENCRYPTED_ATTR>%s</%sDOCUMENT_ENCRYPTED_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DOCUMENT_ENCRYPTED_ATTR_), input_name='DOCUMENT_ENCRYPTED_ATTR')), namespaceprefix_ , eol_))
        if self.DRS_INTERVAL is not None:
            namespaceprefix_ = self.DRS_INTERVAL_nsprefix_ + ':' if (UseCapturedNS_ and self.DRS_INTERVAL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDRS_INTERVAL>%s</%sDRS_INTERVAL>%s' % (namespaceprefix_ , self.gds_format_integer(self.DRS_INTERVAL, input_name='DRS_INTERVAL'), namespaceprefix_ , eol_))
        for DS_MAD_CONF_ in self.DS_MAD_CONF:
            namespaceprefix_ = self.DS_MAD_CONF_nsprefix_ + ':' if (UseCapturedNS_ and self.DS_MAD_CONF_nsprefix_) else ''
            DS_MAD_CONF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DS_MAD_CONF', pretty_print=pretty_print)
        if self.DS_MONITOR_VM_DISK is not None:
            namespaceprefix_ = self.DS_MONITOR_VM_DISK_nsprefix_ + ':' if (UseCapturedNS_ and self.DS_MONITOR_VM_DISK_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDS_MONITOR_VM_DISK>%s</%sDS_MONITOR_VM_DISK>%s' % (namespaceprefix_ , self.gds_format_integer(self.DS_MONITOR_VM_DISK, input_name='DS_MONITOR_VM_DISK'), namespaceprefix_ , eol_))
        if self.ENABLE_OTHER_PERMISSIONS is not None:
            namespaceprefix_ = self.ENABLE_OTHER_PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.ENABLE_OTHER_PERMISSIONS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sENABLE_OTHER_PERMISSIONS>%s</%sENABLE_OTHER_PERMISSIONS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ENABLE_OTHER_PERMISSIONS), input_name='ENABLE_OTHER_PERMISSIONS')), namespaceprefix_ , eol_))
        if self.FEDERATION is not None:
            namespaceprefix_ = self.FEDERATION_nsprefix_ + ':' if (UseCapturedNS_ and self.FEDERATION_nsprefix_) else ''
            self.FEDERATION.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FEDERATION', pretty_print=pretty_print)
        for GROUP_RESTRICTED_ATTR_ in self.GROUP_RESTRICTED_ATTR:
            namespaceprefix_ = self.GROUP_RESTRICTED_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_RESTRICTED_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_RESTRICTED_ATTR>%s</%sGROUP_RESTRICTED_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(GROUP_RESTRICTED_ATTR_), input_name='GROUP_RESTRICTED_ATTR')), namespaceprefix_ , eol_))
        if self.HM_MAD is not None:
            namespaceprefix_ = self.HM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.HM_MAD_nsprefix_) else ''
            self.HM_MAD.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HM_MAD', pretty_print=pretty_print)
        if self.HOOK_LOG_CONF is not None:
            namespaceprefix_ = self.HOOK_LOG_CONF_nsprefix_ + ':' if (UseCapturedNS_ and self.HOOK_LOG_CONF_nsprefix_) else ''
            self.HOOK_LOG_CONF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HOOK_LOG_CONF', pretty_print=pretty_print)
        for HOST_ENCRYPTED_ATTR_ in self.HOST_ENCRYPTED_ATTR:
            namespaceprefix_ = self.HOST_ENCRYPTED_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.HOST_ENCRYPTED_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHOST_ENCRYPTED_ATTR>%s</%sHOST_ENCRYPTED_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(HOST_ENCRYPTED_ATTR_), input_name='HOST_ENCRYPTED_ATTR')), namespaceprefix_ , eol_))
        for IMAGE_ENCRYPTED_ATTR_ in self.IMAGE_ENCRYPTED_ATTR:
            namespaceprefix_ = self.IMAGE_ENCRYPTED_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_ENCRYPTED_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIMAGE_ENCRYPTED_ATTR>%s</%sIMAGE_ENCRYPTED_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(IMAGE_ENCRYPTED_ATTR_), input_name='IMAGE_ENCRYPTED_ATTR')), namespaceprefix_ , eol_))
        for IMAGE_RESTRICTED_ATTR_ in self.IMAGE_RESTRICTED_ATTR:
            namespaceprefix_ = self.IMAGE_RESTRICTED_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_RESTRICTED_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIMAGE_RESTRICTED_ATTR>%s</%sIMAGE_RESTRICTED_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(IMAGE_RESTRICTED_ATTR_), input_name='IMAGE_RESTRICTED_ATTR')), namespaceprefix_ , eol_))
        for IM_MAD_ in self.IM_MAD:
            namespaceprefix_ = self.IM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.IM_MAD_nsprefix_) else ''
            IM_MAD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IM_MAD', pretty_print=pretty_print)
        for INHERIT_DATASTORE_ATTR_ in self.INHERIT_DATASTORE_ATTR:
            namespaceprefix_ = self.INHERIT_DATASTORE_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.INHERIT_DATASTORE_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINHERIT_DATASTORE_ATTR>%s</%sINHERIT_DATASTORE_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(INHERIT_DATASTORE_ATTR_), input_name='INHERIT_DATASTORE_ATTR')), namespaceprefix_ , eol_))
        for INHERIT_IMAGE_ATTR_ in self.INHERIT_IMAGE_ATTR:
            namespaceprefix_ = self.INHERIT_IMAGE_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.INHERIT_IMAGE_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINHERIT_IMAGE_ATTR>%s</%sINHERIT_IMAGE_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(INHERIT_IMAGE_ATTR_), input_name='INHERIT_IMAGE_ATTR')), namespaceprefix_ , eol_))
        for INHERIT_VNET_ATTR_ in self.INHERIT_VNET_ATTR:
            namespaceprefix_ = self.INHERIT_VNET_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.INHERIT_VNET_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINHERIT_VNET_ATTR>%s</%sINHERIT_VNET_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(INHERIT_VNET_ATTR_), input_name='INHERIT_VNET_ATTR')), namespaceprefix_ , eol_))
        for IPAM_MAD_ in self.IPAM_MAD:
            namespaceprefix_ = self.IPAM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.IPAM_MAD_nsprefix_) else ''
            IPAM_MAD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IPAM_MAD', pretty_print=pretty_print)
        for KEEPALIVE_MAX_CONN_ in self.KEEPALIVE_MAX_CONN:
            namespaceprefix_ = self.KEEPALIVE_MAX_CONN_nsprefix_ + ':' if (UseCapturedNS_ and self.KEEPALIVE_MAX_CONN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKEEPALIVE_MAX_CONN>%s</%sKEEPALIVE_MAX_CONN>%s' % (namespaceprefix_ , self.gds_format_integer(KEEPALIVE_MAX_CONN_, input_name='KEEPALIVE_MAX_CONN'), namespaceprefix_ , eol_))
        for KEEPALIVE_TIMEOUT_ in self.KEEPALIVE_TIMEOUT:
            namespaceprefix_ = self.KEEPALIVE_TIMEOUT_nsprefix_ + ':' if (UseCapturedNS_ and self.KEEPALIVE_TIMEOUT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKEEPALIVE_TIMEOUT>%s</%sKEEPALIVE_TIMEOUT>%s' % (namespaceprefix_ , self.gds_format_integer(KEEPALIVE_TIMEOUT_, input_name='KEEPALIVE_TIMEOUT'), namespaceprefix_ , eol_))
        for LISTEN_ADDRESS_ in self.LISTEN_ADDRESS:
            namespaceprefix_ = self.LISTEN_ADDRESS_nsprefix_ + ':' if (UseCapturedNS_ and self.LISTEN_ADDRESS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLISTEN_ADDRESS>%s</%sLISTEN_ADDRESS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(LISTEN_ADDRESS_), input_name='LISTEN_ADDRESS')), namespaceprefix_ , eol_))
        if self.LIVE_RESCHEDS is not None:
            namespaceprefix_ = self.LIVE_RESCHEDS_nsprefix_ + ':' if (UseCapturedNS_ and self.LIVE_RESCHEDS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLIVE_RESCHEDS>%s</%sLIVE_RESCHEDS>%s' % (namespaceprefix_ , self.gds_format_integer(self.LIVE_RESCHEDS, input_name='LIVE_RESCHEDS'), namespaceprefix_ , eol_))
        for LOG_ in self.LOG:
            namespaceprefix_ = self.LOG_nsprefix_ + ':' if (UseCapturedNS_ and self.LOG_nsprefix_) else ''
            LOG_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOG', pretty_print=pretty_print)
        for LOG_CALL_FORMAT_ in self.LOG_CALL_FORMAT:
            namespaceprefix_ = self.LOG_CALL_FORMAT_nsprefix_ + ':' if (UseCapturedNS_ and self.LOG_CALL_FORMAT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOG_CALL_FORMAT>%s</%sLOG_CALL_FORMAT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(LOG_CALL_FORMAT_), input_name='LOG_CALL_FORMAT')), namespaceprefix_ , eol_))
        for MAC_PREFIX_ in self.MAC_PREFIX:
            namespaceprefix_ = self.MAC_PREFIX_nsprefix_ + ':' if (UseCapturedNS_ and self.MAC_PREFIX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAC_PREFIX>%s</%sMAC_PREFIX>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(MAC_PREFIX_), input_name='MAC_PREFIX')), namespaceprefix_ , eol_))
        for MANAGER_TIMER_ in self.MANAGER_TIMER:
            namespaceprefix_ = self.MANAGER_TIMER_nsprefix_ + ':' if (UseCapturedNS_ and self.MANAGER_TIMER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMANAGER_TIMER>%s</%sMANAGER_TIMER>%s' % (namespaceprefix_ , self.gds_format_integer(MANAGER_TIMER_, input_name='MANAGER_TIMER'), namespaceprefix_ , eol_))
        for MARKET_MAD_ in self.MARKET_MAD:
            namespaceprefix_ = self.MARKET_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.MARKET_MAD_nsprefix_) else ''
            MARKET_MAD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MARKET_MAD', pretty_print=pretty_print)
        for MARKET_MAD_CONF_ in self.MARKET_MAD_CONF:
            namespaceprefix_ = self.MARKET_MAD_CONF_nsprefix_ + ':' if (UseCapturedNS_ and self.MARKET_MAD_CONF_nsprefix_) else ''
            MARKET_MAD_CONF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MARKET_MAD_CONF', pretty_print=pretty_print)
        if self.MAX_ACTIONS_PER_CLUSTER is not None:
            namespaceprefix_ = self.MAX_ACTIONS_PER_CLUSTER_nsprefix_ + ':' if (UseCapturedNS_ and self.MAX_ACTIONS_PER_CLUSTER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAX_ACTIONS_PER_CLUSTER>%s</%sMAX_ACTIONS_PER_CLUSTER>%s' % (namespaceprefix_ , self.gds_format_integer(self.MAX_ACTIONS_PER_CLUSTER, input_name='MAX_ACTIONS_PER_CLUSTER'), namespaceprefix_ , eol_))
        if self.MAX_ACTIONS_PER_HOST is not None:
            namespaceprefix_ = self.MAX_ACTIONS_PER_HOST_nsprefix_ + ':' if (UseCapturedNS_ and self.MAX_ACTIONS_PER_HOST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAX_ACTIONS_PER_HOST>%s</%sMAX_ACTIONS_PER_HOST>%s' % (namespaceprefix_ , self.gds_format_integer(self.MAX_ACTIONS_PER_HOST, input_name='MAX_ACTIONS_PER_HOST'), namespaceprefix_ , eol_))
        if self.MAX_BACKUPS is not None:
            namespaceprefix_ = self.MAX_BACKUPS_nsprefix_ + ':' if (UseCapturedNS_ and self.MAX_BACKUPS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAX_BACKUPS>%s</%sMAX_BACKUPS>%s' % (namespaceprefix_ , self.gds_format_integer(self.MAX_BACKUPS, input_name='MAX_BACKUPS'), namespaceprefix_ , eol_))
        if self.MAX_BACKUPS_HOST is not None:
            namespaceprefix_ = self.MAX_BACKUPS_HOST_nsprefix_ + ':' if (UseCapturedNS_ and self.MAX_BACKUPS_HOST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAX_BACKUPS_HOST>%s</%sMAX_BACKUPS_HOST>%s' % (namespaceprefix_ , self.gds_format_integer(self.MAX_BACKUPS_HOST, input_name='MAX_BACKUPS_HOST'), namespaceprefix_ , eol_))
        if self.MAX_CONN is not None:
            namespaceprefix_ = self.MAX_CONN_nsprefix_ + ':' if (UseCapturedNS_ and self.MAX_CONN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAX_CONN>%s</%sMAX_CONN>%s' % (namespaceprefix_ , self.gds_format_integer(self.MAX_CONN, input_name='MAX_CONN'), namespaceprefix_ , eol_))
        if self.MAX_CONN_BACKLOG is not None:
            namespaceprefix_ = self.MAX_CONN_BACKLOG_nsprefix_ + ':' if (UseCapturedNS_ and self.MAX_CONN_BACKLOG_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAX_CONN_BACKLOG>%s</%sMAX_CONN_BACKLOG>%s' % (namespaceprefix_ , self.gds_format_integer(self.MAX_CONN_BACKLOG, input_name='MAX_CONN_BACKLOG'), namespaceprefix_ , eol_))
        if self.MESSAGE_SIZE is not None:
            namespaceprefix_ = self.MESSAGE_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.MESSAGE_SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMESSAGE_SIZE>%s</%sMESSAGE_SIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.MESSAGE_SIZE, input_name='MESSAGE_SIZE'), namespaceprefix_ , eol_))
        if self.MONITORING_INTERVAL_DATASTORE is not None:
            namespaceprefix_ = self.MONITORING_INTERVAL_DATASTORE_nsprefix_ + ':' if (UseCapturedNS_ and self.MONITORING_INTERVAL_DATASTORE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMONITORING_INTERVAL_DATASTORE>%s</%sMONITORING_INTERVAL_DATASTORE>%s' % (namespaceprefix_ , self.gds_format_integer(self.MONITORING_INTERVAL_DATASTORE, input_name='MONITORING_INTERVAL_DATASTORE'), namespaceprefix_ , eol_))
        if self.MONITORING_INTERVAL_HOST is not None:
            namespaceprefix_ = self.MONITORING_INTERVAL_HOST_nsprefix_ + ':' if (UseCapturedNS_ and self.MONITORING_INTERVAL_HOST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMONITORING_INTERVAL_HOST>%s</%sMONITORING_INTERVAL_HOST>%s' % (namespaceprefix_ , self.gds_format_integer(self.MONITORING_INTERVAL_HOST, input_name='MONITORING_INTERVAL_HOST'), namespaceprefix_ , eol_))
        if self.MONITORING_INTERVAL_MARKET is not None:
            namespaceprefix_ = self.MONITORING_INTERVAL_MARKET_nsprefix_ + ':' if (UseCapturedNS_ and self.MONITORING_INTERVAL_MARKET_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMONITORING_INTERVAL_MARKET>%s</%sMONITORING_INTERVAL_MARKET>%s' % (namespaceprefix_ , self.gds_format_integer(self.MONITORING_INTERVAL_MARKET, input_name='MONITORING_INTERVAL_MARKET'), namespaceprefix_ , eol_))
        if self.MONITORING_INTERVAL_VM is not None:
            namespaceprefix_ = self.MONITORING_INTERVAL_VM_nsprefix_ + ':' if (UseCapturedNS_ and self.MONITORING_INTERVAL_VM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMONITORING_INTERVAL_VM>%s</%sMONITORING_INTERVAL_VM>%s' % (namespaceprefix_ , self.gds_format_integer(self.MONITORING_INTERVAL_VM, input_name='MONITORING_INTERVAL_VM'), namespaceprefix_ , eol_))
        if self.NETWORK_SIZE is not None:
            namespaceprefix_ = self.NETWORK_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.NETWORK_SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETWORK_SIZE>%s</%sNETWORK_SIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.NETWORK_SIZE, input_name='NETWORK_SIZE'), namespaceprefix_ , eol_))
        for ONE_KEY_ in self.ONE_KEY:
            namespaceprefix_ = self.ONE_KEY_nsprefix_ + ':' if (UseCapturedNS_ and self.ONE_KEY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sONE_KEY>%s</%sONE_KEY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ONE_KEY_), input_name='ONE_KEY')), namespaceprefix_ , eol_))
        if self.PCI_PASSTHROUGH_BUS is not None:
            namespaceprefix_ = self.PCI_PASSTHROUGH_BUS_nsprefix_ + ':' if (UseCapturedNS_ and self.PCI_PASSTHROUGH_BUS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPCI_PASSTHROUGH_BUS>%s</%sPCI_PASSTHROUGH_BUS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PCI_PASSTHROUGH_BUS), input_name='PCI_PASSTHROUGH_BUS')), namespaceprefix_ , eol_))
        if self.PORT is not None:
            namespaceprefix_ = self.PORT_nsprefix_ + ':' if (UseCapturedNS_ and self.PORT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPORT>%s</%sPORT>%s' % (namespaceprefix_ , self.gds_format_integer(self.PORT, input_name='PORT'), namespaceprefix_ , eol_))
        if self.RAFT is not None:
            namespaceprefix_ = self.RAFT_nsprefix_ + ':' if (UseCapturedNS_ and self.RAFT_nsprefix_) else ''
            self.RAFT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RAFT', pretty_print=pretty_print)
        if self.RPC_LOG is not None:
            namespaceprefix_ = self.RPC_LOG_nsprefix_ + ':' if (UseCapturedNS_ and self.RPC_LOG_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRPC_LOG>%s</%sRPC_LOG>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RPC_LOG), input_name='RPC_LOG')), namespaceprefix_ , eol_))
        if self.SCHED_MAD is not None:
            namespaceprefix_ = self.SCHED_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_MAD_nsprefix_) else ''
            self.SCHED_MAD.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SCHED_MAD', pretty_print=pretty_print)
        if self.SCHED_MAX_WND_LENGTH is not None:
            namespaceprefix_ = self.SCHED_MAX_WND_LENGTH_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_MAX_WND_LENGTH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCHED_MAX_WND_LENGTH>%s</%sSCHED_MAX_WND_LENGTH>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCHED_MAX_WND_LENGTH), input_name='SCHED_MAX_WND_LENGTH')), namespaceprefix_ , eol_))
        if self.SCHED_MAX_WND_TIME is not None:
            namespaceprefix_ = self.SCHED_MAX_WND_TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_MAX_WND_TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCHED_MAX_WND_TIME>%s</%sSCHED_MAX_WND_TIME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCHED_MAX_WND_TIME), input_name='SCHED_MAX_WND_TIME')), namespaceprefix_ , eol_))
        if self.SCHED_RETRY_TIME is not None:
            namespaceprefix_ = self.SCHED_RETRY_TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_RETRY_TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCHED_RETRY_TIME>%s</%sSCHED_RETRY_TIME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCHED_RETRY_TIME), input_name='SCHED_RETRY_TIME')), namespaceprefix_ , eol_))
        if self.SCRIPTS_REMOTE_DIR is not None:
            namespaceprefix_ = self.SCRIPTS_REMOTE_DIR_nsprefix_ + ':' if (UseCapturedNS_ and self.SCRIPTS_REMOTE_DIR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCRIPTS_REMOTE_DIR>%s</%sSCRIPTS_REMOTE_DIR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCRIPTS_REMOTE_DIR), input_name='SCRIPTS_REMOTE_DIR')), namespaceprefix_ , eol_))
        if self.SESSION_EXPIRATION_TIME is not None:
            namespaceprefix_ = self.SESSION_EXPIRATION_TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.SESSION_EXPIRATION_TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSESSION_EXPIRATION_TIME>%s</%sSESSION_EXPIRATION_TIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.SESSION_EXPIRATION_TIME, input_name='SESSION_EXPIRATION_TIME'), namespaceprefix_ , eol_))
        if self.SHOWBACK_ONLY_RUNNING is not None:
            namespaceprefix_ = self.SHOWBACK_ONLY_RUNNING_nsprefix_ + ':' if (UseCapturedNS_ and self.SHOWBACK_ONLY_RUNNING_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHOWBACK_ONLY_RUNNING>%s</%sSHOWBACK_ONLY_RUNNING>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHOWBACK_ONLY_RUNNING), input_name='SHOWBACK_ONLY_RUNNING')), namespaceprefix_ , eol_))
        if self.TIMEOUT is not None:
            namespaceprefix_ = self.TIMEOUT_nsprefix_ + ':' if (UseCapturedNS_ and self.TIMEOUT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIMEOUT>%s</%sTIMEOUT>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIMEOUT, input_name='TIMEOUT'), namespaceprefix_ , eol_))
        for TM_MAD_ in self.TM_MAD:
            namespaceprefix_ = self.TM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.TM_MAD_nsprefix_) else ''
            TM_MAD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TM_MAD', pretty_print=pretty_print)
        for TM_MAD_CONF_ in self.TM_MAD_CONF:
            namespaceprefix_ = self.TM_MAD_CONF_nsprefix_ + ':' if (UseCapturedNS_ and self.TM_MAD_CONF_nsprefix_) else ''
            TM_MAD_CONF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TM_MAD_CONF', pretty_print=pretty_print)
        for USER_ENCRYPTED_ATTR_ in self.USER_ENCRYPTED_ATTR:
            namespaceprefix_ = self.USER_ENCRYPTED_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.USER_ENCRYPTED_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSER_ENCRYPTED_ATTR>%s</%sUSER_ENCRYPTED_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(USER_ENCRYPTED_ATTR_), input_name='USER_ENCRYPTED_ATTR')), namespaceprefix_ , eol_))
        for USER_RESTRICTED_ATTR_ in self.USER_RESTRICTED_ATTR:
            namespaceprefix_ = self.USER_RESTRICTED_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.USER_RESTRICTED_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSER_RESTRICTED_ATTR>%s</%sUSER_RESTRICTED_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(USER_RESTRICTED_ATTR_), input_name='USER_RESTRICTED_ATTR')), namespaceprefix_ , eol_))
        if self.VLAN_IDS is not None:
            namespaceprefix_ = self.VLAN_IDS_nsprefix_ + ':' if (UseCapturedNS_ and self.VLAN_IDS_nsprefix_) else ''
            self.VLAN_IDS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VLAN_IDS', pretty_print=pretty_print)
        if self.VM_ADMIN_OPERATIONS is not None:
            namespaceprefix_ = self.VM_ADMIN_OPERATIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_ADMIN_OPERATIONS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM_ADMIN_OPERATIONS>%s</%sVM_ADMIN_OPERATIONS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VM_ADMIN_OPERATIONS), input_name='VM_ADMIN_OPERATIONS')), namespaceprefix_ , eol_))
        for VM_ENCRYPTED_ATTR_ in self.VM_ENCRYPTED_ATTR:
            namespaceprefix_ = self.VM_ENCRYPTED_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_ENCRYPTED_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM_ENCRYPTED_ATTR>%s</%sVM_ENCRYPTED_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(VM_ENCRYPTED_ATTR_), input_name='VM_ENCRYPTED_ATTR')), namespaceprefix_ , eol_))
        for VM_MAD_ in self.VM_MAD:
            namespaceprefix_ = self.VM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_MAD_nsprefix_) else ''
            VM_MAD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM_MAD', pretty_print=pretty_print)
        if self.VM_MANAGE_OPERATIONS is not None:
            namespaceprefix_ = self.VM_MANAGE_OPERATIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_MANAGE_OPERATIONS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM_MANAGE_OPERATIONS>%s</%sVM_MANAGE_OPERATIONS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VM_MANAGE_OPERATIONS), input_name='VM_MANAGE_OPERATIONS')), namespaceprefix_ , eol_))
        for VM_MONITORING_EXPIRATION_TIME_ in self.VM_MONITORING_EXPIRATION_TIME:
            namespaceprefix_ = self.VM_MONITORING_EXPIRATION_TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_MONITORING_EXPIRATION_TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM_MONITORING_EXPIRATION_TIME>%s</%sVM_MONITORING_EXPIRATION_TIME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(VM_MONITORING_EXPIRATION_TIME_), input_name='VM_MONITORING_EXPIRATION_TIME')), namespaceprefix_ , eol_))
        for VM_RESTRICTED_ATTR_ in self.VM_RESTRICTED_ATTR:
            namespaceprefix_ = self.VM_RESTRICTED_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_RESTRICTED_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM_RESTRICTED_ATTR>%s</%sVM_RESTRICTED_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(VM_RESTRICTED_ATTR_), input_name='VM_RESTRICTED_ATTR')), namespaceprefix_ , eol_))
        if self.VM_SNAPSHOT_FACTOR is not None:
            namespaceprefix_ = self.VM_SNAPSHOT_FACTOR_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_SNAPSHOT_FACTOR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM_SNAPSHOT_FACTOR>%s</%sVM_SNAPSHOT_FACTOR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VM_SNAPSHOT_FACTOR), input_name='VM_SNAPSHOT_FACTOR')), namespaceprefix_ , eol_))
        if self.VM_SUBMIT_ON_HOLD is not None:
            namespaceprefix_ = self.VM_SUBMIT_ON_HOLD_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_SUBMIT_ON_HOLD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM_SUBMIT_ON_HOLD>%s</%sVM_SUBMIT_ON_HOLD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VM_SUBMIT_ON_HOLD), input_name='VM_SUBMIT_ON_HOLD')), namespaceprefix_ , eol_))
        for VM_USE_OPERATIONS_ in self.VM_USE_OPERATIONS:
            namespaceprefix_ = self.VM_USE_OPERATIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_USE_OPERATIONS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM_USE_OPERATIONS>%s</%sVM_USE_OPERATIONS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(VM_USE_OPERATIONS_), input_name='VM_USE_OPERATIONS')), namespaceprefix_ , eol_))
        if self.VNC_PORTS is not None:
            namespaceprefix_ = self.VNC_PORTS_nsprefix_ + ':' if (UseCapturedNS_ and self.VNC_PORTS_nsprefix_) else ''
            self.VNC_PORTS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VNC_PORTS', pretty_print=pretty_print)
        for VNET_ENCRYPTED_ATTR_ in self.VNET_ENCRYPTED_ATTR:
            namespaceprefix_ = self.VNET_ENCRYPTED_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.VNET_ENCRYPTED_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVNET_ENCRYPTED_ATTR>%s</%sVNET_ENCRYPTED_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(VNET_ENCRYPTED_ATTR_), input_name='VNET_ENCRYPTED_ATTR')), namespaceprefix_ , eol_))
        for VNET_RESTRICTED_ATTR_ in self.VNET_RESTRICTED_ATTR:
            namespaceprefix_ = self.VNET_RESTRICTED_ATTR_nsprefix_ + ':' if (UseCapturedNS_ and self.VNET_RESTRICTED_ATTR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVNET_RESTRICTED_ATTR>%s</%sVNET_RESTRICTED_ATTR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(VNET_RESTRICTED_ATTR_), input_name='VNET_RESTRICTED_ATTR')), namespaceprefix_ , eol_))
        for VN_MAD_CONF_ in self.VN_MAD_CONF:
            namespaceprefix_ = self.VN_MAD_CONF_nsprefix_ + ':' if (UseCapturedNS_ and self.VN_MAD_CONF_nsprefix_) else ''
            VN_MAD_CONF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VN_MAD_CONF', pretty_print=pretty_print)
        if self.VXLAN_IDS is not None:
            namespaceprefix_ = self.VXLAN_IDS_nsprefix_ + ':' if (UseCapturedNS_ and self.VXLAN_IDS_nsprefix_) else ''
            self.VXLAN_IDS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VXLAN_IDS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ACTION_TIMEOUT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ACTION_TIMEOUT')
            ival_ = self.gds_validate_integer(ival_, node, 'ACTION_TIMEOUT')
            self.ACTION_TIMEOUT = ival_
            self.ACTION_TIMEOUT_nsprefix_ = child_.prefix
        elif nodeName_ == 'API_LIST_ORDER':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'API_LIST_ORDER')
            value_ = self.gds_validate_string(value_, node, 'API_LIST_ORDER')
            self.API_LIST_ORDER.append(value_)
            self.API_LIST_ORDER_nsprefix_ = child_.prefix
        elif nodeName_ == 'AUTH_MAD':
            obj_ = AUTH_MADType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AUTH_MAD.append(obj_)
            obj_.original_tagname_ = 'AUTH_MAD'
        elif nodeName_ == 'AUTH_MAD_CONF':
            obj_ = AUTH_MAD_CONFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AUTH_MAD_CONF.append(obj_)
            obj_.original_tagname_ = 'AUTH_MAD_CONF'
        elif nodeName_ == 'CLUSTER_ENCRYPTED_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CLUSTER_ENCRYPTED_ATTR')
            value_ = self.gds_validate_string(value_, node, 'CLUSTER_ENCRYPTED_ATTR')
            self.CLUSTER_ENCRYPTED_ATTR.append(value_)
            self.CLUSTER_ENCRYPTED_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'COLD_MIGRATE_MODE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'COLD_MIGRATE_MODE')
            ival_ = self.gds_validate_integer(ival_, node, 'COLD_MIGRATE_MODE')
            self.COLD_MIGRATE_MODE = ival_
            self.COLD_MIGRATE_MODE_nsprefix_ = child_.prefix
        elif nodeName_ == 'CONTEXT_ALLOW_ETH_UPDATES':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CONTEXT_ALLOW_ETH_UPDATES')
            value_ = self.gds_validate_string(value_, node, 'CONTEXT_ALLOW_ETH_UPDATES')
            self.CONTEXT_ALLOW_ETH_UPDATES = value_
            self.CONTEXT_ALLOW_ETH_UPDATES_nsprefix_ = child_.prefix
        elif nodeName_ == 'CONTEXT_RESTRICTED_DIRS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CONTEXT_RESTRICTED_DIRS')
            value_ = self.gds_validate_string(value_, node, 'CONTEXT_RESTRICTED_DIRS')
            self.CONTEXT_RESTRICTED_DIRS = value_
            self.CONTEXT_RESTRICTED_DIRS_nsprefix_ = child_.prefix
        elif nodeName_ == 'CONTEXT_SAFE_DIRS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CONTEXT_SAFE_DIRS')
            value_ = self.gds_validate_string(value_, node, 'CONTEXT_SAFE_DIRS')
            self.CONTEXT_SAFE_DIRS = value_
            self.CONTEXT_SAFE_DIRS_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATASTORE_CAPACITY_CHECK':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DATASTORE_CAPACITY_CHECK')
            value_ = self.gds_validate_string(value_, node, 'DATASTORE_CAPACITY_CHECK')
            self.DATASTORE_CAPACITY_CHECK.append(value_)
            self.DATASTORE_CAPACITY_CHECK_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATASTORE_ENCRYPTED_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DATASTORE_ENCRYPTED_ATTR')
            value_ = self.gds_validate_string(value_, node, 'DATASTORE_ENCRYPTED_ATTR')
            self.DATASTORE_ENCRYPTED_ATTR.append(value_)
            self.DATASTORE_ENCRYPTED_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATASTORE_LOCATION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DATASTORE_LOCATION')
            value_ = self.gds_validate_string(value_, node, 'DATASTORE_LOCATION')
            self.DATASTORE_LOCATION.append(value_)
            self.DATASTORE_LOCATION_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATASTORE_MAD':
            obj_ = DATASTORE_MADType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORE_MAD.append(obj_)
            obj_.original_tagname_ = 'DATASTORE_MAD'
        elif nodeName_ == 'DB':
            obj_ = DBType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DB = obj_
            obj_.original_tagname_ = 'DB'
        elif nodeName_ == 'DEFAULT_AUTH':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT_AUTH')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT_AUTH')
            self.DEFAULT_AUTH.append(value_)
            self.DEFAULT_AUTH_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEFAULT_CDROM_DEVICE_PREFIX':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT_CDROM_DEVICE_PREFIX')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT_CDROM_DEVICE_PREFIX')
            self.DEFAULT_CDROM_DEVICE_PREFIX.append(value_)
            self.DEFAULT_CDROM_DEVICE_PREFIX_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEFAULT_COST':
            obj_ = DEFAULT_COSTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DEFAULT_COST.append(obj_)
            obj_.original_tagname_ = 'DEFAULT_COST'
        elif nodeName_ == 'DEFAULT_DEVICE_PREFIX':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT_DEVICE_PREFIX')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT_DEVICE_PREFIX')
            self.DEFAULT_DEVICE_PREFIX.append(value_)
            self.DEFAULT_DEVICE_PREFIX_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEFAULT_IMAGE_PERSISTENT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT_IMAGE_PERSISTENT')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT_IMAGE_PERSISTENT')
            self.DEFAULT_IMAGE_PERSISTENT.append(value_)
            self.DEFAULT_IMAGE_PERSISTENT_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEFAULT_IMAGE_PERSISTENT_NEW':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT_IMAGE_PERSISTENT_NEW')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT_IMAGE_PERSISTENT_NEW')
            self.DEFAULT_IMAGE_PERSISTENT_NEW.append(value_)
            self.DEFAULT_IMAGE_PERSISTENT_NEW_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEFAULT_IMAGE_TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT_IMAGE_TYPE')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT_IMAGE_TYPE')
            self.DEFAULT_IMAGE_TYPE.append(value_)
            self.DEFAULT_IMAGE_TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEFAULT_UMASK':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT_UMASK')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT_UMASK')
            self.DEFAULT_UMASK.append(value_)
            self.DEFAULT_UMASK_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEFAULT_VDC_CLUSTER_DATASTORE_ACL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT_VDC_CLUSTER_DATASTORE_ACL')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT_VDC_CLUSTER_DATASTORE_ACL')
            self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL.append(value_)
            self.DEFAULT_VDC_CLUSTER_DATASTORE_ACL_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEFAULT_VDC_CLUSTER_HOST_ACL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT_VDC_CLUSTER_HOST_ACL')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT_VDC_CLUSTER_HOST_ACL')
            self.DEFAULT_VDC_CLUSTER_HOST_ACL.append(value_)
            self.DEFAULT_VDC_CLUSTER_HOST_ACL_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEFAULT_VDC_CLUSTER_NET_ACL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT_VDC_CLUSTER_NET_ACL')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT_VDC_CLUSTER_NET_ACL')
            self.DEFAULT_VDC_CLUSTER_NET_ACL.append(value_)
            self.DEFAULT_VDC_CLUSTER_NET_ACL_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEFAULT_VDC_DATASTORE_ACL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT_VDC_DATASTORE_ACL')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT_VDC_DATASTORE_ACL')
            self.DEFAULT_VDC_DATASTORE_ACL.append(value_)
            self.DEFAULT_VDC_DATASTORE_ACL_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEFAULT_VDC_HOST_ACL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT_VDC_HOST_ACL')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT_VDC_HOST_ACL')
            self.DEFAULT_VDC_HOST_ACL.append(value_)
            self.DEFAULT_VDC_HOST_ACL_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEFAULT_VDC_VNET_ACL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT_VDC_VNET_ACL')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT_VDC_VNET_ACL')
            self.DEFAULT_VDC_VNET_ACL.append(value_)
            self.DEFAULT_VDC_VNET_ACL_nsprefix_ = child_.prefix
        elif nodeName_ == 'DOCUMENT_ENCRYPTED_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DOCUMENT_ENCRYPTED_ATTR')
            value_ = self.gds_validate_string(value_, node, 'DOCUMENT_ENCRYPTED_ATTR')
            self.DOCUMENT_ENCRYPTED_ATTR.append(value_)
            self.DOCUMENT_ENCRYPTED_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'DRS_INTERVAL' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DRS_INTERVAL')
            ival_ = self.gds_validate_integer(ival_, node, 'DRS_INTERVAL')
            self.DRS_INTERVAL = ival_
            self.DRS_INTERVAL_nsprefix_ = child_.prefix
        elif nodeName_ == 'DS_MAD_CONF':
            obj_ = DS_MAD_CONFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DS_MAD_CONF.append(obj_)
            obj_.original_tagname_ = 'DS_MAD_CONF'
        elif nodeName_ == 'DS_MONITOR_VM_DISK' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DS_MONITOR_VM_DISK')
            ival_ = self.gds_validate_integer(ival_, node, 'DS_MONITOR_VM_DISK')
            self.DS_MONITOR_VM_DISK = ival_
            self.DS_MONITOR_VM_DISK_nsprefix_ = child_.prefix
        elif nodeName_ == 'ENABLE_OTHER_PERMISSIONS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ENABLE_OTHER_PERMISSIONS')
            value_ = self.gds_validate_string(value_, node, 'ENABLE_OTHER_PERMISSIONS')
            self.ENABLE_OTHER_PERMISSIONS = value_
            self.ENABLE_OTHER_PERMISSIONS_nsprefix_ = child_.prefix
            # validate type ENABLE_OTHER_PERMISSIONSType
            self.validate_ENABLE_OTHER_PERMISSIONSType(self.ENABLE_OTHER_PERMISSIONS)
        elif nodeName_ == 'FEDERATION':
            obj_ = FEDERATIONType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FEDERATION = obj_
            obj_.original_tagname_ = 'FEDERATION'
        elif nodeName_ == 'GROUP_RESTRICTED_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GROUP_RESTRICTED_ATTR')
            value_ = self.gds_validate_string(value_, node, 'GROUP_RESTRICTED_ATTR')
            self.GROUP_RESTRICTED_ATTR.append(value_)
            self.GROUP_RESTRICTED_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'HM_MAD':
            obj_ = HM_MADType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HM_MAD = obj_
            obj_.original_tagname_ = 'HM_MAD'
        elif nodeName_ == 'HOOK_LOG_CONF':
            obj_ = HOOK_LOG_CONFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HOOK_LOG_CONF = obj_
            obj_.original_tagname_ = 'HOOK_LOG_CONF'
        elif nodeName_ == 'HOST_ENCRYPTED_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'HOST_ENCRYPTED_ATTR')
            value_ = self.gds_validate_string(value_, node, 'HOST_ENCRYPTED_ATTR')
            self.HOST_ENCRYPTED_ATTR.append(value_)
            self.HOST_ENCRYPTED_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'IMAGE_ENCRYPTED_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IMAGE_ENCRYPTED_ATTR')
            value_ = self.gds_validate_string(value_, node, 'IMAGE_ENCRYPTED_ATTR')
            self.IMAGE_ENCRYPTED_ATTR.append(value_)
            self.IMAGE_ENCRYPTED_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'IMAGE_RESTRICTED_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IMAGE_RESTRICTED_ATTR')
            value_ = self.gds_validate_string(value_, node, 'IMAGE_RESTRICTED_ATTR')
            self.IMAGE_RESTRICTED_ATTR.append(value_)
            self.IMAGE_RESTRICTED_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'IM_MAD':
            obj_ = IM_MADType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IM_MAD.append(obj_)
            obj_.original_tagname_ = 'IM_MAD'
        elif nodeName_ == 'INHERIT_DATASTORE_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INHERIT_DATASTORE_ATTR')
            value_ = self.gds_validate_string(value_, node, 'INHERIT_DATASTORE_ATTR')
            self.INHERIT_DATASTORE_ATTR.append(value_)
            self.INHERIT_DATASTORE_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'INHERIT_IMAGE_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INHERIT_IMAGE_ATTR')
            value_ = self.gds_validate_string(value_, node, 'INHERIT_IMAGE_ATTR')
            self.INHERIT_IMAGE_ATTR.append(value_)
            self.INHERIT_IMAGE_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'INHERIT_VNET_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INHERIT_VNET_ATTR')
            value_ = self.gds_validate_string(value_, node, 'INHERIT_VNET_ATTR')
            self.INHERIT_VNET_ATTR.append(value_)
            self.INHERIT_VNET_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'IPAM_MAD':
            obj_ = IPAM_MADType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IPAM_MAD.append(obj_)
            obj_.original_tagname_ = 'IPAM_MAD'
        elif nodeName_ == 'KEEPALIVE_MAX_CONN' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'KEEPALIVE_MAX_CONN')
            ival_ = self.gds_validate_integer(ival_, node, 'KEEPALIVE_MAX_CONN')
            self.KEEPALIVE_MAX_CONN.append(ival_)
            self.KEEPALIVE_MAX_CONN_nsprefix_ = child_.prefix
        elif nodeName_ == 'KEEPALIVE_TIMEOUT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'KEEPALIVE_TIMEOUT')
            ival_ = self.gds_validate_integer(ival_, node, 'KEEPALIVE_TIMEOUT')
            self.KEEPALIVE_TIMEOUT.append(ival_)
            self.KEEPALIVE_TIMEOUT_nsprefix_ = child_.prefix
        elif nodeName_ == 'LISTEN_ADDRESS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LISTEN_ADDRESS')
            value_ = self.gds_validate_string(value_, node, 'LISTEN_ADDRESS')
            self.LISTEN_ADDRESS.append(value_)
            self.LISTEN_ADDRESS_nsprefix_ = child_.prefix
        elif nodeName_ == 'LIVE_RESCHEDS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LIVE_RESCHEDS')
            ival_ = self.gds_validate_integer(ival_, node, 'LIVE_RESCHEDS')
            self.LIVE_RESCHEDS = ival_
            self.LIVE_RESCHEDS_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOG':
            obj_ = LOGType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOG.append(obj_)
            obj_.original_tagname_ = 'LOG'
        elif nodeName_ == 'LOG_CALL_FORMAT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LOG_CALL_FORMAT')
            value_ = self.gds_validate_string(value_, node, 'LOG_CALL_FORMAT')
            self.LOG_CALL_FORMAT.append(value_)
            self.LOG_CALL_FORMAT_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAC_PREFIX':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MAC_PREFIX')
            value_ = self.gds_validate_string(value_, node, 'MAC_PREFIX')
            self.MAC_PREFIX.append(value_)
            self.MAC_PREFIX_nsprefix_ = child_.prefix
        elif nodeName_ == 'MANAGER_TIMER' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MANAGER_TIMER')
            ival_ = self.gds_validate_integer(ival_, node, 'MANAGER_TIMER')
            self.MANAGER_TIMER.append(ival_)
            self.MANAGER_TIMER_nsprefix_ = child_.prefix
        elif nodeName_ == 'MARKET_MAD':
            obj_ = MARKET_MADType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MARKET_MAD.append(obj_)
            obj_.original_tagname_ = 'MARKET_MAD'
        elif nodeName_ == 'MARKET_MAD_CONF':
            obj_ = MARKET_MAD_CONFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MARKET_MAD_CONF.append(obj_)
            obj_.original_tagname_ = 'MARKET_MAD_CONF'
        elif nodeName_ == 'MAX_ACTIONS_PER_CLUSTER' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MAX_ACTIONS_PER_CLUSTER')
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_ACTIONS_PER_CLUSTER')
            self.MAX_ACTIONS_PER_CLUSTER = ival_
            self.MAX_ACTIONS_PER_CLUSTER_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAX_ACTIONS_PER_HOST' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MAX_ACTIONS_PER_HOST')
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_ACTIONS_PER_HOST')
            self.MAX_ACTIONS_PER_HOST = ival_
            self.MAX_ACTIONS_PER_HOST_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAX_BACKUPS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MAX_BACKUPS')
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_BACKUPS')
            self.MAX_BACKUPS = ival_
            self.MAX_BACKUPS_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAX_BACKUPS_HOST' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MAX_BACKUPS_HOST')
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_BACKUPS_HOST')
            self.MAX_BACKUPS_HOST = ival_
            self.MAX_BACKUPS_HOST_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAX_CONN' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MAX_CONN')
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_CONN')
            self.MAX_CONN = ival_
            self.MAX_CONN_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAX_CONN_BACKLOG' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MAX_CONN_BACKLOG')
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_CONN_BACKLOG')
            self.MAX_CONN_BACKLOG = ival_
            self.MAX_CONN_BACKLOG_nsprefix_ = child_.prefix
        elif nodeName_ == 'MESSAGE_SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MESSAGE_SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'MESSAGE_SIZE')
            self.MESSAGE_SIZE = ival_
            self.MESSAGE_SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'MONITORING_INTERVAL_DATASTORE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MONITORING_INTERVAL_DATASTORE')
            ival_ = self.gds_validate_integer(ival_, node, 'MONITORING_INTERVAL_DATASTORE')
            self.MONITORING_INTERVAL_DATASTORE = ival_
            self.MONITORING_INTERVAL_DATASTORE_nsprefix_ = child_.prefix
        elif nodeName_ == 'MONITORING_INTERVAL_HOST' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MONITORING_INTERVAL_HOST')
            ival_ = self.gds_validate_integer(ival_, node, 'MONITORING_INTERVAL_HOST')
            self.MONITORING_INTERVAL_HOST = ival_
            self.MONITORING_INTERVAL_HOST_nsprefix_ = child_.prefix
        elif nodeName_ == 'MONITORING_INTERVAL_MARKET' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MONITORING_INTERVAL_MARKET')
            ival_ = self.gds_validate_integer(ival_, node, 'MONITORING_INTERVAL_MARKET')
            self.MONITORING_INTERVAL_MARKET = ival_
            self.MONITORING_INTERVAL_MARKET_nsprefix_ = child_.prefix
        elif nodeName_ == 'MONITORING_INTERVAL_VM' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MONITORING_INTERVAL_VM')
            ival_ = self.gds_validate_integer(ival_, node, 'MONITORING_INTERVAL_VM')
            self.MONITORING_INTERVAL_VM = ival_
            self.MONITORING_INTERVAL_VM_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETWORK_SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NETWORK_SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'NETWORK_SIZE')
            self.NETWORK_SIZE = ival_
            self.NETWORK_SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'ONE_KEY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ONE_KEY')
            value_ = self.gds_validate_string(value_, node, 'ONE_KEY')
            self.ONE_KEY.append(value_)
            self.ONE_KEY_nsprefix_ = child_.prefix
        elif nodeName_ == 'PCI_PASSTHROUGH_BUS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PCI_PASSTHROUGH_BUS')
            value_ = self.gds_validate_string(value_, node, 'PCI_PASSTHROUGH_BUS')
            self.PCI_PASSTHROUGH_BUS = value_
            self.PCI_PASSTHROUGH_BUS_nsprefix_ = child_.prefix
        elif nodeName_ == 'PORT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PORT')
            ival_ = self.gds_validate_integer(ival_, node, 'PORT')
            self.PORT = ival_
            self.PORT_nsprefix_ = child_.prefix
        elif nodeName_ == 'RAFT':
            obj_ = RAFTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RAFT = obj_
            obj_.original_tagname_ = 'RAFT'
        elif nodeName_ == 'RPC_LOG':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RPC_LOG')
            value_ = self.gds_validate_string(value_, node, 'RPC_LOG')
            self.RPC_LOG = value_
            self.RPC_LOG_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHED_MAD':
            obj_ = SCHED_MADType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SCHED_MAD = obj_
            obj_.original_tagname_ = 'SCHED_MAD'
        elif nodeName_ == 'SCHED_MAX_WND_LENGTH':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCHED_MAX_WND_LENGTH')
            value_ = self.gds_validate_string(value_, node, 'SCHED_MAX_WND_LENGTH')
            self.SCHED_MAX_WND_LENGTH = value_
            self.SCHED_MAX_WND_LENGTH_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHED_MAX_WND_TIME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCHED_MAX_WND_TIME')
            value_ = self.gds_validate_string(value_, node, 'SCHED_MAX_WND_TIME')
            self.SCHED_MAX_WND_TIME = value_
            self.SCHED_MAX_WND_TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHED_RETRY_TIME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCHED_RETRY_TIME')
            value_ = self.gds_validate_string(value_, node, 'SCHED_RETRY_TIME')
            self.SCHED_RETRY_TIME = value_
            self.SCHED_RETRY_TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCRIPTS_REMOTE_DIR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCRIPTS_REMOTE_DIR')
            value_ = self.gds_validate_string(value_, node, 'SCRIPTS_REMOTE_DIR')
            self.SCRIPTS_REMOTE_DIR = value_
            self.SCRIPTS_REMOTE_DIR_nsprefix_ = child_.prefix
        elif nodeName_ == 'SESSION_EXPIRATION_TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SESSION_EXPIRATION_TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'SESSION_EXPIRATION_TIME')
            self.SESSION_EXPIRATION_TIME = ival_
            self.SESSION_EXPIRATION_TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'SHOWBACK_ONLY_RUNNING':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHOWBACK_ONLY_RUNNING')
            value_ = self.gds_validate_string(value_, node, 'SHOWBACK_ONLY_RUNNING')
            self.SHOWBACK_ONLY_RUNNING = value_
            self.SHOWBACK_ONLY_RUNNING_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIMEOUT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIMEOUT')
            ival_ = self.gds_validate_integer(ival_, node, 'TIMEOUT')
            self.TIMEOUT = ival_
            self.TIMEOUT_nsprefix_ = child_.prefix
        elif nodeName_ == 'TM_MAD':
            obj_ = TM_MADType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TM_MAD.append(obj_)
            obj_.original_tagname_ = 'TM_MAD'
        elif nodeName_ == 'TM_MAD_CONF':
            obj_ = TM_MAD_CONFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TM_MAD_CONF.append(obj_)
            obj_.original_tagname_ = 'TM_MAD_CONF'
        elif nodeName_ == 'USER_ENCRYPTED_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'USER_ENCRYPTED_ATTR')
            value_ = self.gds_validate_string(value_, node, 'USER_ENCRYPTED_ATTR')
            self.USER_ENCRYPTED_ATTR.append(value_)
            self.USER_ENCRYPTED_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'USER_RESTRICTED_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'USER_RESTRICTED_ATTR')
            value_ = self.gds_validate_string(value_, node, 'USER_RESTRICTED_ATTR')
            self.USER_RESTRICTED_ATTR.append(value_)
            self.USER_RESTRICTED_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'VLAN_IDS':
            obj_ = VLAN_IDSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VLAN_IDS = obj_
            obj_.original_tagname_ = 'VLAN_IDS'
        elif nodeName_ == 'VM_ADMIN_OPERATIONS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VM_ADMIN_OPERATIONS')
            value_ = self.gds_validate_string(value_, node, 'VM_ADMIN_OPERATIONS')
            self.VM_ADMIN_OPERATIONS = value_
            self.VM_ADMIN_OPERATIONS_nsprefix_ = child_.prefix
        elif nodeName_ == 'VM_ENCRYPTED_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VM_ENCRYPTED_ATTR')
            value_ = self.gds_validate_string(value_, node, 'VM_ENCRYPTED_ATTR')
            self.VM_ENCRYPTED_ATTR.append(value_)
            self.VM_ENCRYPTED_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'VM_MAD':
            obj_ = VM_MADType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM_MAD.append(obj_)
            obj_.original_tagname_ = 'VM_MAD'
        elif nodeName_ == 'VM_MANAGE_OPERATIONS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VM_MANAGE_OPERATIONS')
            value_ = self.gds_validate_string(value_, node, 'VM_MANAGE_OPERATIONS')
            self.VM_MANAGE_OPERATIONS = value_
            self.VM_MANAGE_OPERATIONS_nsprefix_ = child_.prefix
        elif nodeName_ == 'VM_MONITORING_EXPIRATION_TIME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VM_MONITORING_EXPIRATION_TIME')
            value_ = self.gds_validate_string(value_, node, 'VM_MONITORING_EXPIRATION_TIME')
            self.VM_MONITORING_EXPIRATION_TIME.append(value_)
            self.VM_MONITORING_EXPIRATION_TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'VM_RESTRICTED_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VM_RESTRICTED_ATTR')
            value_ = self.gds_validate_string(value_, node, 'VM_RESTRICTED_ATTR')
            self.VM_RESTRICTED_ATTR.append(value_)
            self.VM_RESTRICTED_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'VM_SNAPSHOT_FACTOR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VM_SNAPSHOT_FACTOR')
            value_ = self.gds_validate_string(value_, node, 'VM_SNAPSHOT_FACTOR')
            self.VM_SNAPSHOT_FACTOR = value_
            self.VM_SNAPSHOT_FACTOR_nsprefix_ = child_.prefix
        elif nodeName_ == 'VM_SUBMIT_ON_HOLD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VM_SUBMIT_ON_HOLD')
            value_ = self.gds_validate_string(value_, node, 'VM_SUBMIT_ON_HOLD')
            self.VM_SUBMIT_ON_HOLD = value_
            self.VM_SUBMIT_ON_HOLD_nsprefix_ = child_.prefix
            # validate type VM_SUBMIT_ON_HOLDType
            self.validate_VM_SUBMIT_ON_HOLDType(self.VM_SUBMIT_ON_HOLD)
        elif nodeName_ == 'VM_USE_OPERATIONS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VM_USE_OPERATIONS')
            value_ = self.gds_validate_string(value_, node, 'VM_USE_OPERATIONS')
            self.VM_USE_OPERATIONS.append(value_)
            self.VM_USE_OPERATIONS_nsprefix_ = child_.prefix
        elif nodeName_ == 'VNC_PORTS':
            obj_ = VNC_PORTSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VNC_PORTS = obj_
            obj_.original_tagname_ = 'VNC_PORTS'
        elif nodeName_ == 'VNET_ENCRYPTED_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VNET_ENCRYPTED_ATTR')
            value_ = self.gds_validate_string(value_, node, 'VNET_ENCRYPTED_ATTR')
            self.VNET_ENCRYPTED_ATTR.append(value_)
            self.VNET_ENCRYPTED_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'VNET_RESTRICTED_ATTR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VNET_RESTRICTED_ATTR')
            value_ = self.gds_validate_string(value_, node, 'VNET_RESTRICTED_ATTR')
            self.VNET_RESTRICTED_ATTR.append(value_)
            self.VNET_RESTRICTED_ATTR_nsprefix_ = child_.prefix
        elif nodeName_ == 'VN_MAD_CONF':
            obj_ = VN_MAD_CONFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VN_MAD_CONF.append(obj_)
            obj_.original_tagname_ = 'VN_MAD_CONF'
        elif nodeName_ == 'VXLAN_IDS':
            obj_ = VXLAN_IDSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VXLAN_IDS = obj_
            obj_.original_tagname_ = 'VXLAN_IDS'
# end class OPENNEBULA_CONFIGURATION


class RAFT(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SERVER_ID=None, STATE=None, TERM=None, VOTEDFOR=None, COMMIT=None, LOG_INDEX=None, LOG_TERM=None, FEDLOG_INDEX=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.SERVER_ID = SERVER_ID
        self.SERVER_ID_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.TERM = TERM
        self.TERM_nsprefix_ = None
        self.VOTEDFOR = VOTEDFOR
        self.VOTEDFOR_nsprefix_ = None
        self.COMMIT = COMMIT
        self.COMMIT_nsprefix_ = None
        self.LOG_INDEX = LOG_INDEX
        self.LOG_INDEX_nsprefix_ = None
        self.LOG_TERM = LOG_TERM
        self.LOG_TERM_nsprefix_ = None
        self.FEDLOG_INDEX = FEDLOG_INDEX
        self.FEDLOG_INDEX_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RAFT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RAFT.subclass:
            return RAFT.subclass(*args_, **kwargs_)
        else:
            return RAFT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SERVER_ID(self):
        return self.SERVER_ID
    def set_SERVER_ID(self, SERVER_ID):
        self.SERVER_ID = SERVER_ID
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_TERM(self):
        return self.TERM
    def set_TERM(self, TERM):
        self.TERM = TERM
    def get_VOTEDFOR(self):
        return self.VOTEDFOR
    def set_VOTEDFOR(self, VOTEDFOR):
        self.VOTEDFOR = VOTEDFOR
    def get_COMMIT(self):
        return self.COMMIT
    def set_COMMIT(self, COMMIT):
        self.COMMIT = COMMIT
    def get_LOG_INDEX(self):
        return self.LOG_INDEX
    def set_LOG_INDEX(self, LOG_INDEX):
        self.LOG_INDEX = LOG_INDEX
    def get_LOG_TERM(self):
        return self.LOG_TERM
    def set_LOG_TERM(self, LOG_TERM):
        self.LOG_TERM = LOG_TERM
    def get_FEDLOG_INDEX(self):
        return self.FEDLOG_INDEX
    def set_FEDLOG_INDEX(self, FEDLOG_INDEX):
        self.FEDLOG_INDEX = FEDLOG_INDEX
    def has__content(self):
        if (
            self.SERVER_ID is not None or
            self.STATE is not None or
            self.TERM is not None or
            self.VOTEDFOR is not None or
            self.COMMIT is not None or
            self.LOG_INDEX is not None or
            self.LOG_TERM is not None or
            self.FEDLOG_INDEX is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='RAFT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RAFT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RAFT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RAFT')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RAFT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RAFT'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='RAFT', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SERVER_ID is not None:
            namespaceprefix_ = self.SERVER_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.SERVER_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSERVER_ID>%s</%sSERVER_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.SERVER_ID, input_name='SERVER_ID'), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.TERM is not None:
            namespaceprefix_ = self.TERM_nsprefix_ + ':' if (UseCapturedNS_ and self.TERM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTERM>%s</%sTERM>%s' % (namespaceprefix_ , self.gds_format_integer(self.TERM, input_name='TERM'), namespaceprefix_ , eol_))
        if self.VOTEDFOR is not None:
            namespaceprefix_ = self.VOTEDFOR_nsprefix_ + ':' if (UseCapturedNS_ and self.VOTEDFOR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVOTEDFOR>%s</%sVOTEDFOR>%s' % (namespaceprefix_ , self.gds_format_integer(self.VOTEDFOR, input_name='VOTEDFOR'), namespaceprefix_ , eol_))
        if self.COMMIT is not None:
            namespaceprefix_ = self.COMMIT_nsprefix_ + ':' if (UseCapturedNS_ and self.COMMIT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOMMIT>%s</%sCOMMIT>%s' % (namespaceprefix_ , self.gds_format_integer(self.COMMIT, input_name='COMMIT'), namespaceprefix_ , eol_))
        if self.LOG_INDEX is not None:
            namespaceprefix_ = self.LOG_INDEX_nsprefix_ + ':' if (UseCapturedNS_ and self.LOG_INDEX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOG_INDEX>%s</%sLOG_INDEX>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOG_INDEX, input_name='LOG_INDEX'), namespaceprefix_ , eol_))
        if self.LOG_TERM is not None:
            namespaceprefix_ = self.LOG_TERM_nsprefix_ + ':' if (UseCapturedNS_ and self.LOG_TERM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOG_TERM>%s</%sLOG_TERM>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOG_TERM, input_name='LOG_TERM'), namespaceprefix_ , eol_))
        if self.FEDLOG_INDEX is not None:
            namespaceprefix_ = self.FEDLOG_INDEX_nsprefix_ + ':' if (UseCapturedNS_ and self.FEDLOG_INDEX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFEDLOG_INDEX>%s</%sFEDLOG_INDEX>%s' % (namespaceprefix_ , self.gds_format_integer(self.FEDLOG_INDEX, input_name='FEDLOG_INDEX'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SERVER_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SERVER_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'SERVER_ID')
            self.SERVER_ID = ival_
            self.SERVER_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'TERM' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TERM')
            ival_ = self.gds_validate_integer(ival_, node, 'TERM')
            self.TERM = ival_
            self.TERM_nsprefix_ = child_.prefix
        elif nodeName_ == 'VOTEDFOR' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VOTEDFOR')
            ival_ = self.gds_validate_integer(ival_, node, 'VOTEDFOR')
            self.VOTEDFOR = ival_
            self.VOTEDFOR_nsprefix_ = child_.prefix
        elif nodeName_ == 'COMMIT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'COMMIT')
            ival_ = self.gds_validate_integer(ival_, node, 'COMMIT')
            self.COMMIT = ival_
            self.COMMIT_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOG_INDEX' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOG_INDEX')
            ival_ = self.gds_validate_integer(ival_, node, 'LOG_INDEX')
            self.LOG_INDEX = ival_
            self.LOG_INDEX_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOG_TERM' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOG_TERM')
            ival_ = self.gds_validate_integer(ival_, node, 'LOG_TERM')
            self.LOG_TERM = ival_
            self.LOG_TERM_nsprefix_ = child_.prefix
        elif nodeName_ == 'FEDLOG_INDEX' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'FEDLOG_INDEX')
            ival_ = self.gds_validate_integer(ival_, node, 'FEDLOG_INDEX')
            self.FEDLOG_INDEX = ival_
            self.FEDLOG_INDEX_nsprefix_ = child_.prefix
# end class RAFT


class SECURITY_GROUP_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SECURITY_GROUP=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SECURITY_GROUP is None:
            self.SECURITY_GROUP = []
        else:
            self.SECURITY_GROUP = SECURITY_GROUP
        self.SECURITY_GROUP_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURITY_GROUP_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURITY_GROUP_POOL.subclass:
            return SECURITY_GROUP_POOL.subclass(*args_, **kwargs_)
        else:
            return SECURITY_GROUP_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SECURITY_GROUP(self):
        return self.SECURITY_GROUP
    def set_SECURITY_GROUP(self, SECURITY_GROUP):
        self.SECURITY_GROUP = SECURITY_GROUP
    def add_SECURITY_GROUP(self, value):
        self.SECURITY_GROUP.append(value)
    def insert_SECURITY_GROUP_at(self, index, value):
        self.SECURITY_GROUP.insert(index, value)
    def replace_SECURITY_GROUP_at(self, index, value):
        self.SECURITY_GROUP[index] = value
    def has__content(self):
        if (
            self.SECURITY_GROUP
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SECURITY_GROUP_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SECURITY_GROUP_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SECURITY_GROUP_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SECURITY_GROUP_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SECURITY_GROUP_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SECURITY_GROUP_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SECURITY_GROUP_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SECURITY_GROUP_ in self.SECURITY_GROUP:
            namespaceprefix_ = self.SECURITY_GROUP_nsprefix_ + ':' if (UseCapturedNS_ and self.SECURITY_GROUP_nsprefix_) else ''
            SECURITY_GROUP_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SECURITY_GROUP', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SECURITY_GROUP':
            obj_ = SECURITY_GROUP.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SECURITY_GROUP.append(obj_)
            obj_.original_tagname_ = 'SECURITY_GROUP'
# end class SECURITY_GROUP_POOL


class SECURITY_GROUP(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, UPDATED_VMS=None, OUTDATED_VMS=None, UPDATING_VMS=None, ERROR_VMS=None, TEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.UPDATED_VMS = UPDATED_VMS
        self.UPDATED_VMS_nsprefix_ = None
        self.OUTDATED_VMS = OUTDATED_VMS
        self.OUTDATED_VMS_nsprefix_ = None
        self.UPDATING_VMS = UPDATING_VMS
        self.UPDATING_VMS_nsprefix_ = None
        self.ERROR_VMS = ERROR_VMS
        self.ERROR_VMS_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURITY_GROUP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURITY_GROUP.subclass:
            return SECURITY_GROUP.subclass(*args_, **kwargs_)
        else:
            return SECURITY_GROUP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_UPDATED_VMS(self):
        return self.UPDATED_VMS
    def set_UPDATED_VMS(self, UPDATED_VMS):
        self.UPDATED_VMS = UPDATED_VMS
    def get_OUTDATED_VMS(self):
        return self.OUTDATED_VMS
    def set_OUTDATED_VMS(self, OUTDATED_VMS):
        self.OUTDATED_VMS = OUTDATED_VMS
    def get_UPDATING_VMS(self):
        return self.UPDATING_VMS
    def set_UPDATING_VMS(self, UPDATING_VMS):
        self.UPDATING_VMS = UPDATING_VMS
    def get_ERROR_VMS(self):
        return self.ERROR_VMS
    def set_ERROR_VMS(self, ERROR_VMS):
        self.ERROR_VMS = ERROR_VMS
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.UPDATED_VMS is not None or
            self.OUTDATED_VMS is not None or
            self.UPDATING_VMS is not None or
            self.ERROR_VMS is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SECURITY_GROUP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SECURITY_GROUP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SECURITY_GROUP':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SECURITY_GROUP')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SECURITY_GROUP', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SECURITY_GROUP'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SECURITY_GROUP', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.UPDATED_VMS is not None:
            namespaceprefix_ = self.UPDATED_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.UPDATED_VMS_nsprefix_) else ''
            self.UPDATED_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UPDATED_VMS', pretty_print=pretty_print)
        if self.OUTDATED_VMS is not None:
            namespaceprefix_ = self.OUTDATED_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.OUTDATED_VMS_nsprefix_) else ''
            self.OUTDATED_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OUTDATED_VMS', pretty_print=pretty_print)
        if self.UPDATING_VMS is not None:
            namespaceprefix_ = self.UPDATING_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.UPDATING_VMS_nsprefix_) else ''
            self.UPDATING_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UPDATING_VMS', pretty_print=pretty_print)
        if self.ERROR_VMS is not None:
            namespaceprefix_ = self.ERROR_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.ERROR_VMS_nsprefix_) else ''
            self.ERROR_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ERROR_VMS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            self.TEMPLATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEMPLATE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType23.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'UPDATED_VMS':
            obj_ = UPDATED_VMSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UPDATED_VMS = obj_
            obj_.original_tagname_ = 'UPDATED_VMS'
        elif nodeName_ == 'OUTDATED_VMS':
            obj_ = OUTDATED_VMSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OUTDATED_VMS = obj_
            obj_.original_tagname_ = 'OUTDATED_VMS'
        elif nodeName_ == 'UPDATING_VMS':
            obj_ = UPDATING_VMSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UPDATING_VMS = obj_
            obj_.original_tagname_ = 'UPDATING_VMS'
        elif nodeName_ == 'ERROR_VMS':
            obj_ = ERROR_VMSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ERROR_VMS = obj_
            obj_.original_tagname_ = 'ERROR_VMS'
        elif nodeName_ == 'TEMPLATE':
            obj_ = TEMPLATEType24.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEMPLATE = obj_
            obj_.original_tagname_ = 'TEMPLATE'
# end class SECURITY_GROUP


class SHOWBACK_RECORDS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SHOWBACK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SHOWBACK is None:
            self.SHOWBACK = []
        else:
            self.SHOWBACK = SHOWBACK
        self.SHOWBACK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SHOWBACK_RECORDS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SHOWBACK_RECORDS.subclass:
            return SHOWBACK_RECORDS.subclass(*args_, **kwargs_)
        else:
            return SHOWBACK_RECORDS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SHOWBACK(self):
        return self.SHOWBACK
    def set_SHOWBACK(self, SHOWBACK):
        self.SHOWBACK = SHOWBACK
    def add_SHOWBACK(self, value):
        self.SHOWBACK.append(value)
    def insert_SHOWBACK_at(self, index, value):
        self.SHOWBACK.insert(index, value)
    def replace_SHOWBACK_at(self, index, value):
        self.SHOWBACK[index] = value
    def has__content(self):
        if (
            self.SHOWBACK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SHOWBACK_RECORDS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SHOWBACK_RECORDS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SHOWBACK_RECORDS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SHOWBACK_RECORDS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SHOWBACK_RECORDS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SHOWBACK_RECORDS'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SHOWBACK_RECORDS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SHOWBACK_ in self.SHOWBACK:
            namespaceprefix_ = self.SHOWBACK_nsprefix_ + ':' if (UseCapturedNS_ and self.SHOWBACK_nsprefix_) else ''
            SHOWBACK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SHOWBACK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SHOWBACK':
            obj_ = SHOWBACKType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SHOWBACK.append(obj_)
            obj_.original_tagname_ = 'SHOWBACK'
# end class SHOWBACK_RECORDS


class USER_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, USER=None, QUOTAS=None, DEFAULT_USER_QUOTAS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if USER is None:
            self.USER = []
        else:
            self.USER = USER
        self.USER_nsprefix_ = None
        if QUOTAS is None:
            self.QUOTAS = []
        else:
            self.QUOTAS = QUOTAS
        self.QUOTAS_nsprefix_ = None
        self.DEFAULT_USER_QUOTAS = DEFAULT_USER_QUOTAS
        self.DEFAULT_USER_QUOTAS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USER_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USER_POOL.subclass:
            return USER_POOL.subclass(*args_, **kwargs_)
        else:
            return USER_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_USER(self):
        return self.USER
    def set_USER(self, USER):
        self.USER = USER
    def add_USER(self, value):
        self.USER.append(value)
    def insert_USER_at(self, index, value):
        self.USER.insert(index, value)
    def replace_USER_at(self, index, value):
        self.USER[index] = value
    def get_QUOTAS(self):
        return self.QUOTAS
    def set_QUOTAS(self, QUOTAS):
        self.QUOTAS = QUOTAS
    def add_QUOTAS(self, value):
        self.QUOTAS.append(value)
    def insert_QUOTAS_at(self, index, value):
        self.QUOTAS.insert(index, value)
    def replace_QUOTAS_at(self, index, value):
        self.QUOTAS[index] = value
    def get_DEFAULT_USER_QUOTAS(self):
        return self.DEFAULT_USER_QUOTAS
    def set_DEFAULT_USER_QUOTAS(self, DEFAULT_USER_QUOTAS):
        self.DEFAULT_USER_QUOTAS = DEFAULT_USER_QUOTAS
    def has__content(self):
        if (
            self.USER or
            self.QUOTAS or
            self.DEFAULT_USER_QUOTAS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USER_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USER_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'USER_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USER_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='USER_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='USER_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USER_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for USER_ in self.USER:
            namespaceprefix_ = self.USER_nsprefix_ + ':' if (UseCapturedNS_ and self.USER_nsprefix_) else ''
            USER_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='USER', pretty_print=pretty_print)
        for QUOTAS_ in self.QUOTAS:
            namespaceprefix_ = self.QUOTAS_nsprefix_ + ':' if (UseCapturedNS_ and self.QUOTAS_nsprefix_) else ''
            QUOTAS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='QUOTAS', pretty_print=pretty_print)
        if self.DEFAULT_USER_QUOTAS is not None:
            namespaceprefix_ = self.DEFAULT_USER_QUOTAS_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_USER_QUOTAS_nsprefix_) else ''
            self.DEFAULT_USER_QUOTAS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DEFAULT_USER_QUOTAS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'USER':
            obj_ = USERType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.USER.append(obj_)
            obj_.original_tagname_ = 'USER'
        elif nodeName_ == 'QUOTAS':
            obj_ = QUOTASType25.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.QUOTAS.append(obj_)
            obj_.original_tagname_ = 'QUOTAS'
        elif nodeName_ == 'DEFAULT_USER_QUOTAS':
            obj_ = DEFAULT_USER_QUOTASType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DEFAULT_USER_QUOTAS = obj_
            obj_.original_tagname_ = 'DEFAULT_USER_QUOTAS'
# end class USER_POOL


class USER(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, GID=None, GROUPS=None, GNAME=None, NAME=None, PASSWORD=None, AUTH_DRIVER=None, ENABLED=None, LOGIN_TOKEN=None, TEMPLATE=None, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None, DEFAULT_USER_QUOTAS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.GROUPS = GROUPS
        self.GROUPS_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PASSWORD = PASSWORD
        self.PASSWORD_nsprefix_ = None
        self.AUTH_DRIVER = AUTH_DRIVER
        self.AUTH_DRIVER_nsprefix_ = None
        self.ENABLED = ENABLED
        self.ENABLED_nsprefix_ = None
        if LOGIN_TOKEN is None:
            self.LOGIN_TOKEN = []
        else:
            self.LOGIN_TOKEN = LOGIN_TOKEN
        self.LOGIN_TOKEN_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.DATASTORE_QUOTA_nsprefix_ = None
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.NETWORK_QUOTA_nsprefix_ = None
        self.VM_QUOTA = VM_QUOTA
        self.VM_QUOTA_nsprefix_ = None
        self.IMAGE_QUOTA = IMAGE_QUOTA
        self.IMAGE_QUOTA_nsprefix_ = None
        self.DEFAULT_USER_QUOTAS = DEFAULT_USER_QUOTAS
        self.DEFAULT_USER_QUOTAS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USER.subclass:
            return USER.subclass(*args_, **kwargs_)
        else:
            return USER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_GROUPS(self):
        return self.GROUPS
    def set_GROUPS(self, GROUPS):
        self.GROUPS = GROUPS
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PASSWORD(self):
        return self.PASSWORD
    def set_PASSWORD(self, PASSWORD):
        self.PASSWORD = PASSWORD
    def get_AUTH_DRIVER(self):
        return self.AUTH_DRIVER
    def set_AUTH_DRIVER(self, AUTH_DRIVER):
        self.AUTH_DRIVER = AUTH_DRIVER
    def get_ENABLED(self):
        return self.ENABLED
    def set_ENABLED(self, ENABLED):
        self.ENABLED = ENABLED
    def get_LOGIN_TOKEN(self):
        return self.LOGIN_TOKEN
    def set_LOGIN_TOKEN(self, LOGIN_TOKEN):
        self.LOGIN_TOKEN = LOGIN_TOKEN
    def add_LOGIN_TOKEN(self, value):
        self.LOGIN_TOKEN.append(value)
    def insert_LOGIN_TOKEN_at(self, index, value):
        self.LOGIN_TOKEN.insert(index, value)
    def replace_LOGIN_TOKEN_at(self, index, value):
        self.LOGIN_TOKEN[index] = value
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_DATASTORE_QUOTA(self):
        return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA):
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self):
        return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA):
        self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self):
        return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA):
        self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self):
        return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA):
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def get_DEFAULT_USER_QUOTAS(self):
        return self.DEFAULT_USER_QUOTAS
    def set_DEFAULT_USER_QUOTAS(self, DEFAULT_USER_QUOTAS):
        self.DEFAULT_USER_QUOTAS = DEFAULT_USER_QUOTAS
    def has__content(self):
        if (
            self.ID is not None or
            self.GID is not None or
            self.GROUPS is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PASSWORD is not None or
            self.AUTH_DRIVER is not None or
            self.ENABLED is not None or
            self.LOGIN_TOKEN or
            self.TEMPLATE is not None or
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None or
            self.DEFAULT_USER_QUOTAS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USER', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USER')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'USER':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USER')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='USER', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='USER'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USER', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.GROUPS is not None:
            namespaceprefix_ = self.GROUPS_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUPS_nsprefix_) else ''
            self.GROUPS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GROUPS', pretty_print=pretty_print)
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PASSWORD is not None:
            namespaceprefix_ = self.PASSWORD_nsprefix_ + ':' if (UseCapturedNS_ and self.PASSWORD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPASSWORD>%s</%sPASSWORD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PASSWORD), input_name='PASSWORD')), namespaceprefix_ , eol_))
        if self.AUTH_DRIVER is not None:
            namespaceprefix_ = self.AUTH_DRIVER_nsprefix_ + ':' if (UseCapturedNS_ and self.AUTH_DRIVER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAUTH_DRIVER>%s</%sAUTH_DRIVER>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AUTH_DRIVER), input_name='AUTH_DRIVER')), namespaceprefix_ , eol_))
        if self.ENABLED is not None:
            namespaceprefix_ = self.ENABLED_nsprefix_ + ':' if (UseCapturedNS_ and self.ENABLED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sENABLED>%s</%sENABLED>%s' % (namespaceprefix_ , self.gds_format_integer(self.ENABLED, input_name='ENABLED'), namespaceprefix_ , eol_))
        for LOGIN_TOKEN_ in self.LOGIN_TOKEN:
            namespaceprefix_ = self.LOGIN_TOKEN_nsprefix_ + ':' if (UseCapturedNS_ and self.LOGIN_TOKEN_nsprefix_) else ''
            LOGIN_TOKEN_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOGIN_TOKEN', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
        if self.DATASTORE_QUOTA is not None:
            namespaceprefix_ = self.DATASTORE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_QUOTA_nsprefix_) else ''
            self.DATASTORE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            namespaceprefix_ = self.NETWORK_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.NETWORK_QUOTA_nsprefix_) else ''
            self.NETWORK_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            namespaceprefix_ = self.VM_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_QUOTA_nsprefix_) else ''
            self.VM_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            namespaceprefix_ = self.IMAGE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_QUOTA_nsprefix_) else ''
            self.IMAGE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_QUOTA', pretty_print=pretty_print)
        if self.DEFAULT_USER_QUOTAS is not None:
            namespaceprefix_ = self.DEFAULT_USER_QUOTAS_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_USER_QUOTAS_nsprefix_) else ''
            self.DEFAULT_USER_QUOTAS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DEFAULT_USER_QUOTAS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUPS':
            obj_ = GROUPSType28.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GROUPS = obj_
            obj_.original_tagname_ = 'GROUPS'
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PASSWORD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PASSWORD')
            value_ = self.gds_validate_string(value_, node, 'PASSWORD')
            self.PASSWORD = value_
            self.PASSWORD_nsprefix_ = child_.prefix
        elif nodeName_ == 'AUTH_DRIVER':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AUTH_DRIVER')
            value_ = self.gds_validate_string(value_, node, 'AUTH_DRIVER')
            self.AUTH_DRIVER = value_
            self.AUTH_DRIVER_nsprefix_ = child_.prefix
        elif nodeName_ == 'ENABLED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ENABLED')
            ival_ = self.gds_validate_integer(ival_, node, 'ENABLED')
            self.ENABLED = ival_
            self.ENABLED_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOGIN_TOKEN':
            obj_ = LOGIN_TOKENType29.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOGIN_TOKEN.append(obj_)
            obj_.original_tagname_ = 'LOGIN_TOKEN'
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
        elif nodeName_ == 'DEFAULT_USER_QUOTAS':
            obj_ = DEFAULT_USER_QUOTASType30.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DEFAULT_USER_QUOTAS = obj_
            obj_.original_tagname_ = 'DEFAULT_USER_QUOTAS'
# end class USER


class VDC_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VDC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if VDC is None:
            self.VDC = []
        else:
            self.VDC = VDC
        self.VDC_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VDC_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VDC_POOL.subclass:
            return VDC_POOL.subclass(*args_, **kwargs_)
        else:
            return VDC_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VDC(self):
        return self.VDC
    def set_VDC(self, VDC):
        self.VDC = VDC
    def add_VDC(self, value):
        self.VDC.append(value)
    def insert_VDC_at(self, index, value):
        self.VDC.insert(index, value)
    def replace_VDC_at(self, index, value):
        self.VDC[index] = value
    def has__content(self):
        if (
            self.VDC
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VDC_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VDC_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VDC_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VDC_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VDC_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VDC_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VDC_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VDC_ in self.VDC:
            namespaceprefix_ = self.VDC_nsprefix_ + ':' if (UseCapturedNS_ and self.VDC_nsprefix_) else ''
            VDC_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VDC', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VDC':
            obj_ = VDC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VDC.append(obj_)
            obj_.original_tagname_ = 'VDC'
# end class VDC_POOL


class VDC(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, NAME=None, GROUPS=None, CLUSTERS=None, HOSTS=None, DATASTORES=None, VNETS=None, TEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.GROUPS = GROUPS
        self.GROUPS_nsprefix_ = None
        self.CLUSTERS = CLUSTERS
        self.CLUSTERS_nsprefix_ = None
        self.HOSTS = HOSTS
        self.HOSTS_nsprefix_ = None
        self.DATASTORES = DATASTORES
        self.DATASTORES_nsprefix_ = None
        self.VNETS = VNETS
        self.VNETS_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VDC)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VDC.subclass:
            return VDC.subclass(*args_, **kwargs_)
        else:
            return VDC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_GROUPS(self):
        return self.GROUPS
    def set_GROUPS(self, GROUPS):
        self.GROUPS = GROUPS
    def get_CLUSTERS(self):
        return self.CLUSTERS
    def set_CLUSTERS(self, CLUSTERS):
        self.CLUSTERS = CLUSTERS
    def get_HOSTS(self):
        return self.HOSTS
    def set_HOSTS(self, HOSTS):
        self.HOSTS = HOSTS
    def get_DATASTORES(self):
        return self.DATASTORES
    def set_DATASTORES(self, DATASTORES):
        self.DATASTORES = DATASTORES
    def get_VNETS(self):
        return self.VNETS
    def set_VNETS(self, VNETS):
        self.VNETS = VNETS
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def has__content(self):
        if (
            self.ID is not None or
            self.NAME is not None or
            self.GROUPS is not None or
            self.CLUSTERS is not None or
            self.HOSTS is not None or
            self.DATASTORES is not None or
            self.VNETS is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VDC', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VDC')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VDC':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VDC')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VDC', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VDC'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VDC', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.GROUPS is not None:
            namespaceprefix_ = self.GROUPS_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUPS_nsprefix_) else ''
            self.GROUPS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GROUPS', pretty_print=pretty_print)
        if self.CLUSTERS is not None:
            namespaceprefix_ = self.CLUSTERS_nsprefix_ + ':' if (UseCapturedNS_ and self.CLUSTERS_nsprefix_) else ''
            self.CLUSTERS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CLUSTERS', pretty_print=pretty_print)
        if self.HOSTS is not None:
            namespaceprefix_ = self.HOSTS_nsprefix_ + ':' if (UseCapturedNS_ and self.HOSTS_nsprefix_) else ''
            self.HOSTS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HOSTS', pretty_print=pretty_print)
        if self.DATASTORES is not None:
            namespaceprefix_ = self.DATASTORES_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORES_nsprefix_) else ''
            self.DATASTORES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORES', pretty_print=pretty_print)
        if self.VNETS is not None:
            namespaceprefix_ = self.VNETS_nsprefix_ + ':' if (UseCapturedNS_ and self.VNETS_nsprefix_) else ''
            self.VNETS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VNETS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUPS':
            obj_ = GROUPSType33.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GROUPS = obj_
            obj_.original_tagname_ = 'GROUPS'
        elif nodeName_ == 'CLUSTERS':
            obj_ = CLUSTERSType34.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CLUSTERS = obj_
            obj_.original_tagname_ = 'CLUSTERS'
        elif nodeName_ == 'HOSTS':
            obj_ = HOSTSType35.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HOSTS = obj_
            obj_.original_tagname_ = 'HOSTS'
        elif nodeName_ == 'DATASTORES':
            obj_ = DATASTORESType36.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORES = obj_
            obj_.original_tagname_ = 'DATASTORES'
        elif nodeName_ == 'VNETS':
            obj_ = VNETSType38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VNETS = obj_
            obj_.original_tagname_ = 'VNETS'
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
# end class VDC


class VM_GROUP_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VM_GROUP=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if VM_GROUP is None:
            self.VM_GROUP = []
        else:
            self.VM_GROUP = VM_GROUP
        self.VM_GROUP_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_GROUP_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_GROUP_POOL.subclass:
            return VM_GROUP_POOL.subclass(*args_, **kwargs_)
        else:
            return VM_GROUP_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VM_GROUP(self):
        return self.VM_GROUP
    def set_VM_GROUP(self, VM_GROUP):
        self.VM_GROUP = VM_GROUP
    def add_VM_GROUP(self, value):
        self.VM_GROUP.append(value)
    def insert_VM_GROUP_at(self, index, value):
        self.VM_GROUP.insert(index, value)
    def replace_VM_GROUP_at(self, index, value):
        self.VM_GROUP[index] = value
    def has__content(self):
        if (
            self.VM_GROUP
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_GROUP_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_GROUP_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VM_GROUP_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VM_GROUP_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VM_GROUP_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VM_GROUP_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_GROUP_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VM_GROUP_ in self.VM_GROUP:
            namespaceprefix_ = self.VM_GROUP_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_GROUP_nsprefix_) else ''
            VM_GROUP_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM_GROUP', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VM_GROUP':
            obj_ = VM_GROUP.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM_GROUP.append(obj_)
            obj_.original_tagname_ = 'VM_GROUP'
# end class VM_GROUP_POOL


class VM_GROUP(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, LOCK=None, ROLES=None, TEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.LOCK = LOCK
        self.LOCK_nsprefix_ = None
        self.ROLES = ROLES
        self.ROLES_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_GROUP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_GROUP.subclass:
            return VM_GROUP.subclass(*args_, **kwargs_)
        else:
            return VM_GROUP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_LOCK(self):
        return self.LOCK
    def set_LOCK(self, LOCK):
        self.LOCK = LOCK
    def get_ROLES(self):
        return self.ROLES
    def set_ROLES(self, ROLES):
        self.ROLES = ROLES
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.LOCK is not None or
            self.ROLES is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_GROUP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_GROUP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VM_GROUP':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VM_GROUP')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VM_GROUP', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VM_GROUP'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_GROUP', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.LOCK is not None:
            namespaceprefix_ = self.LOCK_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCK_nsprefix_) else ''
            self.LOCK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOCK', pretty_print=pretty_print)
        if self.ROLES is not None:
            namespaceprefix_ = self.ROLES_nsprefix_ + ':' if (UseCapturedNS_ and self.ROLES_nsprefix_) else ''
            self.ROLES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ROLES', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType39.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'LOCK':
            obj_ = LOCKType40.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOCK = obj_
            obj_.original_tagname_ = 'LOCK'
        elif nodeName_ == 'ROLES':
            obj_ = ROLESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ROLES = obj_
            obj_.original_tagname_ = 'ROLES'
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
# end class VM_GROUP


class VM_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VM=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if VM is None:
            self.VM = []
        else:
            self.VM = VM
        self.VM_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_POOL.subclass:
            return VM_POOL.subclass(*args_, **kwargs_)
        else:
            return VM_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VM(self):
        return self.VM
    def set_VM(self, VM):
        self.VM = VM
    def add_VM(self, value):
        self.VM.append(value)
    def insert_VM_at(self, index, value):
        self.VM.insert(index, value)
    def replace_VM_at(self, index, value):
        self.VM[index] = value
    def has__content(self):
        if (
            self.VM
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VM_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VM_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VM_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VM_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VM_ in self.VM:
            namespaceprefix_ = self.VM_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_nsprefix_) else ''
            VM_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VM':
            obj_ = VMType41.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM.append(obj_)
            obj_.original_tagname_ = 'VM'
# end class VM_POOL


class VMTEMPLATE_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VMTEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if VMTEMPLATE is None:
            self.VMTEMPLATE = []
        else:
            self.VMTEMPLATE = VMTEMPLATE
        self.VMTEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMTEMPLATE_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMTEMPLATE_POOL.subclass:
            return VMTEMPLATE_POOL.subclass(*args_, **kwargs_)
        else:
            return VMTEMPLATE_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VMTEMPLATE(self):
        return self.VMTEMPLATE
    def set_VMTEMPLATE(self, VMTEMPLATE):
        self.VMTEMPLATE = VMTEMPLATE
    def add_VMTEMPLATE(self, value):
        self.VMTEMPLATE.append(value)
    def insert_VMTEMPLATE_at(self, index, value):
        self.VMTEMPLATE.insert(index, value)
    def replace_VMTEMPLATE_at(self, index, value):
        self.VMTEMPLATE[index] = value
    def has__content(self):
        if (
            self.VMTEMPLATE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMTEMPLATE_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMTEMPLATE_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VMTEMPLATE_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VMTEMPLATE_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VMTEMPLATE_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VMTEMPLATE_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMTEMPLATE_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VMTEMPLATE_ in self.VMTEMPLATE:
            namespaceprefix_ = self.VMTEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.VMTEMPLATE_nsprefix_) else ''
            VMTEMPLATE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VMTEMPLATE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VMTEMPLATE':
            obj_ = VMTEMPLATE.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VMTEMPLATE.append(obj_)
            obj_.original_tagname_ = 'VMTEMPLATE'
# end class VMTEMPLATE_POOL


class VMTEMPLATE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, LOCK=None, PERMISSIONS=None, REGTIME=None, TEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.LOCK = LOCK
        self.LOCK_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.REGTIME = REGTIME
        self.REGTIME_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMTEMPLATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMTEMPLATE.subclass:
            return VMTEMPLATE.subclass(*args_, **kwargs_)
        else:
            return VMTEMPLATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_LOCK(self):
        return self.LOCK
    def set_LOCK(self, LOCK):
        self.LOCK = LOCK
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_REGTIME(self):
        return self.REGTIME
    def set_REGTIME(self, REGTIME):
        self.REGTIME = REGTIME
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.LOCK is not None or
            self.PERMISSIONS is not None or
            self.REGTIME is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMTEMPLATE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMTEMPLATE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VMTEMPLATE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VMTEMPLATE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VMTEMPLATE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VMTEMPLATE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMTEMPLATE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.LOCK is not None:
            namespaceprefix_ = self.LOCK_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCK_nsprefix_) else ''
            self.LOCK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOCK', pretty_print=pretty_print)
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.REGTIME is not None:
            namespaceprefix_ = self.REGTIME_nsprefix_ + ':' if (UseCapturedNS_ and self.REGTIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREGTIME>%s</%sREGTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.REGTIME, input_name='REGTIME'), namespaceprefix_ , eol_))
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            self.TEMPLATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEMPLATE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOCK':
            obj_ = LOCKType44.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOCK = obj_
            obj_.original_tagname_ = 'LOCK'
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType45.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'REGTIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REGTIME')
            ival_ = self.gds_validate_integer(ival_, node, 'REGTIME')
            self.REGTIME = ival_
            self.REGTIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'TEMPLATE':
            obj_ = TEMPLATEType46.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEMPLATE = obj_
            obj_.original_tagname_ = 'TEMPLATE'
# end class VMTEMPLATE


class VM(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, LAST_POLL=None, STATE=None, LCM_STATE=None, PREV_STATE=None, PREV_LCM_STATE=None, RESCHED=None, STIME=None, ETIME=None, DEPLOY_ID=None, LOCK=None, MONITORING=None, SCHED_ACTIONS=None, TEMPLATE=None, USER_TEMPLATE=None, HISTORY_RECORDS=None, SNAPSHOTS=None, BACKUPS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.LAST_POLL = LAST_POLL
        self.LAST_POLL_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.LCM_STATE = LCM_STATE
        self.LCM_STATE_nsprefix_ = None
        self.PREV_STATE = PREV_STATE
        self.PREV_STATE_nsprefix_ = None
        self.PREV_LCM_STATE = PREV_LCM_STATE
        self.PREV_LCM_STATE_nsprefix_ = None
        self.RESCHED = RESCHED
        self.RESCHED_nsprefix_ = None
        self.STIME = STIME
        self.STIME_nsprefix_ = None
        self.ETIME = ETIME
        self.ETIME_nsprefix_ = None
        self.DEPLOY_ID = DEPLOY_ID
        self.DEPLOY_ID_nsprefix_ = None
        self.LOCK = LOCK
        self.LOCK_nsprefix_ = None
        self.MONITORING = MONITORING
        self.MONITORING_nsprefix_ = None
        self.SCHED_ACTIONS = SCHED_ACTIONS
        self.SCHED_ACTIONS_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.USER_TEMPLATE = USER_TEMPLATE
        self.USER_TEMPLATE_nsprefix_ = None
        self.HISTORY_RECORDS = HISTORY_RECORDS
        self.HISTORY_RECORDS_nsprefix_ = None
        if SNAPSHOTS is None:
            self.SNAPSHOTS = []
        else:
            self.SNAPSHOTS = SNAPSHOTS
        self.SNAPSHOTS_nsprefix_ = None
        self.BACKUPS = BACKUPS
        self.BACKUPS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM.subclass:
            return VM.subclass(*args_, **kwargs_)
        else:
            return VM(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_LAST_POLL(self):
        return self.LAST_POLL
    def set_LAST_POLL(self, LAST_POLL):
        self.LAST_POLL = LAST_POLL
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_LCM_STATE(self):
        return self.LCM_STATE
    def set_LCM_STATE(self, LCM_STATE):
        self.LCM_STATE = LCM_STATE
    def get_PREV_STATE(self):
        return self.PREV_STATE
    def set_PREV_STATE(self, PREV_STATE):
        self.PREV_STATE = PREV_STATE
    def get_PREV_LCM_STATE(self):
        return self.PREV_LCM_STATE
    def set_PREV_LCM_STATE(self, PREV_LCM_STATE):
        self.PREV_LCM_STATE = PREV_LCM_STATE
    def get_RESCHED(self):
        return self.RESCHED
    def set_RESCHED(self, RESCHED):
        self.RESCHED = RESCHED
    def get_STIME(self):
        return self.STIME
    def set_STIME(self, STIME):
        self.STIME = STIME
    def get_ETIME(self):
        return self.ETIME
    def set_ETIME(self, ETIME):
        self.ETIME = ETIME
    def get_DEPLOY_ID(self):
        return self.DEPLOY_ID
    def set_DEPLOY_ID(self, DEPLOY_ID):
        self.DEPLOY_ID = DEPLOY_ID
    def get_LOCK(self):
        return self.LOCK
    def set_LOCK(self, LOCK):
        self.LOCK = LOCK
    def get_MONITORING(self):
        return self.MONITORING
    def set_MONITORING(self, MONITORING):
        self.MONITORING = MONITORING
    def get_SCHED_ACTIONS(self):
        return self.SCHED_ACTIONS
    def set_SCHED_ACTIONS(self, SCHED_ACTIONS):
        self.SCHED_ACTIONS = SCHED_ACTIONS
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_USER_TEMPLATE(self):
        return self.USER_TEMPLATE
    def set_USER_TEMPLATE(self, USER_TEMPLATE):
        self.USER_TEMPLATE = USER_TEMPLATE
    def get_HISTORY_RECORDS(self):
        return self.HISTORY_RECORDS
    def set_HISTORY_RECORDS(self, HISTORY_RECORDS):
        self.HISTORY_RECORDS = HISTORY_RECORDS
    def get_SNAPSHOTS(self):
        return self.SNAPSHOTS
    def set_SNAPSHOTS(self, SNAPSHOTS):
        self.SNAPSHOTS = SNAPSHOTS
    def add_SNAPSHOTS(self, value):
        self.SNAPSHOTS.append(value)
    def insert_SNAPSHOTS_at(self, index, value):
        self.SNAPSHOTS.insert(index, value)
    def replace_SNAPSHOTS_at(self, index, value):
        self.SNAPSHOTS[index] = value
    def get_BACKUPS(self):
        return self.BACKUPS
    def set_BACKUPS(self, BACKUPS):
        self.BACKUPS = BACKUPS
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.LAST_POLL is not None or
            self.STATE is not None or
            self.LCM_STATE is not None or
            self.PREV_STATE is not None or
            self.PREV_LCM_STATE is not None or
            self.RESCHED is not None or
            self.STIME is not None or
            self.ETIME is not None or
            self.DEPLOY_ID is not None or
            self.LOCK is not None or
            self.MONITORING is not None or
            self.SCHED_ACTIONS is not None or
            self.TEMPLATE is not None or
            self.USER_TEMPLATE is not None or
            self.HISTORY_RECORDS is not None or
            self.SNAPSHOTS or
            self.BACKUPS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VM':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VM')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VM', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VM'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.LAST_POLL is not None:
            namespaceprefix_ = self.LAST_POLL_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_POLL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_POLL>%s</%sLAST_POLL>%s' % (namespaceprefix_ , self.gds_format_integer(self.LAST_POLL, input_name='LAST_POLL'), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.LCM_STATE is not None:
            namespaceprefix_ = self.LCM_STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.LCM_STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLCM_STATE>%s</%sLCM_STATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.LCM_STATE, input_name='LCM_STATE'), namespaceprefix_ , eol_))
        if self.PREV_STATE is not None:
            namespaceprefix_ = self.PREV_STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.PREV_STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREV_STATE>%s</%sPREV_STATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.PREV_STATE, input_name='PREV_STATE'), namespaceprefix_ , eol_))
        if self.PREV_LCM_STATE is not None:
            namespaceprefix_ = self.PREV_LCM_STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.PREV_LCM_STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREV_LCM_STATE>%s</%sPREV_LCM_STATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.PREV_LCM_STATE, input_name='PREV_LCM_STATE'), namespaceprefix_ , eol_))
        if self.RESCHED is not None:
            namespaceprefix_ = self.RESCHED_nsprefix_ + ':' if (UseCapturedNS_ and self.RESCHED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRESCHED>%s</%sRESCHED>%s' % (namespaceprefix_ , self.gds_format_integer(self.RESCHED, input_name='RESCHED'), namespaceprefix_ , eol_))
        if self.STIME is not None:
            namespaceprefix_ = self.STIME_nsprefix_ + ':' if (UseCapturedNS_ and self.STIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTIME>%s</%sSTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.STIME, input_name='STIME'), namespaceprefix_ , eol_))
        if self.ETIME is not None:
            namespaceprefix_ = self.ETIME_nsprefix_ + ':' if (UseCapturedNS_ and self.ETIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sETIME>%s</%sETIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.ETIME, input_name='ETIME'), namespaceprefix_ , eol_))
        if self.DEPLOY_ID is not None:
            namespaceprefix_ = self.DEPLOY_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.DEPLOY_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEPLOY_ID>%s</%sDEPLOY_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DEPLOY_ID), input_name='DEPLOY_ID')), namespaceprefix_ , eol_))
        if self.LOCK is not None:
            namespaceprefix_ = self.LOCK_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCK_nsprefix_) else ''
            self.LOCK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOCK', pretty_print=pretty_print)
        if self.MONITORING is not None:
            namespaceprefix_ = self.MONITORING_nsprefix_ + ':' if (UseCapturedNS_ and self.MONITORING_nsprefix_) else ''
            self.MONITORING.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MONITORING', pretty_print=pretty_print)
        if self.SCHED_ACTIONS is not None:
            namespaceprefix_ = self.SCHED_ACTIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_ACTIONS_nsprefix_) else ''
            self.SCHED_ACTIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SCHED_ACTIONS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            self.TEMPLATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEMPLATE', pretty_print=pretty_print)
        if self.USER_TEMPLATE is not None:
            namespaceprefix_ = self.USER_TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.USER_TEMPLATE_nsprefix_) else ''
            self.USER_TEMPLATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='USER_TEMPLATE', pretty_print=pretty_print)
        if self.HISTORY_RECORDS is not None:
            namespaceprefix_ = self.HISTORY_RECORDS_nsprefix_ + ':' if (UseCapturedNS_ and self.HISTORY_RECORDS_nsprefix_) else ''
            self.HISTORY_RECORDS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HISTORY_RECORDS', pretty_print=pretty_print)
        for SNAPSHOTS_ in self.SNAPSHOTS:
            namespaceprefix_ = self.SNAPSHOTS_nsprefix_ + ':' if (UseCapturedNS_ and self.SNAPSHOTS_nsprefix_) else ''
            SNAPSHOTS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SNAPSHOTS', pretty_print=pretty_print)
        if self.BACKUPS is not None:
            namespaceprefix_ = self.BACKUPS_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUPS_nsprefix_) else ''
            self.BACKUPS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BACKUPS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'LAST_POLL' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LAST_POLL')
            ival_ = self.gds_validate_integer(ival_, node, 'LAST_POLL')
            self.LAST_POLL = ival_
            self.LAST_POLL_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'LCM_STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LCM_STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'LCM_STATE')
            self.LCM_STATE = ival_
            self.LCM_STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PREV_STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PREV_STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'PREV_STATE')
            self.PREV_STATE = ival_
            self.PREV_STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PREV_LCM_STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PREV_LCM_STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'PREV_LCM_STATE')
            self.PREV_LCM_STATE = ival_
            self.PREV_LCM_STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'RESCHED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RESCHED')
            ival_ = self.gds_validate_integer(ival_, node, 'RESCHED')
            self.RESCHED = ival_
            self.RESCHED_nsprefix_ = child_.prefix
        elif nodeName_ == 'STIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STIME')
            ival_ = self.gds_validate_integer(ival_, node, 'STIME')
            self.STIME = ival_
            self.STIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'ETIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ETIME')
            ival_ = self.gds_validate_integer(ival_, node, 'ETIME')
            self.ETIME = ival_
            self.ETIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEPLOY_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEPLOY_ID')
            value_ = self.gds_validate_string(value_, node, 'DEPLOY_ID')
            self.DEPLOY_ID = value_
            self.DEPLOY_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOCK':
            obj_ = LOCK.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOCK = obj_
            obj_.original_tagname_ = 'LOCK'
        elif nodeName_ == 'MONITORING':
            obj_ = MONITORINGType47.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MONITORING = obj_
            obj_.original_tagname_ = 'MONITORING'
        elif nodeName_ == 'SCHED_ACTIONS':
            obj_ = IDS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SCHED_ACTIONS = obj_
            obj_.original_tagname_ = 'SCHED_ACTIONS'
        elif nodeName_ == 'TEMPLATE':
            obj_ = TEMPLATEType49.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEMPLATE = obj_
            obj_.original_tagname_ = 'TEMPLATE'
        elif nodeName_ == 'USER_TEMPLATE':
            obj_ = USER_TEMPLATEType53.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.USER_TEMPLATE = obj_
            obj_.original_tagname_ = 'USER_TEMPLATE'
        elif nodeName_ == 'HISTORY_RECORDS':
            obj_ = HISTORY_RECORDSType54.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HISTORY_RECORDS = obj_
            obj_.original_tagname_ = 'HISTORY_RECORDS'
        elif nodeName_ == 'SNAPSHOTS':
            obj_ = SNAPSHOTSType56.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SNAPSHOTS.append(obj_)
            obj_.original_tagname_ = 'SNAPSHOTS'
        elif nodeName_ == 'BACKUPS':
            obj_ = BACKUPSType58.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BACKUPS = obj_
            obj_.original_tagname_ = 'BACKUPS'
# end class VM


class VNET_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VNET=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if VNET is None:
            self.VNET = []
        else:
            self.VNET = VNET
        self.VNET_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNET_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNET_POOL.subclass:
            return VNET_POOL.subclass(*args_, **kwargs_)
        else:
            return VNET_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VNET(self):
        return self.VNET
    def set_VNET(self, VNET):
        self.VNET = VNET
    def add_VNET(self, value):
        self.VNET.append(value)
    def insert_VNET_at(self, index, value):
        self.VNET.insert(index, value)
    def replace_VNET_at(self, index, value):
        self.VNET[index] = value
    def has__content(self):
        if (
            self.VNET
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNET_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNET_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VNET_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VNET_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VNET_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VNET_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNET_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VNET_ in self.VNET:
            namespaceprefix_ = self.VNET_nsprefix_ + ':' if (UseCapturedNS_ and self.VNET_nsprefix_) else ''
            VNET_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VNET', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VNET':
            obj_ = VNETType60.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VNET.append(obj_)
            obj_.original_tagname_ = 'VNET'
# end class VNET_POOL


class VNET(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, LOCK=None, PERMISSIONS=None, CLUSTERS=None, BRIDGE=None, BRIDGE_TYPE=None, STATE=None, PREV_STATE=None, PARENT_NETWORK_ID=None, VN_MAD=None, PHYDEV=None, VLAN_ID=None, OUTER_VLAN_ID=None, VLAN_ID_AUTOMATIC=None, OUTER_VLAN_ID_AUTOMATIC=None, USED_LEASES=None, VROUTERS=None, UPDATED_VMS=None, OUTDATED_VMS=None, UPDATING_VMS=None, ERROR_VMS=None, TEMPLATE=None, AR_POOL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.LOCK = LOCK
        self.LOCK_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.CLUSTERS = CLUSTERS
        self.CLUSTERS_nsprefix_ = None
        self.BRIDGE = BRIDGE
        self.BRIDGE_nsprefix_ = None
        self.BRIDGE_TYPE = BRIDGE_TYPE
        self.BRIDGE_TYPE_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.PREV_STATE = PREV_STATE
        self.PREV_STATE_nsprefix_ = None
        self.PARENT_NETWORK_ID = PARENT_NETWORK_ID
        self.PARENT_NETWORK_ID_nsprefix_ = None
        self.VN_MAD = VN_MAD
        self.VN_MAD_nsprefix_ = None
        self.PHYDEV = PHYDEV
        self.PHYDEV_nsprefix_ = None
        self.VLAN_ID = VLAN_ID
        self.VLAN_ID_nsprefix_ = None
        self.OUTER_VLAN_ID = OUTER_VLAN_ID
        self.OUTER_VLAN_ID_nsprefix_ = None
        self.VLAN_ID_AUTOMATIC = VLAN_ID_AUTOMATIC
        self.VLAN_ID_AUTOMATIC_nsprefix_ = None
        self.OUTER_VLAN_ID_AUTOMATIC = OUTER_VLAN_ID_AUTOMATIC
        self.OUTER_VLAN_ID_AUTOMATIC_nsprefix_ = None
        self.USED_LEASES = USED_LEASES
        self.USED_LEASES_nsprefix_ = None
        self.VROUTERS = VROUTERS
        self.VROUTERS_nsprefix_ = None
        self.UPDATED_VMS = UPDATED_VMS
        self.UPDATED_VMS_nsprefix_ = None
        self.OUTDATED_VMS = OUTDATED_VMS
        self.OUTDATED_VMS_nsprefix_ = None
        self.UPDATING_VMS = UPDATING_VMS
        self.UPDATING_VMS_nsprefix_ = None
        self.ERROR_VMS = ERROR_VMS
        self.ERROR_VMS_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.AR_POOL = AR_POOL
        self.AR_POOL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNET)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNET.subclass:
            return VNET.subclass(*args_, **kwargs_)
        else:
            return VNET(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_LOCK(self):
        return self.LOCK
    def set_LOCK(self, LOCK):
        self.LOCK = LOCK
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_CLUSTERS(self):
        return self.CLUSTERS
    def set_CLUSTERS(self, CLUSTERS):
        self.CLUSTERS = CLUSTERS
    def get_BRIDGE(self):
        return self.BRIDGE
    def set_BRIDGE(self, BRIDGE):
        self.BRIDGE = BRIDGE
    def get_BRIDGE_TYPE(self):
        return self.BRIDGE_TYPE
    def set_BRIDGE_TYPE(self, BRIDGE_TYPE):
        self.BRIDGE_TYPE = BRIDGE_TYPE
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_PREV_STATE(self):
        return self.PREV_STATE
    def set_PREV_STATE(self, PREV_STATE):
        self.PREV_STATE = PREV_STATE
    def get_PARENT_NETWORK_ID(self):
        return self.PARENT_NETWORK_ID
    def set_PARENT_NETWORK_ID(self, PARENT_NETWORK_ID):
        self.PARENT_NETWORK_ID = PARENT_NETWORK_ID
    def get_VN_MAD(self):
        return self.VN_MAD
    def set_VN_MAD(self, VN_MAD):
        self.VN_MAD = VN_MAD
    def get_PHYDEV(self):
        return self.PHYDEV
    def set_PHYDEV(self, PHYDEV):
        self.PHYDEV = PHYDEV
    def get_VLAN_ID(self):
        return self.VLAN_ID
    def set_VLAN_ID(self, VLAN_ID):
        self.VLAN_ID = VLAN_ID
    def get_OUTER_VLAN_ID(self):
        return self.OUTER_VLAN_ID
    def set_OUTER_VLAN_ID(self, OUTER_VLAN_ID):
        self.OUTER_VLAN_ID = OUTER_VLAN_ID
    def get_VLAN_ID_AUTOMATIC(self):
        return self.VLAN_ID_AUTOMATIC
    def set_VLAN_ID_AUTOMATIC(self, VLAN_ID_AUTOMATIC):
        self.VLAN_ID_AUTOMATIC = VLAN_ID_AUTOMATIC
    def get_OUTER_VLAN_ID_AUTOMATIC(self):
        return self.OUTER_VLAN_ID_AUTOMATIC
    def set_OUTER_VLAN_ID_AUTOMATIC(self, OUTER_VLAN_ID_AUTOMATIC):
        self.OUTER_VLAN_ID_AUTOMATIC = OUTER_VLAN_ID_AUTOMATIC
    def get_USED_LEASES(self):
        return self.USED_LEASES
    def set_USED_LEASES(self, USED_LEASES):
        self.USED_LEASES = USED_LEASES
    def get_VROUTERS(self):
        return self.VROUTERS
    def set_VROUTERS(self, VROUTERS):
        self.VROUTERS = VROUTERS
    def get_UPDATED_VMS(self):
        return self.UPDATED_VMS
    def set_UPDATED_VMS(self, UPDATED_VMS):
        self.UPDATED_VMS = UPDATED_VMS
    def get_OUTDATED_VMS(self):
        return self.OUTDATED_VMS
    def set_OUTDATED_VMS(self, OUTDATED_VMS):
        self.OUTDATED_VMS = OUTDATED_VMS
    def get_UPDATING_VMS(self):
        return self.UPDATING_VMS
    def set_UPDATING_VMS(self, UPDATING_VMS):
        self.UPDATING_VMS = UPDATING_VMS
    def get_ERROR_VMS(self):
        return self.ERROR_VMS
    def set_ERROR_VMS(self, ERROR_VMS):
        self.ERROR_VMS = ERROR_VMS
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_AR_POOL(self):
        return self.AR_POOL
    def set_AR_POOL(self, AR_POOL):
        self.AR_POOL = AR_POOL
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.LOCK is not None or
            self.PERMISSIONS is not None or
            self.CLUSTERS is not None or
            self.BRIDGE is not None or
            self.BRIDGE_TYPE is not None or
            self.STATE is not None or
            self.PREV_STATE is not None or
            self.PARENT_NETWORK_ID is not None or
            self.VN_MAD is not None or
            self.PHYDEV is not None or
            self.VLAN_ID is not None or
            self.OUTER_VLAN_ID is not None or
            self.VLAN_ID_AUTOMATIC is not None or
            self.OUTER_VLAN_ID_AUTOMATIC is not None or
            self.USED_LEASES is not None or
            self.VROUTERS is not None or
            self.UPDATED_VMS is not None or
            self.OUTDATED_VMS is not None or
            self.UPDATING_VMS is not None or
            self.ERROR_VMS is not None or
            self.TEMPLATE is not None or
            self.AR_POOL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNET', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNET')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VNET':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VNET')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VNET', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VNET'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNET', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.LOCK is not None:
            namespaceprefix_ = self.LOCK_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCK_nsprefix_) else ''
            self.LOCK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOCK', pretty_print=pretty_print)
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.CLUSTERS is not None:
            namespaceprefix_ = self.CLUSTERS_nsprefix_ + ':' if (UseCapturedNS_ and self.CLUSTERS_nsprefix_) else ''
            self.CLUSTERS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CLUSTERS', pretty_print=pretty_print)
        if self.BRIDGE is not None:
            namespaceprefix_ = self.BRIDGE_nsprefix_ + ':' if (UseCapturedNS_ and self.BRIDGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBRIDGE>%s</%sBRIDGE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BRIDGE), input_name='BRIDGE')), namespaceprefix_ , eol_))
        if self.BRIDGE_TYPE is not None:
            namespaceprefix_ = self.BRIDGE_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.BRIDGE_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBRIDGE_TYPE>%s</%sBRIDGE_TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BRIDGE_TYPE), input_name='BRIDGE_TYPE')), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.PREV_STATE is not None:
            namespaceprefix_ = self.PREV_STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.PREV_STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREV_STATE>%s</%sPREV_STATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.PREV_STATE, input_name='PREV_STATE'), namespaceprefix_ , eol_))
        if self.PARENT_NETWORK_ID is not None:
            namespaceprefix_ = self.PARENT_NETWORK_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.PARENT_NETWORK_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPARENT_NETWORK_ID>%s</%sPARENT_NETWORK_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PARENT_NETWORK_ID), input_name='PARENT_NETWORK_ID')), namespaceprefix_ , eol_))
        if self.VN_MAD is not None:
            namespaceprefix_ = self.VN_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.VN_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVN_MAD>%s</%sVN_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VN_MAD), input_name='VN_MAD')), namespaceprefix_ , eol_))
        if self.PHYDEV is not None:
            namespaceprefix_ = self.PHYDEV_nsprefix_ + ':' if (UseCapturedNS_ and self.PHYDEV_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPHYDEV>%s</%sPHYDEV>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PHYDEV), input_name='PHYDEV')), namespaceprefix_ , eol_))
        if self.VLAN_ID is not None:
            namespaceprefix_ = self.VLAN_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.VLAN_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVLAN_ID>%s</%sVLAN_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VLAN_ID), input_name='VLAN_ID')), namespaceprefix_ , eol_))
        if self.OUTER_VLAN_ID is not None:
            namespaceprefix_ = self.OUTER_VLAN_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.OUTER_VLAN_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOUTER_VLAN_ID>%s</%sOUTER_VLAN_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OUTER_VLAN_ID), input_name='OUTER_VLAN_ID')), namespaceprefix_ , eol_))
        if self.VLAN_ID_AUTOMATIC is not None:
            namespaceprefix_ = self.VLAN_ID_AUTOMATIC_nsprefix_ + ':' if (UseCapturedNS_ and self.VLAN_ID_AUTOMATIC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVLAN_ID_AUTOMATIC>%s</%sVLAN_ID_AUTOMATIC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VLAN_ID_AUTOMATIC), input_name='VLAN_ID_AUTOMATIC')), namespaceprefix_ , eol_))
        if self.OUTER_VLAN_ID_AUTOMATIC is not None:
            namespaceprefix_ = self.OUTER_VLAN_ID_AUTOMATIC_nsprefix_ + ':' if (UseCapturedNS_ and self.OUTER_VLAN_ID_AUTOMATIC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOUTER_VLAN_ID_AUTOMATIC>%s</%sOUTER_VLAN_ID_AUTOMATIC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OUTER_VLAN_ID_AUTOMATIC), input_name='OUTER_VLAN_ID_AUTOMATIC')), namespaceprefix_ , eol_))
        if self.USED_LEASES is not None:
            namespaceprefix_ = self.USED_LEASES_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_LEASES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED_LEASES>%s</%sUSED_LEASES>%s' % (namespaceprefix_ , self.gds_format_integer(self.USED_LEASES, input_name='USED_LEASES'), namespaceprefix_ , eol_))
        if self.VROUTERS is not None:
            namespaceprefix_ = self.VROUTERS_nsprefix_ + ':' if (UseCapturedNS_ and self.VROUTERS_nsprefix_) else ''
            self.VROUTERS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VROUTERS', pretty_print=pretty_print)
        if self.UPDATED_VMS is not None:
            namespaceprefix_ = self.UPDATED_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.UPDATED_VMS_nsprefix_) else ''
            self.UPDATED_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UPDATED_VMS', pretty_print=pretty_print)
        if self.OUTDATED_VMS is not None:
            namespaceprefix_ = self.OUTDATED_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.OUTDATED_VMS_nsprefix_) else ''
            self.OUTDATED_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OUTDATED_VMS', pretty_print=pretty_print)
        if self.UPDATING_VMS is not None:
            namespaceprefix_ = self.UPDATING_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.UPDATING_VMS_nsprefix_) else ''
            self.UPDATING_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UPDATING_VMS', pretty_print=pretty_print)
        if self.ERROR_VMS is not None:
            namespaceprefix_ = self.ERROR_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.ERROR_VMS_nsprefix_) else ''
            self.ERROR_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ERROR_VMS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            self.TEMPLATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEMPLATE', pretty_print=pretty_print)
        if self.AR_POOL is not None:
            namespaceprefix_ = self.AR_POOL_nsprefix_ + ':' if (UseCapturedNS_ and self.AR_POOL_nsprefix_) else ''
            self.AR_POOL.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AR_POOL', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOCK':
            obj_ = LOCKType67.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOCK = obj_
            obj_.original_tagname_ = 'LOCK'
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType68.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'CLUSTERS':
            obj_ = CLUSTERSType69.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CLUSTERS = obj_
            obj_.original_tagname_ = 'CLUSTERS'
        elif nodeName_ == 'BRIDGE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BRIDGE')
            value_ = self.gds_validate_string(value_, node, 'BRIDGE')
            self.BRIDGE = value_
            self.BRIDGE_nsprefix_ = child_.prefix
        elif nodeName_ == 'BRIDGE_TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BRIDGE_TYPE')
            value_ = self.gds_validate_string(value_, node, 'BRIDGE_TYPE')
            self.BRIDGE_TYPE = value_
            self.BRIDGE_TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PREV_STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PREV_STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'PREV_STATE')
            self.PREV_STATE = ival_
            self.PREV_STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PARENT_NETWORK_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PARENT_NETWORK_ID')
            value_ = self.gds_validate_string(value_, node, 'PARENT_NETWORK_ID')
            self.PARENT_NETWORK_ID = value_
            self.PARENT_NETWORK_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'VN_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VN_MAD')
            value_ = self.gds_validate_string(value_, node, 'VN_MAD')
            self.VN_MAD = value_
            self.VN_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'PHYDEV':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PHYDEV')
            value_ = self.gds_validate_string(value_, node, 'PHYDEV')
            self.PHYDEV = value_
            self.PHYDEV_nsprefix_ = child_.prefix
        elif nodeName_ == 'VLAN_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VLAN_ID')
            value_ = self.gds_validate_string(value_, node, 'VLAN_ID')
            self.VLAN_ID = value_
            self.VLAN_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'OUTER_VLAN_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OUTER_VLAN_ID')
            value_ = self.gds_validate_string(value_, node, 'OUTER_VLAN_ID')
            self.OUTER_VLAN_ID = value_
            self.OUTER_VLAN_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'VLAN_ID_AUTOMATIC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VLAN_ID_AUTOMATIC')
            value_ = self.gds_validate_string(value_, node, 'VLAN_ID_AUTOMATIC')
            self.VLAN_ID_AUTOMATIC = value_
            self.VLAN_ID_AUTOMATIC_nsprefix_ = child_.prefix
        elif nodeName_ == 'OUTER_VLAN_ID_AUTOMATIC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OUTER_VLAN_ID_AUTOMATIC')
            value_ = self.gds_validate_string(value_, node, 'OUTER_VLAN_ID_AUTOMATIC')
            self.OUTER_VLAN_ID_AUTOMATIC = value_
            self.OUTER_VLAN_ID_AUTOMATIC_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED_LEASES' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'USED_LEASES')
            ival_ = self.gds_validate_integer(ival_, node, 'USED_LEASES')
            self.USED_LEASES = ival_
            self.USED_LEASES_nsprefix_ = child_.prefix
        elif nodeName_ == 'VROUTERS':
            obj_ = VROUTERSType70.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VROUTERS = obj_
            obj_.original_tagname_ = 'VROUTERS'
        elif nodeName_ == 'UPDATED_VMS':
            obj_ = UPDATED_VMSType71.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UPDATED_VMS = obj_
            obj_.original_tagname_ = 'UPDATED_VMS'
        elif nodeName_ == 'OUTDATED_VMS':
            obj_ = OUTDATED_VMSType72.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OUTDATED_VMS = obj_
            obj_.original_tagname_ = 'OUTDATED_VMS'
        elif nodeName_ == 'UPDATING_VMS':
            obj_ = UPDATING_VMSType73.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UPDATING_VMS = obj_
            obj_.original_tagname_ = 'UPDATING_VMS'
        elif nodeName_ == 'ERROR_VMS':
            obj_ = ERROR_VMSType74.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ERROR_VMS = obj_
            obj_.original_tagname_ = 'ERROR_VMS'
        elif nodeName_ == 'TEMPLATE':
            obj_ = TEMPLATEType75.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEMPLATE = obj_
            obj_.original_tagname_ = 'TEMPLATE'
        elif nodeName_ == 'AR_POOL':
            obj_ = AR_POOLType76.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AR_POOL = obj_
            obj_.original_tagname_ = 'AR_POOL'
# end class VNET


class VNTEMPLATE_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VNTEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if VNTEMPLATE is None:
            self.VNTEMPLATE = []
        else:
            self.VNTEMPLATE = VNTEMPLATE
        self.VNTEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNTEMPLATE_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNTEMPLATE_POOL.subclass:
            return VNTEMPLATE_POOL.subclass(*args_, **kwargs_)
        else:
            return VNTEMPLATE_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VNTEMPLATE(self):
        return self.VNTEMPLATE
    def set_VNTEMPLATE(self, VNTEMPLATE):
        self.VNTEMPLATE = VNTEMPLATE
    def add_VNTEMPLATE(self, value):
        self.VNTEMPLATE.append(value)
    def insert_VNTEMPLATE_at(self, index, value):
        self.VNTEMPLATE.insert(index, value)
    def replace_VNTEMPLATE_at(self, index, value):
        self.VNTEMPLATE[index] = value
    def has__content(self):
        if (
            self.VNTEMPLATE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNTEMPLATE_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNTEMPLATE_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VNTEMPLATE_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VNTEMPLATE_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VNTEMPLATE_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VNTEMPLATE_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNTEMPLATE_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VNTEMPLATE_ in self.VNTEMPLATE:
            namespaceprefix_ = self.VNTEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.VNTEMPLATE_nsprefix_) else ''
            VNTEMPLATE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VNTEMPLATE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VNTEMPLATE':
            obj_ = VNTEMPLATE.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VNTEMPLATE.append(obj_)
            obj_.original_tagname_ = 'VNTEMPLATE'
# end class VNTEMPLATE_POOL


class VNTEMPLATE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, LOCK=None, PERMISSIONS=None, REGTIME=None, TEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.LOCK = LOCK
        self.LOCK_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.REGTIME = REGTIME
        self.REGTIME_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNTEMPLATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNTEMPLATE.subclass:
            return VNTEMPLATE.subclass(*args_, **kwargs_)
        else:
            return VNTEMPLATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_LOCK(self):
        return self.LOCK
    def set_LOCK(self, LOCK):
        self.LOCK = LOCK
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_REGTIME(self):
        return self.REGTIME
    def set_REGTIME(self, REGTIME):
        self.REGTIME = REGTIME
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.LOCK is not None or
            self.PERMISSIONS is not None or
            self.REGTIME is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNTEMPLATE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNTEMPLATE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VNTEMPLATE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VNTEMPLATE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VNTEMPLATE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VNTEMPLATE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNTEMPLATE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.LOCK is not None:
            namespaceprefix_ = self.LOCK_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCK_nsprefix_) else ''
            self.LOCK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOCK', pretty_print=pretty_print)
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.REGTIME is not None:
            namespaceprefix_ = self.REGTIME_nsprefix_ + ':' if (UseCapturedNS_ and self.REGTIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREGTIME>%s</%sREGTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.REGTIME, input_name='REGTIME'), namespaceprefix_ , eol_))
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            self.TEMPLATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEMPLATE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOCK':
            obj_ = LOCKType78.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOCK = obj_
            obj_.original_tagname_ = 'LOCK'
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType79.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'REGTIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REGTIME')
            ival_ = self.gds_validate_integer(ival_, node, 'REGTIME')
            self.REGTIME = ival_
            self.REGTIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'TEMPLATE':
            obj_ = TEMPLATEType80.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEMPLATE = obj_
            obj_.original_tagname_ = 'TEMPLATE'
# end class VNTEMPLATE


class VROUTER_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VROUTER=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if VROUTER is None:
            self.VROUTER = []
        else:
            self.VROUTER = VROUTER
        self.VROUTER_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VROUTER_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VROUTER_POOL.subclass:
            return VROUTER_POOL.subclass(*args_, **kwargs_)
        else:
            return VROUTER_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VROUTER(self):
        return self.VROUTER
    def set_VROUTER(self, VROUTER):
        self.VROUTER = VROUTER
    def add_VROUTER(self, value):
        self.VROUTER.append(value)
    def insert_VROUTER_at(self, index, value):
        self.VROUTER.insert(index, value)
    def replace_VROUTER_at(self, index, value):
        self.VROUTER[index] = value
    def has__content(self):
        if (
            self.VROUTER
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VROUTER_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VROUTER_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VROUTER_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VROUTER_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VROUTER_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VROUTER_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VROUTER_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VROUTER_ in self.VROUTER:
            namespaceprefix_ = self.VROUTER_nsprefix_ + ':' if (UseCapturedNS_ and self.VROUTER_nsprefix_) else ''
            VROUTER_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VROUTER', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VROUTER':
            obj_ = VROUTER.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VROUTER.append(obj_)
            obj_.original_tagname_ = 'VROUTER'
# end class VROUTER_POOL


class VROUTER(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, LOCK=None, VMS=None, TEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.LOCK = LOCK
        self.LOCK_nsprefix_ = None
        self.VMS = VMS
        self.VMS_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VROUTER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VROUTER.subclass:
            return VROUTER.subclass(*args_, **kwargs_)
        else:
            return VROUTER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_LOCK(self):
        return self.LOCK
    def set_LOCK(self, LOCK):
        self.LOCK = LOCK
    def get_VMS(self):
        return self.VMS
    def set_VMS(self, VMS):
        self.VMS = VMS
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.LOCK is not None or
            self.VMS is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VROUTER', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VROUTER')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VROUTER':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VROUTER')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VROUTER', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VROUTER'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VROUTER', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.LOCK is not None:
            namespaceprefix_ = self.LOCK_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCK_nsprefix_) else ''
            self.LOCK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOCK', pretty_print=pretty_print)
        if self.VMS is not None:
            namespaceprefix_ = self.VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_nsprefix_) else ''
            self.VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VMS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType81.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'LOCK':
            obj_ = LOCKType82.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOCK = obj_
            obj_.original_tagname_ = 'LOCK'
        elif nodeName_ == 'VMS':
            obj_ = VMSType83.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VMS = obj_
            obj_.original_tagname_ = 'VMS'
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
# end class VROUTER


class ZONE_POOL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ZONE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ZONE is None:
            self.ZONE = []
        else:
            self.ZONE = ZONE
        self.ZONE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ZONE_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZONE_POOL.subclass:
            return ZONE_POOL.subclass(*args_, **kwargs_)
        else:
            return ZONE_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ZONE(self):
        return self.ZONE
    def set_ZONE(self, ZONE):
        self.ZONE = ZONE
    def add_ZONE(self, value):
        self.ZONE.append(value)
    def insert_ZONE_at(self, index, value):
        self.ZONE.insert(index, value)
    def replace_ZONE_at(self, index, value):
        self.ZONE[index] = value
    def has__content(self):
        if (
            self.ZONE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ZONE_POOL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ZONE_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ZONE_POOL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ZONE_POOL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ZONE_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ZONE_POOL'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ZONE_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ZONE_ in self.ZONE:
            namespaceprefix_ = self.ZONE_nsprefix_ + ':' if (UseCapturedNS_ and self.ZONE_nsprefix_) else ''
            ZONE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ZONE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ZONE':
            obj_ = ZONEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ZONE.append(obj_)
            obj_.original_tagname_ = 'ZONE'
# end class ZONE_POOL


class ZONE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, NAME=None, STATE=None, TEMPLATE=None, SERVER_POOL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.SERVER_POOL = SERVER_POOL
        self.SERVER_POOL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ZONE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZONE.subclass:
            return ZONE.subclass(*args_, **kwargs_)
        else:
            return ZONE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_SERVER_POOL(self):
        return self.SERVER_POOL
    def set_SERVER_POOL(self, SERVER_POOL):
        self.SERVER_POOL = SERVER_POOL
    def has__content(self):
        if (
            self.ID is not None or
            self.NAME is not None or
            self.STATE is not None or
            self.TEMPLATE is not None or
            self.SERVER_POOL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ZONE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ZONE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ZONE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ZONE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ZONE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ZONE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ZONE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            self.TEMPLATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEMPLATE', pretty_print=pretty_print)
        if self.SERVER_POOL is not None:
            namespaceprefix_ = self.SERVER_POOL_nsprefix_ + ':' if (UseCapturedNS_ and self.SERVER_POOL_nsprefix_) else ''
            self.SERVER_POOL.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SERVER_POOL', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'TEMPLATE':
            obj_ = TEMPLATEType85.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEMPLATE = obj_
            obj_.original_tagname_ = 'TEMPLATE'
        elif nodeName_ == 'SERVER_POOL':
            obj_ = SERVER_POOLType86.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SERVER_POOL = obj_
            obj_.original_tagname_ = 'SERVER_POOL'
# end class ZONE


class VMType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, LAST_POLL=None, STATE=None, LCM_STATE=None, PREV_STATE=None, PREV_LCM_STATE=None, RESCHED=None, STIME=None, ETIME=None, DEPLOY_ID=None, MONITORING=None, SCHED_ACTIONS=None, TEMPLATE=None, USER_TEMPLATE=None, HISTORY_RECORDS=None, SNAPSHOTS=None, BACKUPS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.LAST_POLL = LAST_POLL
        self.LAST_POLL_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.LCM_STATE = LCM_STATE
        self.LCM_STATE_nsprefix_ = None
        self.PREV_STATE = PREV_STATE
        self.PREV_STATE_nsprefix_ = None
        self.PREV_LCM_STATE = PREV_LCM_STATE
        self.PREV_LCM_STATE_nsprefix_ = None
        self.RESCHED = RESCHED
        self.RESCHED_nsprefix_ = None
        self.STIME = STIME
        self.STIME_nsprefix_ = None
        self.ETIME = ETIME
        self.ETIME_nsprefix_ = None
        self.DEPLOY_ID = DEPLOY_ID
        self.DEPLOY_ID_nsprefix_ = None
        self.MONITORING = MONITORING
        self.MONITORING_nsprefix_ = None
        self.SCHED_ACTIONS = SCHED_ACTIONS
        self.SCHED_ACTIONS_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.USER_TEMPLATE = USER_TEMPLATE
        self.USER_TEMPLATE_nsprefix_ = None
        self.HISTORY_RECORDS = HISTORY_RECORDS
        self.HISTORY_RECORDS_nsprefix_ = None
        if SNAPSHOTS is None:
            self.SNAPSHOTS = []
        else:
            self.SNAPSHOTS = SNAPSHOTS
        self.SNAPSHOTS_nsprefix_ = None
        self.BACKUPS = BACKUPS
        self.BACKUPS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType.subclass:
            return VMType.subclass(*args_, **kwargs_)
        else:
            return VMType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_LAST_POLL(self):
        return self.LAST_POLL
    def set_LAST_POLL(self, LAST_POLL):
        self.LAST_POLL = LAST_POLL
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_LCM_STATE(self):
        return self.LCM_STATE
    def set_LCM_STATE(self, LCM_STATE):
        self.LCM_STATE = LCM_STATE
    def get_PREV_STATE(self):
        return self.PREV_STATE
    def set_PREV_STATE(self, PREV_STATE):
        self.PREV_STATE = PREV_STATE
    def get_PREV_LCM_STATE(self):
        return self.PREV_LCM_STATE
    def set_PREV_LCM_STATE(self, PREV_LCM_STATE):
        self.PREV_LCM_STATE = PREV_LCM_STATE
    def get_RESCHED(self):
        return self.RESCHED
    def set_RESCHED(self, RESCHED):
        self.RESCHED = RESCHED
    def get_STIME(self):
        return self.STIME
    def set_STIME(self, STIME):
        self.STIME = STIME
    def get_ETIME(self):
        return self.ETIME
    def set_ETIME(self, ETIME):
        self.ETIME = ETIME
    def get_DEPLOY_ID(self):
        return self.DEPLOY_ID
    def set_DEPLOY_ID(self, DEPLOY_ID):
        self.DEPLOY_ID = DEPLOY_ID
    def get_MONITORING(self):
        return self.MONITORING
    def set_MONITORING(self, MONITORING):
        self.MONITORING = MONITORING
    def get_SCHED_ACTIONS(self):
        return self.SCHED_ACTIONS
    def set_SCHED_ACTIONS(self, SCHED_ACTIONS):
        self.SCHED_ACTIONS = SCHED_ACTIONS
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_USER_TEMPLATE(self):
        return self.USER_TEMPLATE
    def set_USER_TEMPLATE(self, USER_TEMPLATE):
        self.USER_TEMPLATE = USER_TEMPLATE
    def get_HISTORY_RECORDS(self):
        return self.HISTORY_RECORDS
    def set_HISTORY_RECORDS(self, HISTORY_RECORDS):
        self.HISTORY_RECORDS = HISTORY_RECORDS
    def get_SNAPSHOTS(self):
        return self.SNAPSHOTS
    def set_SNAPSHOTS(self, SNAPSHOTS):
        self.SNAPSHOTS = SNAPSHOTS
    def add_SNAPSHOTS(self, value):
        self.SNAPSHOTS.append(value)
    def insert_SNAPSHOTS_at(self, index, value):
        self.SNAPSHOTS.insert(index, value)
    def replace_SNAPSHOTS_at(self, index, value):
        self.SNAPSHOTS[index] = value
    def get_BACKUPS(self):
        return self.BACKUPS
    def set_BACKUPS(self, BACKUPS):
        self.BACKUPS = BACKUPS
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.LAST_POLL is not None or
            self.STATE is not None or
            self.LCM_STATE is not None or
            self.PREV_STATE is not None or
            self.PREV_LCM_STATE is not None or
            self.RESCHED is not None or
            self.STIME is not None or
            self.ETIME is not None or
            self.DEPLOY_ID is not None or
            self.MONITORING is not None or
            self.SCHED_ACTIONS is not None or
            self.TEMPLATE is not None or
            self.USER_TEMPLATE is not None or
            self.HISTORY_RECORDS is not None or
            self.SNAPSHOTS or
            self.BACKUPS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VMType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VMType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VMType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VMType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.LAST_POLL is not None:
            namespaceprefix_ = self.LAST_POLL_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_POLL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_POLL>%s</%sLAST_POLL>%s' % (namespaceprefix_ , self.gds_format_integer(self.LAST_POLL, input_name='LAST_POLL'), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.LCM_STATE is not None:
            namespaceprefix_ = self.LCM_STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.LCM_STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLCM_STATE>%s</%sLCM_STATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.LCM_STATE, input_name='LCM_STATE'), namespaceprefix_ , eol_))
        if self.PREV_STATE is not None:
            namespaceprefix_ = self.PREV_STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.PREV_STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREV_STATE>%s</%sPREV_STATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.PREV_STATE, input_name='PREV_STATE'), namespaceprefix_ , eol_))
        if self.PREV_LCM_STATE is not None:
            namespaceprefix_ = self.PREV_LCM_STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.PREV_LCM_STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREV_LCM_STATE>%s</%sPREV_LCM_STATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.PREV_LCM_STATE, input_name='PREV_LCM_STATE'), namespaceprefix_ , eol_))
        if self.RESCHED is not None:
            namespaceprefix_ = self.RESCHED_nsprefix_ + ':' if (UseCapturedNS_ and self.RESCHED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRESCHED>%s</%sRESCHED>%s' % (namespaceprefix_ , self.gds_format_integer(self.RESCHED, input_name='RESCHED'), namespaceprefix_ , eol_))
        if self.STIME is not None:
            namespaceprefix_ = self.STIME_nsprefix_ + ':' if (UseCapturedNS_ and self.STIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTIME>%s</%sSTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.STIME, input_name='STIME'), namespaceprefix_ , eol_))
        if self.ETIME is not None:
            namespaceprefix_ = self.ETIME_nsprefix_ + ':' if (UseCapturedNS_ and self.ETIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sETIME>%s</%sETIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.ETIME, input_name='ETIME'), namespaceprefix_ , eol_))
        if self.DEPLOY_ID is not None:
            namespaceprefix_ = self.DEPLOY_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.DEPLOY_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEPLOY_ID>%s</%sDEPLOY_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DEPLOY_ID), input_name='DEPLOY_ID')), namespaceprefix_ , eol_))
        if self.MONITORING is not None:
            namespaceprefix_ = self.MONITORING_nsprefix_ + ':' if (UseCapturedNS_ and self.MONITORING_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMONITORING>%s</%sMONITORING>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MONITORING), input_name='MONITORING')), namespaceprefix_ , eol_))
        if self.SCHED_ACTIONS is not None:
            namespaceprefix_ = self.SCHED_ACTIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_ACTIONS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCHED_ACTIONS>%s</%sSCHED_ACTIONS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCHED_ACTIONS), input_name='SCHED_ACTIONS')), namespaceprefix_ , eol_))
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
        if self.USER_TEMPLATE is not None:
            namespaceprefix_ = self.USER_TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.USER_TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSER_TEMPLATE>%s</%sUSER_TEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.USER_TEMPLATE), input_name='USER_TEMPLATE')), namespaceprefix_ , eol_))
        if self.HISTORY_RECORDS is not None:
            namespaceprefix_ = self.HISTORY_RECORDS_nsprefix_ + ':' if (UseCapturedNS_ and self.HISTORY_RECORDS_nsprefix_) else ''
            self.HISTORY_RECORDS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HISTORY_RECORDS', pretty_print=pretty_print)
        for SNAPSHOTS_ in self.SNAPSHOTS:
            namespaceprefix_ = self.SNAPSHOTS_nsprefix_ + ':' if (UseCapturedNS_ and self.SNAPSHOTS_nsprefix_) else ''
            SNAPSHOTS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SNAPSHOTS', pretty_print=pretty_print)
        if self.BACKUPS is not None:
            namespaceprefix_ = self.BACKUPS_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUPS_nsprefix_) else ''
            self.BACKUPS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BACKUPS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'LAST_POLL' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LAST_POLL')
            ival_ = self.gds_validate_integer(ival_, node, 'LAST_POLL')
            self.LAST_POLL = ival_
            self.LAST_POLL_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'LCM_STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LCM_STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'LCM_STATE')
            self.LCM_STATE = ival_
            self.LCM_STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PREV_STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PREV_STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'PREV_STATE')
            self.PREV_STATE = ival_
            self.PREV_STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PREV_LCM_STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PREV_LCM_STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'PREV_LCM_STATE')
            self.PREV_LCM_STATE = ival_
            self.PREV_LCM_STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'RESCHED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RESCHED')
            ival_ = self.gds_validate_integer(ival_, node, 'RESCHED')
            self.RESCHED = ival_
            self.RESCHED_nsprefix_ = child_.prefix
        elif nodeName_ == 'STIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STIME')
            ival_ = self.gds_validate_integer(ival_, node, 'STIME')
            self.STIME = ival_
            self.STIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'ETIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ETIME')
            ival_ = self.gds_validate_integer(ival_, node, 'ETIME')
            self.ETIME = ival_
            self.ETIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEPLOY_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEPLOY_ID')
            value_ = self.gds_validate_string(value_, node, 'DEPLOY_ID')
            self.DEPLOY_ID = value_
            self.DEPLOY_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'MONITORING':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MONITORING')
            value_ = self.gds_validate_string(value_, node, 'MONITORING')
            self.MONITORING = value_
            self.MONITORING_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHED_ACTIONS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCHED_ACTIONS')
            value_ = self.gds_validate_string(value_, node, 'SCHED_ACTIONS')
            self.SCHED_ACTIONS = value_
            self.SCHED_ACTIONS_nsprefix_ = child_.prefix
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'USER_TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'USER_TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'USER_TEMPLATE')
            self.USER_TEMPLATE = value_
            self.USER_TEMPLATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'HISTORY_RECORDS':
            obj_ = HISTORY_RECORDS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HISTORY_RECORDS = obj_
            obj_.original_tagname_ = 'HISTORY_RECORDS'
        elif nodeName_ == 'SNAPSHOTS':
            obj_ = SNAPSHOTSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SNAPSHOTS.append(obj_)
            obj_.original_tagname_ = 'SNAPSHOTS'
        elif nodeName_ == 'BACKUPS':
            obj_ = BACKUPSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BACKUPS = obj_
            obj_.original_tagname_ = 'BACKUPS'
# end class VMType


class MONITORING(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MONITORING)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MONITORING.subclass:
            return MONITORING.subclass(*args_, **kwargs_)
        else:
            return MONITORING(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MONITORING', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MONITORING')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MONITORING':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MONITORING')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MONITORING', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MONITORING'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MONITORING', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class MONITORING


class PERMISSIONSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType.subclass:
            return PERMISSIONSType.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONSType


class SNAPSHOTSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ALLOW_ORPHANS=None, CURRENT_BASE=None, DISK_ID=None, NEXT_SNAPSHOT=None, SNAPSHOT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ALLOW_ORPHANS = ALLOW_ORPHANS
        self.ALLOW_ORPHANS_nsprefix_ = None
        self.CURRENT_BASE = CURRENT_BASE
        self.CURRENT_BASE_nsprefix_ = None
        self.DISK_ID = DISK_ID
        self.DISK_ID_nsprefix_ = None
        self.NEXT_SNAPSHOT = NEXT_SNAPSHOT
        self.NEXT_SNAPSHOT_nsprefix_ = None
        if SNAPSHOT is None:
            self.SNAPSHOT = []
        else:
            self.SNAPSHOT = SNAPSHOT
        self.SNAPSHOT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SNAPSHOTSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SNAPSHOTSType.subclass:
            return SNAPSHOTSType.subclass(*args_, **kwargs_)
        else:
            return SNAPSHOTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ALLOW_ORPHANS(self):
        return self.ALLOW_ORPHANS
    def set_ALLOW_ORPHANS(self, ALLOW_ORPHANS):
        self.ALLOW_ORPHANS = ALLOW_ORPHANS
    def get_CURRENT_BASE(self):
        return self.CURRENT_BASE
    def set_CURRENT_BASE(self, CURRENT_BASE):
        self.CURRENT_BASE = CURRENT_BASE
    def get_DISK_ID(self):
        return self.DISK_ID
    def set_DISK_ID(self, DISK_ID):
        self.DISK_ID = DISK_ID
    def get_NEXT_SNAPSHOT(self):
        return self.NEXT_SNAPSHOT
    def set_NEXT_SNAPSHOT(self, NEXT_SNAPSHOT):
        self.NEXT_SNAPSHOT = NEXT_SNAPSHOT
    def get_SNAPSHOT(self):
        return self.SNAPSHOT
    def set_SNAPSHOT(self, SNAPSHOT):
        self.SNAPSHOT = SNAPSHOT
    def add_SNAPSHOT(self, value):
        self.SNAPSHOT.append(value)
    def insert_SNAPSHOT_at(self, index, value):
        self.SNAPSHOT.insert(index, value)
    def replace_SNAPSHOT_at(self, index, value):
        self.SNAPSHOT[index] = value
    def has__content(self):
        if (
            self.ALLOW_ORPHANS is not None or
            self.CURRENT_BASE is not None or
            self.DISK_ID is not None or
            self.NEXT_SNAPSHOT is not None or
            self.SNAPSHOT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SNAPSHOTSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SNAPSHOTSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SNAPSHOTSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SNAPSHOTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SNAPSHOTSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ALLOW_ORPHANS is not None:
            namespaceprefix_ = self.ALLOW_ORPHANS_nsprefix_ + ':' if (UseCapturedNS_ and self.ALLOW_ORPHANS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sALLOW_ORPHANS>%s</%sALLOW_ORPHANS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ALLOW_ORPHANS), input_name='ALLOW_ORPHANS')), namespaceprefix_ , eol_))
        if self.CURRENT_BASE is not None:
            namespaceprefix_ = self.CURRENT_BASE_nsprefix_ + ':' if (UseCapturedNS_ and self.CURRENT_BASE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCURRENT_BASE>%s</%sCURRENT_BASE>%s' % (namespaceprefix_ , self.gds_format_integer(self.CURRENT_BASE, input_name='CURRENT_BASE'), namespaceprefix_ , eol_))
        if self.DISK_ID is not None:
            namespaceprefix_ = self.DISK_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISK_ID>%s</%sDISK_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.DISK_ID, input_name='DISK_ID'), namespaceprefix_ , eol_))
        if self.NEXT_SNAPSHOT is not None:
            namespaceprefix_ = self.NEXT_SNAPSHOT_nsprefix_ + ':' if (UseCapturedNS_ and self.NEXT_SNAPSHOT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNEXT_SNAPSHOT>%s</%sNEXT_SNAPSHOT>%s' % (namespaceprefix_ , self.gds_format_integer(self.NEXT_SNAPSHOT, input_name='NEXT_SNAPSHOT'), namespaceprefix_ , eol_))
        for SNAPSHOT_ in self.SNAPSHOT:
            namespaceprefix_ = self.SNAPSHOT_nsprefix_ + ':' if (UseCapturedNS_ and self.SNAPSHOT_nsprefix_) else ''
            SNAPSHOT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SNAPSHOT', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ALLOW_ORPHANS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ALLOW_ORPHANS')
            value_ = self.gds_validate_string(value_, node, 'ALLOW_ORPHANS')
            self.ALLOW_ORPHANS = value_
            self.ALLOW_ORPHANS_nsprefix_ = child_.prefix
        elif nodeName_ == 'CURRENT_BASE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CURRENT_BASE')
            ival_ = self.gds_validate_integer(ival_, node, 'CURRENT_BASE')
            self.CURRENT_BASE = ival_
            self.CURRENT_BASE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISK_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DISK_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'DISK_ID')
            self.DISK_ID = ival_
            self.DISK_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NEXT_SNAPSHOT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NEXT_SNAPSHOT')
            ival_ = self.gds_validate_integer(ival_, node, 'NEXT_SNAPSHOT')
            self.NEXT_SNAPSHOT = ival_
            self.NEXT_SNAPSHOT_nsprefix_ = child_.prefix
        elif nodeName_ == 'SNAPSHOT':
            obj_ = SNAPSHOTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SNAPSHOT.append(obj_)
            obj_.original_tagname_ = 'SNAPSHOT'
# end class SNAPSHOTSType


class SNAPSHOTType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ACTIVE=None, CHILDREN=None, DATE=None, ID=None, NAME=None, PARENT=None, SIZE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ACTIVE = ACTIVE
        self.ACTIVE_nsprefix_ = None
        self.CHILDREN = CHILDREN
        self.CHILDREN_nsprefix_ = None
        self.DATE = DATE
        self.DATE_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PARENT = PARENT
        self.PARENT_nsprefix_ = None
        self.SIZE = SIZE
        self.SIZE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SNAPSHOTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SNAPSHOTType.subclass:
            return SNAPSHOTType.subclass(*args_, **kwargs_)
        else:
            return SNAPSHOTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ACTIVE(self):
        return self.ACTIVE
    def set_ACTIVE(self, ACTIVE):
        self.ACTIVE = ACTIVE
    def get_CHILDREN(self):
        return self.CHILDREN
    def set_CHILDREN(self, CHILDREN):
        self.CHILDREN = CHILDREN
    def get_DATE(self):
        return self.DATE
    def set_DATE(self, DATE):
        self.DATE = DATE
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PARENT(self):
        return self.PARENT
    def set_PARENT(self, PARENT):
        self.PARENT = PARENT
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def has__content(self):
        if (
            self.ACTIVE is not None or
            self.CHILDREN is not None or
            self.DATE is not None or
            self.ID is not None or
            self.NAME is not None or
            self.PARENT is not None or
            self.SIZE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SNAPSHOTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SNAPSHOTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SNAPSHOTType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SNAPSHOTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SNAPSHOTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ACTIVE is not None:
            namespaceprefix_ = self.ACTIVE_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTIVE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACTIVE>%s</%sACTIVE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ACTIVE), input_name='ACTIVE')), namespaceprefix_ , eol_))
        if self.CHILDREN is not None:
            namespaceprefix_ = self.CHILDREN_nsprefix_ + ':' if (UseCapturedNS_ and self.CHILDREN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCHILDREN>%s</%sCHILDREN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CHILDREN), input_name='CHILDREN')), namespaceprefix_ , eol_))
        if self.DATE is not None:
            namespaceprefix_ = self.DATE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATE>%s</%sDATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.DATE, input_name='DATE'), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PARENT is not None:
            namespaceprefix_ = self.PARENT_nsprefix_ + ':' if (UseCapturedNS_ and self.PARENT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPARENT>%s</%sPARENT>%s' % (namespaceprefix_ , self.gds_format_integer(self.PARENT, input_name='PARENT'), namespaceprefix_ , eol_))
        if self.SIZE is not None:
            namespaceprefix_ = self.SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE>%s</%sSIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.SIZE, input_name='SIZE'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ACTIVE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ACTIVE')
            value_ = self.gds_validate_string(value_, node, 'ACTIVE')
            self.ACTIVE = value_
            self.ACTIVE_nsprefix_ = child_.prefix
        elif nodeName_ == 'CHILDREN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CHILDREN')
            value_ = self.gds_validate_string(value_, node, 'CHILDREN')
            self.CHILDREN = value_
            self.CHILDREN_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DATE')
            ival_ = self.gds_validate_integer(ival_, node, 'DATE')
            self.DATE = ival_
            self.DATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PARENT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PARENT')
            ival_ = self.gds_validate_integer(ival_, node, 'PARENT')
            self.PARENT = ival_
            self.PARENT_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
            self.SIZE_nsprefix_ = child_.prefix
# end class SNAPSHOTType


class BACKUPSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BACKUP_CONFIG=None, BACKUP_IDS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.BACKUP_CONFIG = BACKUP_CONFIG
        self.BACKUP_CONFIG_nsprefix_ = None
        self.BACKUP_IDS = BACKUP_IDS
        self.BACKUP_IDS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BACKUPSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BACKUPSType.subclass:
            return BACKUPSType.subclass(*args_, **kwargs_)
        else:
            return BACKUPSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BACKUP_CONFIG(self):
        return self.BACKUP_CONFIG
    def set_BACKUP_CONFIG(self, BACKUP_CONFIG):
        self.BACKUP_CONFIG = BACKUP_CONFIG
    def get_BACKUP_IDS(self):
        return self.BACKUP_IDS
    def set_BACKUP_IDS(self, BACKUP_IDS):
        self.BACKUP_IDS = BACKUP_IDS
    def has__content(self):
        if (
            self.BACKUP_CONFIG is not None or
            self.BACKUP_IDS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUPSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BACKUPSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BACKUPSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BACKUPSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BACKUPSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BACKUPSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUPSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BACKUP_CONFIG is not None:
            namespaceprefix_ = self.BACKUP_CONFIG_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUP_CONFIG_nsprefix_) else ''
            self.BACKUP_CONFIG.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BACKUP_CONFIG', pretty_print=pretty_print)
        if self.BACKUP_IDS is not None:
            namespaceprefix_ = self.BACKUP_IDS_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUP_IDS_nsprefix_) else ''
            self.BACKUP_IDS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BACKUP_IDS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BACKUP_CONFIG':
            obj_ = BACKUP_CONFIGType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BACKUP_CONFIG = obj_
            obj_.original_tagname_ = 'BACKUP_CONFIG'
        elif nodeName_ == 'BACKUP_IDS':
            obj_ = BACKUP_IDSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BACKUP_IDS = obj_
            obj_.original_tagname_ = 'BACKUP_IDS'
# end class BACKUPSType


class BACKUP_CONFIGType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BACKUP_VOLATILE=None, FS_FREEZE=None, INCREMENTAL_BACKUP_ID=None, INCREMENT_MODE=None, KEEP_LAST=None, LAST_BACKUP_ID=None, LAST_BACKUP_SIZE=None, LAST_BRIDGE=None, LAST_DATASTORE_ID=None, LAST_INCREMENT_ID=None, MODE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.BACKUP_VOLATILE = BACKUP_VOLATILE
        self.BACKUP_VOLATILE_nsprefix_ = None
        self.FS_FREEZE = FS_FREEZE
        self.FS_FREEZE_nsprefix_ = None
        self.INCREMENTAL_BACKUP_ID = INCREMENTAL_BACKUP_ID
        self.INCREMENTAL_BACKUP_ID_nsprefix_ = None
        self.INCREMENT_MODE = INCREMENT_MODE
        self.INCREMENT_MODE_nsprefix_ = None
        self.KEEP_LAST = KEEP_LAST
        self.KEEP_LAST_nsprefix_ = None
        self.LAST_BACKUP_ID = LAST_BACKUP_ID
        self.LAST_BACKUP_ID_nsprefix_ = None
        self.LAST_BACKUP_SIZE = LAST_BACKUP_SIZE
        self.LAST_BACKUP_SIZE_nsprefix_ = None
        self.LAST_BRIDGE = LAST_BRIDGE
        self.LAST_BRIDGE_nsprefix_ = None
        self.LAST_DATASTORE_ID = LAST_DATASTORE_ID
        self.LAST_DATASTORE_ID_nsprefix_ = None
        self.LAST_INCREMENT_ID = LAST_INCREMENT_ID
        self.LAST_INCREMENT_ID_nsprefix_ = None
        self.MODE = MODE
        self.MODE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BACKUP_CONFIGType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BACKUP_CONFIGType.subclass:
            return BACKUP_CONFIGType.subclass(*args_, **kwargs_)
        else:
            return BACKUP_CONFIGType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BACKUP_VOLATILE(self):
        return self.BACKUP_VOLATILE
    def set_BACKUP_VOLATILE(self, BACKUP_VOLATILE):
        self.BACKUP_VOLATILE = BACKUP_VOLATILE
    def get_FS_FREEZE(self):
        return self.FS_FREEZE
    def set_FS_FREEZE(self, FS_FREEZE):
        self.FS_FREEZE = FS_FREEZE
    def get_INCREMENTAL_BACKUP_ID(self):
        return self.INCREMENTAL_BACKUP_ID
    def set_INCREMENTAL_BACKUP_ID(self, INCREMENTAL_BACKUP_ID):
        self.INCREMENTAL_BACKUP_ID = INCREMENTAL_BACKUP_ID
    def get_INCREMENT_MODE(self):
        return self.INCREMENT_MODE
    def set_INCREMENT_MODE(self, INCREMENT_MODE):
        self.INCREMENT_MODE = INCREMENT_MODE
    def get_KEEP_LAST(self):
        return self.KEEP_LAST
    def set_KEEP_LAST(self, KEEP_LAST):
        self.KEEP_LAST = KEEP_LAST
    def get_LAST_BACKUP_ID(self):
        return self.LAST_BACKUP_ID
    def set_LAST_BACKUP_ID(self, LAST_BACKUP_ID):
        self.LAST_BACKUP_ID = LAST_BACKUP_ID
    def get_LAST_BACKUP_SIZE(self):
        return self.LAST_BACKUP_SIZE
    def set_LAST_BACKUP_SIZE(self, LAST_BACKUP_SIZE):
        self.LAST_BACKUP_SIZE = LAST_BACKUP_SIZE
    def get_LAST_BRIDGE(self):
        return self.LAST_BRIDGE
    def set_LAST_BRIDGE(self, LAST_BRIDGE):
        self.LAST_BRIDGE = LAST_BRIDGE
    def get_LAST_DATASTORE_ID(self):
        return self.LAST_DATASTORE_ID
    def set_LAST_DATASTORE_ID(self, LAST_DATASTORE_ID):
        self.LAST_DATASTORE_ID = LAST_DATASTORE_ID
    def get_LAST_INCREMENT_ID(self):
        return self.LAST_INCREMENT_ID
    def set_LAST_INCREMENT_ID(self, LAST_INCREMENT_ID):
        self.LAST_INCREMENT_ID = LAST_INCREMENT_ID
    def get_MODE(self):
        return self.MODE
    def set_MODE(self, MODE):
        self.MODE = MODE
    def has__content(self):
        if (
            self.BACKUP_VOLATILE is not None or
            self.FS_FREEZE is not None or
            self.INCREMENTAL_BACKUP_ID is not None or
            self.INCREMENT_MODE is not None or
            self.KEEP_LAST is not None or
            self.LAST_BACKUP_ID is not None or
            self.LAST_BACKUP_SIZE is not None or
            self.LAST_BRIDGE is not None or
            self.LAST_DATASTORE_ID is not None or
            self.LAST_INCREMENT_ID is not None or
            self.MODE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUP_CONFIGType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BACKUP_CONFIGType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BACKUP_CONFIGType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BACKUP_CONFIGType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BACKUP_CONFIGType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BACKUP_CONFIGType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUP_CONFIGType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BACKUP_VOLATILE is not None:
            namespaceprefix_ = self.BACKUP_VOLATILE_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUP_VOLATILE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBACKUP_VOLATILE>%s</%sBACKUP_VOLATILE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BACKUP_VOLATILE), input_name='BACKUP_VOLATILE')), namespaceprefix_ , eol_))
        if self.FS_FREEZE is not None:
            namespaceprefix_ = self.FS_FREEZE_nsprefix_ + ':' if (UseCapturedNS_ and self.FS_FREEZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFS_FREEZE>%s</%sFS_FREEZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FS_FREEZE), input_name='FS_FREEZE')), namespaceprefix_ , eol_))
        if self.INCREMENTAL_BACKUP_ID is not None:
            namespaceprefix_ = self.INCREMENTAL_BACKUP_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.INCREMENTAL_BACKUP_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINCREMENTAL_BACKUP_ID>%s</%sINCREMENTAL_BACKUP_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INCREMENTAL_BACKUP_ID), input_name='INCREMENTAL_BACKUP_ID')), namespaceprefix_ , eol_))
        if self.INCREMENT_MODE is not None:
            namespaceprefix_ = self.INCREMENT_MODE_nsprefix_ + ':' if (UseCapturedNS_ and self.INCREMENT_MODE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINCREMENT_MODE>%s</%sINCREMENT_MODE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INCREMENT_MODE), input_name='INCREMENT_MODE')), namespaceprefix_ , eol_))
        if self.KEEP_LAST is not None:
            namespaceprefix_ = self.KEEP_LAST_nsprefix_ + ':' if (UseCapturedNS_ and self.KEEP_LAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKEEP_LAST>%s</%sKEEP_LAST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.KEEP_LAST), input_name='KEEP_LAST')), namespaceprefix_ , eol_))
        if self.LAST_BACKUP_ID is not None:
            namespaceprefix_ = self.LAST_BACKUP_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_BACKUP_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_BACKUP_ID>%s</%sLAST_BACKUP_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LAST_BACKUP_ID), input_name='LAST_BACKUP_ID')), namespaceprefix_ , eol_))
        if self.LAST_BACKUP_SIZE is not None:
            namespaceprefix_ = self.LAST_BACKUP_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_BACKUP_SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_BACKUP_SIZE>%s</%sLAST_BACKUP_SIZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LAST_BACKUP_SIZE), input_name='LAST_BACKUP_SIZE')), namespaceprefix_ , eol_))
        if self.LAST_BRIDGE is not None:
            namespaceprefix_ = self.LAST_BRIDGE_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_BRIDGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_BRIDGE>%s</%sLAST_BRIDGE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LAST_BRIDGE), input_name='LAST_BRIDGE')), namespaceprefix_ , eol_))
        if self.LAST_DATASTORE_ID is not None:
            namespaceprefix_ = self.LAST_DATASTORE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_DATASTORE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_DATASTORE_ID>%s</%sLAST_DATASTORE_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LAST_DATASTORE_ID), input_name='LAST_DATASTORE_ID')), namespaceprefix_ , eol_))
        if self.LAST_INCREMENT_ID is not None:
            namespaceprefix_ = self.LAST_INCREMENT_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_INCREMENT_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_INCREMENT_ID>%s</%sLAST_INCREMENT_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LAST_INCREMENT_ID), input_name='LAST_INCREMENT_ID')), namespaceprefix_ , eol_))
        if self.MODE is not None:
            namespaceprefix_ = self.MODE_nsprefix_ + ':' if (UseCapturedNS_ and self.MODE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMODE>%s</%sMODE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MODE), input_name='MODE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BACKUP_VOLATILE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BACKUP_VOLATILE')
            value_ = self.gds_validate_string(value_, node, 'BACKUP_VOLATILE')
            self.BACKUP_VOLATILE = value_
            self.BACKUP_VOLATILE_nsprefix_ = child_.prefix
        elif nodeName_ == 'FS_FREEZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FS_FREEZE')
            value_ = self.gds_validate_string(value_, node, 'FS_FREEZE')
            self.FS_FREEZE = value_
            self.FS_FREEZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'INCREMENTAL_BACKUP_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INCREMENTAL_BACKUP_ID')
            value_ = self.gds_validate_string(value_, node, 'INCREMENTAL_BACKUP_ID')
            self.INCREMENTAL_BACKUP_ID = value_
            self.INCREMENTAL_BACKUP_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'INCREMENT_MODE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INCREMENT_MODE')
            value_ = self.gds_validate_string(value_, node, 'INCREMENT_MODE')
            self.INCREMENT_MODE = value_
            self.INCREMENT_MODE_nsprefix_ = child_.prefix
        elif nodeName_ == 'KEEP_LAST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'KEEP_LAST')
            value_ = self.gds_validate_string(value_, node, 'KEEP_LAST')
            self.KEEP_LAST = value_
            self.KEEP_LAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'LAST_BACKUP_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LAST_BACKUP_ID')
            value_ = self.gds_validate_string(value_, node, 'LAST_BACKUP_ID')
            self.LAST_BACKUP_ID = value_
            self.LAST_BACKUP_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'LAST_BACKUP_SIZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LAST_BACKUP_SIZE')
            value_ = self.gds_validate_string(value_, node, 'LAST_BACKUP_SIZE')
            self.LAST_BACKUP_SIZE = value_
            self.LAST_BACKUP_SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'LAST_BRIDGE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LAST_BRIDGE')
            value_ = self.gds_validate_string(value_, node, 'LAST_BRIDGE')
            self.LAST_BRIDGE = value_
            self.LAST_BRIDGE_nsprefix_ = child_.prefix
        elif nodeName_ == 'LAST_DATASTORE_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LAST_DATASTORE_ID')
            value_ = self.gds_validate_string(value_, node, 'LAST_DATASTORE_ID')
            self.LAST_DATASTORE_ID = value_
            self.LAST_DATASTORE_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'LAST_INCREMENT_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LAST_INCREMENT_ID')
            value_ = self.gds_validate_string(value_, node, 'LAST_INCREMENT_ID')
            self.LAST_INCREMENT_ID = value_
            self.LAST_INCREMENT_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'MODE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MODE')
            value_ = self.gds_validate_string(value_, node, 'MODE')
            self.MODE = value_
            self.MODE_nsprefix_ = child_.prefix
# end class BACKUP_CONFIGType


class BACKUP_IDSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BACKUP_IDSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BACKUP_IDSType.subclass:
            return BACKUP_IDSType.subclass(*args_, **kwargs_)
        else:
            return BACKUP_IDSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUP_IDSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BACKUP_IDSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BACKUP_IDSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BACKUP_IDSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BACKUP_IDSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BACKUP_IDSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUP_IDSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ID_), input_name='ID')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID.append(value_)
            self.ID_nsprefix_ = child_.prefix
# end class BACKUP_IDSType


class ACLType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, USER=None, RESOURCE=None, RIGHTS=None, ZONE=None, STRING=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.USER = USER
        self.USER_nsprefix_ = None
        self.RESOURCE = RESOURCE
        self.RESOURCE_nsprefix_ = None
        self.RIGHTS = RIGHTS
        self.RIGHTS_nsprefix_ = None
        self.ZONE = ZONE
        self.ZONE_nsprefix_ = None
        self.STRING = STRING
        self.STRING_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACLType.subclass:
            return ACLType.subclass(*args_, **kwargs_)
        else:
            return ACLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_USER(self):
        return self.USER
    def set_USER(self, USER):
        self.USER = USER
    def get_RESOURCE(self):
        return self.RESOURCE
    def set_RESOURCE(self, RESOURCE):
        self.RESOURCE = RESOURCE
    def get_RIGHTS(self):
        return self.RIGHTS
    def set_RIGHTS(self, RIGHTS):
        self.RIGHTS = RIGHTS
    def get_ZONE(self):
        return self.ZONE
    def set_ZONE(self, ZONE):
        self.ZONE = ZONE
    def get_STRING(self):
        return self.STRING
    def set_STRING(self, STRING):
        self.STRING = STRING
    def has__content(self):
        if (
            self.ID is not None or
            self.USER is not None or
            self.RESOURCE is not None or
            self.RIGHTS is not None or
            self.ZONE is not None or
            self.STRING is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ACLType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ACLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ACLType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ACLType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ACLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ACLType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ACLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.USER is not None:
            namespaceprefix_ = self.USER_nsprefix_ + ':' if (UseCapturedNS_ and self.USER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSER>%s</%sUSER>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.USER), input_name='USER')), namespaceprefix_ , eol_))
        if self.RESOURCE is not None:
            namespaceprefix_ = self.RESOURCE_nsprefix_ + ':' if (UseCapturedNS_ and self.RESOURCE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRESOURCE>%s</%sRESOURCE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RESOURCE), input_name='RESOURCE')), namespaceprefix_ , eol_))
        if self.RIGHTS is not None:
            namespaceprefix_ = self.RIGHTS_nsprefix_ + ':' if (UseCapturedNS_ and self.RIGHTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRIGHTS>%s</%sRIGHTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RIGHTS), input_name='RIGHTS')), namespaceprefix_ , eol_))
        if self.ZONE is not None:
            namespaceprefix_ = self.ZONE_nsprefix_ + ':' if (UseCapturedNS_ and self.ZONE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZONE>%s</%sZONE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ZONE), input_name='ZONE')), namespaceprefix_ , eol_))
        if self.STRING is not None:
            namespaceprefix_ = self.STRING_nsprefix_ + ':' if (UseCapturedNS_ and self.STRING_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTRING>%s</%sSTRING>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.STRING), input_name='STRING')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'USER':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'USER')
            value_ = self.gds_validate_string(value_, node, 'USER')
            self.USER = value_
            self.USER_nsprefix_ = child_.prefix
        elif nodeName_ == 'RESOURCE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RESOURCE')
            value_ = self.gds_validate_string(value_, node, 'RESOURCE')
            self.RESOURCE = value_
            self.RESOURCE_nsprefix_ = child_.prefix
        elif nodeName_ == 'RIGHTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RIGHTS')
            value_ = self.gds_validate_string(value_, node, 'RIGHTS')
            self.RIGHTS = value_
            self.RIGHTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'ZONE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ZONE')
            value_ = self.gds_validate_string(value_, node, 'ZONE')
            self.ZONE = value_
            self.ZONE_nsprefix_ = child_.prefix
        elif nodeName_ == 'STRING':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'STRING')
            value_ = self.gds_validate_string(value_, node, 'STRING')
            self.STRING = value_
            self.STRING_nsprefix_ = child_.prefix
# end class ACLType


class PARAMETERSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PARAMETER=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if PARAMETER is None:
            self.PARAMETER = []
        else:
            self.PARAMETER = PARAMETER
        self.PARAMETER_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PARAMETERSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PARAMETERSType.subclass:
            return PARAMETERSType.subclass(*args_, **kwargs_)
        else:
            return PARAMETERSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PARAMETER(self):
        return self.PARAMETER
    def set_PARAMETER(self, PARAMETER):
        self.PARAMETER = PARAMETER
    def add_PARAMETER(self, value):
        self.PARAMETER.append(value)
    def insert_PARAMETER_at(self, index, value):
        self.PARAMETER.insert(index, value)
    def replace_PARAMETER_at(self, index, value):
        self.PARAMETER[index] = value
    def has__content(self):
        if (
            self.PARAMETER
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PARAMETERSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PARAMETERSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PARAMETERSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PARAMETERSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PARAMETERSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PARAMETERSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PARAMETERSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PARAMETER_ in self.PARAMETER:
            namespaceprefix_ = self.PARAMETER_nsprefix_ + ':' if (UseCapturedNS_ and self.PARAMETER_nsprefix_) else ''
            PARAMETER_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PARAMETER', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PARAMETER':
            obj_ = PARAMETERType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PARAMETER.append(obj_)
            obj_.original_tagname_ = 'PARAMETER'
# end class PARAMETERSType


class PARAMETERType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, POSITION=None, TYPE=None, VALUE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.POSITION = POSITION
        self.POSITION_nsprefix_ = None
        self.TYPE = TYPE
        self.validate_TYPEType(self.TYPE)
        self.TYPE_nsprefix_ = None
        self.VALUE = VALUE
        self.VALUE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PARAMETERType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PARAMETERType.subclass:
            return PARAMETERType.subclass(*args_, **kwargs_)
        else:
            return PARAMETERType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_POSITION(self):
        return self.POSITION
    def set_POSITION(self, POSITION):
        self.POSITION = POSITION
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_VALUE(self):
        return self.VALUE
    def set_VALUE(self, VALUE):
        self.VALUE = VALUE
    def validate_TYPEType(self, value):
        result = True
        # Validate type TYPEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['IN', 'OUT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TYPEType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.POSITION is not None or
            self.TYPE is not None or
            self.VALUE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PARAMETERType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PARAMETERType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PARAMETERType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PARAMETERType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PARAMETERType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PARAMETERType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PARAMETERType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.POSITION is not None:
            namespaceprefix_ = self.POSITION_nsprefix_ + ':' if (UseCapturedNS_ and self.POSITION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPOSITION>%s</%sPOSITION>%s' % (namespaceprefix_ , self.gds_format_integer(self.POSITION, input_name='POSITION'), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), namespaceprefix_ , eol_))
        if self.VALUE is not None:
            namespaceprefix_ = self.VALUE_nsprefix_ + ':' if (UseCapturedNS_ and self.VALUE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVALUE>%s</%sVALUE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VALUE), input_name='VALUE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'POSITION' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'POSITION')
            ival_ = self.gds_validate_integer(ival_, node, 'POSITION')
            self.POSITION = ival_
            self.POSITION_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TYPE')
            value_ = self.gds_validate_string(value_, node, 'TYPE')
            self.TYPE = value_
            self.TYPE_nsprefix_ = child_.prefix
            # validate type TYPEType
            self.validate_TYPEType(self.TYPE)
        elif nodeName_ == 'VALUE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VALUE')
            value_ = self.gds_validate_string(value_, node, 'VALUE')
            self.VALUE = value_
            self.VALUE_nsprefix_ = child_.prefix
# end class PARAMETERType


class EXTRAType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EXTRAType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EXTRAType.subclass:
            return EXTRAType.subclass(*args_, **kwargs_)
        else:
            return EXTRAType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='EXTRAType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EXTRAType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EXTRAType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EXTRAType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EXTRAType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EXTRAType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='EXTRAType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'EXTRAType')
        self.anytypeobjs_.append(content_)
# end class EXTRAType


class TEMPLATEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BACKUP_VMS=None, BACKUP_VOLATILE=None, DATASTORE_ID=None, ERROR=None, EXECUTION=None, FS_FREEZE=None, KEEP_LAST=None, MODE=None, RESET=None, SCHED_ACTION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.BACKUP_VMS = BACKUP_VMS
        self.BACKUP_VMS_nsprefix_ = None
        self.BACKUP_VOLATILE = BACKUP_VOLATILE
        self.BACKUP_VOLATILE_nsprefix_ = None
        self.DATASTORE_ID = DATASTORE_ID
        self.DATASTORE_ID_nsprefix_ = None
        self.ERROR = ERROR
        self.ERROR_nsprefix_ = None
        self.EXECUTION = EXECUTION
        self.EXECUTION_nsprefix_ = None
        self.FS_FREEZE = FS_FREEZE
        self.FS_FREEZE_nsprefix_ = None
        self.KEEP_LAST = KEEP_LAST
        self.KEEP_LAST_nsprefix_ = None
        self.MODE = MODE
        self.MODE_nsprefix_ = None
        self.RESET = RESET
        self.RESET_nsprefix_ = None
        if SCHED_ACTION is None:
            self.SCHED_ACTION = []
        else:
            self.SCHED_ACTION = SCHED_ACTION
        self.SCHED_ACTION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEMPLATEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEMPLATEType.subclass:
            return TEMPLATEType.subclass(*args_, **kwargs_)
        else:
            return TEMPLATEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BACKUP_VMS(self):
        return self.BACKUP_VMS
    def set_BACKUP_VMS(self, BACKUP_VMS):
        self.BACKUP_VMS = BACKUP_VMS
    def get_BACKUP_VOLATILE(self):
        return self.BACKUP_VOLATILE
    def set_BACKUP_VOLATILE(self, BACKUP_VOLATILE):
        self.BACKUP_VOLATILE = BACKUP_VOLATILE
    def get_DATASTORE_ID(self):
        return self.DATASTORE_ID
    def set_DATASTORE_ID(self, DATASTORE_ID):
        self.DATASTORE_ID = DATASTORE_ID
    def get_ERROR(self):
        return self.ERROR
    def set_ERROR(self, ERROR):
        self.ERROR = ERROR
    def get_EXECUTION(self):
        return self.EXECUTION
    def set_EXECUTION(self, EXECUTION):
        self.EXECUTION = EXECUTION
    def get_FS_FREEZE(self):
        return self.FS_FREEZE
    def set_FS_FREEZE(self, FS_FREEZE):
        self.FS_FREEZE = FS_FREEZE
    def get_KEEP_LAST(self):
        return self.KEEP_LAST
    def set_KEEP_LAST(self, KEEP_LAST):
        self.KEEP_LAST = KEEP_LAST
    def get_MODE(self):
        return self.MODE
    def set_MODE(self, MODE):
        self.MODE = MODE
    def get_RESET(self):
        return self.RESET
    def set_RESET(self, RESET):
        self.RESET = RESET
    def get_SCHED_ACTION(self):
        return self.SCHED_ACTION
    def set_SCHED_ACTION(self, SCHED_ACTION):
        self.SCHED_ACTION = SCHED_ACTION
    def add_SCHED_ACTION(self, value):
        self.SCHED_ACTION.append(value)
    def insert_SCHED_ACTION_at(self, index, value):
        self.SCHED_ACTION.insert(index, value)
    def replace_SCHED_ACTION_at(self, index, value):
        self.SCHED_ACTION[index] = value
    def has__content(self):
        if (
            self.BACKUP_VMS is not None or
            self.BACKUP_VOLATILE is not None or
            self.DATASTORE_ID is not None or
            self.ERROR is not None or
            self.EXECUTION is not None or
            self.FS_FREEZE is not None or
            self.KEEP_LAST is not None or
            self.MODE is not None or
            self.RESET is not None or
            self.SCHED_ACTION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEMPLATEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEMPLATEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEMPLATEType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEMPLATEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEMPLATEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BACKUP_VMS is not None:
            namespaceprefix_ = self.BACKUP_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUP_VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBACKUP_VMS>%s</%sBACKUP_VMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BACKUP_VMS), input_name='BACKUP_VMS')), namespaceprefix_ , eol_))
        if self.BACKUP_VOLATILE is not None:
            namespaceprefix_ = self.BACKUP_VOLATILE_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUP_VOLATILE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBACKUP_VOLATILE>%s</%sBACKUP_VOLATILE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BACKUP_VOLATILE), input_name='BACKUP_VOLATILE')), namespaceprefix_ , eol_))
        if self.DATASTORE_ID is not None:
            namespaceprefix_ = self.DATASTORE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATASTORE_ID>%s</%sDATASTORE_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DATASTORE_ID), input_name='DATASTORE_ID')), namespaceprefix_ , eol_))
        if self.ERROR is not None:
            namespaceprefix_ = self.ERROR_nsprefix_ + ':' if (UseCapturedNS_ and self.ERROR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sERROR>%s</%sERROR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ERROR), input_name='ERROR')), namespaceprefix_ , eol_))
        if self.EXECUTION is not None:
            namespaceprefix_ = self.EXECUTION_nsprefix_ + ':' if (UseCapturedNS_ and self.EXECUTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXECUTION>%s</%sEXECUTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EXECUTION), input_name='EXECUTION')), namespaceprefix_ , eol_))
        if self.FS_FREEZE is not None:
            namespaceprefix_ = self.FS_FREEZE_nsprefix_ + ':' if (UseCapturedNS_ and self.FS_FREEZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFS_FREEZE>%s</%sFS_FREEZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FS_FREEZE), input_name='FS_FREEZE')), namespaceprefix_ , eol_))
        if self.KEEP_LAST is not None:
            namespaceprefix_ = self.KEEP_LAST_nsprefix_ + ':' if (UseCapturedNS_ and self.KEEP_LAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKEEP_LAST>%s</%sKEEP_LAST>%s' % (namespaceprefix_ , self.gds_format_integer(self.KEEP_LAST, input_name='KEEP_LAST'), namespaceprefix_ , eol_))
        if self.MODE is not None:
            namespaceprefix_ = self.MODE_nsprefix_ + ':' if (UseCapturedNS_ and self.MODE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMODE>%s</%sMODE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MODE), input_name='MODE')), namespaceprefix_ , eol_))
        if self.RESET is not None:
            namespaceprefix_ = self.RESET_nsprefix_ + ':' if (UseCapturedNS_ and self.RESET_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRESET>%s</%sRESET>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RESET), input_name='RESET')), namespaceprefix_ , eol_))
        for SCHED_ACTION_ in self.SCHED_ACTION:
            namespaceprefix_ = self.SCHED_ACTION_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_ACTION_nsprefix_) else ''
            SCHED_ACTION_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SCHED_ACTION', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BACKUP_VMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BACKUP_VMS')
            value_ = self.gds_validate_string(value_, node, 'BACKUP_VMS')
            self.BACKUP_VMS = value_
            self.BACKUP_VMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'BACKUP_VOLATILE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BACKUP_VOLATILE')
            value_ = self.gds_validate_string(value_, node, 'BACKUP_VOLATILE')
            self.BACKUP_VOLATILE = value_
            self.BACKUP_VOLATILE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATASTORE_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DATASTORE_ID')
            value_ = self.gds_validate_string(value_, node, 'DATASTORE_ID')
            self.DATASTORE_ID = value_
            self.DATASTORE_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'ERROR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ERROR')
            value_ = self.gds_validate_string(value_, node, 'ERROR')
            self.ERROR = value_
            self.ERROR_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXECUTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EXECUTION')
            value_ = self.gds_validate_string(value_, node, 'EXECUTION')
            self.EXECUTION = value_
            self.EXECUTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'FS_FREEZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FS_FREEZE')
            value_ = self.gds_validate_string(value_, node, 'FS_FREEZE')
            self.FS_FREEZE = value_
            self.FS_FREEZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'KEEP_LAST' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'KEEP_LAST')
            ival_ = self.gds_validate_integer(ival_, node, 'KEEP_LAST')
            self.KEEP_LAST = ival_
            self.KEEP_LAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'MODE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MODE')
            value_ = self.gds_validate_string(value_, node, 'MODE')
            self.MODE = value_
            self.MODE_nsprefix_ = child_.prefix
        elif nodeName_ == 'RESET':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RESET')
            value_ = self.gds_validate_string(value_, node, 'RESET')
            self.RESET = value_
            self.RESET_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHED_ACTION':
            obj_ = SCHED_ACTION.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SCHED_ACTION.append(obj_)
            obj_.original_tagname_ = 'SCHED_ACTION'
# end class TEMPLATEType


class DATASTOREType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, IMAGES=None, IMAGES_USED=None, SIZE=None, SIZE_USED=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.IMAGES = IMAGES
        self.IMAGES_nsprefix_ = None
        self.IMAGES_USED = IMAGES_USED
        self.IMAGES_USED_nsprefix_ = None
        self.SIZE = SIZE
        self.SIZE_nsprefix_ = None
        self.SIZE_USED = SIZE_USED
        self.SIZE_USED_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTOREType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTOREType.subclass:
            return DATASTOREType.subclass(*args_, **kwargs_)
        else:
            return DATASTOREType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_IMAGES(self):
        return self.IMAGES
    def set_IMAGES(self, IMAGES):
        self.IMAGES = IMAGES
    def get_IMAGES_USED(self):
        return self.IMAGES_USED
    def set_IMAGES_USED(self, IMAGES_USED):
        self.IMAGES_USED = IMAGES_USED
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def get_SIZE_USED(self):
        return self.SIZE_USED
    def set_SIZE_USED(self, SIZE_USED):
        self.SIZE_USED = SIZE_USED
    def has__content(self):
        if (
            self.ID is not None or
            self.IMAGES is not None or
            self.IMAGES_USED is not None or
            self.SIZE is not None or
            self.SIZE_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTOREType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTOREType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATASTOREType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATASTOREType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATASTOREType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATASTOREType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTOREType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.IMAGES is not None:
            namespaceprefix_ = self.IMAGES_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIMAGES>%s</%sIMAGES>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES), input_name='IMAGES')), namespaceprefix_ , eol_))
        if self.IMAGES_USED is not None:
            namespaceprefix_ = self.IMAGES_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGES_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIMAGES_USED>%s</%sIMAGES_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES_USED), input_name='IMAGES_USED')), namespaceprefix_ , eol_))
        if self.SIZE is not None:
            namespaceprefix_ = self.SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE>%s</%sSIZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SIZE), input_name='SIZE')), namespaceprefix_ , eol_))
        if self.SIZE_USED is not None:
            namespaceprefix_ = self.SIZE_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE_USED>%s</%sSIZE_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SIZE_USED), input_name='SIZE_USED')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'IMAGES':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IMAGES')
            value_ = self.gds_validate_string(value_, node, 'IMAGES')
            self.IMAGES = value_
            self.IMAGES_nsprefix_ = child_.prefix
        elif nodeName_ == 'IMAGES_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IMAGES_USED')
            value_ = self.gds_validate_string(value_, node, 'IMAGES_USED')
            self.IMAGES_USED = value_
            self.IMAGES_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SIZE')
            value_ = self.gds_validate_string(value_, node, 'SIZE')
            self.SIZE = value_
            self.SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SIZE_USED')
            value_ = self.gds_validate_string(value_, node, 'SIZE_USED')
            self.SIZE_USED = value_
            self.SIZE_USED_nsprefix_ = child_.prefix
# end class DATASTOREType


class NETWORKType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, LEASES=None, LEASES_USED=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.LEASES = LEASES
        self.LEASES_nsprefix_ = None
        self.LEASES_USED = LEASES_USED
        self.LEASES_USED_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORKType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORKType.subclass:
            return NETWORKType.subclass(*args_, **kwargs_)
        else:
            return NETWORKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_LEASES(self):
        return self.LEASES
    def set_LEASES(self, LEASES):
        self.LEASES = LEASES
    def get_LEASES_USED(self):
        return self.LEASES_USED
    def set_LEASES_USED(self, LEASES_USED):
        self.LEASES_USED = LEASES_USED
    def has__content(self):
        if (
            self.ID is not None or
            self.LEASES is not None or
            self.LEASES_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NETWORKType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORKType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NETWORKType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NETWORKType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NETWORKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NETWORKType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NETWORKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.LEASES is not None:
            namespaceprefix_ = self.LEASES_nsprefix_ + ':' if (UseCapturedNS_ and self.LEASES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLEASES>%s</%sLEASES>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LEASES), input_name='LEASES')), namespaceprefix_ , eol_))
        if self.LEASES_USED is not None:
            namespaceprefix_ = self.LEASES_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.LEASES_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLEASES_USED>%s</%sLEASES_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LEASES_USED), input_name='LEASES_USED')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'LEASES':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LEASES')
            value_ = self.gds_validate_string(value_, node, 'LEASES')
            self.LEASES = value_
            self.LEASES_nsprefix_ = child_.prefix
        elif nodeName_ == 'LEASES_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LEASES_USED')
            value_ = self.gds_validate_string(value_, node, 'LEASES_USED')
            self.LEASES_USED = value_
            self.LEASES_USED_nsprefix_ = child_.prefix
# end class NETWORKType


class VMType1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CLUSTER_IDS=None, CPU=None, CPU_USED=None, MEMORY=None, MEMORY_USED=None, RUNNING_CPU=None, RUNNING_CPU_USED=None, RUNNING_MEMORY=None, RUNNING_MEMORY_USED=None, RUNNING_VMS=None, RUNNING_VMS_USED=None, SYSTEM_DISK_SIZE=None, SYSTEM_DISK_SIZE_USED=None, VMS=None, VMS_USED=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CLUSTER_IDS = CLUSTER_IDS
        self.CLUSTER_IDS_nsprefix_ = None
        self.CPU = CPU
        self.CPU_nsprefix_ = None
        self.CPU_USED = CPU_USED
        self.CPU_USED_nsprefix_ = None
        self.MEMORY = MEMORY
        self.MEMORY_nsprefix_ = None
        self.MEMORY_USED = MEMORY_USED
        self.MEMORY_USED_nsprefix_ = None
        self.RUNNING_CPU = RUNNING_CPU
        self.RUNNING_CPU_nsprefix_ = None
        self.RUNNING_CPU_USED = RUNNING_CPU_USED
        self.RUNNING_CPU_USED_nsprefix_ = None
        self.RUNNING_MEMORY = RUNNING_MEMORY
        self.RUNNING_MEMORY_nsprefix_ = None
        self.RUNNING_MEMORY_USED = RUNNING_MEMORY_USED
        self.RUNNING_MEMORY_USED_nsprefix_ = None
        self.RUNNING_VMS = RUNNING_VMS
        self.RUNNING_VMS_nsprefix_ = None
        self.RUNNING_VMS_USED = RUNNING_VMS_USED
        self.RUNNING_VMS_USED_nsprefix_ = None
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_nsprefix_ = None
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
        self.SYSTEM_DISK_SIZE_USED_nsprefix_ = None
        self.VMS = VMS
        self.VMS_nsprefix_ = None
        self.VMS_USED = VMS_USED
        self.VMS_USED_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType1.subclass:
            return VMType1.subclass(*args_, **kwargs_)
        else:
            return VMType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CLUSTER_IDS(self):
        return self.CLUSTER_IDS
    def set_CLUSTER_IDS(self, CLUSTER_IDS):
        self.CLUSTER_IDS = CLUSTER_IDS
    def get_CPU(self):
        return self.CPU
    def set_CPU(self, CPU):
        self.CPU = CPU
    def get_CPU_USED(self):
        return self.CPU_USED
    def set_CPU_USED(self, CPU_USED):
        self.CPU_USED = CPU_USED
    def get_MEMORY(self):
        return self.MEMORY
    def set_MEMORY(self, MEMORY):
        self.MEMORY = MEMORY
    def get_MEMORY_USED(self):
        return self.MEMORY_USED
    def set_MEMORY_USED(self, MEMORY_USED):
        self.MEMORY_USED = MEMORY_USED
    def get_RUNNING_CPU(self):
        return self.RUNNING_CPU
    def set_RUNNING_CPU(self, RUNNING_CPU):
        self.RUNNING_CPU = RUNNING_CPU
    def get_RUNNING_CPU_USED(self):
        return self.RUNNING_CPU_USED
    def set_RUNNING_CPU_USED(self, RUNNING_CPU_USED):
        self.RUNNING_CPU_USED = RUNNING_CPU_USED
    def get_RUNNING_MEMORY(self):
        return self.RUNNING_MEMORY
    def set_RUNNING_MEMORY(self, RUNNING_MEMORY):
        self.RUNNING_MEMORY = RUNNING_MEMORY
    def get_RUNNING_MEMORY_USED(self):
        return self.RUNNING_MEMORY_USED
    def set_RUNNING_MEMORY_USED(self, RUNNING_MEMORY_USED):
        self.RUNNING_MEMORY_USED = RUNNING_MEMORY_USED
    def get_RUNNING_VMS(self):
        return self.RUNNING_VMS
    def set_RUNNING_VMS(self, RUNNING_VMS):
        self.RUNNING_VMS = RUNNING_VMS
    def get_RUNNING_VMS_USED(self):
        return self.RUNNING_VMS_USED
    def set_RUNNING_VMS_USED(self, RUNNING_VMS_USED):
        self.RUNNING_VMS_USED = RUNNING_VMS_USED
    def get_SYSTEM_DISK_SIZE(self):
        return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE):
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_SYSTEM_DISK_SIZE_USED(self):
        return self.SYSTEM_DISK_SIZE_USED
    def set_SYSTEM_DISK_SIZE_USED(self, SYSTEM_DISK_SIZE_USED):
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
    def get_VMS(self):
        return self.VMS
    def set_VMS(self, VMS):
        self.VMS = VMS
    def get_VMS_USED(self):
        return self.VMS_USED
    def set_VMS_USED(self, VMS_USED):
        self.VMS_USED = VMS_USED
    def has__content(self):
        if (
            self.CLUSTER_IDS is not None or
            self.CPU is not None or
            self.CPU_USED is not None or
            self.MEMORY is not None or
            self.MEMORY_USED is not None or
            self.RUNNING_CPU is not None or
            self.RUNNING_CPU_USED is not None or
            self.RUNNING_MEMORY is not None or
            self.RUNNING_MEMORY_USED is not None or
            self.RUNNING_VMS is not None or
            self.RUNNING_VMS_USED is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.SYSTEM_DISK_SIZE_USED is not None or
            self.VMS is not None or
            self.VMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VMType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VMType1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VMType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VMType1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CLUSTER_IDS is not None:
            namespaceprefix_ = self.CLUSTER_IDS_nsprefix_ + ':' if (UseCapturedNS_ and self.CLUSTER_IDS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLUSTER_IDS>%s</%sCLUSTER_IDS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CLUSTER_IDS), input_name='CLUSTER_IDS')), namespaceprefix_ , eol_))
        if self.CPU is not None:
            namespaceprefix_ = self.CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU>%s</%sCPU>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), namespaceprefix_ , eol_))
        if self.CPU_USED is not None:
            namespaceprefix_ = self.CPU_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU_USED>%s</%sCPU_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPU_USED), input_name='CPU_USED')), namespaceprefix_ , eol_))
        if self.MEMORY is not None:
            namespaceprefix_ = self.MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY>%s</%sMEMORY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), namespaceprefix_ , eol_))
        if self.MEMORY_USED is not None:
            namespaceprefix_ = self.MEMORY_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY_USED>%s</%sMEMORY_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_USED), input_name='MEMORY_USED')), namespaceprefix_ , eol_))
        if self.RUNNING_CPU is not None:
            namespaceprefix_ = self.RUNNING_CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_CPU>%s</%sRUNNING_CPU>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_CPU), input_name='RUNNING_CPU')), namespaceprefix_ , eol_))
        if self.RUNNING_CPU_USED is not None:
            namespaceprefix_ = self.RUNNING_CPU_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_CPU_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_CPU_USED>%s</%sRUNNING_CPU_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_CPU_USED), input_name='RUNNING_CPU_USED')), namespaceprefix_ , eol_))
        if self.RUNNING_MEMORY is not None:
            namespaceprefix_ = self.RUNNING_MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_MEMORY>%s</%sRUNNING_MEMORY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_MEMORY), input_name='RUNNING_MEMORY')), namespaceprefix_ , eol_))
        if self.RUNNING_MEMORY_USED is not None:
            namespaceprefix_ = self.RUNNING_MEMORY_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_MEMORY_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_MEMORY_USED>%s</%sRUNNING_MEMORY_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_MEMORY_USED), input_name='RUNNING_MEMORY_USED')), namespaceprefix_ , eol_))
        if self.RUNNING_VMS is not None:
            namespaceprefix_ = self.RUNNING_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_VMS>%s</%sRUNNING_VMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_VMS), input_name='RUNNING_VMS')), namespaceprefix_ , eol_))
        if self.RUNNING_VMS_USED is not None:
            namespaceprefix_ = self.RUNNING_VMS_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_VMS_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_VMS_USED>%s</%sRUNNING_VMS_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_VMS_USED), input_name='RUNNING_VMS_USED')), namespaceprefix_ , eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            namespaceprefix_ = self.SYSTEM_DISK_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SYSTEM_DISK_SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYSTEM_DISK_SIZE>%s</%sSYSTEM_DISK_SIZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE), input_name='SYSTEM_DISK_SIZE')), namespaceprefix_ , eol_))
        if self.SYSTEM_DISK_SIZE_USED is not None:
            namespaceprefix_ = self.SYSTEM_DISK_SIZE_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.SYSTEM_DISK_SIZE_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYSTEM_DISK_SIZE_USED>%s</%sSYSTEM_DISK_SIZE_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE_USED), input_name='SYSTEM_DISK_SIZE_USED')), namespaceprefix_ , eol_))
        if self.VMS is not None:
            namespaceprefix_ = self.VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMS>%s</%sVMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VMS), input_name='VMS')), namespaceprefix_ , eol_))
        if self.VMS_USED is not None:
            namespaceprefix_ = self.VMS_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMS_USED>%s</%sVMS_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VMS_USED), input_name='VMS_USED')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CLUSTER_IDS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CLUSTER_IDS')
            value_ = self.gds_validate_string(value_, node, 'CLUSTER_IDS')
            self.CLUSTER_IDS = value_
            self.CLUSTER_IDS_nsprefix_ = child_.prefix
        elif nodeName_ == 'CPU':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPU')
            value_ = self.gds_validate_string(value_, node, 'CPU')
            self.CPU = value_
            self.CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'CPU_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPU_USED')
            value_ = self.gds_validate_string(value_, node, 'CPU_USED')
            self.CPU_USED = value_
            self.CPU_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY')
            value_ = self.gds_validate_string(value_, node, 'MEMORY')
            self.MEMORY = value_
            self.MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY_USED')
            value_ = self.gds_validate_string(value_, node, 'MEMORY_USED')
            self.MEMORY_USED = value_
            self.MEMORY_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_CPU':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_CPU')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_CPU')
            self.RUNNING_CPU = value_
            self.RUNNING_CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_CPU_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_CPU_USED')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_CPU_USED')
            self.RUNNING_CPU_USED = value_
            self.RUNNING_CPU_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_MEMORY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_MEMORY')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_MEMORY')
            self.RUNNING_MEMORY = value_
            self.RUNNING_MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_MEMORY_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_MEMORY_USED')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_MEMORY_USED')
            self.RUNNING_MEMORY_USED = value_
            self.RUNNING_MEMORY_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_VMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_VMS')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_VMS')
            self.RUNNING_VMS = value_
            self.RUNNING_VMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_VMS_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_VMS_USED')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_VMS_USED')
            self.RUNNING_VMS_USED = value_
            self.RUNNING_VMS_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYSTEM_DISK_SIZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SYSTEM_DISK_SIZE')
            value_ = self.gds_validate_string(value_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = value_
            self.SYSTEM_DISK_SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYSTEM_DISK_SIZE_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SYSTEM_DISK_SIZE_USED')
            value_ = self.gds_validate_string(value_, node, 'SYSTEM_DISK_SIZE_USED')
            self.SYSTEM_DISK_SIZE_USED = value_
            self.SYSTEM_DISK_SIZE_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VMS')
            value_ = self.gds_validate_string(value_, node, 'VMS')
            self.VMS = value_
            self.VMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMS_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VMS_USED')
            value_ = self.gds_validate_string(value_, node, 'VMS_USED')
            self.VMS_USED = value_
            self.VMS_USED_nsprefix_ = child_.prefix
# end class VMType1


class IMAGEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, RVMS=None, RVMS_USED=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.RVMS = RVMS
        self.RVMS_nsprefix_ = None
        self.RVMS_USED = RVMS_USED
        self.RVMS_USED_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGEType.subclass:
            return IMAGEType.subclass(*args_, **kwargs_)
        else:
            return IMAGEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_RVMS(self):
        return self.RVMS
    def set_RVMS(self, RVMS):
        self.RVMS = RVMS
    def get_RVMS_USED(self):
        return self.RVMS_USED
    def set_RVMS_USED(self, RVMS_USED):
        self.RVMS_USED = RVMS_USED
    def has__content(self):
        if (
            self.ID is not None or
            self.RVMS is not None or
            self.RVMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IMAGEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IMAGEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGEType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IMAGEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IMAGEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IMAGEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.RVMS is not None:
            namespaceprefix_ = self.RVMS_nsprefix_ + ':' if (UseCapturedNS_ and self.RVMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRVMS>%s</%sRVMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RVMS), input_name='RVMS')), namespaceprefix_ , eol_))
        if self.RVMS_USED is not None:
            namespaceprefix_ = self.RVMS_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RVMS_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRVMS_USED>%s</%sRVMS_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RVMS_USED), input_name='RVMS_USED')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'RVMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RVMS')
            value_ = self.gds_validate_string(value_, node, 'RVMS')
            self.RVMS = value_
            self.RVMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'RVMS_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RVMS_USED')
            value_ = self.gds_validate_string(value_, node, 'RVMS_USED')
            self.RVMS_USED = value_
            self.RVMS_USED_nsprefix_ = child_.prefix
# end class IMAGEType


class HOSTSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOSTSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOSTSType.subclass:
            return HOSTSType.subclass(*args_, **kwargs_)
        else:
            return HOSTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOSTSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOSTSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HOSTSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HOSTSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HOSTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HOSTSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOSTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class HOSTSType


class DATASTORESType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORESType.subclass:
            return DATASTORESType.subclass(*args_, **kwargs_)
        else:
            return DATASTORESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATASTORESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATASTORESType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATASTORESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATASTORESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class DATASTORESType


class VNETSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNETSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNETSType.subclass:
            return VNETSType.subclass(*args_, **kwargs_)
        else:
            return VNETSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNETSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNETSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VNETSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VNETSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VNETSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VNETSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNETSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class VNETSType


class PLANType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, STATE=None, ACTION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.ACTION = ACTION
        self.ACTION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PLANType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PLANType.subclass:
            return PLANType.subclass(*args_, **kwargs_)
        else:
            return PLANType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_ACTION(self):
        return self.ACTION
    def set_ACTION(self, ACTION):
        self.ACTION = ACTION
    def has__content(self):
        if (
            self.ID is not None or
            self.STATE is not None or
            self.ACTION is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PLANType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PLANType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PLANType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PLANType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PLANType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PLANType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PLANType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.ACTION is not None:
            namespaceprefix_ = self.ACTION_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTION_nsprefix_) else ''
            self.ACTION.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ACTION', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'ACTION':
            obj_ = ACTIONType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ACTION = obj_
            obj_.original_tagname_ = 'ACTION'
# end class PLANType


class ACTIONType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, VM_ID=None, STATE=None, OPERATION=None, HOST_ID=None, DS_ID=None, TIMESTAMP=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.VM_ID = VM_ID
        self.VM_ID_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.OPERATION = OPERATION
        self.OPERATION_nsprefix_ = None
        self.HOST_ID = HOST_ID
        self.HOST_ID_nsprefix_ = None
        self.DS_ID = DS_ID
        self.DS_ID_nsprefix_ = None
        self.TIMESTAMP = TIMESTAMP
        self.TIMESTAMP_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACTIONType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACTIONType.subclass:
            return ACTIONType.subclass(*args_, **kwargs_)
        else:
            return ACTIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_VM_ID(self):
        return self.VM_ID
    def set_VM_ID(self, VM_ID):
        self.VM_ID = VM_ID
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_OPERATION(self):
        return self.OPERATION
    def set_OPERATION(self, OPERATION):
        self.OPERATION = OPERATION
    def get_HOST_ID(self):
        return self.HOST_ID
    def set_HOST_ID(self, HOST_ID):
        self.HOST_ID = HOST_ID
    def get_DS_ID(self):
        return self.DS_ID
    def set_DS_ID(self, DS_ID):
        self.DS_ID = DS_ID
    def get_TIMESTAMP(self):
        return self.TIMESTAMP
    def set_TIMESTAMP(self, TIMESTAMP):
        self.TIMESTAMP = TIMESTAMP
    def has__content(self):
        if (
            self.ID is not None or
            self.VM_ID is not None or
            self.STATE is not None or
            self.OPERATION is not None or
            self.HOST_ID is not None or
            self.DS_ID is not None or
            self.TIMESTAMP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ACTIONType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ACTIONType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ACTIONType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ACTIONType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ACTIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ACTIONType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ACTIONType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.VM_ID is not None:
            namespaceprefix_ = self.VM_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM_ID>%s</%sVM_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.VM_ID, input_name='VM_ID'), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.OPERATION is not None:
            namespaceprefix_ = self.OPERATION_nsprefix_ + ':' if (UseCapturedNS_ and self.OPERATION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOPERATION>%s</%sOPERATION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OPERATION), input_name='OPERATION')), namespaceprefix_ , eol_))
        if self.HOST_ID is not None:
            namespaceprefix_ = self.HOST_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.HOST_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHOST_ID>%s</%sHOST_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.HOST_ID, input_name='HOST_ID'), namespaceprefix_ , eol_))
        if self.DS_ID is not None:
            namespaceprefix_ = self.DS_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.DS_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDS_ID>%s</%sDS_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.DS_ID, input_name='DS_ID'), namespaceprefix_ , eol_))
        if self.TIMESTAMP is not None:
            namespaceprefix_ = self.TIMESTAMP_nsprefix_ + ':' if (UseCapturedNS_ and self.TIMESTAMP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIMESTAMP>%s</%sTIMESTAMP>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIMESTAMP, input_name='TIMESTAMP'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'VM_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VM_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'VM_ID')
            self.VM_ID = ival_
            self.VM_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'OPERATION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OPERATION')
            value_ = self.gds_validate_string(value_, node, 'OPERATION')
            self.OPERATION = value_
            self.OPERATION_nsprefix_ = child_.prefix
        elif nodeName_ == 'HOST_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'HOST_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'HOST_ID')
            self.HOST_ID = ival_
            self.HOST_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'DS_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DS_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'DS_ID')
            self.DS_ID = ival_
            self.DS_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIMESTAMP' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIMESTAMP')
            ival_ = self.gds_validate_integer(ival_, node, 'TIMESTAMP')
            self.TIMESTAMP = ival_
            self.TIMESTAMP_nsprefix_ = child_.prefix
# end class ACTIONType


class PERMISSIONSType2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType2.subclass:
            return PERMISSIONSType2.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONSType2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONSType2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONSType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONSType2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONSType2


class CLUSTERSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTERSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTERSType.subclass:
            return CLUSTERSType.subclass(*args_, **kwargs_)
        else:
            return CLUSTERSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTERSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTERSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CLUSTERSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CLUSTERSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CLUSTERSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CLUSTERSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTERSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class CLUSTERSType


class IMAGESType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGESType.subclass:
            return IMAGESType.subclass(*args_, **kwargs_)
        else:
            return IMAGESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IMAGESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IMAGESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGESType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IMAGESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IMAGESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IMAGESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class IMAGESType


class PERMISSIONSType3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType3.subclass:
            return PERMISSIONSType3.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONSType3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONSType3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONSType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONSType3'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONSType3


class LOCKType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LOCKED=None, OWNER=None, TIME=None, REQ_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LOCKED = LOCKED
        self.LOCKED_nsprefix_ = None
        self.OWNER = OWNER
        self.OWNER_nsprefix_ = None
        self.TIME = TIME
        self.TIME_nsprefix_ = None
        self.REQ_ID = REQ_ID
        self.REQ_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOCKType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOCKType.subclass:
            return LOCKType.subclass(*args_, **kwargs_)
        else:
            return LOCKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LOCKED(self):
        return self.LOCKED
    def set_LOCKED(self, LOCKED):
        self.LOCKED = LOCKED
    def get_OWNER(self):
        return self.OWNER
    def set_OWNER(self, OWNER):
        self.OWNER = OWNER
    def get_TIME(self):
        return self.TIME
    def set_TIME(self, TIME):
        self.TIME = TIME
    def get_REQ_ID(self):
        return self.REQ_ID
    def set_REQ_ID(self, REQ_ID):
        self.REQ_ID = REQ_ID
    def has__content(self):
        if (
            self.LOCKED is not None or
            self.OWNER is not None or
            self.TIME is not None or
            self.REQ_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOCKType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LOCKType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LOCKType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LOCKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LOCKType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LOCKED is not None:
            namespaceprefix_ = self.LOCKED_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCKED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOCKED>%s</%sLOCKED>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOCKED, input_name='LOCKED'), namespaceprefix_ , eol_))
        if self.OWNER is not None:
            namespaceprefix_ = self.OWNER_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER>%s</%sOWNER>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER, input_name='OWNER'), namespaceprefix_ , eol_))
        if self.TIME is not None:
            namespaceprefix_ = self.TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIME>%s</%sTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIME, input_name='TIME'), namespaceprefix_ , eol_))
        if self.REQ_ID is not None:
            namespaceprefix_ = self.REQ_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.REQ_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREQ_ID>%s</%sREQ_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.REQ_ID, input_name='REQ_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LOCKED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOCKED')
            ival_ = self.gds_validate_integer(ival_, node, 'LOCKED')
            self.LOCKED = ival_
            self.LOCKED_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER')
            self.OWNER = ival_
            self.OWNER_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'TIME')
            self.TIME = ival_
            self.TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'REQ_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REQ_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'REQ_ID')
            self.REQ_ID = ival_
            self.REQ_ID_nsprefix_ = child_.prefix
# end class LOCKType


class GROUPType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, NAME=None, TEMPLATE=None, USERS=None, ADMINS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.USERS = USERS
        self.USERS_nsprefix_ = None
        self.ADMINS = ADMINS
        self.ADMINS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GROUPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GROUPType.subclass:
            return GROUPType.subclass(*args_, **kwargs_)
        else:
            return GROUPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_USERS(self):
        return self.USERS
    def set_USERS(self, USERS):
        self.USERS = USERS
    def get_ADMINS(self):
        return self.ADMINS
    def set_ADMINS(self, ADMINS):
        self.ADMINS = ADMINS
    def has__content(self):
        if (
            self.ID is not None or
            self.NAME is not None or
            self.TEMPLATE is not None or
            self.USERS is not None or
            self.ADMINS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='GROUPType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GROUPType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GROUPType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GROUPType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GROUPType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GROUPType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='GROUPType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
        if self.USERS is not None:
            namespaceprefix_ = self.USERS_nsprefix_ + ':' if (UseCapturedNS_ and self.USERS_nsprefix_) else ''
            self.USERS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='USERS', pretty_print=pretty_print)
        if self.ADMINS is not None:
            namespaceprefix_ = self.ADMINS_nsprefix_ + ':' if (UseCapturedNS_ and self.ADMINS_nsprefix_) else ''
            self.ADMINS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ADMINS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'USERS':
            obj_ = USERSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.USERS = obj_
            obj_.original_tagname_ = 'USERS'
        elif nodeName_ == 'ADMINS':
            obj_ = ADMINSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ADMINS = obj_
            obj_.original_tagname_ = 'ADMINS'
# end class GROUPType


class USERSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USERSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USERSType.subclass:
            return USERSType.subclass(*args_, **kwargs_)
        else:
            return USERSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USERSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USERSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'USERSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USERSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='USERSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='USERSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USERSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class USERSType


class ADMINSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADMINSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADMINSType.subclass:
            return ADMINSType.subclass(*args_, **kwargs_)
        else:
            return ADMINSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ADMINSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ADMINSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ADMINSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ADMINSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ADMINSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ADMINSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ADMINSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class ADMINSType


class QUOTASType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.DATASTORE_QUOTA_nsprefix_ = None
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.NETWORK_QUOTA_nsprefix_ = None
        self.VM_QUOTA = VM_QUOTA
        self.VM_QUOTA_nsprefix_ = None
        self.IMAGE_QUOTA = IMAGE_QUOTA
        self.IMAGE_QUOTA_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QUOTASType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QUOTASType.subclass:
            return QUOTASType.subclass(*args_, **kwargs_)
        else:
            return QUOTASType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_DATASTORE_QUOTA(self):
        return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA):
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self):
        return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA):
        self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self):
        return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA):
        self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self):
        return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA):
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def has__content(self):
        if (
            self.ID is not None or
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='QUOTASType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QUOTASType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QUOTASType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QUOTASType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QUOTASType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QUOTASType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='QUOTASType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.DATASTORE_QUOTA is not None:
            namespaceprefix_ = self.DATASTORE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_QUOTA_nsprefix_) else ''
            self.DATASTORE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            namespaceprefix_ = self.NETWORK_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.NETWORK_QUOTA_nsprefix_) else ''
            self.NETWORK_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            namespaceprefix_ = self.VM_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_QUOTA_nsprefix_) else ''
            self.VM_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            namespaceprefix_ = self.IMAGE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_QUOTA_nsprefix_) else ''
            self.IMAGE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_QUOTA', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
# end class QUOTASType


class DEFAULT_GROUP_QUOTASType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.DATASTORE_QUOTA_nsprefix_ = None
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.NETWORK_QUOTA_nsprefix_ = None
        self.VM_QUOTA = VM_QUOTA
        self.VM_QUOTA_nsprefix_ = None
        self.IMAGE_QUOTA = IMAGE_QUOTA
        self.IMAGE_QUOTA_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DEFAULT_GROUP_QUOTASType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DEFAULT_GROUP_QUOTASType.subclass:
            return DEFAULT_GROUP_QUOTASType.subclass(*args_, **kwargs_)
        else:
            return DEFAULT_GROUP_QUOTASType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATASTORE_QUOTA(self):
        return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA):
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self):
        return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA):
        self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self):
        return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA):
        self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self):
        return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA):
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def has__content(self):
        if (
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DEFAULT_GROUP_QUOTASType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DEFAULT_GROUP_QUOTASType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DEFAULT_GROUP_QUOTASType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DEFAULT_GROUP_QUOTASType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DEFAULT_GROUP_QUOTASType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DEFAULT_GROUP_QUOTASType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DEFAULT_GROUP_QUOTASType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DATASTORE_QUOTA is not None:
            namespaceprefix_ = self.DATASTORE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_QUOTA_nsprefix_) else ''
            self.DATASTORE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            namespaceprefix_ = self.NETWORK_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.NETWORK_QUOTA_nsprefix_) else ''
            self.NETWORK_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            namespaceprefix_ = self.VM_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_QUOTA_nsprefix_) else ''
            self.VM_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            namespaceprefix_ = self.IMAGE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_QUOTA_nsprefix_) else ''
            self.IMAGE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_QUOTA', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTAType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
# end class DEFAULT_GROUP_QUOTASType


class VM_QUOTAType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VM=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.VM = VM
        self.VM_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_QUOTAType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_QUOTAType.subclass:
            return VM_QUOTAType.subclass(*args_, **kwargs_)
        else:
            return VM_QUOTAType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VM(self):
        return self.VM
    def set_VM(self, VM):
        self.VM = VM
    def has__content(self):
        if (
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_QUOTAType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_QUOTAType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VM_QUOTAType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VM_QUOTAType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VM_QUOTAType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VM_QUOTAType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_QUOTAType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VM is not None:
            namespaceprefix_ = self.VM_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_nsprefix_) else ''
            self.VM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VM':
            obj_ = VMType4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class VM_QUOTAType


class VMType4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CPU=None, CPU_USED=None, MEMORY=None, MEMORY_USED=None, RUNNING_CPU=None, RUNNING_CPU_USED=None, RUNNING_MEMORY=None, RUNNING_MEMORY_USED=None, RUNNING_VMS=None, RUNNING_VMS_USED=None, SYSTEM_DISK_SIZE=None, SYSTEM_DISK_SIZE_USED=None, VMS=None, VMS_USED=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CPU = CPU
        self.CPU_nsprefix_ = None
        self.CPU_USED = CPU_USED
        self.CPU_USED_nsprefix_ = None
        self.MEMORY = MEMORY
        self.MEMORY_nsprefix_ = None
        self.MEMORY_USED = MEMORY_USED
        self.MEMORY_USED_nsprefix_ = None
        self.RUNNING_CPU = RUNNING_CPU
        self.RUNNING_CPU_nsprefix_ = None
        self.RUNNING_CPU_USED = RUNNING_CPU_USED
        self.RUNNING_CPU_USED_nsprefix_ = None
        self.RUNNING_MEMORY = RUNNING_MEMORY
        self.RUNNING_MEMORY_nsprefix_ = None
        self.RUNNING_MEMORY_USED = RUNNING_MEMORY_USED
        self.RUNNING_MEMORY_USED_nsprefix_ = None
        self.RUNNING_VMS = RUNNING_VMS
        self.RUNNING_VMS_nsprefix_ = None
        self.RUNNING_VMS_USED = RUNNING_VMS_USED
        self.RUNNING_VMS_USED_nsprefix_ = None
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_nsprefix_ = None
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
        self.SYSTEM_DISK_SIZE_USED_nsprefix_ = None
        self.VMS = VMS
        self.VMS_nsprefix_ = None
        self.VMS_USED = VMS_USED
        self.VMS_USED_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType4.subclass:
            return VMType4.subclass(*args_, **kwargs_)
        else:
            return VMType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CPU(self):
        return self.CPU
    def set_CPU(self, CPU):
        self.CPU = CPU
    def get_CPU_USED(self):
        return self.CPU_USED
    def set_CPU_USED(self, CPU_USED):
        self.CPU_USED = CPU_USED
    def get_MEMORY(self):
        return self.MEMORY
    def set_MEMORY(self, MEMORY):
        self.MEMORY = MEMORY
    def get_MEMORY_USED(self):
        return self.MEMORY_USED
    def set_MEMORY_USED(self, MEMORY_USED):
        self.MEMORY_USED = MEMORY_USED
    def get_RUNNING_CPU(self):
        return self.RUNNING_CPU
    def set_RUNNING_CPU(self, RUNNING_CPU):
        self.RUNNING_CPU = RUNNING_CPU
    def get_RUNNING_CPU_USED(self):
        return self.RUNNING_CPU_USED
    def set_RUNNING_CPU_USED(self, RUNNING_CPU_USED):
        self.RUNNING_CPU_USED = RUNNING_CPU_USED
    def get_RUNNING_MEMORY(self):
        return self.RUNNING_MEMORY
    def set_RUNNING_MEMORY(self, RUNNING_MEMORY):
        self.RUNNING_MEMORY = RUNNING_MEMORY
    def get_RUNNING_MEMORY_USED(self):
        return self.RUNNING_MEMORY_USED
    def set_RUNNING_MEMORY_USED(self, RUNNING_MEMORY_USED):
        self.RUNNING_MEMORY_USED = RUNNING_MEMORY_USED
    def get_RUNNING_VMS(self):
        return self.RUNNING_VMS
    def set_RUNNING_VMS(self, RUNNING_VMS):
        self.RUNNING_VMS = RUNNING_VMS
    def get_RUNNING_VMS_USED(self):
        return self.RUNNING_VMS_USED
    def set_RUNNING_VMS_USED(self, RUNNING_VMS_USED):
        self.RUNNING_VMS_USED = RUNNING_VMS_USED
    def get_SYSTEM_DISK_SIZE(self):
        return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE):
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_SYSTEM_DISK_SIZE_USED(self):
        return self.SYSTEM_DISK_SIZE_USED
    def set_SYSTEM_DISK_SIZE_USED(self, SYSTEM_DISK_SIZE_USED):
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
    def get_VMS(self):
        return self.VMS
    def set_VMS(self, VMS):
        self.VMS = VMS
    def get_VMS_USED(self):
        return self.VMS_USED
    def set_VMS_USED(self, VMS_USED):
        self.VMS_USED = VMS_USED
    def has__content(self):
        if (
            self.CPU is not None or
            self.CPU_USED is not None or
            self.MEMORY is not None or
            self.MEMORY_USED is not None or
            self.RUNNING_CPU is not None or
            self.RUNNING_CPU_USED is not None or
            self.RUNNING_MEMORY is not None or
            self.RUNNING_MEMORY_USED is not None or
            self.RUNNING_VMS is not None or
            self.RUNNING_VMS_USED is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.SYSTEM_DISK_SIZE_USED is not None or
            self.VMS is not None or
            self.VMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VMType4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VMType4')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VMType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VMType4'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            namespaceprefix_ = self.CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU>%s</%sCPU>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), namespaceprefix_ , eol_))
        if self.CPU_USED is not None:
            namespaceprefix_ = self.CPU_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU_USED>%s</%sCPU_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPU_USED), input_name='CPU_USED')), namespaceprefix_ , eol_))
        if self.MEMORY is not None:
            namespaceprefix_ = self.MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY>%s</%sMEMORY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), namespaceprefix_ , eol_))
        if self.MEMORY_USED is not None:
            namespaceprefix_ = self.MEMORY_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY_USED>%s</%sMEMORY_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_USED), input_name='MEMORY_USED')), namespaceprefix_ , eol_))
        if self.RUNNING_CPU is not None:
            namespaceprefix_ = self.RUNNING_CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_CPU>%s</%sRUNNING_CPU>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_CPU), input_name='RUNNING_CPU')), namespaceprefix_ , eol_))
        if self.RUNNING_CPU_USED is not None:
            namespaceprefix_ = self.RUNNING_CPU_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_CPU_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_CPU_USED>%s</%sRUNNING_CPU_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_CPU_USED), input_name='RUNNING_CPU_USED')), namespaceprefix_ , eol_))
        if self.RUNNING_MEMORY is not None:
            namespaceprefix_ = self.RUNNING_MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_MEMORY>%s</%sRUNNING_MEMORY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_MEMORY), input_name='RUNNING_MEMORY')), namespaceprefix_ , eol_))
        if self.RUNNING_MEMORY_USED is not None:
            namespaceprefix_ = self.RUNNING_MEMORY_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_MEMORY_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_MEMORY_USED>%s</%sRUNNING_MEMORY_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_MEMORY_USED), input_name='RUNNING_MEMORY_USED')), namespaceprefix_ , eol_))
        if self.RUNNING_VMS is not None:
            namespaceprefix_ = self.RUNNING_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_VMS>%s</%sRUNNING_VMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_VMS), input_name='RUNNING_VMS')), namespaceprefix_ , eol_))
        if self.RUNNING_VMS_USED is not None:
            namespaceprefix_ = self.RUNNING_VMS_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_VMS_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_VMS_USED>%s</%sRUNNING_VMS_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_VMS_USED), input_name='RUNNING_VMS_USED')), namespaceprefix_ , eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            namespaceprefix_ = self.SYSTEM_DISK_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SYSTEM_DISK_SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYSTEM_DISK_SIZE>%s</%sSYSTEM_DISK_SIZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE), input_name='SYSTEM_DISK_SIZE')), namespaceprefix_ , eol_))
        if self.SYSTEM_DISK_SIZE_USED is not None:
            namespaceprefix_ = self.SYSTEM_DISK_SIZE_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.SYSTEM_DISK_SIZE_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYSTEM_DISK_SIZE_USED>%s</%sSYSTEM_DISK_SIZE_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE_USED), input_name='SYSTEM_DISK_SIZE_USED')), namespaceprefix_ , eol_))
        if self.VMS is not None:
            namespaceprefix_ = self.VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMS>%s</%sVMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VMS), input_name='VMS')), namespaceprefix_ , eol_))
        if self.VMS_USED is not None:
            namespaceprefix_ = self.VMS_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMS_USED>%s</%sVMS_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VMS_USED), input_name='VMS_USED')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CPU':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPU')
            value_ = self.gds_validate_string(value_, node, 'CPU')
            self.CPU = value_
            self.CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'CPU_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPU_USED')
            value_ = self.gds_validate_string(value_, node, 'CPU_USED')
            self.CPU_USED = value_
            self.CPU_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY')
            value_ = self.gds_validate_string(value_, node, 'MEMORY')
            self.MEMORY = value_
            self.MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY_USED')
            value_ = self.gds_validate_string(value_, node, 'MEMORY_USED')
            self.MEMORY_USED = value_
            self.MEMORY_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_CPU':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_CPU')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_CPU')
            self.RUNNING_CPU = value_
            self.RUNNING_CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_CPU_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_CPU_USED')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_CPU_USED')
            self.RUNNING_CPU_USED = value_
            self.RUNNING_CPU_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_MEMORY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_MEMORY')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_MEMORY')
            self.RUNNING_MEMORY = value_
            self.RUNNING_MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_MEMORY_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_MEMORY_USED')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_MEMORY_USED')
            self.RUNNING_MEMORY_USED = value_
            self.RUNNING_MEMORY_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_VMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_VMS')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_VMS')
            self.RUNNING_VMS = value_
            self.RUNNING_VMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_VMS_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_VMS_USED')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_VMS_USED')
            self.RUNNING_VMS_USED = value_
            self.RUNNING_VMS_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYSTEM_DISK_SIZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SYSTEM_DISK_SIZE')
            value_ = self.gds_validate_string(value_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = value_
            self.SYSTEM_DISK_SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYSTEM_DISK_SIZE_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SYSTEM_DISK_SIZE_USED')
            value_ = self.gds_validate_string(value_, node, 'SYSTEM_DISK_SIZE_USED')
            self.SYSTEM_DISK_SIZE_USED = value_
            self.SYSTEM_DISK_SIZE_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VMS')
            value_ = self.gds_validate_string(value_, node, 'VMS')
            self.VMS = value_
            self.VMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMS_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VMS_USED')
            value_ = self.gds_validate_string(value_, node, 'VMS_USED')
            self.VMS_USED = value_
            self.VMS_USED_nsprefix_ = child_.prefix
# end class VMType4


class USERSType5(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USERSType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USERSType5.subclass:
            return USERSType5.subclass(*args_, **kwargs_)
        else:
            return USERSType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USERSType5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USERSType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'USERSType5':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USERSType5')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='USERSType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='USERSType5'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USERSType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class USERSType5


class ADMINSType6(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADMINSType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADMINSType6.subclass:
            return ADMINSType6.subclass(*args_, **kwargs_)
        else:
            return ADMINSType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ADMINSType6', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ADMINSType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ADMINSType6':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ADMINSType6')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ADMINSType6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ADMINSType6'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ADMINSType6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class ADMINSType6


class DEFAULT_GROUP_QUOTASType7(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.DATASTORE_QUOTA_nsprefix_ = None
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.NETWORK_QUOTA_nsprefix_ = None
        self.VM_QUOTA = VM_QUOTA
        self.VM_QUOTA_nsprefix_ = None
        self.IMAGE_QUOTA = IMAGE_QUOTA
        self.IMAGE_QUOTA_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DEFAULT_GROUP_QUOTASType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DEFAULT_GROUP_QUOTASType7.subclass:
            return DEFAULT_GROUP_QUOTASType7.subclass(*args_, **kwargs_)
        else:
            return DEFAULT_GROUP_QUOTASType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATASTORE_QUOTA(self):
        return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA):
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self):
        return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA):
        self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self):
        return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA):
        self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self):
        return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA):
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def has__content(self):
        if (
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DEFAULT_GROUP_QUOTASType7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DEFAULT_GROUP_QUOTASType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DEFAULT_GROUP_QUOTASType7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DEFAULT_GROUP_QUOTASType7')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DEFAULT_GROUP_QUOTASType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DEFAULT_GROUP_QUOTASType7'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DEFAULT_GROUP_QUOTASType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DATASTORE_QUOTA is not None:
            namespaceprefix_ = self.DATASTORE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_QUOTA_nsprefix_) else ''
            self.DATASTORE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            namespaceprefix_ = self.NETWORK_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.NETWORK_QUOTA_nsprefix_) else ''
            self.NETWORK_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            namespaceprefix_ = self.VM_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_QUOTA_nsprefix_) else ''
            self.VM_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            namespaceprefix_ = self.IMAGE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_QUOTA_nsprefix_) else ''
            self.IMAGE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_QUOTA', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTAType8.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
# end class DEFAULT_GROUP_QUOTASType7


class VM_QUOTAType8(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VM=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.VM = VM
        self.VM_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_QUOTAType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_QUOTAType8.subclass:
            return VM_QUOTAType8.subclass(*args_, **kwargs_)
        else:
            return VM_QUOTAType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VM(self):
        return self.VM
    def set_VM(self, VM):
        self.VM = VM
    def has__content(self):
        if (
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_QUOTAType8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_QUOTAType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VM_QUOTAType8':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VM_QUOTAType8')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VM_QUOTAType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VM_QUOTAType8'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_QUOTAType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VM is not None:
            namespaceprefix_ = self.VM_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_nsprefix_) else ''
            self.VM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VM':
            obj_ = VMType9.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class VM_QUOTAType8


class VMType9(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CLUSTER_IDS=None, CPU=None, CPU_USED=None, MEMORY=None, MEMORY_USED=None, RUNNING_CPU=None, RUNNING_CPU_USED=None, RUNNING_MEMORY=None, RUNNING_MEMORY_USED=None, RUNNING_VMS=None, RUNNING_VMS_USED=None, SYSTEM_DISK_SIZE=None, SYSTEM_DISK_SIZE_USED=None, VMS=None, VMS_USED=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CLUSTER_IDS = CLUSTER_IDS
        self.CLUSTER_IDS_nsprefix_ = None
        self.CPU = CPU
        self.CPU_nsprefix_ = None
        self.CPU_USED = CPU_USED
        self.CPU_USED_nsprefix_ = None
        self.MEMORY = MEMORY
        self.MEMORY_nsprefix_ = None
        self.MEMORY_USED = MEMORY_USED
        self.MEMORY_USED_nsprefix_ = None
        self.RUNNING_CPU = RUNNING_CPU
        self.RUNNING_CPU_nsprefix_ = None
        self.RUNNING_CPU_USED = RUNNING_CPU_USED
        self.RUNNING_CPU_USED_nsprefix_ = None
        self.RUNNING_MEMORY = RUNNING_MEMORY
        self.RUNNING_MEMORY_nsprefix_ = None
        self.RUNNING_MEMORY_USED = RUNNING_MEMORY_USED
        self.RUNNING_MEMORY_USED_nsprefix_ = None
        self.RUNNING_VMS = RUNNING_VMS
        self.RUNNING_VMS_nsprefix_ = None
        self.RUNNING_VMS_USED = RUNNING_VMS_USED
        self.RUNNING_VMS_USED_nsprefix_ = None
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_nsprefix_ = None
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
        self.SYSTEM_DISK_SIZE_USED_nsprefix_ = None
        self.VMS = VMS
        self.VMS_nsprefix_ = None
        self.VMS_USED = VMS_USED
        self.VMS_USED_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType9.subclass:
            return VMType9.subclass(*args_, **kwargs_)
        else:
            return VMType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CLUSTER_IDS(self):
        return self.CLUSTER_IDS
    def set_CLUSTER_IDS(self, CLUSTER_IDS):
        self.CLUSTER_IDS = CLUSTER_IDS
    def get_CPU(self):
        return self.CPU
    def set_CPU(self, CPU):
        self.CPU = CPU
    def get_CPU_USED(self):
        return self.CPU_USED
    def set_CPU_USED(self, CPU_USED):
        self.CPU_USED = CPU_USED
    def get_MEMORY(self):
        return self.MEMORY
    def set_MEMORY(self, MEMORY):
        self.MEMORY = MEMORY
    def get_MEMORY_USED(self):
        return self.MEMORY_USED
    def set_MEMORY_USED(self, MEMORY_USED):
        self.MEMORY_USED = MEMORY_USED
    def get_RUNNING_CPU(self):
        return self.RUNNING_CPU
    def set_RUNNING_CPU(self, RUNNING_CPU):
        self.RUNNING_CPU = RUNNING_CPU
    def get_RUNNING_CPU_USED(self):
        return self.RUNNING_CPU_USED
    def set_RUNNING_CPU_USED(self, RUNNING_CPU_USED):
        self.RUNNING_CPU_USED = RUNNING_CPU_USED
    def get_RUNNING_MEMORY(self):
        return self.RUNNING_MEMORY
    def set_RUNNING_MEMORY(self, RUNNING_MEMORY):
        self.RUNNING_MEMORY = RUNNING_MEMORY
    def get_RUNNING_MEMORY_USED(self):
        return self.RUNNING_MEMORY_USED
    def set_RUNNING_MEMORY_USED(self, RUNNING_MEMORY_USED):
        self.RUNNING_MEMORY_USED = RUNNING_MEMORY_USED
    def get_RUNNING_VMS(self):
        return self.RUNNING_VMS
    def set_RUNNING_VMS(self, RUNNING_VMS):
        self.RUNNING_VMS = RUNNING_VMS
    def get_RUNNING_VMS_USED(self):
        return self.RUNNING_VMS_USED
    def set_RUNNING_VMS_USED(self, RUNNING_VMS_USED):
        self.RUNNING_VMS_USED = RUNNING_VMS_USED
    def get_SYSTEM_DISK_SIZE(self):
        return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE):
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_SYSTEM_DISK_SIZE_USED(self):
        return self.SYSTEM_DISK_SIZE_USED
    def set_SYSTEM_DISK_SIZE_USED(self, SYSTEM_DISK_SIZE_USED):
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
    def get_VMS(self):
        return self.VMS
    def set_VMS(self, VMS):
        self.VMS = VMS
    def get_VMS_USED(self):
        return self.VMS_USED
    def set_VMS_USED(self, VMS_USED):
        self.VMS_USED = VMS_USED
    def has__content(self):
        if (
            self.CLUSTER_IDS is not None or
            self.CPU is not None or
            self.CPU_USED is not None or
            self.MEMORY is not None or
            self.MEMORY_USED is not None or
            self.RUNNING_CPU is not None or
            self.RUNNING_CPU_USED is not None or
            self.RUNNING_MEMORY is not None or
            self.RUNNING_MEMORY_USED is not None or
            self.RUNNING_VMS is not None or
            self.RUNNING_VMS_USED is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.SYSTEM_DISK_SIZE_USED is not None or
            self.VMS is not None or
            self.VMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType9', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VMType9':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VMType9')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VMType9', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VMType9'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CLUSTER_IDS is not None:
            namespaceprefix_ = self.CLUSTER_IDS_nsprefix_ + ':' if (UseCapturedNS_ and self.CLUSTER_IDS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLUSTER_IDS>%s</%sCLUSTER_IDS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CLUSTER_IDS), input_name='CLUSTER_IDS')), namespaceprefix_ , eol_))
        if self.CPU is not None:
            namespaceprefix_ = self.CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU>%s</%sCPU>%s' % (namespaceprefix_ , self.gds_format_float(self.CPU, input_name='CPU'), namespaceprefix_ , eol_))
        if self.CPU_USED is not None:
            namespaceprefix_ = self.CPU_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU_USED>%s</%sCPU_USED>%s' % (namespaceprefix_ , self.gds_format_float(self.CPU_USED, input_name='CPU_USED'), namespaceprefix_ , eol_))
        if self.MEMORY is not None:
            namespaceprefix_ = self.MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY>%s</%sMEMORY>%s' % (namespaceprefix_ , self.gds_format_integer(self.MEMORY, input_name='MEMORY'), namespaceprefix_ , eol_))
        if self.MEMORY_USED is not None:
            namespaceprefix_ = self.MEMORY_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY_USED>%s</%sMEMORY_USED>%s' % (namespaceprefix_ , self.gds_format_integer(self.MEMORY_USED, input_name='MEMORY_USED'), namespaceprefix_ , eol_))
        if self.RUNNING_CPU is not None:
            namespaceprefix_ = self.RUNNING_CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_CPU>%s</%sRUNNING_CPU>%s' % (namespaceprefix_ , self.gds_format_float(self.RUNNING_CPU, input_name='RUNNING_CPU'), namespaceprefix_ , eol_))
        if self.RUNNING_CPU_USED is not None:
            namespaceprefix_ = self.RUNNING_CPU_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_CPU_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_CPU_USED>%s</%sRUNNING_CPU_USED>%s' % (namespaceprefix_ , self.gds_format_float(self.RUNNING_CPU_USED, input_name='RUNNING_CPU_USED'), namespaceprefix_ , eol_))
        if self.RUNNING_MEMORY is not None:
            namespaceprefix_ = self.RUNNING_MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_MEMORY>%s</%sRUNNING_MEMORY>%s' % (namespaceprefix_ , self.gds_format_integer(self.RUNNING_MEMORY, input_name='RUNNING_MEMORY'), namespaceprefix_ , eol_))
        if self.RUNNING_MEMORY_USED is not None:
            namespaceprefix_ = self.RUNNING_MEMORY_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_MEMORY_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_MEMORY_USED>%s</%sRUNNING_MEMORY_USED>%s' % (namespaceprefix_ , self.gds_format_integer(self.RUNNING_MEMORY_USED, input_name='RUNNING_MEMORY_USED'), namespaceprefix_ , eol_))
        if self.RUNNING_VMS is not None:
            namespaceprefix_ = self.RUNNING_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_VMS>%s</%sRUNNING_VMS>%s' % (namespaceprefix_ , self.gds_format_integer(self.RUNNING_VMS, input_name='RUNNING_VMS'), namespaceprefix_ , eol_))
        if self.RUNNING_VMS_USED is not None:
            namespaceprefix_ = self.RUNNING_VMS_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_VMS_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_VMS_USED>%s</%sRUNNING_VMS_USED>%s' % (namespaceprefix_ , self.gds_format_integer(self.RUNNING_VMS_USED, input_name='RUNNING_VMS_USED'), namespaceprefix_ , eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            namespaceprefix_ = self.SYSTEM_DISK_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SYSTEM_DISK_SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYSTEM_DISK_SIZE>%s</%sSYSTEM_DISK_SIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.SYSTEM_DISK_SIZE, input_name='SYSTEM_DISK_SIZE'), namespaceprefix_ , eol_))
        if self.SYSTEM_DISK_SIZE_USED is not None:
            namespaceprefix_ = self.SYSTEM_DISK_SIZE_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.SYSTEM_DISK_SIZE_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYSTEM_DISK_SIZE_USED>%s</%sSYSTEM_DISK_SIZE_USED>%s' % (namespaceprefix_ , self.gds_format_integer(self.SYSTEM_DISK_SIZE_USED, input_name='SYSTEM_DISK_SIZE_USED'), namespaceprefix_ , eol_))
        if self.VMS is not None:
            namespaceprefix_ = self.VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMS>%s</%sVMS>%s' % (namespaceprefix_ , self.gds_format_integer(self.VMS, input_name='VMS'), namespaceprefix_ , eol_))
        if self.VMS_USED is not None:
            namespaceprefix_ = self.VMS_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMS_USED>%s</%sVMS_USED>%s' % (namespaceprefix_ , self.gds_format_integer(self.VMS_USED, input_name='VMS_USED'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CLUSTER_IDS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CLUSTER_IDS')
            value_ = self.gds_validate_string(value_, node, 'CLUSTER_IDS')
            self.CLUSTER_IDS = value_
            self.CLUSTER_IDS_nsprefix_ = child_.prefix
        elif nodeName_ == 'CPU' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'CPU')
            fval_ = self.gds_validate_float(fval_, node, 'CPU')
            self.CPU = fval_
            self.CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'CPU_USED' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'CPU_USED')
            fval_ = self.gds_validate_float(fval_, node, 'CPU_USED')
            self.CPU_USED = fval_
            self.CPU_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MEMORY')
            ival_ = self.gds_validate_integer(ival_, node, 'MEMORY')
            self.MEMORY = ival_
            self.MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY_USED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MEMORY_USED')
            ival_ = self.gds_validate_integer(ival_, node, 'MEMORY_USED')
            self.MEMORY_USED = ival_
            self.MEMORY_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_CPU' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'RUNNING_CPU')
            fval_ = self.gds_validate_float(fval_, node, 'RUNNING_CPU')
            self.RUNNING_CPU = fval_
            self.RUNNING_CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_CPU_USED' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'RUNNING_CPU_USED')
            fval_ = self.gds_validate_float(fval_, node, 'RUNNING_CPU_USED')
            self.RUNNING_CPU_USED = fval_
            self.RUNNING_CPU_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_MEMORY' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RUNNING_MEMORY')
            ival_ = self.gds_validate_integer(ival_, node, 'RUNNING_MEMORY')
            self.RUNNING_MEMORY = ival_
            self.RUNNING_MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_MEMORY_USED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RUNNING_MEMORY_USED')
            ival_ = self.gds_validate_integer(ival_, node, 'RUNNING_MEMORY_USED')
            self.RUNNING_MEMORY_USED = ival_
            self.RUNNING_MEMORY_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_VMS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RUNNING_VMS')
            ival_ = self.gds_validate_integer(ival_, node, 'RUNNING_VMS')
            self.RUNNING_VMS = ival_
            self.RUNNING_VMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_VMS_USED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RUNNING_VMS_USED')
            ival_ = self.gds_validate_integer(ival_, node, 'RUNNING_VMS_USED')
            self.RUNNING_VMS_USED = ival_
            self.RUNNING_VMS_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYSTEM_DISK_SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SYSTEM_DISK_SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = ival_
            self.SYSTEM_DISK_SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYSTEM_DISK_SIZE_USED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SYSTEM_DISK_SIZE_USED')
            ival_ = self.gds_validate_integer(ival_, node, 'SYSTEM_DISK_SIZE_USED')
            self.SYSTEM_DISK_SIZE_USED = ival_
            self.SYSTEM_DISK_SIZE_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VMS')
            ival_ = self.gds_validate_integer(ival_, node, 'VMS')
            self.VMS = ival_
            self.VMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMS_USED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VMS_USED')
            ival_ = self.gds_validate_integer(ival_, node, 'VMS_USED')
            self.VMS_USED = ival_
            self.VMS_USED_nsprefix_ = child_.prefix
# end class VMType9


class TEMPLATEType10(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ARGUMENTS=None, ARGUMENTS_STDIN=None, CALL=None, COMMAND=None, REMOTE=None, RESOURCE=None, STATE=None, LCM_STATE=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ARGUMENTS = ARGUMENTS
        self.ARGUMENTS_nsprefix_ = None
        self.ARGUMENTS_STDIN = ARGUMENTS_STDIN
        self.ARGUMENTS_STDIN_nsprefix_ = None
        self.CALL = CALL
        self.CALL_nsprefix_ = None
        self.COMMAND = COMMAND
        self.COMMAND_nsprefix_ = None
        self.REMOTE = REMOTE
        self.REMOTE_nsprefix_ = None
        self.RESOURCE = RESOURCE
        self.RESOURCE_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.LCM_STATE = LCM_STATE
        self.LCM_STATE_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEMPLATEType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEMPLATEType10.subclass:
            return TEMPLATEType10.subclass(*args_, **kwargs_)
        else:
            return TEMPLATEType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ARGUMENTS(self):
        return self.ARGUMENTS
    def set_ARGUMENTS(self, ARGUMENTS):
        self.ARGUMENTS = ARGUMENTS
    def get_ARGUMENTS_STDIN(self):
        return self.ARGUMENTS_STDIN
    def set_ARGUMENTS_STDIN(self, ARGUMENTS_STDIN):
        self.ARGUMENTS_STDIN = ARGUMENTS_STDIN
    def get_CALL(self):
        return self.CALL
    def set_CALL(self, CALL):
        self.CALL = CALL
    def get_COMMAND(self):
        return self.COMMAND
    def set_COMMAND(self, COMMAND):
        self.COMMAND = COMMAND
    def get_REMOTE(self):
        return self.REMOTE
    def set_REMOTE(self, REMOTE):
        self.REMOTE = REMOTE
    def get_RESOURCE(self):
        return self.RESOURCE
    def set_RESOURCE(self, RESOURCE):
        self.RESOURCE = RESOURCE
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_LCM_STATE(self):
        return self.LCM_STATE
    def set_LCM_STATE(self, LCM_STATE):
        self.LCM_STATE = LCM_STATE
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.ARGUMENTS is not None or
            self.ARGUMENTS_STDIN is not None or
            self.CALL is not None or
            self.COMMAND is not None or
            self.REMOTE is not None or
            self.RESOURCE is not None or
            self.STATE is not None or
            self.LCM_STATE is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType10', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEMPLATEType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEMPLATEType10':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEMPLATEType10')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEMPLATEType10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEMPLATEType10'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType10', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ARGUMENTS is not None:
            namespaceprefix_ = self.ARGUMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.ARGUMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sARGUMENTS>%s</%sARGUMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ARGUMENTS), input_name='ARGUMENTS')), namespaceprefix_ , eol_))
        if self.ARGUMENTS_STDIN is not None:
            namespaceprefix_ = self.ARGUMENTS_STDIN_nsprefix_ + ':' if (UseCapturedNS_ and self.ARGUMENTS_STDIN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sARGUMENTS_STDIN>%s</%sARGUMENTS_STDIN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ARGUMENTS_STDIN), input_name='ARGUMENTS_STDIN')), namespaceprefix_ , eol_))
        if self.CALL is not None:
            namespaceprefix_ = self.CALL_nsprefix_ + ':' if (UseCapturedNS_ and self.CALL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCALL>%s</%sCALL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CALL), input_name='CALL')), namespaceprefix_ , eol_))
        if self.COMMAND is not None:
            namespaceprefix_ = self.COMMAND_nsprefix_ + ':' if (UseCapturedNS_ and self.COMMAND_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOMMAND>%s</%sCOMMAND>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.COMMAND), input_name='COMMAND')), namespaceprefix_ , eol_))
        if self.REMOTE is not None:
            namespaceprefix_ = self.REMOTE_nsprefix_ + ':' if (UseCapturedNS_ and self.REMOTE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREMOTE>%s</%sREMOTE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.REMOTE), input_name='REMOTE')), namespaceprefix_ , eol_))
        if self.RESOURCE is not None:
            namespaceprefix_ = self.RESOURCE_nsprefix_ + ':' if (UseCapturedNS_ and self.RESOURCE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRESOURCE>%s</%sRESOURCE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RESOURCE), input_name='RESOURCE')), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.STATE), input_name='STATE')), namespaceprefix_ , eol_))
        if self.LCM_STATE is not None:
            namespaceprefix_ = self.LCM_STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.LCM_STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLCM_STATE>%s</%sLCM_STATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LCM_STATE), input_name='LCM_STATE')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ARGUMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ARGUMENTS')
            value_ = self.gds_validate_string(value_, node, 'ARGUMENTS')
            self.ARGUMENTS = value_
            self.ARGUMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'ARGUMENTS_STDIN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ARGUMENTS_STDIN')
            value_ = self.gds_validate_string(value_, node, 'ARGUMENTS_STDIN')
            self.ARGUMENTS_STDIN = value_
            self.ARGUMENTS_STDIN_nsprefix_ = child_.prefix
        elif nodeName_ == 'CALL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CALL')
            value_ = self.gds_validate_string(value_, node, 'CALL')
            self.CALL = value_
            self.CALL_nsprefix_ = child_.prefix
        elif nodeName_ == 'COMMAND':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'COMMAND')
            value_ = self.gds_validate_string(value_, node, 'COMMAND')
            self.COMMAND = value_
            self.COMMAND_nsprefix_ = child_.prefix
        elif nodeName_ == 'REMOTE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'REMOTE')
            value_ = self.gds_validate_string(value_, node, 'REMOTE')
            self.REMOTE = value_
            self.REMOTE_nsprefix_ = child_.prefix
        elif nodeName_ == 'RESOURCE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RESOURCE')
            value_ = self.gds_validate_string(value_, node, 'RESOURCE')
            self.RESOURCE = value_
            self.RESOURCE_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'STATE')
            value_ = self.gds_validate_string(value_, node, 'STATE')
            self.STATE = value_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'LCM_STATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LCM_STATE')
            value_ = self.gds_validate_string(value_, node, 'LCM_STATE')
            self.LCM_STATE = value_
            self.LCM_STATE_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'TEMPLATEType10')
            self.anytypeobjs_.append(content_)
# end class TEMPLATEType10


class HOOKLOGType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, HOOK_EXECUTION_RECORD=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if HOOK_EXECUTION_RECORD is None:
            self.HOOK_EXECUTION_RECORD = []
        else:
            self.HOOK_EXECUTION_RECORD = HOOK_EXECUTION_RECORD
        self.HOOK_EXECUTION_RECORD_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOOKLOGType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOOKLOGType.subclass:
            return HOOKLOGType.subclass(*args_, **kwargs_)
        else:
            return HOOKLOGType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HOOK_EXECUTION_RECORD(self):
        return self.HOOK_EXECUTION_RECORD
    def set_HOOK_EXECUTION_RECORD(self, HOOK_EXECUTION_RECORD):
        self.HOOK_EXECUTION_RECORD = HOOK_EXECUTION_RECORD
    def add_HOOK_EXECUTION_RECORD(self, value):
        self.HOOK_EXECUTION_RECORD.append(value)
    def insert_HOOK_EXECUTION_RECORD_at(self, index, value):
        self.HOOK_EXECUTION_RECORD.insert(index, value)
    def replace_HOOK_EXECUTION_RECORD_at(self, index, value):
        self.HOOK_EXECUTION_RECORD[index] = value
    def has__content(self):
        if (
            self.HOOK_EXECUTION_RECORD
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOOKLOGType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOOKLOGType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HOOKLOGType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HOOKLOGType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HOOKLOGType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HOOKLOGType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOOKLOGType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HOOK_EXECUTION_RECORD_ in self.HOOK_EXECUTION_RECORD:
            namespaceprefix_ = self.HOOK_EXECUTION_RECORD_nsprefix_ + ':' if (UseCapturedNS_ and self.HOOK_EXECUTION_RECORD_nsprefix_) else ''
            HOOK_EXECUTION_RECORD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HOOK_EXECUTION_RECORD', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HOOK_EXECUTION_RECORD':
            obj_ = HOOK_EXECUTION_RECORDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HOOK_EXECUTION_RECORD.append(obj_)
            obj_.original_tagname_ = 'HOOK_EXECUTION_RECORD'
# end class HOOKLOGType


class HOOK_EXECUTION_RECORDType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, HOOK_ID=None, EXECUTION_ID=None, TIMESTAMP=None, ARGUMENTS=None, EXECUTION_RESULT=None, REMOTE_HOST=None, RETRY=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.HOOK_ID = HOOK_ID
        self.HOOK_ID_nsprefix_ = None
        self.EXECUTION_ID = EXECUTION_ID
        self.EXECUTION_ID_nsprefix_ = None
        self.TIMESTAMP = TIMESTAMP
        self.TIMESTAMP_nsprefix_ = None
        self.ARGUMENTS = ARGUMENTS
        self.ARGUMENTS_nsprefix_ = None
        self.EXECUTION_RESULT = EXECUTION_RESULT
        self.EXECUTION_RESULT_nsprefix_ = None
        self.REMOTE_HOST = REMOTE_HOST
        self.REMOTE_HOST_nsprefix_ = None
        self.RETRY = RETRY
        self.RETRY_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOOK_EXECUTION_RECORDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOOK_EXECUTION_RECORDType.subclass:
            return HOOK_EXECUTION_RECORDType.subclass(*args_, **kwargs_)
        else:
            return HOOK_EXECUTION_RECORDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HOOK_ID(self):
        return self.HOOK_ID
    def set_HOOK_ID(self, HOOK_ID):
        self.HOOK_ID = HOOK_ID
    def get_EXECUTION_ID(self):
        return self.EXECUTION_ID
    def set_EXECUTION_ID(self, EXECUTION_ID):
        self.EXECUTION_ID = EXECUTION_ID
    def get_TIMESTAMP(self):
        return self.TIMESTAMP
    def set_TIMESTAMP(self, TIMESTAMP):
        self.TIMESTAMP = TIMESTAMP
    def get_ARGUMENTS(self):
        return self.ARGUMENTS
    def set_ARGUMENTS(self, ARGUMENTS):
        self.ARGUMENTS = ARGUMENTS
    def get_EXECUTION_RESULT(self):
        return self.EXECUTION_RESULT
    def set_EXECUTION_RESULT(self, EXECUTION_RESULT):
        self.EXECUTION_RESULT = EXECUTION_RESULT
    def get_REMOTE_HOST(self):
        return self.REMOTE_HOST
    def set_REMOTE_HOST(self, REMOTE_HOST):
        self.REMOTE_HOST = REMOTE_HOST
    def get_RETRY(self):
        return self.RETRY
    def set_RETRY(self, RETRY):
        self.RETRY = RETRY
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.HOOK_ID is not None or
            self.EXECUTION_ID is not None or
            self.TIMESTAMP is not None or
            self.ARGUMENTS is not None or
            self.EXECUTION_RESULT is not None or
            self.REMOTE_HOST is not None or
            self.RETRY is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOOK_EXECUTION_RECORDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOOK_EXECUTION_RECORDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HOOK_EXECUTION_RECORDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HOOK_EXECUTION_RECORDType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HOOK_EXECUTION_RECORDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HOOK_EXECUTION_RECORDType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOOK_EXECUTION_RECORDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HOOK_ID is not None:
            namespaceprefix_ = self.HOOK_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.HOOK_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHOOK_ID>%s</%sHOOK_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.HOOK_ID, input_name='HOOK_ID'), namespaceprefix_ , eol_))
        if self.EXECUTION_ID is not None:
            namespaceprefix_ = self.EXECUTION_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.EXECUTION_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXECUTION_ID>%s</%sEXECUTION_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.EXECUTION_ID, input_name='EXECUTION_ID'), namespaceprefix_ , eol_))
        if self.TIMESTAMP is not None:
            namespaceprefix_ = self.TIMESTAMP_nsprefix_ + ':' if (UseCapturedNS_ and self.TIMESTAMP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIMESTAMP>%s</%sTIMESTAMP>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIMESTAMP, input_name='TIMESTAMP'), namespaceprefix_ , eol_))
        if self.ARGUMENTS is not None:
            namespaceprefix_ = self.ARGUMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.ARGUMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sARGUMENTS>%s</%sARGUMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ARGUMENTS), input_name='ARGUMENTS')), namespaceprefix_ , eol_))
        if self.EXECUTION_RESULT is not None:
            namespaceprefix_ = self.EXECUTION_RESULT_nsprefix_ + ':' if (UseCapturedNS_ and self.EXECUTION_RESULT_nsprefix_) else ''
            self.EXECUTION_RESULT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EXECUTION_RESULT', pretty_print=pretty_print)
        if self.REMOTE_HOST is not None:
            namespaceprefix_ = self.REMOTE_HOST_nsprefix_ + ':' if (UseCapturedNS_ and self.REMOTE_HOST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREMOTE_HOST>%s</%sREMOTE_HOST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.REMOTE_HOST), input_name='REMOTE_HOST')), namespaceprefix_ , eol_))
        if self.RETRY is not None:
            namespaceprefix_ = self.RETRY_nsprefix_ + ':' if (UseCapturedNS_ and self.RETRY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRETRY>%s</%sRETRY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RETRY), input_name='RETRY')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HOOK_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'HOOK_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'HOOK_ID')
            self.HOOK_ID = ival_
            self.HOOK_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXECUTION_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'EXECUTION_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'EXECUTION_ID')
            self.EXECUTION_ID = ival_
            self.EXECUTION_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIMESTAMP' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIMESTAMP')
            ival_ = self.gds_validate_integer(ival_, node, 'TIMESTAMP')
            self.TIMESTAMP = ival_
            self.TIMESTAMP_nsprefix_ = child_.prefix
        elif nodeName_ == 'ARGUMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ARGUMENTS')
            value_ = self.gds_validate_string(value_, node, 'ARGUMENTS')
            self.ARGUMENTS = value_
            self.ARGUMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXECUTION_RESULT':
            obj_ = EXECUTION_RESULTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EXECUTION_RESULT = obj_
            obj_.original_tagname_ = 'EXECUTION_RESULT'
        elif nodeName_ == 'REMOTE_HOST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'REMOTE_HOST')
            value_ = self.gds_validate_string(value_, node, 'REMOTE_HOST')
            self.REMOTE_HOST = value_
            self.REMOTE_HOST_nsprefix_ = child_.prefix
        elif nodeName_ == 'RETRY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RETRY')
            value_ = self.gds_validate_string(value_, node, 'RETRY')
            self.RETRY = value_
            self.RETRY_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'HOOK_EXECUTION_RECORDType')
            self.anytypeobjs_.append(content_)
# end class HOOK_EXECUTION_RECORDType


class EXECUTION_RESULTType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, COMMAND=None, STDOUT=None, STDERR=None, CODE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.COMMAND = COMMAND
        self.COMMAND_nsprefix_ = None
        self.STDOUT = STDOUT
        self.STDOUT_nsprefix_ = None
        self.STDERR = STDERR
        self.STDERR_nsprefix_ = None
        self.CODE = CODE
        self.CODE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EXECUTION_RESULTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EXECUTION_RESULTType.subclass:
            return EXECUTION_RESULTType.subclass(*args_, **kwargs_)
        else:
            return EXECUTION_RESULTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_COMMAND(self):
        return self.COMMAND
    def set_COMMAND(self, COMMAND):
        self.COMMAND = COMMAND
    def get_STDOUT(self):
        return self.STDOUT
    def set_STDOUT(self, STDOUT):
        self.STDOUT = STDOUT
    def get_STDERR(self):
        return self.STDERR
    def set_STDERR(self, STDERR):
        self.STDERR = STDERR
    def get_CODE(self):
        return self.CODE
    def set_CODE(self, CODE):
        self.CODE = CODE
    def has__content(self):
        if (
            self.COMMAND is not None or
            self.STDOUT is not None or
            self.STDERR is not None or
            self.CODE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='EXECUTION_RESULTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EXECUTION_RESULTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EXECUTION_RESULTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EXECUTION_RESULTType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EXECUTION_RESULTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EXECUTION_RESULTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='EXECUTION_RESULTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.COMMAND is not None:
            namespaceprefix_ = self.COMMAND_nsprefix_ + ':' if (UseCapturedNS_ and self.COMMAND_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOMMAND>%s</%sCOMMAND>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.COMMAND), input_name='COMMAND')), namespaceprefix_ , eol_))
        if self.STDOUT is not None:
            namespaceprefix_ = self.STDOUT_nsprefix_ + ':' if (UseCapturedNS_ and self.STDOUT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTDOUT>%s</%sSTDOUT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.STDOUT), input_name='STDOUT')), namespaceprefix_ , eol_))
        if self.STDERR is not None:
            namespaceprefix_ = self.STDERR_nsprefix_ + ':' if (UseCapturedNS_ and self.STDERR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTDERR>%s</%sSTDERR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.STDERR), input_name='STDERR')), namespaceprefix_ , eol_))
        if self.CODE is not None:
            namespaceprefix_ = self.CODE_nsprefix_ + ':' if (UseCapturedNS_ and self.CODE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCODE>%s</%sCODE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CODE), input_name='CODE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'COMMAND':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'COMMAND')
            value_ = self.gds_validate_string(value_, node, 'COMMAND')
            self.COMMAND = value_
            self.COMMAND_nsprefix_ = child_.prefix
        elif nodeName_ == 'STDOUT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'STDOUT')
            value_ = self.gds_validate_string(value_, node, 'STDOUT')
            self.STDOUT = value_
            self.STDOUT_nsprefix_ = child_.prefix
        elif nodeName_ == 'STDERR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'STDERR')
            value_ = self.gds_validate_string(value_, node, 'STDERR')
            self.STDERR = value_
            self.STDERR_nsprefix_ = child_.prefix
        elif nodeName_ == 'CODE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CODE')
            value_ = self.gds_validate_string(value_, node, 'CODE')
            self.CODE = value_
            self.CODE_nsprefix_ = child_.prefix
# end class EXECUTION_RESULTType


class HOST_SHAREType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, MEM_USAGE=None, CPU_USAGE=None, TOTAL_MEM=None, TOTAL_CPU=None, MAX_MEM=None, MAX_CPU=None, RUNNING_VMS=None, VMS_THREAD=None, DATASTORES=None, PCI_DEVICES=None, NUMA_NODES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MEM_USAGE = MEM_USAGE
        self.MEM_USAGE_nsprefix_ = None
        self.CPU_USAGE = CPU_USAGE
        self.CPU_USAGE_nsprefix_ = None
        self.TOTAL_MEM = TOTAL_MEM
        self.TOTAL_MEM_nsprefix_ = None
        self.TOTAL_CPU = TOTAL_CPU
        self.TOTAL_CPU_nsprefix_ = None
        self.MAX_MEM = MAX_MEM
        self.MAX_MEM_nsprefix_ = None
        self.MAX_CPU = MAX_CPU
        self.MAX_CPU_nsprefix_ = None
        self.RUNNING_VMS = RUNNING_VMS
        self.RUNNING_VMS_nsprefix_ = None
        self.VMS_THREAD = VMS_THREAD
        self.VMS_THREAD_nsprefix_ = None
        self.DATASTORES = DATASTORES
        self.DATASTORES_nsprefix_ = None
        self.PCI_DEVICES = PCI_DEVICES
        self.PCI_DEVICES_nsprefix_ = None
        self.NUMA_NODES = NUMA_NODES
        self.NUMA_NODES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOST_SHAREType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOST_SHAREType.subclass:
            return HOST_SHAREType.subclass(*args_, **kwargs_)
        else:
            return HOST_SHAREType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MEM_USAGE(self):
        return self.MEM_USAGE
    def set_MEM_USAGE(self, MEM_USAGE):
        self.MEM_USAGE = MEM_USAGE
    def get_CPU_USAGE(self):
        return self.CPU_USAGE
    def set_CPU_USAGE(self, CPU_USAGE):
        self.CPU_USAGE = CPU_USAGE
    def get_TOTAL_MEM(self):
        return self.TOTAL_MEM
    def set_TOTAL_MEM(self, TOTAL_MEM):
        self.TOTAL_MEM = TOTAL_MEM
    def get_TOTAL_CPU(self):
        return self.TOTAL_CPU
    def set_TOTAL_CPU(self, TOTAL_CPU):
        self.TOTAL_CPU = TOTAL_CPU
    def get_MAX_MEM(self):
        return self.MAX_MEM
    def set_MAX_MEM(self, MAX_MEM):
        self.MAX_MEM = MAX_MEM
    def get_MAX_CPU(self):
        return self.MAX_CPU
    def set_MAX_CPU(self, MAX_CPU):
        self.MAX_CPU = MAX_CPU
    def get_RUNNING_VMS(self):
        return self.RUNNING_VMS
    def set_RUNNING_VMS(self, RUNNING_VMS):
        self.RUNNING_VMS = RUNNING_VMS
    def get_VMS_THREAD(self):
        return self.VMS_THREAD
    def set_VMS_THREAD(self, VMS_THREAD):
        self.VMS_THREAD = VMS_THREAD
    def get_DATASTORES(self):
        return self.DATASTORES
    def set_DATASTORES(self, DATASTORES):
        self.DATASTORES = DATASTORES
    def get_PCI_DEVICES(self):
        return self.PCI_DEVICES
    def set_PCI_DEVICES(self, PCI_DEVICES):
        self.PCI_DEVICES = PCI_DEVICES
    def get_NUMA_NODES(self):
        return self.NUMA_NODES
    def set_NUMA_NODES(self, NUMA_NODES):
        self.NUMA_NODES = NUMA_NODES
    def has__content(self):
        if (
            self.MEM_USAGE is not None or
            self.CPU_USAGE is not None or
            self.TOTAL_MEM is not None or
            self.TOTAL_CPU is not None or
            self.MAX_MEM is not None or
            self.MAX_CPU is not None or
            self.RUNNING_VMS is not None or
            self.VMS_THREAD is not None or
            self.DATASTORES is not None or
            self.PCI_DEVICES is not None or
            self.NUMA_NODES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOST_SHAREType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOST_SHAREType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HOST_SHAREType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HOST_SHAREType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HOST_SHAREType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HOST_SHAREType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOST_SHAREType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MEM_USAGE is not None:
            namespaceprefix_ = self.MEM_USAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.MEM_USAGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEM_USAGE>%s</%sMEM_USAGE>%s' % (namespaceprefix_ , self.gds_format_integer(self.MEM_USAGE, input_name='MEM_USAGE'), namespaceprefix_ , eol_))
        if self.CPU_USAGE is not None:
            namespaceprefix_ = self.CPU_USAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_USAGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU_USAGE>%s</%sCPU_USAGE>%s' % (namespaceprefix_ , self.gds_format_integer(self.CPU_USAGE, input_name='CPU_USAGE'), namespaceprefix_ , eol_))
        if self.TOTAL_MEM is not None:
            namespaceprefix_ = self.TOTAL_MEM_nsprefix_ + ':' if (UseCapturedNS_ and self.TOTAL_MEM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTOTAL_MEM>%s</%sTOTAL_MEM>%s' % (namespaceprefix_ , self.gds_format_integer(self.TOTAL_MEM, input_name='TOTAL_MEM'), namespaceprefix_ , eol_))
        if self.TOTAL_CPU is not None:
            namespaceprefix_ = self.TOTAL_CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.TOTAL_CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTOTAL_CPU>%s</%sTOTAL_CPU>%s' % (namespaceprefix_ , self.gds_format_integer(self.TOTAL_CPU, input_name='TOTAL_CPU'), namespaceprefix_ , eol_))
        if self.MAX_MEM is not None:
            namespaceprefix_ = self.MAX_MEM_nsprefix_ + ':' if (UseCapturedNS_ and self.MAX_MEM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAX_MEM>%s</%sMAX_MEM>%s' % (namespaceprefix_ , self.gds_format_integer(self.MAX_MEM, input_name='MAX_MEM'), namespaceprefix_ , eol_))
        if self.MAX_CPU is not None:
            namespaceprefix_ = self.MAX_CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.MAX_CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAX_CPU>%s</%sMAX_CPU>%s' % (namespaceprefix_ , self.gds_format_integer(self.MAX_CPU, input_name='MAX_CPU'), namespaceprefix_ , eol_))
        if self.RUNNING_VMS is not None:
            namespaceprefix_ = self.RUNNING_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_VMS>%s</%sRUNNING_VMS>%s' % (namespaceprefix_ , self.gds_format_integer(self.RUNNING_VMS, input_name='RUNNING_VMS'), namespaceprefix_ , eol_))
        if self.VMS_THREAD is not None:
            namespaceprefix_ = self.VMS_THREAD_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_THREAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMS_THREAD>%s</%sVMS_THREAD>%s' % (namespaceprefix_ , self.gds_format_integer(self.VMS_THREAD, input_name='VMS_THREAD'), namespaceprefix_ , eol_))
        if self.DATASTORES is not None:
            namespaceprefix_ = self.DATASTORES_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORES_nsprefix_) else ''
            self.DATASTORES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORES', pretty_print=pretty_print)
        if self.PCI_DEVICES is not None:
            namespaceprefix_ = self.PCI_DEVICES_nsprefix_ + ':' if (UseCapturedNS_ and self.PCI_DEVICES_nsprefix_) else ''
            self.PCI_DEVICES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PCI_DEVICES', pretty_print=pretty_print)
        if self.NUMA_NODES is not None:
            namespaceprefix_ = self.NUMA_NODES_nsprefix_ + ':' if (UseCapturedNS_ and self.NUMA_NODES_nsprefix_) else ''
            self.NUMA_NODES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NUMA_NODES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MEM_USAGE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MEM_USAGE')
            ival_ = self.gds_validate_integer(ival_, node, 'MEM_USAGE')
            self.MEM_USAGE = ival_
            self.MEM_USAGE_nsprefix_ = child_.prefix
        elif nodeName_ == 'CPU_USAGE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CPU_USAGE')
            ival_ = self.gds_validate_integer(ival_, node, 'CPU_USAGE')
            self.CPU_USAGE = ival_
            self.CPU_USAGE_nsprefix_ = child_.prefix
        elif nodeName_ == 'TOTAL_MEM' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TOTAL_MEM')
            ival_ = self.gds_validate_integer(ival_, node, 'TOTAL_MEM')
            self.TOTAL_MEM = ival_
            self.TOTAL_MEM_nsprefix_ = child_.prefix
        elif nodeName_ == 'TOTAL_CPU' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TOTAL_CPU')
            ival_ = self.gds_validate_integer(ival_, node, 'TOTAL_CPU')
            self.TOTAL_CPU = ival_
            self.TOTAL_CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAX_MEM' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MAX_MEM')
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_MEM')
            self.MAX_MEM = ival_
            self.MAX_MEM_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAX_CPU' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MAX_CPU')
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_CPU')
            self.MAX_CPU = ival_
            self.MAX_CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_VMS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RUNNING_VMS')
            ival_ = self.gds_validate_integer(ival_, node, 'RUNNING_VMS')
            self.RUNNING_VMS = ival_
            self.RUNNING_VMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMS_THREAD' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VMS_THREAD')
            ival_ = self.gds_validate_integer(ival_, node, 'VMS_THREAD')
            self.VMS_THREAD = ival_
            self.VMS_THREAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATASTORES':
            obj_ = DATASTORESType11.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORES = obj_
            obj_.original_tagname_ = 'DATASTORES'
        elif nodeName_ == 'PCI_DEVICES':
            obj_ = PCI_DEVICESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PCI_DEVICES = obj_
            obj_.original_tagname_ = 'PCI_DEVICES'
        elif nodeName_ == 'NUMA_NODES':
            obj_ = NUMA_NODESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NUMA_NODES = obj_
            obj_.original_tagname_ = 'NUMA_NODES'
# end class HOST_SHAREType


class DATASTORESType11(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DISK_USAGE=None, DS=None, FREE_DISK=None, MAX_DISK=None, USED_DISK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DISK_USAGE = DISK_USAGE
        self.DISK_USAGE_nsprefix_ = None
        if DS is None:
            self.DS = []
        else:
            self.DS = DS
        self.DS_nsprefix_ = None
        self.FREE_DISK = FREE_DISK
        self.FREE_DISK_nsprefix_ = None
        self.MAX_DISK = MAX_DISK
        self.MAX_DISK_nsprefix_ = None
        self.USED_DISK = USED_DISK
        self.USED_DISK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORESType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORESType11.subclass:
            return DATASTORESType11.subclass(*args_, **kwargs_)
        else:
            return DATASTORESType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DISK_USAGE(self):
        return self.DISK_USAGE
    def set_DISK_USAGE(self, DISK_USAGE):
        self.DISK_USAGE = DISK_USAGE
    def get_DS(self):
        return self.DS
    def set_DS(self, DS):
        self.DS = DS
    def add_DS(self, value):
        self.DS.append(value)
    def insert_DS_at(self, index, value):
        self.DS.insert(index, value)
    def replace_DS_at(self, index, value):
        self.DS[index] = value
    def get_FREE_DISK(self):
        return self.FREE_DISK
    def set_FREE_DISK(self, FREE_DISK):
        self.FREE_DISK = FREE_DISK
    def get_MAX_DISK(self):
        return self.MAX_DISK
    def set_MAX_DISK(self, MAX_DISK):
        self.MAX_DISK = MAX_DISK
    def get_USED_DISK(self):
        return self.USED_DISK
    def set_USED_DISK(self, USED_DISK):
        self.USED_DISK = USED_DISK
    def has__content(self):
        if (
            self.DISK_USAGE is not None or
            self.DS or
            self.FREE_DISK is not None or
            self.MAX_DISK is not None or
            self.USED_DISK is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORESType11', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORESType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATASTORESType11':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATASTORESType11')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATASTORESType11', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATASTORESType11'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORESType11', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DISK_USAGE is not None:
            namespaceprefix_ = self.DISK_USAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_USAGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISK_USAGE>%s</%sDISK_USAGE>%s' % (namespaceprefix_ , self.gds_format_integer(self.DISK_USAGE, input_name='DISK_USAGE'), namespaceprefix_ , eol_))
        for DS_ in self.DS:
            namespaceprefix_ = self.DS_nsprefix_ + ':' if (UseCapturedNS_ and self.DS_nsprefix_) else ''
            DS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DS', pretty_print=pretty_print)
        if self.FREE_DISK is not None:
            namespaceprefix_ = self.FREE_DISK_nsprefix_ + ':' if (UseCapturedNS_ and self.FREE_DISK_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFREE_DISK>%s</%sFREE_DISK>%s' % (namespaceprefix_ , self.gds_format_integer(self.FREE_DISK, input_name='FREE_DISK'), namespaceprefix_ , eol_))
        if self.MAX_DISK is not None:
            namespaceprefix_ = self.MAX_DISK_nsprefix_ + ':' if (UseCapturedNS_ and self.MAX_DISK_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAX_DISK>%s</%sMAX_DISK>%s' % (namespaceprefix_ , self.gds_format_integer(self.MAX_DISK, input_name='MAX_DISK'), namespaceprefix_ , eol_))
        if self.USED_DISK is not None:
            namespaceprefix_ = self.USED_DISK_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_DISK_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED_DISK>%s</%sUSED_DISK>%s' % (namespaceprefix_ , self.gds_format_integer(self.USED_DISK, input_name='USED_DISK'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DISK_USAGE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DISK_USAGE')
            ival_ = self.gds_validate_integer(ival_, node, 'DISK_USAGE')
            self.DISK_USAGE = ival_
            self.DISK_USAGE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DS':
            obj_ = DSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DS.append(obj_)
            obj_.original_tagname_ = 'DS'
        elif nodeName_ == 'FREE_DISK' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'FREE_DISK')
            ival_ = self.gds_validate_integer(ival_, node, 'FREE_DISK')
            self.FREE_DISK = ival_
            self.FREE_DISK_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAX_DISK' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MAX_DISK')
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_DISK')
            self.MAX_DISK = ival_
            self.MAX_DISK_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED_DISK' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'USED_DISK')
            ival_ = self.gds_validate_integer(ival_, node, 'USED_DISK')
            self.USED_DISK = ival_
            self.USED_DISK_nsprefix_ = child_.prefix
# end class DATASTORESType11


class DSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, FREE_MB=None, ID=None, TOTAL_MB=None, USED_MB=None, REPLICA_CACHE=None, REPLICA_CACHE_SIZE=None, REPLICA_IMAGES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.FREE_MB = FREE_MB
        self.FREE_MB_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.TOTAL_MB = TOTAL_MB
        self.TOTAL_MB_nsprefix_ = None
        self.USED_MB = USED_MB
        self.USED_MB_nsprefix_ = None
        self.REPLICA_CACHE = REPLICA_CACHE
        self.REPLICA_CACHE_nsprefix_ = None
        self.REPLICA_CACHE_SIZE = REPLICA_CACHE_SIZE
        self.REPLICA_CACHE_SIZE_nsprefix_ = None
        self.REPLICA_IMAGES = REPLICA_IMAGES
        self.REPLICA_IMAGES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DSType.subclass:
            return DSType.subclass(*args_, **kwargs_)
        else:
            return DSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FREE_MB(self):
        return self.FREE_MB
    def set_FREE_MB(self, FREE_MB):
        self.FREE_MB = FREE_MB
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_TOTAL_MB(self):
        return self.TOTAL_MB
    def set_TOTAL_MB(self, TOTAL_MB):
        self.TOTAL_MB = TOTAL_MB
    def get_USED_MB(self):
        return self.USED_MB
    def set_USED_MB(self, USED_MB):
        self.USED_MB = USED_MB
    def get_REPLICA_CACHE(self):
        return self.REPLICA_CACHE
    def set_REPLICA_CACHE(self, REPLICA_CACHE):
        self.REPLICA_CACHE = REPLICA_CACHE
    def get_REPLICA_CACHE_SIZE(self):
        return self.REPLICA_CACHE_SIZE
    def set_REPLICA_CACHE_SIZE(self, REPLICA_CACHE_SIZE):
        self.REPLICA_CACHE_SIZE = REPLICA_CACHE_SIZE
    def get_REPLICA_IMAGES(self):
        return self.REPLICA_IMAGES
    def set_REPLICA_IMAGES(self, REPLICA_IMAGES):
        self.REPLICA_IMAGES = REPLICA_IMAGES
    def has__content(self):
        if (
            self.FREE_MB is not None or
            self.ID is not None or
            self.TOTAL_MB is not None or
            self.USED_MB is not None or
            self.REPLICA_CACHE is not None or
            self.REPLICA_CACHE_SIZE is not None or
            self.REPLICA_IMAGES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FREE_MB is not None:
            namespaceprefix_ = self.FREE_MB_nsprefix_ + ':' if (UseCapturedNS_ and self.FREE_MB_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFREE_MB>%s</%sFREE_MB>%s' % (namespaceprefix_ , self.gds_format_integer(self.FREE_MB, input_name='FREE_MB'), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.TOTAL_MB is not None:
            namespaceprefix_ = self.TOTAL_MB_nsprefix_ + ':' if (UseCapturedNS_ and self.TOTAL_MB_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTOTAL_MB>%s</%sTOTAL_MB>%s' % (namespaceprefix_ , self.gds_format_integer(self.TOTAL_MB, input_name='TOTAL_MB'), namespaceprefix_ , eol_))
        if self.USED_MB is not None:
            namespaceprefix_ = self.USED_MB_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_MB_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED_MB>%s</%sUSED_MB>%s' % (namespaceprefix_ , self.gds_format_integer(self.USED_MB, input_name='USED_MB'), namespaceprefix_ , eol_))
        if self.REPLICA_CACHE is not None:
            namespaceprefix_ = self.REPLICA_CACHE_nsprefix_ + ':' if (UseCapturedNS_ and self.REPLICA_CACHE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREPLICA_CACHE>%s</%sREPLICA_CACHE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.REPLICA_CACHE), input_name='REPLICA_CACHE')), namespaceprefix_ , eol_))
        if self.REPLICA_CACHE_SIZE is not None:
            namespaceprefix_ = self.REPLICA_CACHE_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.REPLICA_CACHE_SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREPLICA_CACHE_SIZE>%s</%sREPLICA_CACHE_SIZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.REPLICA_CACHE_SIZE), input_name='REPLICA_CACHE_SIZE')), namespaceprefix_ , eol_))
        if self.REPLICA_IMAGES is not None:
            namespaceprefix_ = self.REPLICA_IMAGES_nsprefix_ + ':' if (UseCapturedNS_ and self.REPLICA_IMAGES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREPLICA_IMAGES>%s</%sREPLICA_IMAGES>%s' % (namespaceprefix_ , self.gds_format_integer(self.REPLICA_IMAGES, input_name='REPLICA_IMAGES'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FREE_MB' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'FREE_MB')
            ival_ = self.gds_validate_integer(ival_, node, 'FREE_MB')
            self.FREE_MB = ival_
            self.FREE_MB_nsprefix_ = child_.prefix
        elif nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'TOTAL_MB' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TOTAL_MB')
            ival_ = self.gds_validate_integer(ival_, node, 'TOTAL_MB')
            self.TOTAL_MB = ival_
            self.TOTAL_MB_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED_MB' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'USED_MB')
            ival_ = self.gds_validate_integer(ival_, node, 'USED_MB')
            self.USED_MB = ival_
            self.USED_MB_nsprefix_ = child_.prefix
        elif nodeName_ == 'REPLICA_CACHE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'REPLICA_CACHE')
            value_ = self.gds_validate_string(value_, node, 'REPLICA_CACHE')
            self.REPLICA_CACHE = value_
            self.REPLICA_CACHE_nsprefix_ = child_.prefix
        elif nodeName_ == 'REPLICA_CACHE_SIZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'REPLICA_CACHE_SIZE')
            value_ = self.gds_validate_string(value_, node, 'REPLICA_CACHE_SIZE')
            self.REPLICA_CACHE_SIZE = value_
            self.REPLICA_CACHE_SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'REPLICA_IMAGES' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REPLICA_IMAGES')
            ival_ = self.gds_validate_integer(ival_, node, 'REPLICA_IMAGES')
            self.REPLICA_IMAGES = ival_
            self.REPLICA_IMAGES_nsprefix_ = child_.prefix
# end class DSType


class PCI_DEVICESType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PCI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if PCI is None:
            self.PCI = []
        else:
            self.PCI = PCI
        self.PCI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PCI_DEVICESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PCI_DEVICESType.subclass:
            return PCI_DEVICESType.subclass(*args_, **kwargs_)
        else:
            return PCI_DEVICESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PCI(self):
        return self.PCI
    def set_PCI(self, PCI):
        self.PCI = PCI
    def add_PCI(self, value):
        self.PCI.append(value)
    def insert_PCI_at(self, index, value):
        self.PCI.insert(index, value)
    def replace_PCI_at(self, index, value):
        self.PCI[index] = value
    def has__content(self):
        if (
            self.PCI
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PCI_DEVICESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PCI_DEVICESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PCI_DEVICESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PCI_DEVICESType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PCI_DEVICESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PCI_DEVICESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PCI_DEVICESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PCI_ in self.PCI:
            namespaceprefix_ = self.PCI_nsprefix_ + ':' if (UseCapturedNS_ and self.PCI_nsprefix_) else ''
            PCI_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PCI', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PCI':
            obj_ = PCIType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PCI.append(obj_)
            obj_.original_tagname_ = 'PCI'
# end class PCI_DEVICESType


class PCIType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ADDRESS=None, BUS=None, CLASS=None, CLASS_NAME=None, DEVICE=None, DEVICE_NAME=None, DOMAIN=None, FUNCTION=None, NUMA_NODE=None, PROFILES=None, SHORT_ADDRESS=None, SLOT=None, TYPE=None, UUID=None, VENDOR=None, VENDOR_NAME=None, VMID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ADDRESS = ADDRESS
        self.ADDRESS_nsprefix_ = None
        self.BUS = BUS
        self.BUS_nsprefix_ = None
        self.CLASS = CLASS
        self.CLASS_nsprefix_ = None
        self.CLASS_NAME = CLASS_NAME
        self.CLASS_NAME_nsprefix_ = None
        self.DEVICE = DEVICE
        self.DEVICE_nsprefix_ = None
        self.DEVICE_NAME = DEVICE_NAME
        self.DEVICE_NAME_nsprefix_ = None
        self.DOMAIN = DOMAIN
        self.DOMAIN_nsprefix_ = None
        self.FUNCTION = FUNCTION
        self.FUNCTION_nsprefix_ = None
        self.NUMA_NODE = NUMA_NODE
        self.NUMA_NODE_nsprefix_ = None
        self.PROFILES = PROFILES
        self.PROFILES_nsprefix_ = None
        self.SHORT_ADDRESS = SHORT_ADDRESS
        self.SHORT_ADDRESS_nsprefix_ = None
        self.SLOT = SLOT
        self.SLOT_nsprefix_ = None
        self.TYPE = TYPE
        self.TYPE_nsprefix_ = None
        self.UUID = UUID
        self.UUID_nsprefix_ = None
        self.VENDOR = VENDOR
        self.VENDOR_nsprefix_ = None
        self.VENDOR_NAME = VENDOR_NAME
        self.VENDOR_NAME_nsprefix_ = None
        self.VMID = VMID
        self.VMID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PCIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PCIType.subclass:
            return PCIType.subclass(*args_, **kwargs_)
        else:
            return PCIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ADDRESS(self):
        return self.ADDRESS
    def set_ADDRESS(self, ADDRESS):
        self.ADDRESS = ADDRESS
    def get_BUS(self):
        return self.BUS
    def set_BUS(self, BUS):
        self.BUS = BUS
    def get_CLASS(self):
        return self.CLASS
    def set_CLASS(self, CLASS):
        self.CLASS = CLASS
    def get_CLASS_NAME(self):
        return self.CLASS_NAME
    def set_CLASS_NAME(self, CLASS_NAME):
        self.CLASS_NAME = CLASS_NAME
    def get_DEVICE(self):
        return self.DEVICE
    def set_DEVICE(self, DEVICE):
        self.DEVICE = DEVICE
    def get_DEVICE_NAME(self):
        return self.DEVICE_NAME
    def set_DEVICE_NAME(self, DEVICE_NAME):
        self.DEVICE_NAME = DEVICE_NAME
    def get_DOMAIN(self):
        return self.DOMAIN
    def set_DOMAIN(self, DOMAIN):
        self.DOMAIN = DOMAIN
    def get_FUNCTION(self):
        return self.FUNCTION
    def set_FUNCTION(self, FUNCTION):
        self.FUNCTION = FUNCTION
    def get_NUMA_NODE(self):
        return self.NUMA_NODE
    def set_NUMA_NODE(self, NUMA_NODE):
        self.NUMA_NODE = NUMA_NODE
    def get_PROFILES(self):
        return self.PROFILES
    def set_PROFILES(self, PROFILES):
        self.PROFILES = PROFILES
    def get_SHORT_ADDRESS(self):
        return self.SHORT_ADDRESS
    def set_SHORT_ADDRESS(self, SHORT_ADDRESS):
        self.SHORT_ADDRESS = SHORT_ADDRESS
    def get_SLOT(self):
        return self.SLOT
    def set_SLOT(self, SLOT):
        self.SLOT = SLOT
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def get_VENDOR(self):
        return self.VENDOR
    def set_VENDOR(self, VENDOR):
        self.VENDOR = VENDOR
    def get_VENDOR_NAME(self):
        return self.VENDOR_NAME
    def set_VENDOR_NAME(self, VENDOR_NAME):
        self.VENDOR_NAME = VENDOR_NAME
    def get_VMID(self):
        return self.VMID
    def set_VMID(self, VMID):
        self.VMID = VMID
    def has__content(self):
        if (
            self.ADDRESS is not None or
            self.BUS is not None or
            self.CLASS is not None or
            self.CLASS_NAME is not None or
            self.DEVICE is not None or
            self.DEVICE_NAME is not None or
            self.DOMAIN is not None or
            self.FUNCTION is not None or
            self.NUMA_NODE is not None or
            self.PROFILES is not None or
            self.SHORT_ADDRESS is not None or
            self.SLOT is not None or
            self.TYPE is not None or
            self.UUID is not None or
            self.VENDOR is not None or
            self.VENDOR_NAME is not None or
            self.VMID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PCIType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PCIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PCIType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PCIType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PCIType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PCIType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PCIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ADDRESS is not None:
            namespaceprefix_ = self.ADDRESS_nsprefix_ + ':' if (UseCapturedNS_ and self.ADDRESS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sADDRESS>%s</%sADDRESS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ADDRESS), input_name='ADDRESS')), namespaceprefix_ , eol_))
        if self.BUS is not None:
            namespaceprefix_ = self.BUS_nsprefix_ + ':' if (UseCapturedNS_ and self.BUS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBUS>%s</%sBUS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BUS), input_name='BUS')), namespaceprefix_ , eol_))
        if self.CLASS is not None:
            namespaceprefix_ = self.CLASS_nsprefix_ + ':' if (UseCapturedNS_ and self.CLASS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLASS>%s</%sCLASS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CLASS), input_name='CLASS')), namespaceprefix_ , eol_))
        if self.CLASS_NAME is not None:
            namespaceprefix_ = self.CLASS_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.CLASS_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLASS_NAME>%s</%sCLASS_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CLASS_NAME), input_name='CLASS_NAME')), namespaceprefix_ , eol_))
        if self.DEVICE is not None:
            namespaceprefix_ = self.DEVICE_nsprefix_ + ':' if (UseCapturedNS_ and self.DEVICE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEVICE>%s</%sDEVICE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DEVICE), input_name='DEVICE')), namespaceprefix_ , eol_))
        if self.DEVICE_NAME is not None:
            namespaceprefix_ = self.DEVICE_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.DEVICE_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEVICE_NAME>%s</%sDEVICE_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DEVICE_NAME), input_name='DEVICE_NAME')), namespaceprefix_ , eol_))
        if self.DOMAIN is not None:
            namespaceprefix_ = self.DOMAIN_nsprefix_ + ':' if (UseCapturedNS_ and self.DOMAIN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDOMAIN>%s</%sDOMAIN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DOMAIN), input_name='DOMAIN')), namespaceprefix_ , eol_))
        if self.FUNCTION is not None:
            namespaceprefix_ = self.FUNCTION_nsprefix_ + ':' if (UseCapturedNS_ and self.FUNCTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFUNCTION>%s</%sFUNCTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FUNCTION), input_name='FUNCTION')), namespaceprefix_ , eol_))
        if self.NUMA_NODE is not None:
            namespaceprefix_ = self.NUMA_NODE_nsprefix_ + ':' if (UseCapturedNS_ and self.NUMA_NODE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNUMA_NODE>%s</%sNUMA_NODE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NUMA_NODE), input_name='NUMA_NODE')), namespaceprefix_ , eol_))
        if self.PROFILES is not None:
            namespaceprefix_ = self.PROFILES_nsprefix_ + ':' if (UseCapturedNS_ and self.PROFILES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROFILES>%s</%sPROFILES>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PROFILES), input_name='PROFILES')), namespaceprefix_ , eol_))
        if self.SHORT_ADDRESS is not None:
            namespaceprefix_ = self.SHORT_ADDRESS_nsprefix_ + ':' if (UseCapturedNS_ and self.SHORT_ADDRESS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHORT_ADDRESS>%s</%sSHORT_ADDRESS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHORT_ADDRESS), input_name='SHORT_ADDRESS')), namespaceprefix_ , eol_))
        if self.SLOT is not None:
            namespaceprefix_ = self.SLOT_nsprefix_ + ':' if (UseCapturedNS_ and self.SLOT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSLOT>%s</%sSLOT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SLOT), input_name='SLOT')), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), namespaceprefix_ , eol_))
        if self.UUID is not None:
            namespaceprefix_ = self.UUID_nsprefix_ + ':' if (UseCapturedNS_ and self.UUID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUUID>%s</%sUUID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UUID), input_name='UUID')), namespaceprefix_ , eol_))
        if self.VENDOR is not None:
            namespaceprefix_ = self.VENDOR_nsprefix_ + ':' if (UseCapturedNS_ and self.VENDOR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVENDOR>%s</%sVENDOR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VENDOR), input_name='VENDOR')), namespaceprefix_ , eol_))
        if self.VENDOR_NAME is not None:
            namespaceprefix_ = self.VENDOR_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.VENDOR_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVENDOR_NAME>%s</%sVENDOR_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VENDOR_NAME), input_name='VENDOR_NAME')), namespaceprefix_ , eol_))
        if self.VMID is not None:
            namespaceprefix_ = self.VMID_nsprefix_ + ':' if (UseCapturedNS_ and self.VMID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMID>%s</%sVMID>%s' % (namespaceprefix_ , self.gds_format_integer(self.VMID, input_name='VMID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ADDRESS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ADDRESS')
            value_ = self.gds_validate_string(value_, node, 'ADDRESS')
            self.ADDRESS = value_
            self.ADDRESS_nsprefix_ = child_.prefix
        elif nodeName_ == 'BUS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BUS')
            value_ = self.gds_validate_string(value_, node, 'BUS')
            self.BUS = value_
            self.BUS_nsprefix_ = child_.prefix
        elif nodeName_ == 'CLASS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CLASS')
            value_ = self.gds_validate_string(value_, node, 'CLASS')
            self.CLASS = value_
            self.CLASS_nsprefix_ = child_.prefix
        elif nodeName_ == 'CLASS_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CLASS_NAME')
            value_ = self.gds_validate_string(value_, node, 'CLASS_NAME')
            self.CLASS_NAME = value_
            self.CLASS_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEVICE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEVICE')
            value_ = self.gds_validate_string(value_, node, 'DEVICE')
            self.DEVICE = value_
            self.DEVICE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEVICE_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEVICE_NAME')
            value_ = self.gds_validate_string(value_, node, 'DEVICE_NAME')
            self.DEVICE_NAME = value_
            self.DEVICE_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'DOMAIN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DOMAIN')
            value_ = self.gds_validate_string(value_, node, 'DOMAIN')
            self.DOMAIN = value_
            self.DOMAIN_nsprefix_ = child_.prefix
        elif nodeName_ == 'FUNCTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FUNCTION')
            value_ = self.gds_validate_string(value_, node, 'FUNCTION')
            self.FUNCTION = value_
            self.FUNCTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'NUMA_NODE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NUMA_NODE')
            value_ = self.gds_validate_string(value_, node, 'NUMA_NODE')
            self.NUMA_NODE = value_
            self.NUMA_NODE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PROFILES':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PROFILES')
            value_ = self.gds_validate_string(value_, node, 'PROFILES')
            self.PROFILES = value_
            self.PROFILES_nsprefix_ = child_.prefix
        elif nodeName_ == 'SHORT_ADDRESS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHORT_ADDRESS')
            value_ = self.gds_validate_string(value_, node, 'SHORT_ADDRESS')
            self.SHORT_ADDRESS = value_
            self.SHORT_ADDRESS_nsprefix_ = child_.prefix
        elif nodeName_ == 'SLOT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SLOT')
            value_ = self.gds_validate_string(value_, node, 'SLOT')
            self.SLOT = value_
            self.SLOT_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TYPE')
            value_ = self.gds_validate_string(value_, node, 'TYPE')
            self.TYPE = value_
            self.TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'UUID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UUID')
            value_ = self.gds_validate_string(value_, node, 'UUID')
            self.UUID = value_
            self.UUID_nsprefix_ = child_.prefix
        elif nodeName_ == 'VENDOR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VENDOR')
            value_ = self.gds_validate_string(value_, node, 'VENDOR')
            self.VENDOR = value_
            self.VENDOR_nsprefix_ = child_.prefix
        elif nodeName_ == 'VENDOR_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VENDOR_NAME')
            value_ = self.gds_validate_string(value_, node, 'VENDOR_NAME')
            self.VENDOR_NAME = value_
            self.VENDOR_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VMID')
            ival_ = self.gds_validate_integer(ival_, node, 'VMID')
            self.VMID = ival_
            self.VMID_nsprefix_ = child_.prefix
# end class PCIType


class NUMA_NODESType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NODE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if NODE is None:
            self.NODE = []
        else:
            self.NODE = NODE
        self.NODE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NUMA_NODESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NUMA_NODESType.subclass:
            return NUMA_NODESType.subclass(*args_, **kwargs_)
        else:
            return NUMA_NODESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NODE(self):
        return self.NODE
    def set_NODE(self, NODE):
        self.NODE = NODE
    def add_NODE(self, value):
        self.NODE.append(value)
    def insert_NODE_at(self, index, value):
        self.NODE.insert(index, value)
    def replace_NODE_at(self, index, value):
        self.NODE[index] = value
    def has__content(self):
        if (
            self.NODE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NUMA_NODESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NUMA_NODESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NUMA_NODESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NUMA_NODESType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NUMA_NODESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NUMA_NODESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NUMA_NODESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NODE_ in self.NODE:
            namespaceprefix_ = self.NODE_nsprefix_ + ':' if (UseCapturedNS_ and self.NODE_nsprefix_) else ''
            NODE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NODE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NODE':
            obj_ = NODEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NODE.append(obj_)
            obj_.original_tagname_ = 'NODE'
# end class NUMA_NODESType


class NODEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CORE=None, HUGEPAGE=None, MEMORY=None, NODE_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CORE is None:
            self.CORE = []
        else:
            self.CORE = CORE
        self.CORE_nsprefix_ = None
        if HUGEPAGE is None:
            self.HUGEPAGE = []
        else:
            self.HUGEPAGE = HUGEPAGE
        self.HUGEPAGE_nsprefix_ = None
        self.MEMORY = MEMORY
        self.MEMORY_nsprefix_ = None
        self.NODE_ID = NODE_ID
        self.NODE_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NODEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NODEType.subclass:
            return NODEType.subclass(*args_, **kwargs_)
        else:
            return NODEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CORE(self):
        return self.CORE
    def set_CORE(self, CORE):
        self.CORE = CORE
    def add_CORE(self, value):
        self.CORE.append(value)
    def insert_CORE_at(self, index, value):
        self.CORE.insert(index, value)
    def replace_CORE_at(self, index, value):
        self.CORE[index] = value
    def get_HUGEPAGE(self):
        return self.HUGEPAGE
    def set_HUGEPAGE(self, HUGEPAGE):
        self.HUGEPAGE = HUGEPAGE
    def add_HUGEPAGE(self, value):
        self.HUGEPAGE.append(value)
    def insert_HUGEPAGE_at(self, index, value):
        self.HUGEPAGE.insert(index, value)
    def replace_HUGEPAGE_at(self, index, value):
        self.HUGEPAGE[index] = value
    def get_MEMORY(self):
        return self.MEMORY
    def set_MEMORY(self, MEMORY):
        self.MEMORY = MEMORY
    def get_NODE_ID(self):
        return self.NODE_ID
    def set_NODE_ID(self, NODE_ID):
        self.NODE_ID = NODE_ID
    def has__content(self):
        if (
            self.CORE or
            self.HUGEPAGE or
            self.MEMORY is not None or
            self.NODE_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NODEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NODEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NODEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NODEType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NODEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NODEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NODEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CORE_ in self.CORE:
            namespaceprefix_ = self.CORE_nsprefix_ + ':' if (UseCapturedNS_ and self.CORE_nsprefix_) else ''
            CORE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CORE', pretty_print=pretty_print)
        for HUGEPAGE_ in self.HUGEPAGE:
            namespaceprefix_ = self.HUGEPAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.HUGEPAGE_nsprefix_) else ''
            HUGEPAGE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HUGEPAGE', pretty_print=pretty_print)
        if self.MEMORY is not None:
            namespaceprefix_ = self.MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_nsprefix_) else ''
            self.MEMORY.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MEMORY', pretty_print=pretty_print)
        if self.NODE_ID is not None:
            namespaceprefix_ = self.NODE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.NODE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNODE_ID>%s</%sNODE_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.NODE_ID, input_name='NODE_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CORE':
            obj_ = COREType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CORE.append(obj_)
            obj_.original_tagname_ = 'CORE'
        elif nodeName_ == 'HUGEPAGE':
            obj_ = HUGEPAGEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HUGEPAGE.append(obj_)
            obj_.original_tagname_ = 'HUGEPAGE'
        elif nodeName_ == 'MEMORY':
            obj_ = MEMORYType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MEMORY = obj_
            obj_.original_tagname_ = 'MEMORY'
        elif nodeName_ == 'NODE_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NODE_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'NODE_ID')
            self.NODE_ID = ival_
            self.NODE_ID_nsprefix_ = child_.prefix
# end class NODEType


class COREType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CPUS=None, DEDICATED=None, FREE=None, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CPUS = CPUS
        self.CPUS_nsprefix_ = None
        self.DEDICATED = DEDICATED
        self.DEDICATED_nsprefix_ = None
        self.FREE = FREE
        self.FREE_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COREType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COREType.subclass:
            return COREType.subclass(*args_, **kwargs_)
        else:
            return COREType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CPUS(self):
        return self.CPUS
    def set_CPUS(self, CPUS):
        self.CPUS = CPUS
    def get_DEDICATED(self):
        return self.DEDICATED
    def set_DEDICATED(self, DEDICATED):
        self.DEDICATED = DEDICATED
    def get_FREE(self):
        return self.FREE
    def set_FREE(self, FREE):
        self.FREE = FREE
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def has__content(self):
        if (
            self.CPUS is not None or
            self.DEDICATED is not None or
            self.FREE is not None or
            self.ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='COREType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COREType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COREType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COREType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COREType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='COREType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='COREType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPUS is not None:
            namespaceprefix_ = self.CPUS_nsprefix_ + ':' if (UseCapturedNS_ and self.CPUS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPUS>%s</%sCPUS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPUS), input_name='CPUS')), namespaceprefix_ , eol_))
        if self.DEDICATED is not None:
            namespaceprefix_ = self.DEDICATED_nsprefix_ + ':' if (UseCapturedNS_ and self.DEDICATED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEDICATED>%s</%sDEDICATED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DEDICATED), input_name='DEDICATED')), namespaceprefix_ , eol_))
        if self.FREE is not None:
            namespaceprefix_ = self.FREE_nsprefix_ + ':' if (UseCapturedNS_ and self.FREE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFREE>%s</%sFREE>%s' % (namespaceprefix_ , self.gds_format_integer(self.FREE, input_name='FREE'), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CPUS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPUS')
            value_ = self.gds_validate_string(value_, node, 'CPUS')
            self.CPUS = value_
            self.CPUS_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEDICATED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEDICATED')
            value_ = self.gds_validate_string(value_, node, 'DEDICATED')
            self.DEDICATED = value_
            self.DEDICATED_nsprefix_ = child_.prefix
        elif nodeName_ == 'FREE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'FREE')
            ival_ = self.gds_validate_integer(ival_, node, 'FREE')
            self.FREE = ival_
            self.FREE_nsprefix_ = child_.prefix
        elif nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
# end class COREType


class HUGEPAGEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PAGES=None, SIZE=None, USAGE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PAGES = PAGES
        self.PAGES_nsprefix_ = None
        self.SIZE = SIZE
        self.SIZE_nsprefix_ = None
        self.USAGE = USAGE
        self.USAGE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HUGEPAGEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HUGEPAGEType.subclass:
            return HUGEPAGEType.subclass(*args_, **kwargs_)
        else:
            return HUGEPAGEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PAGES(self):
        return self.PAGES
    def set_PAGES(self, PAGES):
        self.PAGES = PAGES
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def get_USAGE(self):
        return self.USAGE
    def set_USAGE(self, USAGE):
        self.USAGE = USAGE
    def has__content(self):
        if (
            self.PAGES is not None or
            self.SIZE is not None or
            self.USAGE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HUGEPAGEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HUGEPAGEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HUGEPAGEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HUGEPAGEType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HUGEPAGEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HUGEPAGEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HUGEPAGEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PAGES is not None:
            namespaceprefix_ = self.PAGES_nsprefix_ + ':' if (UseCapturedNS_ and self.PAGES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPAGES>%s</%sPAGES>%s' % (namespaceprefix_ , self.gds_format_integer(self.PAGES, input_name='PAGES'), namespaceprefix_ , eol_))
        if self.SIZE is not None:
            namespaceprefix_ = self.SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE>%s</%sSIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.SIZE, input_name='SIZE'), namespaceprefix_ , eol_))
        if self.USAGE is not None:
            namespaceprefix_ = self.USAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.USAGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSAGE>%s</%sUSAGE>%s' % (namespaceprefix_ , self.gds_format_integer(self.USAGE, input_name='USAGE'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PAGES' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PAGES')
            ival_ = self.gds_validate_integer(ival_, node, 'PAGES')
            self.PAGES = ival_
            self.PAGES_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
            self.SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'USAGE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'USAGE')
            ival_ = self.gds_validate_integer(ival_, node, 'USAGE')
            self.USAGE = ival_
            self.USAGE_nsprefix_ = child_.prefix
# end class HUGEPAGEType


class MEMORYType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DISTANCE=None, TOTAL=None, USAGE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DISTANCE = DISTANCE
        self.DISTANCE_nsprefix_ = None
        self.TOTAL = TOTAL
        self.TOTAL_nsprefix_ = None
        self.USAGE = USAGE
        self.USAGE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MEMORYType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MEMORYType.subclass:
            return MEMORYType.subclass(*args_, **kwargs_)
        else:
            return MEMORYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DISTANCE(self):
        return self.DISTANCE
    def set_DISTANCE(self, DISTANCE):
        self.DISTANCE = DISTANCE
    def get_TOTAL(self):
        return self.TOTAL
    def set_TOTAL(self, TOTAL):
        self.TOTAL = TOTAL
    def get_USAGE(self):
        return self.USAGE
    def set_USAGE(self, USAGE):
        self.USAGE = USAGE
    def has__content(self):
        if (
            self.DISTANCE is not None or
            self.TOTAL is not None or
            self.USAGE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MEMORYType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MEMORYType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MEMORYType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MEMORYType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MEMORYType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MEMORYType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MEMORYType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DISTANCE is not None:
            namespaceprefix_ = self.DISTANCE_nsprefix_ + ':' if (UseCapturedNS_ and self.DISTANCE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISTANCE>%s</%sDISTANCE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DISTANCE), input_name='DISTANCE')), namespaceprefix_ , eol_))
        if self.TOTAL is not None:
            namespaceprefix_ = self.TOTAL_nsprefix_ + ':' if (UseCapturedNS_ and self.TOTAL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTOTAL>%s</%sTOTAL>%s' % (namespaceprefix_ , self.gds_format_integer(self.TOTAL, input_name='TOTAL'), namespaceprefix_ , eol_))
        if self.USAGE is not None:
            namespaceprefix_ = self.USAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.USAGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSAGE>%s</%sUSAGE>%s' % (namespaceprefix_ , self.gds_format_integer(self.USAGE, input_name='USAGE'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DISTANCE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DISTANCE')
            value_ = self.gds_validate_string(value_, node, 'DISTANCE')
            self.DISTANCE = value_
            self.DISTANCE_nsprefix_ = child_.prefix
        elif nodeName_ == 'TOTAL' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TOTAL')
            ival_ = self.gds_validate_integer(ival_, node, 'TOTAL')
            self.TOTAL = ival_
            self.TOTAL_nsprefix_ = child_.prefix
        elif nodeName_ == 'USAGE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'USAGE')
            ival_ = self.gds_validate_integer(ival_, node, 'USAGE')
            self.USAGE = ival_
            self.USAGE_nsprefix_ = child_.prefix
# end class MEMORYType


class VMSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMSType.subclass:
            return VMSType.subclass(*args_, **kwargs_)
        else:
            return VMSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VMSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VMSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VMSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VMSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class VMSType


class MONITORINGType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, TIMESTAMP=None, ID=None, CAPACITY=None, SYSTEM=None, NUMA_NODE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TIMESTAMP = TIMESTAMP
        self.TIMESTAMP_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.CAPACITY = CAPACITY
        self.CAPACITY_nsprefix_ = None
        self.SYSTEM = SYSTEM
        self.SYSTEM_nsprefix_ = None
        if NUMA_NODE is None:
            self.NUMA_NODE = []
        else:
            self.NUMA_NODE = NUMA_NODE
        self.NUMA_NODE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MONITORINGType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MONITORINGType.subclass:
            return MONITORINGType.subclass(*args_, **kwargs_)
        else:
            return MONITORINGType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TIMESTAMP(self):
        return self.TIMESTAMP
    def set_TIMESTAMP(self, TIMESTAMP):
        self.TIMESTAMP = TIMESTAMP
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_CAPACITY(self):
        return self.CAPACITY
    def set_CAPACITY(self, CAPACITY):
        self.CAPACITY = CAPACITY
    def get_SYSTEM(self):
        return self.SYSTEM
    def set_SYSTEM(self, SYSTEM):
        self.SYSTEM = SYSTEM
    def get_NUMA_NODE(self):
        return self.NUMA_NODE
    def set_NUMA_NODE(self, NUMA_NODE):
        self.NUMA_NODE = NUMA_NODE
    def add_NUMA_NODE(self, value):
        self.NUMA_NODE.append(value)
    def insert_NUMA_NODE_at(self, index, value):
        self.NUMA_NODE.insert(index, value)
    def replace_NUMA_NODE_at(self, index, value):
        self.NUMA_NODE[index] = value
    def has__content(self):
        if (
            self.TIMESTAMP is not None or
            self.ID is not None or
            self.CAPACITY is not None or
            self.SYSTEM is not None or
            self.NUMA_NODE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MONITORINGType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MONITORINGType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MONITORINGType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MONITORINGType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MONITORINGType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MONITORINGType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MONITORINGType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TIMESTAMP is not None:
            namespaceprefix_ = self.TIMESTAMP_nsprefix_ + ':' if (UseCapturedNS_ and self.TIMESTAMP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIMESTAMP>%s</%sTIMESTAMP>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIMESTAMP, input_name='TIMESTAMP'), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.CAPACITY is not None:
            namespaceprefix_ = self.CAPACITY_nsprefix_ + ':' if (UseCapturedNS_ and self.CAPACITY_nsprefix_) else ''
            self.CAPACITY.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CAPACITY', pretty_print=pretty_print)
        if self.SYSTEM is not None:
            namespaceprefix_ = self.SYSTEM_nsprefix_ + ':' if (UseCapturedNS_ and self.SYSTEM_nsprefix_) else ''
            self.SYSTEM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SYSTEM', pretty_print=pretty_print)
        for NUMA_NODE_ in self.NUMA_NODE:
            namespaceprefix_ = self.NUMA_NODE_nsprefix_ + ':' if (UseCapturedNS_ and self.NUMA_NODE_nsprefix_) else ''
            NUMA_NODE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NUMA_NODE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TIMESTAMP' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIMESTAMP')
            ival_ = self.gds_validate_integer(ival_, node, 'TIMESTAMP')
            self.TIMESTAMP = ival_
            self.TIMESTAMP_nsprefix_ = child_.prefix
        elif nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'CAPACITY':
            obj_ = CAPACITYType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CAPACITY = obj_
            obj_.original_tagname_ = 'CAPACITY'
        elif nodeName_ == 'SYSTEM':
            obj_ = SYSTEMType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SYSTEM = obj_
            obj_.original_tagname_ = 'SYSTEM'
        elif nodeName_ == 'NUMA_NODE':
            obj_ = NUMA_NODEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NUMA_NODE.append(obj_)
            obj_.original_tagname_ = 'NUMA_NODE'
# end class MONITORINGType


class CAPACITYType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, FREE_CPU=None, FREE_CPU_FORECAST=None, FREE_CPU_FORECAST_FAR=None, FREE_MEMORY=None, FREE_MEMORY_FORECAST=None, FREE_MEMORY_FORECAST_FAR=None, USED_CPU=None, USED_CPU_FORECAST=None, USED_CPU_FORECAST_FAR=None, USED_MEMORY=None, USED_MEMORY_FORECAST=None, USED_MEMORY_FORECAST_FAR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.FREE_CPU = FREE_CPU
        self.FREE_CPU_nsprefix_ = None
        self.FREE_CPU_FORECAST = FREE_CPU_FORECAST
        self.FREE_CPU_FORECAST_nsprefix_ = None
        self.FREE_CPU_FORECAST_FAR = FREE_CPU_FORECAST_FAR
        self.FREE_CPU_FORECAST_FAR_nsprefix_ = None
        self.FREE_MEMORY = FREE_MEMORY
        self.FREE_MEMORY_nsprefix_ = None
        self.FREE_MEMORY_FORECAST = FREE_MEMORY_FORECAST
        self.FREE_MEMORY_FORECAST_nsprefix_ = None
        self.FREE_MEMORY_FORECAST_FAR = FREE_MEMORY_FORECAST_FAR
        self.FREE_MEMORY_FORECAST_FAR_nsprefix_ = None
        self.USED_CPU = USED_CPU
        self.USED_CPU_nsprefix_ = None
        self.USED_CPU_FORECAST = USED_CPU_FORECAST
        self.USED_CPU_FORECAST_nsprefix_ = None
        self.USED_CPU_FORECAST_FAR = USED_CPU_FORECAST_FAR
        self.USED_CPU_FORECAST_FAR_nsprefix_ = None
        self.USED_MEMORY = USED_MEMORY
        self.USED_MEMORY_nsprefix_ = None
        self.USED_MEMORY_FORECAST = USED_MEMORY_FORECAST
        self.USED_MEMORY_FORECAST_nsprefix_ = None
        self.USED_MEMORY_FORECAST_FAR = USED_MEMORY_FORECAST_FAR
        self.USED_MEMORY_FORECAST_FAR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CAPACITYType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CAPACITYType.subclass:
            return CAPACITYType.subclass(*args_, **kwargs_)
        else:
            return CAPACITYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FREE_CPU(self):
        return self.FREE_CPU
    def set_FREE_CPU(self, FREE_CPU):
        self.FREE_CPU = FREE_CPU
    def get_FREE_CPU_FORECAST(self):
        return self.FREE_CPU_FORECAST
    def set_FREE_CPU_FORECAST(self, FREE_CPU_FORECAST):
        self.FREE_CPU_FORECAST = FREE_CPU_FORECAST
    def get_FREE_CPU_FORECAST_FAR(self):
        return self.FREE_CPU_FORECAST_FAR
    def set_FREE_CPU_FORECAST_FAR(self, FREE_CPU_FORECAST_FAR):
        self.FREE_CPU_FORECAST_FAR = FREE_CPU_FORECAST_FAR
    def get_FREE_MEMORY(self):
        return self.FREE_MEMORY
    def set_FREE_MEMORY(self, FREE_MEMORY):
        self.FREE_MEMORY = FREE_MEMORY
    def get_FREE_MEMORY_FORECAST(self):
        return self.FREE_MEMORY_FORECAST
    def set_FREE_MEMORY_FORECAST(self, FREE_MEMORY_FORECAST):
        self.FREE_MEMORY_FORECAST = FREE_MEMORY_FORECAST
    def get_FREE_MEMORY_FORECAST_FAR(self):
        return self.FREE_MEMORY_FORECAST_FAR
    def set_FREE_MEMORY_FORECAST_FAR(self, FREE_MEMORY_FORECAST_FAR):
        self.FREE_MEMORY_FORECAST_FAR = FREE_MEMORY_FORECAST_FAR
    def get_USED_CPU(self):
        return self.USED_CPU
    def set_USED_CPU(self, USED_CPU):
        self.USED_CPU = USED_CPU
    def get_USED_CPU_FORECAST(self):
        return self.USED_CPU_FORECAST
    def set_USED_CPU_FORECAST(self, USED_CPU_FORECAST):
        self.USED_CPU_FORECAST = USED_CPU_FORECAST
    def get_USED_CPU_FORECAST_FAR(self):
        return self.USED_CPU_FORECAST_FAR
    def set_USED_CPU_FORECAST_FAR(self, USED_CPU_FORECAST_FAR):
        self.USED_CPU_FORECAST_FAR = USED_CPU_FORECAST_FAR
    def get_USED_MEMORY(self):
        return self.USED_MEMORY
    def set_USED_MEMORY(self, USED_MEMORY):
        self.USED_MEMORY = USED_MEMORY
    def get_USED_MEMORY_FORECAST(self):
        return self.USED_MEMORY_FORECAST
    def set_USED_MEMORY_FORECAST(self, USED_MEMORY_FORECAST):
        self.USED_MEMORY_FORECAST = USED_MEMORY_FORECAST
    def get_USED_MEMORY_FORECAST_FAR(self):
        return self.USED_MEMORY_FORECAST_FAR
    def set_USED_MEMORY_FORECAST_FAR(self, USED_MEMORY_FORECAST_FAR):
        self.USED_MEMORY_FORECAST_FAR = USED_MEMORY_FORECAST_FAR
    def has__content(self):
        if (
            self.FREE_CPU is not None or
            self.FREE_CPU_FORECAST is not None or
            self.FREE_CPU_FORECAST_FAR is not None or
            self.FREE_MEMORY is not None or
            self.FREE_MEMORY_FORECAST is not None or
            self.FREE_MEMORY_FORECAST_FAR is not None or
            self.USED_CPU is not None or
            self.USED_CPU_FORECAST is not None or
            self.USED_CPU_FORECAST_FAR is not None or
            self.USED_MEMORY is not None or
            self.USED_MEMORY_FORECAST is not None or
            self.USED_MEMORY_FORECAST_FAR is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CAPACITYType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CAPACITYType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CAPACITYType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CAPACITYType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CAPACITYType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CAPACITYType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CAPACITYType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FREE_CPU is not None:
            namespaceprefix_ = self.FREE_CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.FREE_CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFREE_CPU>%s</%sFREE_CPU>%s' % (namespaceprefix_ , self.gds_format_integer(self.FREE_CPU, input_name='FREE_CPU'), namespaceprefix_ , eol_))
        if self.FREE_CPU_FORECAST is not None:
            namespaceprefix_ = self.FREE_CPU_FORECAST_nsprefix_ + ':' if (UseCapturedNS_ and self.FREE_CPU_FORECAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFREE_CPU_FORECAST>%s</%sFREE_CPU_FORECAST>%s' % (namespaceprefix_ , self.gds_format_decimal(self.FREE_CPU_FORECAST, input_name='FREE_CPU_FORECAST'), namespaceprefix_ , eol_))
        if self.FREE_CPU_FORECAST_FAR is not None:
            namespaceprefix_ = self.FREE_CPU_FORECAST_FAR_nsprefix_ + ':' if (UseCapturedNS_ and self.FREE_CPU_FORECAST_FAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFREE_CPU_FORECAST_FAR>%s</%sFREE_CPU_FORECAST_FAR>%s' % (namespaceprefix_ , self.gds_format_decimal(self.FREE_CPU_FORECAST_FAR, input_name='FREE_CPU_FORECAST_FAR'), namespaceprefix_ , eol_))
        if self.FREE_MEMORY is not None:
            namespaceprefix_ = self.FREE_MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.FREE_MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFREE_MEMORY>%s</%sFREE_MEMORY>%s' % (namespaceprefix_ , self.gds_format_integer(self.FREE_MEMORY, input_name='FREE_MEMORY'), namespaceprefix_ , eol_))
        if self.FREE_MEMORY_FORECAST is not None:
            namespaceprefix_ = self.FREE_MEMORY_FORECAST_nsprefix_ + ':' if (UseCapturedNS_ and self.FREE_MEMORY_FORECAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFREE_MEMORY_FORECAST>%s</%sFREE_MEMORY_FORECAST>%s' % (namespaceprefix_ , self.gds_format_decimal(self.FREE_MEMORY_FORECAST, input_name='FREE_MEMORY_FORECAST'), namespaceprefix_ , eol_))
        if self.FREE_MEMORY_FORECAST_FAR is not None:
            namespaceprefix_ = self.FREE_MEMORY_FORECAST_FAR_nsprefix_ + ':' if (UseCapturedNS_ and self.FREE_MEMORY_FORECAST_FAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFREE_MEMORY_FORECAST_FAR>%s</%sFREE_MEMORY_FORECAST_FAR>%s' % (namespaceprefix_ , self.gds_format_decimal(self.FREE_MEMORY_FORECAST_FAR, input_name='FREE_MEMORY_FORECAST_FAR'), namespaceprefix_ , eol_))
        if self.USED_CPU is not None:
            namespaceprefix_ = self.USED_CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED_CPU>%s</%sUSED_CPU>%s' % (namespaceprefix_ , self.gds_format_integer(self.USED_CPU, input_name='USED_CPU'), namespaceprefix_ , eol_))
        if self.USED_CPU_FORECAST is not None:
            namespaceprefix_ = self.USED_CPU_FORECAST_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_CPU_FORECAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED_CPU_FORECAST>%s</%sUSED_CPU_FORECAST>%s' % (namespaceprefix_ , self.gds_format_decimal(self.USED_CPU_FORECAST, input_name='USED_CPU_FORECAST'), namespaceprefix_ , eol_))
        if self.USED_CPU_FORECAST_FAR is not None:
            namespaceprefix_ = self.USED_CPU_FORECAST_FAR_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_CPU_FORECAST_FAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED_CPU_FORECAST_FAR>%s</%sUSED_CPU_FORECAST_FAR>%s' % (namespaceprefix_ , self.gds_format_decimal(self.USED_CPU_FORECAST_FAR, input_name='USED_CPU_FORECAST_FAR'), namespaceprefix_ , eol_))
        if self.USED_MEMORY is not None:
            namespaceprefix_ = self.USED_MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED_MEMORY>%s</%sUSED_MEMORY>%s' % (namespaceprefix_ , self.gds_format_integer(self.USED_MEMORY, input_name='USED_MEMORY'), namespaceprefix_ , eol_))
        if self.USED_MEMORY_FORECAST is not None:
            namespaceprefix_ = self.USED_MEMORY_FORECAST_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_MEMORY_FORECAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED_MEMORY_FORECAST>%s</%sUSED_MEMORY_FORECAST>%s' % (namespaceprefix_ , self.gds_format_decimal(self.USED_MEMORY_FORECAST, input_name='USED_MEMORY_FORECAST'), namespaceprefix_ , eol_))
        if self.USED_MEMORY_FORECAST_FAR is not None:
            namespaceprefix_ = self.USED_MEMORY_FORECAST_FAR_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_MEMORY_FORECAST_FAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED_MEMORY_FORECAST_FAR>%s</%sUSED_MEMORY_FORECAST_FAR>%s' % (namespaceprefix_ , self.gds_format_decimal(self.USED_MEMORY_FORECAST_FAR, input_name='USED_MEMORY_FORECAST_FAR'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FREE_CPU' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'FREE_CPU')
            ival_ = self.gds_validate_integer(ival_, node, 'FREE_CPU')
            self.FREE_CPU = ival_
            self.FREE_CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'FREE_CPU_FORECAST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'FREE_CPU_FORECAST')
            fval_ = self.gds_validate_decimal(fval_, node, 'FREE_CPU_FORECAST')
            self.FREE_CPU_FORECAST = fval_
            self.FREE_CPU_FORECAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'FREE_CPU_FORECAST_FAR' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'FREE_CPU_FORECAST_FAR')
            fval_ = self.gds_validate_decimal(fval_, node, 'FREE_CPU_FORECAST_FAR')
            self.FREE_CPU_FORECAST_FAR = fval_
            self.FREE_CPU_FORECAST_FAR_nsprefix_ = child_.prefix
        elif nodeName_ == 'FREE_MEMORY' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'FREE_MEMORY')
            ival_ = self.gds_validate_integer(ival_, node, 'FREE_MEMORY')
            self.FREE_MEMORY = ival_
            self.FREE_MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'FREE_MEMORY_FORECAST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'FREE_MEMORY_FORECAST')
            fval_ = self.gds_validate_decimal(fval_, node, 'FREE_MEMORY_FORECAST')
            self.FREE_MEMORY_FORECAST = fval_
            self.FREE_MEMORY_FORECAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'FREE_MEMORY_FORECAST_FAR' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'FREE_MEMORY_FORECAST_FAR')
            fval_ = self.gds_validate_decimal(fval_, node, 'FREE_MEMORY_FORECAST_FAR')
            self.FREE_MEMORY_FORECAST_FAR = fval_
            self.FREE_MEMORY_FORECAST_FAR_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED_CPU' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'USED_CPU')
            ival_ = self.gds_validate_integer(ival_, node, 'USED_CPU')
            self.USED_CPU = ival_
            self.USED_CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED_CPU_FORECAST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'USED_CPU_FORECAST')
            fval_ = self.gds_validate_decimal(fval_, node, 'USED_CPU_FORECAST')
            self.USED_CPU_FORECAST = fval_
            self.USED_CPU_FORECAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED_CPU_FORECAST_FAR' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'USED_CPU_FORECAST_FAR')
            fval_ = self.gds_validate_decimal(fval_, node, 'USED_CPU_FORECAST_FAR')
            self.USED_CPU_FORECAST_FAR = fval_
            self.USED_CPU_FORECAST_FAR_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED_MEMORY' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'USED_MEMORY')
            ival_ = self.gds_validate_integer(ival_, node, 'USED_MEMORY')
            self.USED_MEMORY = ival_
            self.USED_MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED_MEMORY_FORECAST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'USED_MEMORY_FORECAST')
            fval_ = self.gds_validate_decimal(fval_, node, 'USED_MEMORY_FORECAST')
            self.USED_MEMORY_FORECAST = fval_
            self.USED_MEMORY_FORECAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED_MEMORY_FORECAST_FAR' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'USED_MEMORY_FORECAST_FAR')
            fval_ = self.gds_validate_decimal(fval_, node, 'USED_MEMORY_FORECAST_FAR')
            self.USED_MEMORY_FORECAST_FAR = fval_
            self.USED_MEMORY_FORECAST_FAR_nsprefix_ = child_.prefix
# end class CAPACITYType


class SYSTEMType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NETRX=None, NETRX_BW=None, NETRX_BW_FORECAST=None, NETRX_BW_FORECAST_FAR=None, NETTX=None, NETTX_BW=None, NETTX_BW_FORECAST=None, NETTX_BW_FORECAST_FAR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NETRX = NETRX
        self.NETRX_nsprefix_ = None
        self.NETRX_BW = NETRX_BW
        self.NETRX_BW_nsprefix_ = None
        self.NETRX_BW_FORECAST = NETRX_BW_FORECAST
        self.NETRX_BW_FORECAST_nsprefix_ = None
        self.NETRX_BW_FORECAST_FAR = NETRX_BW_FORECAST_FAR
        self.NETRX_BW_FORECAST_FAR_nsprefix_ = None
        self.NETTX = NETTX
        self.NETTX_nsprefix_ = None
        self.NETTX_BW = NETTX_BW
        self.NETTX_BW_nsprefix_ = None
        self.NETTX_BW_FORECAST = NETTX_BW_FORECAST
        self.NETTX_BW_FORECAST_nsprefix_ = None
        self.NETTX_BW_FORECAST_FAR = NETTX_BW_FORECAST_FAR
        self.NETTX_BW_FORECAST_FAR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SYSTEMType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SYSTEMType.subclass:
            return SYSTEMType.subclass(*args_, **kwargs_)
        else:
            return SYSTEMType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NETRX(self):
        return self.NETRX
    def set_NETRX(self, NETRX):
        self.NETRX = NETRX
    def get_NETRX_BW(self):
        return self.NETRX_BW
    def set_NETRX_BW(self, NETRX_BW):
        self.NETRX_BW = NETRX_BW
    def get_NETRX_BW_FORECAST(self):
        return self.NETRX_BW_FORECAST
    def set_NETRX_BW_FORECAST(self, NETRX_BW_FORECAST):
        self.NETRX_BW_FORECAST = NETRX_BW_FORECAST
    def get_NETRX_BW_FORECAST_FAR(self):
        return self.NETRX_BW_FORECAST_FAR
    def set_NETRX_BW_FORECAST_FAR(self, NETRX_BW_FORECAST_FAR):
        self.NETRX_BW_FORECAST_FAR = NETRX_BW_FORECAST_FAR
    def get_NETTX(self):
        return self.NETTX
    def set_NETTX(self, NETTX):
        self.NETTX = NETTX
    def get_NETTX_BW(self):
        return self.NETTX_BW
    def set_NETTX_BW(self, NETTX_BW):
        self.NETTX_BW = NETTX_BW
    def get_NETTX_BW_FORECAST(self):
        return self.NETTX_BW_FORECAST
    def set_NETTX_BW_FORECAST(self, NETTX_BW_FORECAST):
        self.NETTX_BW_FORECAST = NETTX_BW_FORECAST
    def get_NETTX_BW_FORECAST_FAR(self):
        return self.NETTX_BW_FORECAST_FAR
    def set_NETTX_BW_FORECAST_FAR(self, NETTX_BW_FORECAST_FAR):
        self.NETTX_BW_FORECAST_FAR = NETTX_BW_FORECAST_FAR
    def has__content(self):
        if (
            self.NETRX is not None or
            self.NETRX_BW is not None or
            self.NETRX_BW_FORECAST is not None or
            self.NETRX_BW_FORECAST_FAR is not None or
            self.NETTX is not None or
            self.NETTX_BW is not None or
            self.NETTX_BW_FORECAST is not None or
            self.NETTX_BW_FORECAST_FAR is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SYSTEMType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SYSTEMType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SYSTEMType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SYSTEMType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SYSTEMType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SYSTEMType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SYSTEMType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NETRX is not None:
            namespaceprefix_ = self.NETRX_nsprefix_ + ':' if (UseCapturedNS_ and self.NETRX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETRX>%s</%sNETRX>%s' % (namespaceprefix_ , self.gds_format_integer(self.NETRX, input_name='NETRX'), namespaceprefix_ , eol_))
        if self.NETRX_BW is not None:
            namespaceprefix_ = self.NETRX_BW_nsprefix_ + ':' if (UseCapturedNS_ and self.NETRX_BW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETRX_BW>%s</%sNETRX_BW>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETRX_BW, input_name='NETRX_BW'), namespaceprefix_ , eol_))
        if self.NETRX_BW_FORECAST is not None:
            namespaceprefix_ = self.NETRX_BW_FORECAST_nsprefix_ + ':' if (UseCapturedNS_ and self.NETRX_BW_FORECAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETRX_BW_FORECAST>%s</%sNETRX_BW_FORECAST>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETRX_BW_FORECAST, input_name='NETRX_BW_FORECAST'), namespaceprefix_ , eol_))
        if self.NETRX_BW_FORECAST_FAR is not None:
            namespaceprefix_ = self.NETRX_BW_FORECAST_FAR_nsprefix_ + ':' if (UseCapturedNS_ and self.NETRX_BW_FORECAST_FAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETRX_BW_FORECAST_FAR>%s</%sNETRX_BW_FORECAST_FAR>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETRX_BW_FORECAST_FAR, input_name='NETRX_BW_FORECAST_FAR'), namespaceprefix_ , eol_))
        if self.NETTX is not None:
            namespaceprefix_ = self.NETTX_nsprefix_ + ':' if (UseCapturedNS_ and self.NETTX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETTX>%s</%sNETTX>%s' % (namespaceprefix_ , self.gds_format_integer(self.NETTX, input_name='NETTX'), namespaceprefix_ , eol_))
        if self.NETTX_BW is not None:
            namespaceprefix_ = self.NETTX_BW_nsprefix_ + ':' if (UseCapturedNS_ and self.NETTX_BW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETTX_BW>%s</%sNETTX_BW>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETTX_BW, input_name='NETTX_BW'), namespaceprefix_ , eol_))
        if self.NETTX_BW_FORECAST is not None:
            namespaceprefix_ = self.NETTX_BW_FORECAST_nsprefix_ + ':' if (UseCapturedNS_ and self.NETTX_BW_FORECAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETTX_BW_FORECAST>%s</%sNETTX_BW_FORECAST>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETTX_BW_FORECAST, input_name='NETTX_BW_FORECAST'), namespaceprefix_ , eol_))
        if self.NETTX_BW_FORECAST_FAR is not None:
            namespaceprefix_ = self.NETTX_BW_FORECAST_FAR_nsprefix_ + ':' if (UseCapturedNS_ and self.NETTX_BW_FORECAST_FAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETTX_BW_FORECAST_FAR>%s</%sNETTX_BW_FORECAST_FAR>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETTX_BW_FORECAST_FAR, input_name='NETTX_BW_FORECAST_FAR'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NETRX' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NETRX')
            ival_ = self.gds_validate_integer(ival_, node, 'NETRX')
            self.NETRX = ival_
            self.NETRX_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETRX_BW' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETRX_BW')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETRX_BW')
            self.NETRX_BW = fval_
            self.NETRX_BW_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETRX_BW_FORECAST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETRX_BW_FORECAST')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETRX_BW_FORECAST')
            self.NETRX_BW_FORECAST = fval_
            self.NETRX_BW_FORECAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETRX_BW_FORECAST_FAR' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETRX_BW_FORECAST_FAR')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETRX_BW_FORECAST_FAR')
            self.NETRX_BW_FORECAST_FAR = fval_
            self.NETRX_BW_FORECAST_FAR_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETTX' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NETTX')
            ival_ = self.gds_validate_integer(ival_, node, 'NETTX')
            self.NETTX = ival_
            self.NETTX_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETTX_BW' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETTX_BW')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETTX_BW')
            self.NETTX_BW = fval_
            self.NETTX_BW_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETTX_BW_FORECAST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETTX_BW_FORECAST')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETTX_BW_FORECAST')
            self.NETTX_BW_FORECAST = fval_
            self.NETTX_BW_FORECAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETTX_BW_FORECAST_FAR' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETTX_BW_FORECAST_FAR')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETTX_BW_FORECAST_FAR')
            self.NETTX_BW_FORECAST_FAR = fval_
            self.NETTX_BW_FORECAST_FAR_nsprefix_ = child_.prefix
# end class SYSTEMType


class NUMA_NODEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, HUGEPAGE=None, MEMORY=None, NODE_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if HUGEPAGE is None:
            self.HUGEPAGE = []
        else:
            self.HUGEPAGE = HUGEPAGE
        self.HUGEPAGE_nsprefix_ = None
        self.MEMORY = MEMORY
        self.MEMORY_nsprefix_ = None
        self.NODE_ID = NODE_ID
        self.NODE_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NUMA_NODEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NUMA_NODEType.subclass:
            return NUMA_NODEType.subclass(*args_, **kwargs_)
        else:
            return NUMA_NODEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HUGEPAGE(self):
        return self.HUGEPAGE
    def set_HUGEPAGE(self, HUGEPAGE):
        self.HUGEPAGE = HUGEPAGE
    def add_HUGEPAGE(self, value):
        self.HUGEPAGE.append(value)
    def insert_HUGEPAGE_at(self, index, value):
        self.HUGEPAGE.insert(index, value)
    def replace_HUGEPAGE_at(self, index, value):
        self.HUGEPAGE[index] = value
    def get_MEMORY(self):
        return self.MEMORY
    def set_MEMORY(self, MEMORY):
        self.MEMORY = MEMORY
    def get_NODE_ID(self):
        return self.NODE_ID
    def set_NODE_ID(self, NODE_ID):
        self.NODE_ID = NODE_ID
    def has__content(self):
        if (
            self.HUGEPAGE or
            self.MEMORY is not None or
            self.NODE_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NUMA_NODEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NUMA_NODEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NUMA_NODEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NUMA_NODEType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NUMA_NODEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NUMA_NODEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NUMA_NODEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HUGEPAGE_ in self.HUGEPAGE:
            namespaceprefix_ = self.HUGEPAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.HUGEPAGE_nsprefix_) else ''
            HUGEPAGE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HUGEPAGE', pretty_print=pretty_print)
        if self.MEMORY is not None:
            namespaceprefix_ = self.MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_nsprefix_) else ''
            self.MEMORY.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MEMORY', pretty_print=pretty_print)
        if self.NODE_ID is not None:
            namespaceprefix_ = self.NODE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.NODE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNODE_ID>%s</%sNODE_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.NODE_ID, input_name='NODE_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HUGEPAGE':
            obj_ = HUGEPAGEType12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HUGEPAGE.append(obj_)
            obj_.original_tagname_ = 'HUGEPAGE'
        elif nodeName_ == 'MEMORY':
            obj_ = MEMORYType13.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MEMORY = obj_
            obj_.original_tagname_ = 'MEMORY'
        elif nodeName_ == 'NODE_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NODE_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'NODE_ID')
            self.NODE_ID = ival_
            self.NODE_ID_nsprefix_ = child_.prefix
# end class NUMA_NODEType


class HUGEPAGEType12(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, FREE=None, SIZE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.FREE = FREE
        self.FREE_nsprefix_ = None
        self.SIZE = SIZE
        self.SIZE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HUGEPAGEType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HUGEPAGEType12.subclass:
            return HUGEPAGEType12.subclass(*args_, **kwargs_)
        else:
            return HUGEPAGEType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FREE(self):
        return self.FREE
    def set_FREE(self, FREE):
        self.FREE = FREE
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def has__content(self):
        if (
            self.FREE is not None or
            self.SIZE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HUGEPAGEType12', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HUGEPAGEType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HUGEPAGEType12':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HUGEPAGEType12')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HUGEPAGEType12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HUGEPAGEType12'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HUGEPAGEType12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FREE is not None:
            namespaceprefix_ = self.FREE_nsprefix_ + ':' if (UseCapturedNS_ and self.FREE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFREE>%s</%sFREE>%s' % (namespaceprefix_ , self.gds_format_integer(self.FREE, input_name='FREE'), namespaceprefix_ , eol_))
        if self.SIZE is not None:
            namespaceprefix_ = self.SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE>%s</%sSIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.SIZE, input_name='SIZE'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FREE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'FREE')
            ival_ = self.gds_validate_integer(ival_, node, 'FREE')
            self.FREE = ival_
            self.FREE_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
            self.SIZE_nsprefix_ = child_.prefix
# end class HUGEPAGEType12


class MEMORYType13(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, FREE=None, USED=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.FREE = FREE
        self.FREE_nsprefix_ = None
        self.USED = USED
        self.USED_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MEMORYType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MEMORYType13.subclass:
            return MEMORYType13.subclass(*args_, **kwargs_)
        else:
            return MEMORYType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FREE(self):
        return self.FREE
    def set_FREE(self, FREE):
        self.FREE = FREE
    def get_USED(self):
        return self.USED
    def set_USED(self, USED):
        self.USED = USED
    def has__content(self):
        if (
            self.FREE is not None or
            self.USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MEMORYType13', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MEMORYType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MEMORYType13':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MEMORYType13')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MEMORYType13', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MEMORYType13'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MEMORYType13', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FREE is not None:
            namespaceprefix_ = self.FREE_nsprefix_ + ':' if (UseCapturedNS_ and self.FREE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFREE>%s</%sFREE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FREE), input_name='FREE')), namespaceprefix_ , eol_))
        if self.USED is not None:
            namespaceprefix_ = self.USED_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED>%s</%sUSED>%s' % (namespaceprefix_ , self.gds_format_integer(self.USED, input_name='USED'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FREE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FREE')
            value_ = self.gds_validate_string(value_, node, 'FREE')
            self.FREE = value_
            self.FREE_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'USED')
            ival_ = self.gds_validate_integer(ival_, node, 'USED')
            self.USED = ival_
            self.USED_nsprefix_ = child_.prefix
# end class MEMORYType13


class LOCKType14(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LOCKED=None, OWNER=None, TIME=None, REQ_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LOCKED = LOCKED
        self.LOCKED_nsprefix_ = None
        self.OWNER = OWNER
        self.OWNER_nsprefix_ = None
        self.TIME = TIME
        self.TIME_nsprefix_ = None
        self.REQ_ID = REQ_ID
        self.REQ_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOCKType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOCKType14.subclass:
            return LOCKType14.subclass(*args_, **kwargs_)
        else:
            return LOCKType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LOCKED(self):
        return self.LOCKED
    def set_LOCKED(self, LOCKED):
        self.LOCKED = LOCKED
    def get_OWNER(self):
        return self.OWNER
    def set_OWNER(self, OWNER):
        self.OWNER = OWNER
    def get_TIME(self):
        return self.TIME
    def set_TIME(self, TIME):
        self.TIME = TIME
    def get_REQ_ID(self):
        return self.REQ_ID
    def set_REQ_ID(self, REQ_ID):
        self.REQ_ID = REQ_ID
    def has__content(self):
        if (
            self.LOCKED is not None or
            self.OWNER is not None or
            self.TIME is not None or
            self.REQ_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType14', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOCKType14')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LOCKType14':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LOCKType14')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LOCKType14', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LOCKType14'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType14', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LOCKED is not None:
            namespaceprefix_ = self.LOCKED_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCKED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOCKED>%s</%sLOCKED>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOCKED, input_name='LOCKED'), namespaceprefix_ , eol_))
        if self.OWNER is not None:
            namespaceprefix_ = self.OWNER_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER>%s</%sOWNER>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER, input_name='OWNER'), namespaceprefix_ , eol_))
        if self.TIME is not None:
            namespaceprefix_ = self.TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIME>%s</%sTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIME, input_name='TIME'), namespaceprefix_ , eol_))
        if self.REQ_ID is not None:
            namespaceprefix_ = self.REQ_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.REQ_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREQ_ID>%s</%sREQ_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.REQ_ID, input_name='REQ_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LOCKED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOCKED')
            ival_ = self.gds_validate_integer(ival_, node, 'LOCKED')
            self.LOCKED = ival_
            self.LOCKED_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER')
            self.OWNER = ival_
            self.OWNER_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'TIME')
            self.TIME = ival_
            self.TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'REQ_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REQ_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'REQ_ID')
            self.REQ_ID = ival_
            self.REQ_ID_nsprefix_ = child_.prefix
# end class LOCKType14


class PERMISSIONSType15(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType15.subclass:
            return PERMISSIONSType15.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType15', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONSType15':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONSType15')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONSType15', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONSType15'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType15', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONSType15


class TEMPLATEType16(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEMPLATEType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEMPLATEType16.subclass:
            return TEMPLATEType16.subclass(*args_, **kwargs_)
        else:
            return TEMPLATEType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType16', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEMPLATEType16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEMPLATEType16':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEMPLATEType16')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEMPLATEType16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEMPLATEType16'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'TEMPLATEType16')
        self.anytypeobjs_.append(content_)
# end class TEMPLATEType16


class SNAPSHOTSType17(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ALLOW_ORPHANS=None, CURRENT_BASE=None, NEXT_SNAPSHOT=None, SNAPSHOT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ALLOW_ORPHANS = ALLOW_ORPHANS
        self.ALLOW_ORPHANS_nsprefix_ = None
        self.CURRENT_BASE = CURRENT_BASE
        self.CURRENT_BASE_nsprefix_ = None
        self.NEXT_SNAPSHOT = NEXT_SNAPSHOT
        self.NEXT_SNAPSHOT_nsprefix_ = None
        if SNAPSHOT is None:
            self.SNAPSHOT = []
        else:
            self.SNAPSHOT = SNAPSHOT
        self.SNAPSHOT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SNAPSHOTSType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SNAPSHOTSType17.subclass:
            return SNAPSHOTSType17.subclass(*args_, **kwargs_)
        else:
            return SNAPSHOTSType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ALLOW_ORPHANS(self):
        return self.ALLOW_ORPHANS
    def set_ALLOW_ORPHANS(self, ALLOW_ORPHANS):
        self.ALLOW_ORPHANS = ALLOW_ORPHANS
    def get_CURRENT_BASE(self):
        return self.CURRENT_BASE
    def set_CURRENT_BASE(self, CURRENT_BASE):
        self.CURRENT_BASE = CURRENT_BASE
    def get_NEXT_SNAPSHOT(self):
        return self.NEXT_SNAPSHOT
    def set_NEXT_SNAPSHOT(self, NEXT_SNAPSHOT):
        self.NEXT_SNAPSHOT = NEXT_SNAPSHOT
    def get_SNAPSHOT(self):
        return self.SNAPSHOT
    def set_SNAPSHOT(self, SNAPSHOT):
        self.SNAPSHOT = SNAPSHOT
    def add_SNAPSHOT(self, value):
        self.SNAPSHOT.append(value)
    def insert_SNAPSHOT_at(self, index, value):
        self.SNAPSHOT.insert(index, value)
    def replace_SNAPSHOT_at(self, index, value):
        self.SNAPSHOT[index] = value
    def has__content(self):
        if (
            self.ALLOW_ORPHANS is not None or
            self.CURRENT_BASE is not None or
            self.NEXT_SNAPSHOT is not None or
            self.SNAPSHOT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTSType17', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SNAPSHOTSType17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SNAPSHOTSType17':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SNAPSHOTSType17')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SNAPSHOTSType17', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SNAPSHOTSType17'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTSType17', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ALLOW_ORPHANS is not None:
            namespaceprefix_ = self.ALLOW_ORPHANS_nsprefix_ + ':' if (UseCapturedNS_ and self.ALLOW_ORPHANS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sALLOW_ORPHANS>%s</%sALLOW_ORPHANS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ALLOW_ORPHANS), input_name='ALLOW_ORPHANS')), namespaceprefix_ , eol_))
        if self.CURRENT_BASE is not None:
            namespaceprefix_ = self.CURRENT_BASE_nsprefix_ + ':' if (UseCapturedNS_ and self.CURRENT_BASE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCURRENT_BASE>%s</%sCURRENT_BASE>%s' % (namespaceprefix_ , self.gds_format_integer(self.CURRENT_BASE, input_name='CURRENT_BASE'), namespaceprefix_ , eol_))
        if self.NEXT_SNAPSHOT is not None:
            namespaceprefix_ = self.NEXT_SNAPSHOT_nsprefix_ + ':' if (UseCapturedNS_ and self.NEXT_SNAPSHOT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNEXT_SNAPSHOT>%s</%sNEXT_SNAPSHOT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NEXT_SNAPSHOT), input_name='NEXT_SNAPSHOT')), namespaceprefix_ , eol_))
        for SNAPSHOT_ in self.SNAPSHOT:
            namespaceprefix_ = self.SNAPSHOT_nsprefix_ + ':' if (UseCapturedNS_ and self.SNAPSHOT_nsprefix_) else ''
            SNAPSHOT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SNAPSHOT', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ALLOW_ORPHANS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ALLOW_ORPHANS')
            value_ = self.gds_validate_string(value_, node, 'ALLOW_ORPHANS')
            self.ALLOW_ORPHANS = value_
            self.ALLOW_ORPHANS_nsprefix_ = child_.prefix
        elif nodeName_ == 'CURRENT_BASE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CURRENT_BASE')
            ival_ = self.gds_validate_integer(ival_, node, 'CURRENT_BASE')
            self.CURRENT_BASE = ival_
            self.CURRENT_BASE_nsprefix_ = child_.prefix
        elif nodeName_ == 'NEXT_SNAPSHOT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NEXT_SNAPSHOT')
            value_ = self.gds_validate_string(value_, node, 'NEXT_SNAPSHOT')
            self.NEXT_SNAPSHOT = value_
            self.NEXT_SNAPSHOT_nsprefix_ = child_.prefix
        elif nodeName_ == 'SNAPSHOT':
            obj_ = SNAPSHOTType18.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SNAPSHOT.append(obj_)
            obj_.original_tagname_ = 'SNAPSHOT'
# end class SNAPSHOTSType17


class SNAPSHOTType18(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CHILDREN=None, ACTIVE=None, DATE=None, ID=None, NAME=None, PARENT=None, SIZE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CHILDREN = CHILDREN
        self.CHILDREN_nsprefix_ = None
        self.ACTIVE = ACTIVE
        self.ACTIVE_nsprefix_ = None
        self.DATE = DATE
        self.DATE_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PARENT = PARENT
        self.PARENT_nsprefix_ = None
        self.SIZE = SIZE
        self.SIZE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SNAPSHOTType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SNAPSHOTType18.subclass:
            return SNAPSHOTType18.subclass(*args_, **kwargs_)
        else:
            return SNAPSHOTType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CHILDREN(self):
        return self.CHILDREN
    def set_CHILDREN(self, CHILDREN):
        self.CHILDREN = CHILDREN
    def get_ACTIVE(self):
        return self.ACTIVE
    def set_ACTIVE(self, ACTIVE):
        self.ACTIVE = ACTIVE
    def get_DATE(self):
        return self.DATE
    def set_DATE(self, DATE):
        self.DATE = DATE
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PARENT(self):
        return self.PARENT
    def set_PARENT(self, PARENT):
        self.PARENT = PARENT
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def has__content(self):
        if (
            self.CHILDREN is not None or
            self.ACTIVE is not None or
            self.DATE is not None or
            self.ID is not None or
            self.NAME is not None or
            self.PARENT is not None or
            self.SIZE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTType18', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SNAPSHOTType18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SNAPSHOTType18':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SNAPSHOTType18')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SNAPSHOTType18', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SNAPSHOTType18'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTType18', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CHILDREN is not None:
            namespaceprefix_ = self.CHILDREN_nsprefix_ + ':' if (UseCapturedNS_ and self.CHILDREN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCHILDREN>%s</%sCHILDREN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CHILDREN), input_name='CHILDREN')), namespaceprefix_ , eol_))
        if self.ACTIVE is not None:
            namespaceprefix_ = self.ACTIVE_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTIVE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACTIVE>%s</%sACTIVE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ACTIVE), input_name='ACTIVE')), namespaceprefix_ , eol_))
        if self.DATE is not None:
            namespaceprefix_ = self.DATE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATE>%s</%sDATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.DATE, input_name='DATE'), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PARENT is not None:
            namespaceprefix_ = self.PARENT_nsprefix_ + ':' if (UseCapturedNS_ and self.PARENT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPARENT>%s</%sPARENT>%s' % (namespaceprefix_ , self.gds_format_integer(self.PARENT, input_name='PARENT'), namespaceprefix_ , eol_))
        if self.SIZE is not None:
            namespaceprefix_ = self.SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE>%s</%sSIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.SIZE, input_name='SIZE'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CHILDREN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CHILDREN')
            value_ = self.gds_validate_string(value_, node, 'CHILDREN')
            self.CHILDREN = value_
            self.CHILDREN_nsprefix_ = child_.prefix
        elif nodeName_ == 'ACTIVE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ACTIVE')
            value_ = self.gds_validate_string(value_, node, 'ACTIVE')
            self.ACTIVE = value_
            self.ACTIVE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DATE')
            ival_ = self.gds_validate_integer(ival_, node, 'DATE')
            self.DATE = ival_
            self.DATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PARENT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PARENT')
            ival_ = self.gds_validate_integer(ival_, node, 'PARENT')
            self.PARENT = ival_
            self.PARENT_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
            self.SIZE_nsprefix_ = child_.prefix
# end class SNAPSHOTType18


class BACKUP_INCREMENTSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, INCREMENT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if INCREMENT is None:
            self.INCREMENT = []
        else:
            self.INCREMENT = INCREMENT
        self.INCREMENT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BACKUP_INCREMENTSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BACKUP_INCREMENTSType.subclass:
            return BACKUP_INCREMENTSType.subclass(*args_, **kwargs_)
        else:
            return BACKUP_INCREMENTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_INCREMENT(self):
        return self.INCREMENT
    def set_INCREMENT(self, INCREMENT):
        self.INCREMENT = INCREMENT
    def add_INCREMENT(self, value):
        self.INCREMENT.append(value)
    def insert_INCREMENT_at(self, index, value):
        self.INCREMENT.insert(index, value)
    def replace_INCREMENT_at(self, index, value):
        self.INCREMENT[index] = value
    def has__content(self):
        if (
            self.INCREMENT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUP_INCREMENTSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BACKUP_INCREMENTSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BACKUP_INCREMENTSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BACKUP_INCREMENTSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BACKUP_INCREMENTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BACKUP_INCREMENTSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUP_INCREMENTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for INCREMENT_ in self.INCREMENT:
            namespaceprefix_ = self.INCREMENT_nsprefix_ + ':' if (UseCapturedNS_ and self.INCREMENT_nsprefix_) else ''
            INCREMENT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='INCREMENT', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'INCREMENT':
            obj_ = INCREMENTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.INCREMENT.append(obj_)
            obj_.original_tagname_ = 'INCREMENT'
# end class BACKUP_INCREMENTSType


class INCREMENTType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATE=None, ID=None, PARENT_ID=None, SIZE=None, SOURCE=None, TYPE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DATE = DATE
        self.DATE_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.PARENT_ID = PARENT_ID
        self.PARENT_ID_nsprefix_ = None
        self.SIZE = SIZE
        self.SIZE_nsprefix_ = None
        self.SOURCE = SOURCE
        self.SOURCE_nsprefix_ = None
        self.TYPE = TYPE
        self.TYPE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INCREMENTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INCREMENTType.subclass:
            return INCREMENTType.subclass(*args_, **kwargs_)
        else:
            return INCREMENTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATE(self):
        return self.DATE
    def set_DATE(self, DATE):
        self.DATE = DATE
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_PARENT_ID(self):
        return self.PARENT_ID
    def set_PARENT_ID(self, PARENT_ID):
        self.PARENT_ID = PARENT_ID
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def get_SOURCE(self):
        return self.SOURCE
    def set_SOURCE(self, SOURCE):
        self.SOURCE = SOURCE
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def has__content(self):
        if (
            self.DATE is not None or
            self.ID is not None or
            self.PARENT_ID is not None or
            self.SIZE is not None or
            self.SOURCE is not None or
            self.TYPE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='INCREMENTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INCREMENTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'INCREMENTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INCREMENTType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='INCREMENTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='INCREMENTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='INCREMENTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DATE is not None:
            namespaceprefix_ = self.DATE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATE>%s</%sDATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DATE), input_name='DATE')), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.PARENT_ID is not None:
            namespaceprefix_ = self.PARENT_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.PARENT_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPARENT_ID>%s</%sPARENT_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.PARENT_ID, input_name='PARENT_ID'), namespaceprefix_ , eol_))
        if self.SIZE is not None:
            namespaceprefix_ = self.SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE>%s</%sSIZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SIZE), input_name='SIZE')), namespaceprefix_ , eol_))
        if self.SOURCE is not None:
            namespaceprefix_ = self.SOURCE_nsprefix_ + ':' if (UseCapturedNS_ and self.SOURCE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSOURCE>%s</%sSOURCE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SOURCE), input_name='SOURCE')), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DATE')
            value_ = self.gds_validate_string(value_, node, 'DATE')
            self.DATE = value_
            self.DATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'PARENT_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PARENT_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'PARENT_ID')
            self.PARENT_ID = ival_
            self.PARENT_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SIZE')
            value_ = self.gds_validate_string(value_, node, 'SIZE')
            self.SIZE = value_
            self.SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'SOURCE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SOURCE')
            value_ = self.gds_validate_string(value_, node, 'SOURCE')
            self.SOURCE = value_
            self.SOURCE_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TYPE')
            value_ = self.gds_validate_string(value_, node, 'TYPE')
            self.TYPE = value_
            self.TYPE_nsprefix_ = child_.prefix
# end class INCREMENTType


class LOCKType19(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LOCKED=None, OWNER=None, TIME=None, REQ_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LOCKED = LOCKED
        self.LOCKED_nsprefix_ = None
        self.OWNER = OWNER
        self.OWNER_nsprefix_ = None
        self.TIME = TIME
        self.TIME_nsprefix_ = None
        self.REQ_ID = REQ_ID
        self.REQ_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOCKType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOCKType19.subclass:
            return LOCKType19.subclass(*args_, **kwargs_)
        else:
            return LOCKType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LOCKED(self):
        return self.LOCKED
    def set_LOCKED(self, LOCKED):
        self.LOCKED = LOCKED
    def get_OWNER(self):
        return self.OWNER
    def set_OWNER(self, OWNER):
        self.OWNER = OWNER
    def get_TIME(self):
        return self.TIME
    def set_TIME(self, TIME):
        self.TIME = TIME
    def get_REQ_ID(self):
        return self.REQ_ID
    def set_REQ_ID(self, REQ_ID):
        self.REQ_ID = REQ_ID
    def has__content(self):
        if (
            self.LOCKED is not None or
            self.OWNER is not None or
            self.TIME is not None or
            self.REQ_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType19', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOCKType19')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LOCKType19':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LOCKType19')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LOCKType19', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LOCKType19'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType19', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LOCKED is not None:
            namespaceprefix_ = self.LOCKED_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCKED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOCKED>%s</%sLOCKED>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOCKED, input_name='LOCKED'), namespaceprefix_ , eol_))
        if self.OWNER is not None:
            namespaceprefix_ = self.OWNER_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER>%s</%sOWNER>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER, input_name='OWNER'), namespaceprefix_ , eol_))
        if self.TIME is not None:
            namespaceprefix_ = self.TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIME>%s</%sTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIME, input_name='TIME'), namespaceprefix_ , eol_))
        if self.REQ_ID is not None:
            namespaceprefix_ = self.REQ_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.REQ_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREQ_ID>%s</%sREQ_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.REQ_ID, input_name='REQ_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LOCKED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOCKED')
            ival_ = self.gds_validate_integer(ival_, node, 'LOCKED')
            self.LOCKED = ival_
            self.LOCKED_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER')
            self.OWNER = ival_
            self.OWNER_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'TIME')
            self.TIME = ival_
            self.TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'REQ_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REQ_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'REQ_ID')
            self.REQ_ID = ival_
            self.REQ_ID_nsprefix_ = child_.prefix
# end class LOCKType19


class PERMISSIONSType20(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType20.subclass:
            return PERMISSIONSType20.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType20', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONSType20':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONSType20')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONSType20', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONSType20'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType20', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONSType20


class MARKETPLACEAPPSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MARKETPLACEAPPSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MARKETPLACEAPPSType.subclass:
            return MARKETPLACEAPPSType.subclass(*args_, **kwargs_)
        else:
            return MARKETPLACEAPPSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKETPLACEAPPSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MARKETPLACEAPPSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MARKETPLACEAPPSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MARKETPLACEAPPSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MARKETPLACEAPPSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MARKETPLACEAPPSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKETPLACEAPPSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class MARKETPLACEAPPSType


class PERMISSIONSType21(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType21.subclass:
            return PERMISSIONSType21.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType21', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType21')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONSType21':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONSType21')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONSType21', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONSType21'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType21', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONSType21


class MONITORINGType22(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CPU=None, DISKRDBYTES=None, DISKRDIOPS=None, DISKWRBYTES=None, DISKWRIOPS=None, DISK_SIZE=None, ID=None, MEMORY=None, NETRX=None, NETTX=None, TIMESTAMP=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CPU = CPU
        self.CPU_nsprefix_ = None
        self.DISKRDBYTES = DISKRDBYTES
        self.DISKRDBYTES_nsprefix_ = None
        self.DISKRDIOPS = DISKRDIOPS
        self.DISKRDIOPS_nsprefix_ = None
        self.DISKWRBYTES = DISKWRBYTES
        self.DISKWRBYTES_nsprefix_ = None
        self.DISKWRIOPS = DISKWRIOPS
        self.DISKWRIOPS_nsprefix_ = None
        if DISK_SIZE is None:
            self.DISK_SIZE = []
        else:
            self.DISK_SIZE = DISK_SIZE
        self.DISK_SIZE_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.MEMORY = MEMORY
        self.MEMORY_nsprefix_ = None
        self.NETRX = NETRX
        self.NETRX_nsprefix_ = None
        self.NETTX = NETTX
        self.NETTX_nsprefix_ = None
        self.TIMESTAMP = TIMESTAMP
        self.TIMESTAMP_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MONITORINGType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MONITORINGType22.subclass:
            return MONITORINGType22.subclass(*args_, **kwargs_)
        else:
            return MONITORINGType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CPU(self):
        return self.CPU
    def set_CPU(self, CPU):
        self.CPU = CPU
    def get_DISKRDBYTES(self):
        return self.DISKRDBYTES
    def set_DISKRDBYTES(self, DISKRDBYTES):
        self.DISKRDBYTES = DISKRDBYTES
    def get_DISKRDIOPS(self):
        return self.DISKRDIOPS
    def set_DISKRDIOPS(self, DISKRDIOPS):
        self.DISKRDIOPS = DISKRDIOPS
    def get_DISKWRBYTES(self):
        return self.DISKWRBYTES
    def set_DISKWRBYTES(self, DISKWRBYTES):
        self.DISKWRBYTES = DISKWRBYTES
    def get_DISKWRIOPS(self):
        return self.DISKWRIOPS
    def set_DISKWRIOPS(self, DISKWRIOPS):
        self.DISKWRIOPS = DISKWRIOPS
    def get_DISK_SIZE(self):
        return self.DISK_SIZE
    def set_DISK_SIZE(self, DISK_SIZE):
        self.DISK_SIZE = DISK_SIZE
    def add_DISK_SIZE(self, value):
        self.DISK_SIZE.append(value)
    def insert_DISK_SIZE_at(self, index, value):
        self.DISK_SIZE.insert(index, value)
    def replace_DISK_SIZE_at(self, index, value):
        self.DISK_SIZE[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_MEMORY(self):
        return self.MEMORY
    def set_MEMORY(self, MEMORY):
        self.MEMORY = MEMORY
    def get_NETRX(self):
        return self.NETRX
    def set_NETRX(self, NETRX):
        self.NETRX = NETRX
    def get_NETTX(self):
        return self.NETTX
    def set_NETTX(self, NETTX):
        self.NETTX = NETTX
    def get_TIMESTAMP(self):
        return self.TIMESTAMP
    def set_TIMESTAMP(self, TIMESTAMP):
        self.TIMESTAMP = TIMESTAMP
    def has__content(self):
        if (
            self.CPU is not None or
            self.DISKRDBYTES is not None or
            self.DISKRDIOPS is not None or
            self.DISKWRBYTES is not None or
            self.DISKWRIOPS is not None or
            self.DISK_SIZE or
            self.ID is not None or
            self.MEMORY is not None or
            self.NETRX is not None or
            self.NETTX is not None or
            self.TIMESTAMP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MONITORINGType22', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MONITORINGType22')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MONITORINGType22':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MONITORINGType22')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MONITORINGType22', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MONITORINGType22'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MONITORINGType22', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            namespaceprefix_ = self.CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU>%s</%sCPU>%s' % (namespaceprefix_ , self.gds_format_decimal(self.CPU, input_name='CPU'), namespaceprefix_ , eol_))
        if self.DISKRDBYTES is not None:
            namespaceprefix_ = self.DISKRDBYTES_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKRDBYTES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKRDBYTES>%s</%sDISKRDBYTES>%s' % (namespaceprefix_ , self.gds_format_integer(self.DISKRDBYTES, input_name='DISKRDBYTES'), namespaceprefix_ , eol_))
        if self.DISKRDIOPS is not None:
            namespaceprefix_ = self.DISKRDIOPS_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKRDIOPS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKRDIOPS>%s</%sDISKRDIOPS>%s' % (namespaceprefix_ , self.gds_format_integer(self.DISKRDIOPS, input_name='DISKRDIOPS'), namespaceprefix_ , eol_))
        if self.DISKWRBYTES is not None:
            namespaceprefix_ = self.DISKWRBYTES_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKWRBYTES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKWRBYTES>%s</%sDISKWRBYTES>%s' % (namespaceprefix_ , self.gds_format_integer(self.DISKWRBYTES, input_name='DISKWRBYTES'), namespaceprefix_ , eol_))
        if self.DISKWRIOPS is not None:
            namespaceprefix_ = self.DISKWRIOPS_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKWRIOPS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKWRIOPS>%s</%sDISKWRIOPS>%s' % (namespaceprefix_ , self.gds_format_integer(self.DISKWRIOPS, input_name='DISKWRIOPS'), namespaceprefix_ , eol_))
        for DISK_SIZE_ in self.DISK_SIZE:
            namespaceprefix_ = self.DISK_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_SIZE_nsprefix_) else ''
            DISK_SIZE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DISK_SIZE', pretty_print=pretty_print)
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.MEMORY is not None:
            namespaceprefix_ = self.MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY>%s</%sMEMORY>%s' % (namespaceprefix_ , self.gds_format_integer(self.MEMORY, input_name='MEMORY'), namespaceprefix_ , eol_))
        if self.NETRX is not None:
            namespaceprefix_ = self.NETRX_nsprefix_ + ':' if (UseCapturedNS_ and self.NETRX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETRX>%s</%sNETRX>%s' % (namespaceprefix_ , self.gds_format_integer(self.NETRX, input_name='NETRX'), namespaceprefix_ , eol_))
        if self.NETTX is not None:
            namespaceprefix_ = self.NETTX_nsprefix_ + ':' if (UseCapturedNS_ and self.NETTX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETTX>%s</%sNETTX>%s' % (namespaceprefix_ , self.gds_format_integer(self.NETTX, input_name='NETTX'), namespaceprefix_ , eol_))
        if self.TIMESTAMP is not None:
            namespaceprefix_ = self.TIMESTAMP_nsprefix_ + ':' if (UseCapturedNS_ and self.TIMESTAMP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIMESTAMP>%s</%sTIMESTAMP>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIMESTAMP, input_name='TIMESTAMP'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CPU' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'CPU')
            fval_ = self.gds_validate_decimal(fval_, node, 'CPU')
            self.CPU = fval_
            self.CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKRDBYTES' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DISKRDBYTES')
            ival_ = self.gds_validate_integer(ival_, node, 'DISKRDBYTES')
            self.DISKRDBYTES = ival_
            self.DISKRDBYTES_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKRDIOPS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DISKRDIOPS')
            ival_ = self.gds_validate_integer(ival_, node, 'DISKRDIOPS')
            self.DISKRDIOPS = ival_
            self.DISKRDIOPS_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKWRBYTES' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DISKWRBYTES')
            ival_ = self.gds_validate_integer(ival_, node, 'DISKWRBYTES')
            self.DISKWRBYTES = ival_
            self.DISKWRBYTES_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKWRIOPS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DISKWRIOPS')
            ival_ = self.gds_validate_integer(ival_, node, 'DISKWRIOPS')
            self.DISKWRIOPS = ival_
            self.DISKWRIOPS_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISK_SIZE':
            obj_ = DISK_SIZEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DISK_SIZE.append(obj_)
            obj_.original_tagname_ = 'DISK_SIZE'
        elif nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MEMORY')
            ival_ = self.gds_validate_integer(ival_, node, 'MEMORY')
            self.MEMORY = ival_
            self.MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETRX' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NETRX')
            ival_ = self.gds_validate_integer(ival_, node, 'NETRX')
            self.NETRX = ival_
            self.NETRX_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETTX' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NETTX')
            ival_ = self.gds_validate_integer(ival_, node, 'NETTX')
            self.NETTX = ival_
            self.NETTX_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIMESTAMP' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIMESTAMP')
            ival_ = self.gds_validate_integer(ival_, node, 'TIMESTAMP')
            self.TIMESTAMP = ival_
            self.TIMESTAMP_nsprefix_ = child_.prefix
# end class MONITORINGType22


class DISK_SIZEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, SIZE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.SIZE = SIZE
        self.SIZE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DISK_SIZEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DISK_SIZEType.subclass:
            return DISK_SIZEType.subclass(*args_, **kwargs_)
        else:
            return DISK_SIZEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def has__content(self):
        if (
            self.ID is not None or
            self.SIZE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DISK_SIZEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DISK_SIZEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DISK_SIZEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DISK_SIZEType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DISK_SIZEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DISK_SIZEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DISK_SIZEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.SIZE is not None:
            namespaceprefix_ = self.SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE>%s</%sSIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.SIZE, input_name='SIZE'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
            self.SIZE_nsprefix_ = child_.prefix
# end class DISK_SIZEType


class AUTH_MADType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, AUTHN=None, EXECUTABLE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AUTHN = AUTHN
        self.AUTHN_nsprefix_ = None
        self.EXECUTABLE = EXECUTABLE
        self.EXECUTABLE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AUTH_MADType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AUTH_MADType.subclass:
            return AUTH_MADType.subclass(*args_, **kwargs_)
        else:
            return AUTH_MADType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AUTHN(self):
        return self.AUTHN
    def set_AUTHN(self, AUTHN):
        self.AUTHN = AUTHN
    def get_EXECUTABLE(self):
        return self.EXECUTABLE
    def set_EXECUTABLE(self, EXECUTABLE):
        self.EXECUTABLE = EXECUTABLE
    def has__content(self):
        if (
            self.AUTHN is not None or
            self.EXECUTABLE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='AUTH_MADType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AUTH_MADType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AUTH_MADType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AUTH_MADType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AUTH_MADType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AUTH_MADType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='AUTH_MADType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AUTHN is not None:
            namespaceprefix_ = self.AUTHN_nsprefix_ + ':' if (UseCapturedNS_ and self.AUTHN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAUTHN>%s</%sAUTHN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AUTHN), input_name='AUTHN')), namespaceprefix_ , eol_))
        if self.EXECUTABLE is not None:
            namespaceprefix_ = self.EXECUTABLE_nsprefix_ + ':' if (UseCapturedNS_ and self.EXECUTABLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXECUTABLE>%s</%sEXECUTABLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EXECUTABLE), input_name='EXECUTABLE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AUTHN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AUTHN')
            value_ = self.gds_validate_string(value_, node, 'AUTHN')
            self.AUTHN = value_
            self.AUTHN_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXECUTABLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EXECUTABLE')
            value_ = self.gds_validate_string(value_, node, 'EXECUTABLE')
            self.EXECUTABLE = value_
            self.EXECUTABLE_nsprefix_ = child_.prefix
# end class AUTH_MADType


class AUTH_MAD_CONFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DRIVER_MANAGED_GROUPS=None, DRIVER_MANAGED_GROUP_ADMIN=None, MAX_TOKEN_TIME=None, NAME=None, PASSWORD_CHANGE=None, PASSWORD_REQUIRED=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DRIVER_MANAGED_GROUPS = DRIVER_MANAGED_GROUPS
        self.DRIVER_MANAGED_GROUPS_nsprefix_ = None
        self.DRIVER_MANAGED_GROUP_ADMIN = DRIVER_MANAGED_GROUP_ADMIN
        self.DRIVER_MANAGED_GROUP_ADMIN_nsprefix_ = None
        self.MAX_TOKEN_TIME = MAX_TOKEN_TIME
        self.MAX_TOKEN_TIME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PASSWORD_CHANGE = PASSWORD_CHANGE
        self.PASSWORD_CHANGE_nsprefix_ = None
        self.PASSWORD_REQUIRED = PASSWORD_REQUIRED
        self.PASSWORD_REQUIRED_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AUTH_MAD_CONFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AUTH_MAD_CONFType.subclass:
            return AUTH_MAD_CONFType.subclass(*args_, **kwargs_)
        else:
            return AUTH_MAD_CONFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DRIVER_MANAGED_GROUPS(self):
        return self.DRIVER_MANAGED_GROUPS
    def set_DRIVER_MANAGED_GROUPS(self, DRIVER_MANAGED_GROUPS):
        self.DRIVER_MANAGED_GROUPS = DRIVER_MANAGED_GROUPS
    def get_DRIVER_MANAGED_GROUP_ADMIN(self):
        return self.DRIVER_MANAGED_GROUP_ADMIN
    def set_DRIVER_MANAGED_GROUP_ADMIN(self, DRIVER_MANAGED_GROUP_ADMIN):
        self.DRIVER_MANAGED_GROUP_ADMIN = DRIVER_MANAGED_GROUP_ADMIN
    def get_MAX_TOKEN_TIME(self):
        return self.MAX_TOKEN_TIME
    def set_MAX_TOKEN_TIME(self, MAX_TOKEN_TIME):
        self.MAX_TOKEN_TIME = MAX_TOKEN_TIME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PASSWORD_CHANGE(self):
        return self.PASSWORD_CHANGE
    def set_PASSWORD_CHANGE(self, PASSWORD_CHANGE):
        self.PASSWORD_CHANGE = PASSWORD_CHANGE
    def get_PASSWORD_REQUIRED(self):
        return self.PASSWORD_REQUIRED
    def set_PASSWORD_REQUIRED(self, PASSWORD_REQUIRED):
        self.PASSWORD_REQUIRED = PASSWORD_REQUIRED
    def has__content(self):
        if (
            self.DRIVER_MANAGED_GROUPS is not None or
            self.DRIVER_MANAGED_GROUP_ADMIN is not None or
            self.MAX_TOKEN_TIME is not None or
            self.NAME is not None or
            self.PASSWORD_CHANGE is not None or
            self.PASSWORD_REQUIRED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='AUTH_MAD_CONFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AUTH_MAD_CONFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AUTH_MAD_CONFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AUTH_MAD_CONFType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AUTH_MAD_CONFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AUTH_MAD_CONFType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='AUTH_MAD_CONFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DRIVER_MANAGED_GROUPS is not None:
            namespaceprefix_ = self.DRIVER_MANAGED_GROUPS_nsprefix_ + ':' if (UseCapturedNS_ and self.DRIVER_MANAGED_GROUPS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDRIVER_MANAGED_GROUPS>%s</%sDRIVER_MANAGED_GROUPS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DRIVER_MANAGED_GROUPS), input_name='DRIVER_MANAGED_GROUPS')), namespaceprefix_ , eol_))
        if self.DRIVER_MANAGED_GROUP_ADMIN is not None:
            namespaceprefix_ = self.DRIVER_MANAGED_GROUP_ADMIN_nsprefix_ + ':' if (UseCapturedNS_ and self.DRIVER_MANAGED_GROUP_ADMIN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDRIVER_MANAGED_GROUP_ADMIN>%s</%sDRIVER_MANAGED_GROUP_ADMIN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DRIVER_MANAGED_GROUP_ADMIN), input_name='DRIVER_MANAGED_GROUP_ADMIN')), namespaceprefix_ , eol_))
        if self.MAX_TOKEN_TIME is not None:
            namespaceprefix_ = self.MAX_TOKEN_TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.MAX_TOKEN_TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAX_TOKEN_TIME>%s</%sMAX_TOKEN_TIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.MAX_TOKEN_TIME, input_name='MAX_TOKEN_TIME'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PASSWORD_CHANGE is not None:
            namespaceprefix_ = self.PASSWORD_CHANGE_nsprefix_ + ':' if (UseCapturedNS_ and self.PASSWORD_CHANGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPASSWORD_CHANGE>%s</%sPASSWORD_CHANGE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PASSWORD_CHANGE), input_name='PASSWORD_CHANGE')), namespaceprefix_ , eol_))
        if self.PASSWORD_REQUIRED is not None:
            namespaceprefix_ = self.PASSWORD_REQUIRED_nsprefix_ + ':' if (UseCapturedNS_ and self.PASSWORD_REQUIRED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPASSWORD_REQUIRED>%s</%sPASSWORD_REQUIRED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PASSWORD_REQUIRED), input_name='PASSWORD_REQUIRED')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DRIVER_MANAGED_GROUPS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DRIVER_MANAGED_GROUPS')
            value_ = self.gds_validate_string(value_, node, 'DRIVER_MANAGED_GROUPS')
            self.DRIVER_MANAGED_GROUPS = value_
            self.DRIVER_MANAGED_GROUPS_nsprefix_ = child_.prefix
        elif nodeName_ == 'DRIVER_MANAGED_GROUP_ADMIN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DRIVER_MANAGED_GROUP_ADMIN')
            value_ = self.gds_validate_string(value_, node, 'DRIVER_MANAGED_GROUP_ADMIN')
            self.DRIVER_MANAGED_GROUP_ADMIN = value_
            self.DRIVER_MANAGED_GROUP_ADMIN_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAX_TOKEN_TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MAX_TOKEN_TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_TOKEN_TIME')
            self.MAX_TOKEN_TIME = ival_
            self.MAX_TOKEN_TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PASSWORD_CHANGE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PASSWORD_CHANGE')
            value_ = self.gds_validate_string(value_, node, 'PASSWORD_CHANGE')
            self.PASSWORD_CHANGE = value_
            self.PASSWORD_CHANGE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PASSWORD_REQUIRED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PASSWORD_REQUIRED')
            value_ = self.gds_validate_string(value_, node, 'PASSWORD_REQUIRED')
            self.PASSWORD_REQUIRED = value_
            self.PASSWORD_REQUIRED_nsprefix_ = child_.prefix
# end class AUTH_MAD_CONFType


class DATASTORE_MADType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ARGUMENTS=None, EXECUTABLE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ARGUMENTS = ARGUMENTS
        self.ARGUMENTS_nsprefix_ = None
        self.EXECUTABLE = EXECUTABLE
        self.EXECUTABLE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE_MADType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE_MADType.subclass:
            return DATASTORE_MADType.subclass(*args_, **kwargs_)
        else:
            return DATASTORE_MADType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ARGUMENTS(self):
        return self.ARGUMENTS
    def set_ARGUMENTS(self, ARGUMENTS):
        self.ARGUMENTS = ARGUMENTS
    def get_EXECUTABLE(self):
        return self.EXECUTABLE
    def set_EXECUTABLE(self, EXECUTABLE):
        self.EXECUTABLE = EXECUTABLE
    def has__content(self):
        if (
            self.ARGUMENTS is not None or
            self.EXECUTABLE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORE_MADType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE_MADType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATASTORE_MADType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATASTORE_MADType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATASTORE_MADType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATASTORE_MADType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORE_MADType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ARGUMENTS is not None:
            namespaceprefix_ = self.ARGUMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.ARGUMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sARGUMENTS>%s</%sARGUMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ARGUMENTS), input_name='ARGUMENTS')), namespaceprefix_ , eol_))
        if self.EXECUTABLE is not None:
            namespaceprefix_ = self.EXECUTABLE_nsprefix_ + ':' if (UseCapturedNS_ and self.EXECUTABLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXECUTABLE>%s</%sEXECUTABLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EXECUTABLE), input_name='EXECUTABLE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ARGUMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ARGUMENTS')
            value_ = self.gds_validate_string(value_, node, 'ARGUMENTS')
            self.ARGUMENTS = value_
            self.ARGUMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXECUTABLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EXECUTABLE')
            value_ = self.gds_validate_string(value_, node, 'EXECUTABLE')
            self.EXECUTABLE = value_
            self.EXECUTABLE_nsprefix_ = child_.prefix
# end class DATASTORE_MADType


class DBType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BACKEND=None, COMPARE_BINARY=None, CONNECTIONS=None, DB_NAME=None, PASSWD=None, PORT=None, SERVER=None, USER=None, TIMEOUT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.BACKEND = BACKEND
        self.validate_BACKENDType(self.BACKEND)
        self.BACKEND_nsprefix_ = None
        self.COMPARE_BINARY = COMPARE_BINARY
        self.validate_COMPARE_BINARYType(self.COMPARE_BINARY)
        self.COMPARE_BINARY_nsprefix_ = None
        self.CONNECTIONS = CONNECTIONS
        self.CONNECTIONS_nsprefix_ = None
        self.DB_NAME = DB_NAME
        self.DB_NAME_nsprefix_ = None
        self.PASSWD = PASSWD
        self.PASSWD_nsprefix_ = None
        self.PORT = PORT
        self.PORT_nsprefix_ = None
        self.SERVER = SERVER
        self.SERVER_nsprefix_ = None
        self.USER = USER
        self.USER_nsprefix_ = None
        self.TIMEOUT = TIMEOUT
        self.TIMEOUT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DBType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DBType.subclass:
            return DBType.subclass(*args_, **kwargs_)
        else:
            return DBType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BACKEND(self):
        return self.BACKEND
    def set_BACKEND(self, BACKEND):
        self.BACKEND = BACKEND
    def get_COMPARE_BINARY(self):
        return self.COMPARE_BINARY
    def set_COMPARE_BINARY(self, COMPARE_BINARY):
        self.COMPARE_BINARY = COMPARE_BINARY
    def get_CONNECTIONS(self):
        return self.CONNECTIONS
    def set_CONNECTIONS(self, CONNECTIONS):
        self.CONNECTIONS = CONNECTIONS
    def get_DB_NAME(self):
        return self.DB_NAME
    def set_DB_NAME(self, DB_NAME):
        self.DB_NAME = DB_NAME
    def get_PASSWD(self):
        return self.PASSWD
    def set_PASSWD(self, PASSWD):
        self.PASSWD = PASSWD
    def get_PORT(self):
        return self.PORT
    def set_PORT(self, PORT):
        self.PORT = PORT
    def get_SERVER(self):
        return self.SERVER
    def set_SERVER(self, SERVER):
        self.SERVER = SERVER
    def get_USER(self):
        return self.USER
    def set_USER(self, USER):
        self.USER = USER
    def get_TIMEOUT(self):
        return self.TIMEOUT
    def set_TIMEOUT(self, TIMEOUT):
        self.TIMEOUT = TIMEOUT
    def validate_BACKENDType(self, value):
        result = True
        # Validate type BACKENDType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['mysql', 'sqlite']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BACKENDType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_COMPARE_BINARYType(self, value):
        result = True
        # Validate type COMPARE_BINARYType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_COMPARE_BINARYType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_COMPARE_BINARYType_patterns_, ))
                result = False
        return result
    validate_COMPARE_BINARYType_patterns_ = [['^([yY][eE][sS])$', '^([nN][oO])$']]
    def has__content(self):
        if (
            self.BACKEND is not None or
            self.COMPARE_BINARY is not None or
            self.CONNECTIONS is not None or
            self.DB_NAME is not None or
            self.PASSWD is not None or
            self.PORT is not None or
            self.SERVER is not None or
            self.USER is not None or
            self.TIMEOUT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DBType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DBType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DBType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DBType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DBType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DBType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DBType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BACKEND is not None:
            namespaceprefix_ = self.BACKEND_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKEND_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBACKEND>%s</%sBACKEND>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BACKEND), input_name='BACKEND')), namespaceprefix_ , eol_))
        if self.COMPARE_BINARY is not None:
            namespaceprefix_ = self.COMPARE_BINARY_nsprefix_ + ':' if (UseCapturedNS_ and self.COMPARE_BINARY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOMPARE_BINARY>%s</%sCOMPARE_BINARY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.COMPARE_BINARY), input_name='COMPARE_BINARY')), namespaceprefix_ , eol_))
        if self.CONNECTIONS is not None:
            namespaceprefix_ = self.CONNECTIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.CONNECTIONS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCONNECTIONS>%s</%sCONNECTIONS>%s' % (namespaceprefix_ , self.gds_format_integer(self.CONNECTIONS, input_name='CONNECTIONS'), namespaceprefix_ , eol_))
        if self.DB_NAME is not None:
            namespaceprefix_ = self.DB_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.DB_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDB_NAME>%s</%sDB_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DB_NAME), input_name='DB_NAME')), namespaceprefix_ , eol_))
        if self.PASSWD is not None:
            namespaceprefix_ = self.PASSWD_nsprefix_ + ':' if (UseCapturedNS_ and self.PASSWD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPASSWD>%s</%sPASSWD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PASSWD), input_name='PASSWD')), namespaceprefix_ , eol_))
        if self.PORT is not None:
            namespaceprefix_ = self.PORT_nsprefix_ + ':' if (UseCapturedNS_ and self.PORT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPORT>%s</%sPORT>%s' % (namespaceprefix_ , self.gds_format_integer(self.PORT, input_name='PORT'), namespaceprefix_ , eol_))
        if self.SERVER is not None:
            namespaceprefix_ = self.SERVER_nsprefix_ + ':' if (UseCapturedNS_ and self.SERVER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSERVER>%s</%sSERVER>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SERVER), input_name='SERVER')), namespaceprefix_ , eol_))
        if self.USER is not None:
            namespaceprefix_ = self.USER_nsprefix_ + ':' if (UseCapturedNS_ and self.USER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSER>%s</%sUSER>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.USER), input_name='USER')), namespaceprefix_ , eol_))
        if self.TIMEOUT is not None:
            namespaceprefix_ = self.TIMEOUT_nsprefix_ + ':' if (UseCapturedNS_ and self.TIMEOUT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIMEOUT>%s</%sTIMEOUT>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIMEOUT, input_name='TIMEOUT'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BACKEND':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BACKEND')
            value_ = self.gds_validate_string(value_, node, 'BACKEND')
            self.BACKEND = value_
            self.BACKEND_nsprefix_ = child_.prefix
            # validate type BACKENDType
            self.validate_BACKENDType(self.BACKEND)
        elif nodeName_ == 'COMPARE_BINARY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'COMPARE_BINARY')
            value_ = self.gds_validate_string(value_, node, 'COMPARE_BINARY')
            self.COMPARE_BINARY = value_
            self.COMPARE_BINARY_nsprefix_ = child_.prefix
            # validate type COMPARE_BINARYType
            self.validate_COMPARE_BINARYType(self.COMPARE_BINARY)
        elif nodeName_ == 'CONNECTIONS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CONNECTIONS')
            ival_ = self.gds_validate_integer(ival_, node, 'CONNECTIONS')
            self.CONNECTIONS = ival_
            self.CONNECTIONS_nsprefix_ = child_.prefix
        elif nodeName_ == 'DB_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DB_NAME')
            value_ = self.gds_validate_string(value_, node, 'DB_NAME')
            self.DB_NAME = value_
            self.DB_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PASSWD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PASSWD')
            value_ = self.gds_validate_string(value_, node, 'PASSWD')
            self.PASSWD = value_
            self.PASSWD_nsprefix_ = child_.prefix
        elif nodeName_ == 'PORT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PORT')
            ival_ = self.gds_validate_integer(ival_, node, 'PORT')
            self.PORT = ival_
            self.PORT_nsprefix_ = child_.prefix
        elif nodeName_ == 'SERVER':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SERVER')
            value_ = self.gds_validate_string(value_, node, 'SERVER')
            self.SERVER = value_
            self.SERVER_nsprefix_ = child_.prefix
        elif nodeName_ == 'USER':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'USER')
            value_ = self.gds_validate_string(value_, node, 'USER')
            self.USER = value_
            self.USER_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIMEOUT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIMEOUT')
            ival_ = self.gds_validate_integer(ival_, node, 'TIMEOUT')
            self.TIMEOUT = ival_
            self.TIMEOUT_nsprefix_ = child_.prefix
# end class DBType


class DEFAULT_COSTType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CPU_COST=None, DISK_COST=None, MEMORY_COST=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CPU_COST = CPU_COST
        self.CPU_COST_nsprefix_ = None
        self.DISK_COST = DISK_COST
        self.DISK_COST_nsprefix_ = None
        self.MEMORY_COST = MEMORY_COST
        self.MEMORY_COST_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DEFAULT_COSTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DEFAULT_COSTType.subclass:
            return DEFAULT_COSTType.subclass(*args_, **kwargs_)
        else:
            return DEFAULT_COSTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CPU_COST(self):
        return self.CPU_COST
    def set_CPU_COST(self, CPU_COST):
        self.CPU_COST = CPU_COST
    def get_DISK_COST(self):
        return self.DISK_COST
    def set_DISK_COST(self, DISK_COST):
        self.DISK_COST = DISK_COST
    def get_MEMORY_COST(self):
        return self.MEMORY_COST
    def set_MEMORY_COST(self, MEMORY_COST):
        self.MEMORY_COST = MEMORY_COST
    def has__content(self):
        if (
            self.CPU_COST is not None or
            self.DISK_COST is not None or
            self.MEMORY_COST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DEFAULT_COSTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DEFAULT_COSTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DEFAULT_COSTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DEFAULT_COSTType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DEFAULT_COSTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DEFAULT_COSTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DEFAULT_COSTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU_COST is not None:
            namespaceprefix_ = self.CPU_COST_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_COST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU_COST>%s</%sCPU_COST>%s' % (namespaceprefix_ , self.gds_format_integer(self.CPU_COST, input_name='CPU_COST'), namespaceprefix_ , eol_))
        if self.DISK_COST is not None:
            namespaceprefix_ = self.DISK_COST_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_COST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISK_COST>%s</%sDISK_COST>%s' % (namespaceprefix_ , self.gds_format_integer(self.DISK_COST, input_name='DISK_COST'), namespaceprefix_ , eol_))
        if self.MEMORY_COST is not None:
            namespaceprefix_ = self.MEMORY_COST_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_COST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY_COST>%s</%sMEMORY_COST>%s' % (namespaceprefix_ , self.gds_format_integer(self.MEMORY_COST, input_name='MEMORY_COST'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CPU_COST' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CPU_COST')
            ival_ = self.gds_validate_integer(ival_, node, 'CPU_COST')
            self.CPU_COST = ival_
            self.CPU_COST_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISK_COST' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DISK_COST')
            ival_ = self.gds_validate_integer(ival_, node, 'DISK_COST')
            self.DISK_COST = ival_
            self.DISK_COST_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY_COST' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MEMORY_COST')
            ival_ = self.gds_validate_integer(ival_, node, 'MEMORY_COST')
            self.MEMORY_COST = ival_
            self.MEMORY_COST_nsprefix_ = child_.prefix
# end class DEFAULT_COSTType


class DS_MAD_CONFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, MARKETPLACE_ACTIONS=None, NAME=None, PERSISTENT_ONLY=None, REQUIRED_ATTRS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MARKETPLACE_ACTIONS = MARKETPLACE_ACTIONS
        self.MARKETPLACE_ACTIONS_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PERSISTENT_ONLY = PERSISTENT_ONLY
        self.validate_PERSISTENT_ONLYType(self.PERSISTENT_ONLY)
        self.PERSISTENT_ONLY_nsprefix_ = None
        self.REQUIRED_ATTRS = REQUIRED_ATTRS
        self.REQUIRED_ATTRS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DS_MAD_CONFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DS_MAD_CONFType.subclass:
            return DS_MAD_CONFType.subclass(*args_, **kwargs_)
        else:
            return DS_MAD_CONFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MARKETPLACE_ACTIONS(self):
        return self.MARKETPLACE_ACTIONS
    def set_MARKETPLACE_ACTIONS(self, MARKETPLACE_ACTIONS):
        self.MARKETPLACE_ACTIONS = MARKETPLACE_ACTIONS
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PERSISTENT_ONLY(self):
        return self.PERSISTENT_ONLY
    def set_PERSISTENT_ONLY(self, PERSISTENT_ONLY):
        self.PERSISTENT_ONLY = PERSISTENT_ONLY
    def get_REQUIRED_ATTRS(self):
        return self.REQUIRED_ATTRS
    def set_REQUIRED_ATTRS(self, REQUIRED_ATTRS):
        self.REQUIRED_ATTRS = REQUIRED_ATTRS
    def validate_PERSISTENT_ONLYType(self, value):
        result = True
        # Validate type PERSISTENT_ONLYType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_PERSISTENT_ONLYType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_PERSISTENT_ONLYType_patterns_, ))
                result = False
        return result
    validate_PERSISTENT_ONLYType_patterns_ = [['^([yY][eE][sS])$', '^([nN][oO])$']]
    def has__content(self):
        if (
            self.MARKETPLACE_ACTIONS is not None or
            self.NAME is not None or
            self.PERSISTENT_ONLY is not None or
            self.REQUIRED_ATTRS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DS_MAD_CONFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DS_MAD_CONFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DS_MAD_CONFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DS_MAD_CONFType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DS_MAD_CONFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DS_MAD_CONFType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DS_MAD_CONFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MARKETPLACE_ACTIONS is not None:
            namespaceprefix_ = self.MARKETPLACE_ACTIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.MARKETPLACE_ACTIONS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMARKETPLACE_ACTIONS>%s</%sMARKETPLACE_ACTIONS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MARKETPLACE_ACTIONS), input_name='MARKETPLACE_ACTIONS')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PERSISTENT_ONLY is not None:
            namespaceprefix_ = self.PERSISTENT_ONLY_nsprefix_ + ':' if (UseCapturedNS_ and self.PERSISTENT_ONLY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPERSISTENT_ONLY>%s</%sPERSISTENT_ONLY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PERSISTENT_ONLY), input_name='PERSISTENT_ONLY')), namespaceprefix_ , eol_))
        if self.REQUIRED_ATTRS is not None:
            namespaceprefix_ = self.REQUIRED_ATTRS_nsprefix_ + ':' if (UseCapturedNS_ and self.REQUIRED_ATTRS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREQUIRED_ATTRS>%s</%sREQUIRED_ATTRS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.REQUIRED_ATTRS), input_name='REQUIRED_ATTRS')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MARKETPLACE_ACTIONS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MARKETPLACE_ACTIONS')
            value_ = self.gds_validate_string(value_, node, 'MARKETPLACE_ACTIONS')
            self.MARKETPLACE_ACTIONS = value_
            self.MARKETPLACE_ACTIONS_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PERSISTENT_ONLY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PERSISTENT_ONLY')
            value_ = self.gds_validate_string(value_, node, 'PERSISTENT_ONLY')
            self.PERSISTENT_ONLY = value_
            self.PERSISTENT_ONLY_nsprefix_ = child_.prefix
            # validate type PERSISTENT_ONLYType
            self.validate_PERSISTENT_ONLYType(self.PERSISTENT_ONLY)
        elif nodeName_ == 'REQUIRED_ATTRS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'REQUIRED_ATTRS')
            value_ = self.gds_validate_string(value_, node, 'REQUIRED_ATTRS')
            self.REQUIRED_ATTRS = value_
            self.REQUIRED_ATTRS_nsprefix_ = child_.prefix
# end class DS_MAD_CONFType


class FEDERATIONType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, MASTER_ONED=None, MODE=None, SERVER_ID=None, ZONE_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MASTER_ONED = MASTER_ONED
        self.MASTER_ONED_nsprefix_ = None
        self.MODE = MODE
        self.validate_MODEType(self.MODE)
        self.MODE_nsprefix_ = None
        self.SERVER_ID = SERVER_ID
        self.SERVER_ID_nsprefix_ = None
        self.ZONE_ID = ZONE_ID
        self.ZONE_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FEDERATIONType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FEDERATIONType.subclass:
            return FEDERATIONType.subclass(*args_, **kwargs_)
        else:
            return FEDERATIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MASTER_ONED(self):
        return self.MASTER_ONED
    def set_MASTER_ONED(self, MASTER_ONED):
        self.MASTER_ONED = MASTER_ONED
    def get_MODE(self):
        return self.MODE
    def set_MODE(self, MODE):
        self.MODE = MODE
    def get_SERVER_ID(self):
        return self.SERVER_ID
    def set_SERVER_ID(self, SERVER_ID):
        self.SERVER_ID = SERVER_ID
    def get_ZONE_ID(self):
        return self.ZONE_ID
    def set_ZONE_ID(self, ZONE_ID):
        self.ZONE_ID = ZONE_ID
    def validate_MODEType(self, value):
        result = True
        # Validate type MODEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['STANDALONE', 'MASTER', 'SLAVE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MODEType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.MASTER_ONED is not None or
            self.MODE is not None or
            self.SERVER_ID is not None or
            self.ZONE_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='FEDERATIONType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FEDERATIONType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FEDERATIONType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FEDERATIONType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FEDERATIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FEDERATIONType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='FEDERATIONType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MASTER_ONED is not None:
            namespaceprefix_ = self.MASTER_ONED_nsprefix_ + ':' if (UseCapturedNS_ and self.MASTER_ONED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMASTER_ONED>%s</%sMASTER_ONED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MASTER_ONED), input_name='MASTER_ONED')), namespaceprefix_ , eol_))
        if self.MODE is not None:
            namespaceprefix_ = self.MODE_nsprefix_ + ':' if (UseCapturedNS_ and self.MODE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMODE>%s</%sMODE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MODE), input_name='MODE')), namespaceprefix_ , eol_))
        if self.SERVER_ID is not None:
            namespaceprefix_ = self.SERVER_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.SERVER_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSERVER_ID>%s</%sSERVER_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.SERVER_ID, input_name='SERVER_ID'), namespaceprefix_ , eol_))
        if self.ZONE_ID is not None:
            namespaceprefix_ = self.ZONE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ZONE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZONE_ID>%s</%sZONE_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ZONE_ID, input_name='ZONE_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MASTER_ONED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MASTER_ONED')
            value_ = self.gds_validate_string(value_, node, 'MASTER_ONED')
            self.MASTER_ONED = value_
            self.MASTER_ONED_nsprefix_ = child_.prefix
        elif nodeName_ == 'MODE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MODE')
            value_ = self.gds_validate_string(value_, node, 'MODE')
            self.MODE = value_
            self.MODE_nsprefix_ = child_.prefix
            # validate type MODEType
            self.validate_MODEType(self.MODE)
        elif nodeName_ == 'SERVER_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SERVER_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'SERVER_ID')
            self.SERVER_ID = ival_
            self.SERVER_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'ZONE_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ZONE_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ZONE_ID')
            self.ZONE_ID = ival_
            self.ZONE_ID_nsprefix_ = child_.prefix
# end class FEDERATIONType


class HM_MADType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ARGUMENTS=None, EXECUTABLE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ARGUMENTS = ARGUMENTS
        self.ARGUMENTS_nsprefix_ = None
        self.EXECUTABLE = EXECUTABLE
        self.EXECUTABLE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HM_MADType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HM_MADType.subclass:
            return HM_MADType.subclass(*args_, **kwargs_)
        else:
            return HM_MADType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ARGUMENTS(self):
        return self.ARGUMENTS
    def set_ARGUMENTS(self, ARGUMENTS):
        self.ARGUMENTS = ARGUMENTS
    def get_EXECUTABLE(self):
        return self.EXECUTABLE
    def set_EXECUTABLE(self, EXECUTABLE):
        self.EXECUTABLE = EXECUTABLE
    def has__content(self):
        if (
            self.ARGUMENTS is not None or
            self.EXECUTABLE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HM_MADType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HM_MADType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HM_MADType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HM_MADType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HM_MADType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HM_MADType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HM_MADType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ARGUMENTS is not None:
            namespaceprefix_ = self.ARGUMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.ARGUMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sARGUMENTS>%s</%sARGUMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ARGUMENTS), input_name='ARGUMENTS')), namespaceprefix_ , eol_))
        if self.EXECUTABLE is not None:
            namespaceprefix_ = self.EXECUTABLE_nsprefix_ + ':' if (UseCapturedNS_ and self.EXECUTABLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXECUTABLE>%s</%sEXECUTABLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EXECUTABLE), input_name='EXECUTABLE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ARGUMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ARGUMENTS')
            value_ = self.gds_validate_string(value_, node, 'ARGUMENTS')
            self.ARGUMENTS = value_
            self.ARGUMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXECUTABLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EXECUTABLE')
            value_ = self.gds_validate_string(value_, node, 'EXECUTABLE')
            self.EXECUTABLE = value_
            self.EXECUTABLE_nsprefix_ = child_.prefix
# end class HM_MADType


class HOOK_LOG_CONFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LOG_RETENTION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LOG_RETENTION = LOG_RETENTION
        self.LOG_RETENTION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOOK_LOG_CONFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOOK_LOG_CONFType.subclass:
            return HOOK_LOG_CONFType.subclass(*args_, **kwargs_)
        else:
            return HOOK_LOG_CONFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LOG_RETENTION(self):
        return self.LOG_RETENTION
    def set_LOG_RETENTION(self, LOG_RETENTION):
        self.LOG_RETENTION = LOG_RETENTION
    def has__content(self):
        if (
            self.LOG_RETENTION is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOOK_LOG_CONFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOOK_LOG_CONFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HOOK_LOG_CONFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HOOK_LOG_CONFType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HOOK_LOG_CONFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HOOK_LOG_CONFType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOOK_LOG_CONFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LOG_RETENTION is not None:
            namespaceprefix_ = self.LOG_RETENTION_nsprefix_ + ':' if (UseCapturedNS_ and self.LOG_RETENTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOG_RETENTION>%s</%sLOG_RETENTION>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOG_RETENTION, input_name='LOG_RETENTION'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LOG_RETENTION' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOG_RETENTION')
            ival_ = self.gds_validate_integer(ival_, node, 'LOG_RETENTION')
            self.LOG_RETENTION = ival_
            self.LOG_RETENTION_nsprefix_ = child_.prefix
# end class HOOK_LOG_CONFType


class IM_MADType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ARGUMENTS=None, EXECUTABLE=None, NAME=None, THREADS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ARGUMENTS = ARGUMENTS
        self.ARGUMENTS_nsprefix_ = None
        self.EXECUTABLE = EXECUTABLE
        self.EXECUTABLE_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.THREADS = THREADS
        self.THREADS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IM_MADType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IM_MADType.subclass:
            return IM_MADType.subclass(*args_, **kwargs_)
        else:
            return IM_MADType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ARGUMENTS(self):
        return self.ARGUMENTS
    def set_ARGUMENTS(self, ARGUMENTS):
        self.ARGUMENTS = ARGUMENTS
    def get_EXECUTABLE(self):
        return self.EXECUTABLE
    def set_EXECUTABLE(self, EXECUTABLE):
        self.EXECUTABLE = EXECUTABLE
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_THREADS(self):
        return self.THREADS
    def set_THREADS(self, THREADS):
        self.THREADS = THREADS
    def has__content(self):
        if (
            self.ARGUMENTS is not None or
            self.EXECUTABLE is not None or
            self.NAME is not None or
            self.THREADS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IM_MADType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IM_MADType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IM_MADType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IM_MADType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IM_MADType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IM_MADType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IM_MADType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ARGUMENTS is not None:
            namespaceprefix_ = self.ARGUMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.ARGUMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sARGUMENTS>%s</%sARGUMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ARGUMENTS), input_name='ARGUMENTS')), namespaceprefix_ , eol_))
        if self.EXECUTABLE is not None:
            namespaceprefix_ = self.EXECUTABLE_nsprefix_ + ':' if (UseCapturedNS_ and self.EXECUTABLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXECUTABLE>%s</%sEXECUTABLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EXECUTABLE), input_name='EXECUTABLE')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.THREADS is not None:
            namespaceprefix_ = self.THREADS_nsprefix_ + ':' if (UseCapturedNS_ and self.THREADS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTHREADS>%s</%sTHREADS>%s' % (namespaceprefix_ , self.gds_format_integer(self.THREADS, input_name='THREADS'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ARGUMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ARGUMENTS')
            value_ = self.gds_validate_string(value_, node, 'ARGUMENTS')
            self.ARGUMENTS = value_
            self.ARGUMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXECUTABLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EXECUTABLE')
            value_ = self.gds_validate_string(value_, node, 'EXECUTABLE')
            self.EXECUTABLE = value_
            self.EXECUTABLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'THREADS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'THREADS')
            ival_ = self.gds_validate_integer(ival_, node, 'THREADS')
            self.THREADS = ival_
            self.THREADS_nsprefix_ = child_.prefix
# end class IM_MADType


class IPAM_MADType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ARGUMENTS=None, EXECUTABLE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ARGUMENTS = ARGUMENTS
        self.ARGUMENTS_nsprefix_ = None
        self.EXECUTABLE = EXECUTABLE
        self.EXECUTABLE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPAM_MADType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPAM_MADType.subclass:
            return IPAM_MADType.subclass(*args_, **kwargs_)
        else:
            return IPAM_MADType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ARGUMENTS(self):
        return self.ARGUMENTS
    def set_ARGUMENTS(self, ARGUMENTS):
        self.ARGUMENTS = ARGUMENTS
    def get_EXECUTABLE(self):
        return self.EXECUTABLE
    def set_EXECUTABLE(self, EXECUTABLE):
        self.EXECUTABLE = EXECUTABLE
    def has__content(self):
        if (
            self.ARGUMENTS is not None or
            self.EXECUTABLE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IPAM_MADType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPAM_MADType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IPAM_MADType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPAM_MADType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IPAM_MADType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IPAM_MADType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='IPAM_MADType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ARGUMENTS is not None:
            namespaceprefix_ = self.ARGUMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.ARGUMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sARGUMENTS>%s</%sARGUMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ARGUMENTS), input_name='ARGUMENTS')), namespaceprefix_ , eol_))
        if self.EXECUTABLE is not None:
            namespaceprefix_ = self.EXECUTABLE_nsprefix_ + ':' if (UseCapturedNS_ and self.EXECUTABLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXECUTABLE>%s</%sEXECUTABLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EXECUTABLE), input_name='EXECUTABLE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ARGUMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ARGUMENTS')
            value_ = self.gds_validate_string(value_, node, 'ARGUMENTS')
            self.ARGUMENTS = value_
            self.ARGUMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXECUTABLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EXECUTABLE')
            value_ = self.gds_validate_string(value_, node, 'EXECUTABLE')
            self.EXECUTABLE = value_
            self.EXECUTABLE_nsprefix_ = child_.prefix
# end class IPAM_MADType


class LOGType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DEBUG_LEVEL=None, SYSTEM=None, USE_VMS_LOCATION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DEBUG_LEVEL = DEBUG_LEVEL
        self.DEBUG_LEVEL_nsprefix_ = None
        self.SYSTEM = SYSTEM
        self.SYSTEM_nsprefix_ = None
        self.USE_VMS_LOCATION = USE_VMS_LOCATION
        self.USE_VMS_LOCATION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOGType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOGType.subclass:
            return LOGType.subclass(*args_, **kwargs_)
        else:
            return LOGType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DEBUG_LEVEL(self):
        return self.DEBUG_LEVEL
    def set_DEBUG_LEVEL(self, DEBUG_LEVEL):
        self.DEBUG_LEVEL = DEBUG_LEVEL
    def get_SYSTEM(self):
        return self.SYSTEM
    def set_SYSTEM(self, SYSTEM):
        self.SYSTEM = SYSTEM
    def get_USE_VMS_LOCATION(self):
        return self.USE_VMS_LOCATION
    def set_USE_VMS_LOCATION(self, USE_VMS_LOCATION):
        self.USE_VMS_LOCATION = USE_VMS_LOCATION
    def has__content(self):
        if (
            self.DEBUG_LEVEL is not None or
            self.SYSTEM is not None or
            self.USE_VMS_LOCATION is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOGType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOGType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LOGType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LOGType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LOGType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LOGType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOGType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DEBUG_LEVEL is not None:
            namespaceprefix_ = self.DEBUG_LEVEL_nsprefix_ + ':' if (UseCapturedNS_ and self.DEBUG_LEVEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEBUG_LEVEL>%s</%sDEBUG_LEVEL>%s' % (namespaceprefix_ , self.gds_format_integer(self.DEBUG_LEVEL, input_name='DEBUG_LEVEL'), namespaceprefix_ , eol_))
        if self.SYSTEM is not None:
            namespaceprefix_ = self.SYSTEM_nsprefix_ + ':' if (UseCapturedNS_ and self.SYSTEM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYSTEM>%s</%sSYSTEM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM), input_name='SYSTEM')), namespaceprefix_ , eol_))
        if self.USE_VMS_LOCATION is not None:
            namespaceprefix_ = self.USE_VMS_LOCATION_nsprefix_ + ':' if (UseCapturedNS_ and self.USE_VMS_LOCATION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSE_VMS_LOCATION>%s</%sUSE_VMS_LOCATION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.USE_VMS_LOCATION), input_name='USE_VMS_LOCATION')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DEBUG_LEVEL' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DEBUG_LEVEL')
            ival_ = self.gds_validate_integer(ival_, node, 'DEBUG_LEVEL')
            self.DEBUG_LEVEL = ival_
            self.DEBUG_LEVEL_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYSTEM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SYSTEM')
            value_ = self.gds_validate_string(value_, node, 'SYSTEM')
            self.SYSTEM = value_
            self.SYSTEM_nsprefix_ = child_.prefix
        elif nodeName_ == 'USE_VMS_LOCATION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'USE_VMS_LOCATION')
            value_ = self.gds_validate_string(value_, node, 'USE_VMS_LOCATION')
            self.USE_VMS_LOCATION = value_
            self.USE_VMS_LOCATION_nsprefix_ = child_.prefix
# end class LOGType


class MARKET_MADType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ARGUMENTS=None, EXECUTABLE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ARGUMENTS = ARGUMENTS
        self.ARGUMENTS_nsprefix_ = None
        self.EXECUTABLE = EXECUTABLE
        self.EXECUTABLE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MARKET_MADType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MARKET_MADType.subclass:
            return MARKET_MADType.subclass(*args_, **kwargs_)
        else:
            return MARKET_MADType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ARGUMENTS(self):
        return self.ARGUMENTS
    def set_ARGUMENTS(self, ARGUMENTS):
        self.ARGUMENTS = ARGUMENTS
    def get_EXECUTABLE(self):
        return self.EXECUTABLE
    def set_EXECUTABLE(self, EXECUTABLE):
        self.EXECUTABLE = EXECUTABLE
    def has__content(self):
        if (
            self.ARGUMENTS is not None or
            self.EXECUTABLE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKET_MADType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MARKET_MADType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MARKET_MADType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MARKET_MADType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MARKET_MADType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MARKET_MADType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKET_MADType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ARGUMENTS is not None:
            namespaceprefix_ = self.ARGUMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.ARGUMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sARGUMENTS>%s</%sARGUMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ARGUMENTS), input_name='ARGUMENTS')), namespaceprefix_ , eol_))
        if self.EXECUTABLE is not None:
            namespaceprefix_ = self.EXECUTABLE_nsprefix_ + ':' if (UseCapturedNS_ and self.EXECUTABLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXECUTABLE>%s</%sEXECUTABLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EXECUTABLE), input_name='EXECUTABLE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ARGUMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ARGUMENTS')
            value_ = self.gds_validate_string(value_, node, 'ARGUMENTS')
            self.ARGUMENTS = value_
            self.ARGUMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXECUTABLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EXECUTABLE')
            value_ = self.gds_validate_string(value_, node, 'EXECUTABLE')
            self.EXECUTABLE = value_
            self.EXECUTABLE_nsprefix_ = child_.prefix
# end class MARKET_MADType


class MARKET_MAD_CONFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, APP_ACTIONS=None, NAME=None, PUBLIC=None, REQUIRED_ATTRS=None, SUNSTONE_NAME=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.APP_ACTIONS = APP_ACTIONS
        self.APP_ACTIONS_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PUBLIC = PUBLIC
        self.validate_PUBLICType(self.PUBLIC)
        self.PUBLIC_nsprefix_ = None
        self.REQUIRED_ATTRS = REQUIRED_ATTRS
        self.REQUIRED_ATTRS_nsprefix_ = None
        self.SUNSTONE_NAME = SUNSTONE_NAME
        self.SUNSTONE_NAME_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MARKET_MAD_CONFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MARKET_MAD_CONFType.subclass:
            return MARKET_MAD_CONFType.subclass(*args_, **kwargs_)
        else:
            return MARKET_MAD_CONFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_APP_ACTIONS(self):
        return self.APP_ACTIONS
    def set_APP_ACTIONS(self, APP_ACTIONS):
        self.APP_ACTIONS = APP_ACTIONS
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PUBLIC(self):
        return self.PUBLIC
    def set_PUBLIC(self, PUBLIC):
        self.PUBLIC = PUBLIC
    def get_REQUIRED_ATTRS(self):
        return self.REQUIRED_ATTRS
    def set_REQUIRED_ATTRS(self, REQUIRED_ATTRS):
        self.REQUIRED_ATTRS = REQUIRED_ATTRS
    def get_SUNSTONE_NAME(self):
        return self.SUNSTONE_NAME
    def set_SUNSTONE_NAME(self, SUNSTONE_NAME):
        self.SUNSTONE_NAME = SUNSTONE_NAME
    def validate_PUBLICType(self, value):
        result = True
        # Validate type PUBLICType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_PUBLICType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_PUBLICType_patterns_, ))
                result = False
        return result
    validate_PUBLICType_patterns_ = [['^([yY][eE][sS])$', '^([nN][oO])$']]
    def has__content(self):
        if (
            self.APP_ACTIONS is not None or
            self.NAME is not None or
            self.PUBLIC is not None or
            self.REQUIRED_ATTRS is not None or
            self.SUNSTONE_NAME is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKET_MAD_CONFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MARKET_MAD_CONFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MARKET_MAD_CONFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MARKET_MAD_CONFType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MARKET_MAD_CONFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MARKET_MAD_CONFType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MARKET_MAD_CONFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.APP_ACTIONS is not None:
            namespaceprefix_ = self.APP_ACTIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.APP_ACTIONS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAPP_ACTIONS>%s</%sAPP_ACTIONS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.APP_ACTIONS), input_name='APP_ACTIONS')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PUBLIC is not None:
            namespaceprefix_ = self.PUBLIC_nsprefix_ + ':' if (UseCapturedNS_ and self.PUBLIC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPUBLIC>%s</%sPUBLIC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PUBLIC), input_name='PUBLIC')), namespaceprefix_ , eol_))
        if self.REQUIRED_ATTRS is not None:
            namespaceprefix_ = self.REQUIRED_ATTRS_nsprefix_ + ':' if (UseCapturedNS_ and self.REQUIRED_ATTRS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREQUIRED_ATTRS>%s</%sREQUIRED_ATTRS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.REQUIRED_ATTRS), input_name='REQUIRED_ATTRS')), namespaceprefix_ , eol_))
        if self.SUNSTONE_NAME is not None:
            namespaceprefix_ = self.SUNSTONE_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SUNSTONE_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSUNSTONE_NAME>%s</%sSUNSTONE_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SUNSTONE_NAME), input_name='SUNSTONE_NAME')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'APP_ACTIONS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'APP_ACTIONS')
            value_ = self.gds_validate_string(value_, node, 'APP_ACTIONS')
            self.APP_ACTIONS = value_
            self.APP_ACTIONS_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PUBLIC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PUBLIC')
            value_ = self.gds_validate_string(value_, node, 'PUBLIC')
            self.PUBLIC = value_
            self.PUBLIC_nsprefix_ = child_.prefix
            # validate type PUBLICType
            self.validate_PUBLICType(self.PUBLIC)
        elif nodeName_ == 'REQUIRED_ATTRS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'REQUIRED_ATTRS')
            value_ = self.gds_validate_string(value_, node, 'REQUIRED_ATTRS')
            self.REQUIRED_ATTRS = value_
            self.REQUIRED_ATTRS_nsprefix_ = child_.prefix
        elif nodeName_ == 'SUNSTONE_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SUNSTONE_NAME')
            value_ = self.gds_validate_string(value_, node, 'SUNSTONE_NAME')
            self.SUNSTONE_NAME = value_
            self.SUNSTONE_NAME_nsprefix_ = child_.prefix
# end class MARKET_MAD_CONFType


class RAFTType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BROADCAST_TIMEOUT_MS=None, ELECTION_TIMEOUT_MS=None, LIMIT_PURGE=None, LOG_PURGE_TIMEOUT=None, LOG_RETENTION=None, XMLRPC_TIMEOUT_MS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.BROADCAST_TIMEOUT_MS = BROADCAST_TIMEOUT_MS
        self.BROADCAST_TIMEOUT_MS_nsprefix_ = None
        self.ELECTION_TIMEOUT_MS = ELECTION_TIMEOUT_MS
        self.ELECTION_TIMEOUT_MS_nsprefix_ = None
        self.LIMIT_PURGE = LIMIT_PURGE
        self.LIMIT_PURGE_nsprefix_ = None
        self.LOG_PURGE_TIMEOUT = LOG_PURGE_TIMEOUT
        self.LOG_PURGE_TIMEOUT_nsprefix_ = None
        self.LOG_RETENTION = LOG_RETENTION
        self.LOG_RETENTION_nsprefix_ = None
        self.XMLRPC_TIMEOUT_MS = XMLRPC_TIMEOUT_MS
        self.XMLRPC_TIMEOUT_MS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RAFTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RAFTType.subclass:
            return RAFTType.subclass(*args_, **kwargs_)
        else:
            return RAFTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BROADCAST_TIMEOUT_MS(self):
        return self.BROADCAST_TIMEOUT_MS
    def set_BROADCAST_TIMEOUT_MS(self, BROADCAST_TIMEOUT_MS):
        self.BROADCAST_TIMEOUT_MS = BROADCAST_TIMEOUT_MS
    def get_ELECTION_TIMEOUT_MS(self):
        return self.ELECTION_TIMEOUT_MS
    def set_ELECTION_TIMEOUT_MS(self, ELECTION_TIMEOUT_MS):
        self.ELECTION_TIMEOUT_MS = ELECTION_TIMEOUT_MS
    def get_LIMIT_PURGE(self):
        return self.LIMIT_PURGE
    def set_LIMIT_PURGE(self, LIMIT_PURGE):
        self.LIMIT_PURGE = LIMIT_PURGE
    def get_LOG_PURGE_TIMEOUT(self):
        return self.LOG_PURGE_TIMEOUT
    def set_LOG_PURGE_TIMEOUT(self, LOG_PURGE_TIMEOUT):
        self.LOG_PURGE_TIMEOUT = LOG_PURGE_TIMEOUT
    def get_LOG_RETENTION(self):
        return self.LOG_RETENTION
    def set_LOG_RETENTION(self, LOG_RETENTION):
        self.LOG_RETENTION = LOG_RETENTION
    def get_XMLRPC_TIMEOUT_MS(self):
        return self.XMLRPC_TIMEOUT_MS
    def set_XMLRPC_TIMEOUT_MS(self, XMLRPC_TIMEOUT_MS):
        self.XMLRPC_TIMEOUT_MS = XMLRPC_TIMEOUT_MS
    def has__content(self):
        if (
            self.BROADCAST_TIMEOUT_MS is not None or
            self.ELECTION_TIMEOUT_MS is not None or
            self.LIMIT_PURGE is not None or
            self.LOG_PURGE_TIMEOUT is not None or
            self.LOG_RETENTION is not None or
            self.XMLRPC_TIMEOUT_MS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='RAFTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RAFTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RAFTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RAFTType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RAFTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RAFTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='RAFTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BROADCAST_TIMEOUT_MS is not None:
            namespaceprefix_ = self.BROADCAST_TIMEOUT_MS_nsprefix_ + ':' if (UseCapturedNS_ and self.BROADCAST_TIMEOUT_MS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBROADCAST_TIMEOUT_MS>%s</%sBROADCAST_TIMEOUT_MS>%s' % (namespaceprefix_ , self.gds_format_integer(self.BROADCAST_TIMEOUT_MS, input_name='BROADCAST_TIMEOUT_MS'), namespaceprefix_ , eol_))
        if self.ELECTION_TIMEOUT_MS is not None:
            namespaceprefix_ = self.ELECTION_TIMEOUT_MS_nsprefix_ + ':' if (UseCapturedNS_ and self.ELECTION_TIMEOUT_MS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sELECTION_TIMEOUT_MS>%s</%sELECTION_TIMEOUT_MS>%s' % (namespaceprefix_ , self.gds_format_integer(self.ELECTION_TIMEOUT_MS, input_name='ELECTION_TIMEOUT_MS'), namespaceprefix_ , eol_))
        if self.LIMIT_PURGE is not None:
            namespaceprefix_ = self.LIMIT_PURGE_nsprefix_ + ':' if (UseCapturedNS_ and self.LIMIT_PURGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLIMIT_PURGE>%s</%sLIMIT_PURGE>%s' % (namespaceprefix_ , self.gds_format_integer(self.LIMIT_PURGE, input_name='LIMIT_PURGE'), namespaceprefix_ , eol_))
        if self.LOG_PURGE_TIMEOUT is not None:
            namespaceprefix_ = self.LOG_PURGE_TIMEOUT_nsprefix_ + ':' if (UseCapturedNS_ and self.LOG_PURGE_TIMEOUT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOG_PURGE_TIMEOUT>%s</%sLOG_PURGE_TIMEOUT>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOG_PURGE_TIMEOUT, input_name='LOG_PURGE_TIMEOUT'), namespaceprefix_ , eol_))
        if self.LOG_RETENTION is not None:
            namespaceprefix_ = self.LOG_RETENTION_nsprefix_ + ':' if (UseCapturedNS_ and self.LOG_RETENTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOG_RETENTION>%s</%sLOG_RETENTION>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOG_RETENTION, input_name='LOG_RETENTION'), namespaceprefix_ , eol_))
        if self.XMLRPC_TIMEOUT_MS is not None:
            namespaceprefix_ = self.XMLRPC_TIMEOUT_MS_nsprefix_ + ':' if (UseCapturedNS_ and self.XMLRPC_TIMEOUT_MS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sXMLRPC_TIMEOUT_MS>%s</%sXMLRPC_TIMEOUT_MS>%s' % (namespaceprefix_ , self.gds_format_integer(self.XMLRPC_TIMEOUT_MS, input_name='XMLRPC_TIMEOUT_MS'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BROADCAST_TIMEOUT_MS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'BROADCAST_TIMEOUT_MS')
            ival_ = self.gds_validate_integer(ival_, node, 'BROADCAST_TIMEOUT_MS')
            self.BROADCAST_TIMEOUT_MS = ival_
            self.BROADCAST_TIMEOUT_MS_nsprefix_ = child_.prefix
        elif nodeName_ == 'ELECTION_TIMEOUT_MS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ELECTION_TIMEOUT_MS')
            ival_ = self.gds_validate_integer(ival_, node, 'ELECTION_TIMEOUT_MS')
            self.ELECTION_TIMEOUT_MS = ival_
            self.ELECTION_TIMEOUT_MS_nsprefix_ = child_.prefix
        elif nodeName_ == 'LIMIT_PURGE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LIMIT_PURGE')
            ival_ = self.gds_validate_integer(ival_, node, 'LIMIT_PURGE')
            self.LIMIT_PURGE = ival_
            self.LIMIT_PURGE_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOG_PURGE_TIMEOUT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOG_PURGE_TIMEOUT')
            ival_ = self.gds_validate_integer(ival_, node, 'LOG_PURGE_TIMEOUT')
            self.LOG_PURGE_TIMEOUT = ival_
            self.LOG_PURGE_TIMEOUT_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOG_RETENTION' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOG_RETENTION')
            ival_ = self.gds_validate_integer(ival_, node, 'LOG_RETENTION')
            self.LOG_RETENTION = ival_
            self.LOG_RETENTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'XMLRPC_TIMEOUT_MS' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'XMLRPC_TIMEOUT_MS')
            ival_ = self.gds_validate_integer(ival_, node, 'XMLRPC_TIMEOUT_MS')
            self.XMLRPC_TIMEOUT_MS = ival_
            self.XMLRPC_TIMEOUT_MS_nsprefix_ = child_.prefix
# end class RAFTType


class SCHED_MADType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ARGUMENTS=None, EXECUTABLE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ARGUMENTS = ARGUMENTS
        self.ARGUMENTS_nsprefix_ = None
        self.EXECUTABLE = EXECUTABLE
        self.EXECUTABLE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SCHED_MADType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SCHED_MADType.subclass:
            return SCHED_MADType.subclass(*args_, **kwargs_)
        else:
            return SCHED_MADType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ARGUMENTS(self):
        return self.ARGUMENTS
    def set_ARGUMENTS(self, ARGUMENTS):
        self.ARGUMENTS = ARGUMENTS
    def get_EXECUTABLE(self):
        return self.EXECUTABLE
    def set_EXECUTABLE(self, EXECUTABLE):
        self.EXECUTABLE = EXECUTABLE
    def has__content(self):
        if (
            self.ARGUMENTS is not None or
            self.EXECUTABLE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SCHED_MADType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SCHED_MADType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SCHED_MADType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SCHED_MADType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SCHED_MADType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SCHED_MADType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SCHED_MADType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ARGUMENTS is not None:
            namespaceprefix_ = self.ARGUMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.ARGUMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sARGUMENTS>%s</%sARGUMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ARGUMENTS), input_name='ARGUMENTS')), namespaceprefix_ , eol_))
        if self.EXECUTABLE is not None:
            namespaceprefix_ = self.EXECUTABLE_nsprefix_ + ':' if (UseCapturedNS_ and self.EXECUTABLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXECUTABLE>%s</%sEXECUTABLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EXECUTABLE), input_name='EXECUTABLE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ARGUMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ARGUMENTS')
            value_ = self.gds_validate_string(value_, node, 'ARGUMENTS')
            self.ARGUMENTS = value_
            self.ARGUMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXECUTABLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EXECUTABLE')
            value_ = self.gds_validate_string(value_, node, 'EXECUTABLE')
            self.EXECUTABLE = value_
            self.EXECUTABLE_nsprefix_ = child_.prefix
# end class SCHED_MADType


class TM_MADType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ARGUMENTS=None, EXECUTABLE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ARGUMENTS = ARGUMENTS
        self.ARGUMENTS_nsprefix_ = None
        self.EXECUTABLE = EXECUTABLE
        self.EXECUTABLE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TM_MADType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TM_MADType.subclass:
            return TM_MADType.subclass(*args_, **kwargs_)
        else:
            return TM_MADType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ARGUMENTS(self):
        return self.ARGUMENTS
    def set_ARGUMENTS(self, ARGUMENTS):
        self.ARGUMENTS = ARGUMENTS
    def get_EXECUTABLE(self):
        return self.EXECUTABLE
    def set_EXECUTABLE(self, EXECUTABLE):
        self.EXECUTABLE = EXECUTABLE
    def has__content(self):
        if (
            self.ARGUMENTS is not None or
            self.EXECUTABLE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TM_MADType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TM_MADType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TM_MADType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TM_MADType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TM_MADType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TM_MADType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TM_MADType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ARGUMENTS is not None:
            namespaceprefix_ = self.ARGUMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.ARGUMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sARGUMENTS>%s</%sARGUMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ARGUMENTS), input_name='ARGUMENTS')), namespaceprefix_ , eol_))
        if self.EXECUTABLE is not None:
            namespaceprefix_ = self.EXECUTABLE_nsprefix_ + ':' if (UseCapturedNS_ and self.EXECUTABLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXECUTABLE>%s</%sEXECUTABLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EXECUTABLE), input_name='EXECUTABLE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ARGUMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ARGUMENTS')
            value_ = self.gds_validate_string(value_, node, 'ARGUMENTS')
            self.ARGUMENTS = value_
            self.ARGUMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXECUTABLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EXECUTABLE')
            value_ = self.gds_validate_string(value_, node, 'EXECUTABLE')
            self.EXECUTABLE = value_
            self.EXECUTABLE_nsprefix_ = child_.prefix
# end class TM_MADType


class TM_MAD_CONFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ALLOW_ORPHANS=None, CLONE_TARGET=None, CLONE_TARGET_SHARED=None, CLONE_TARGET_SSH=None, DISK_TYPE=None, DISK_TYPE_SHARED=None, DISK_TYPE_SSH=None, DRIVER=None, DS_MIGRATE=None, LN_TARGET=None, LN_TARGET_SHARED=None, LN_TARGET_SSH=None, NAME=None, PERSISTENT_SNAPSHOTS=None, SHARED=None, TM_MAD_SYSTEM=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ALLOW_ORPHANS = ALLOW_ORPHANS
        self.ALLOW_ORPHANS_nsprefix_ = None
        self.CLONE_TARGET = CLONE_TARGET
        self.CLONE_TARGET_nsprefix_ = None
        self.CLONE_TARGET_SHARED = CLONE_TARGET_SHARED
        self.CLONE_TARGET_SHARED_nsprefix_ = None
        self.CLONE_TARGET_SSH = CLONE_TARGET_SSH
        self.CLONE_TARGET_SSH_nsprefix_ = None
        self.DISK_TYPE = DISK_TYPE
        self.DISK_TYPE_nsprefix_ = None
        self.DISK_TYPE_SHARED = DISK_TYPE_SHARED
        self.DISK_TYPE_SHARED_nsprefix_ = None
        self.DISK_TYPE_SSH = DISK_TYPE_SSH
        self.DISK_TYPE_SSH_nsprefix_ = None
        self.DRIVER = DRIVER
        self.DRIVER_nsprefix_ = None
        self.DS_MIGRATE = DS_MIGRATE
        self.DS_MIGRATE_nsprefix_ = None
        self.LN_TARGET = LN_TARGET
        self.LN_TARGET_nsprefix_ = None
        self.LN_TARGET_SHARED = LN_TARGET_SHARED
        self.LN_TARGET_SHARED_nsprefix_ = None
        self.LN_TARGET_SSH = LN_TARGET_SSH
        self.LN_TARGET_SSH_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PERSISTENT_SNAPSHOTS = PERSISTENT_SNAPSHOTS
        self.PERSISTENT_SNAPSHOTS_nsprefix_ = None
        self.SHARED = SHARED
        self.SHARED_nsprefix_ = None
        self.TM_MAD_SYSTEM = TM_MAD_SYSTEM
        self.TM_MAD_SYSTEM_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TM_MAD_CONFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TM_MAD_CONFType.subclass:
            return TM_MAD_CONFType.subclass(*args_, **kwargs_)
        else:
            return TM_MAD_CONFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ALLOW_ORPHANS(self):
        return self.ALLOW_ORPHANS
    def set_ALLOW_ORPHANS(self, ALLOW_ORPHANS):
        self.ALLOW_ORPHANS = ALLOW_ORPHANS
    def get_CLONE_TARGET(self):
        return self.CLONE_TARGET
    def set_CLONE_TARGET(self, CLONE_TARGET):
        self.CLONE_TARGET = CLONE_TARGET
    def get_CLONE_TARGET_SHARED(self):
        return self.CLONE_TARGET_SHARED
    def set_CLONE_TARGET_SHARED(self, CLONE_TARGET_SHARED):
        self.CLONE_TARGET_SHARED = CLONE_TARGET_SHARED
    def get_CLONE_TARGET_SSH(self):
        return self.CLONE_TARGET_SSH
    def set_CLONE_TARGET_SSH(self, CLONE_TARGET_SSH):
        self.CLONE_TARGET_SSH = CLONE_TARGET_SSH
    def get_DISK_TYPE(self):
        return self.DISK_TYPE
    def set_DISK_TYPE(self, DISK_TYPE):
        self.DISK_TYPE = DISK_TYPE
    def get_DISK_TYPE_SHARED(self):
        return self.DISK_TYPE_SHARED
    def set_DISK_TYPE_SHARED(self, DISK_TYPE_SHARED):
        self.DISK_TYPE_SHARED = DISK_TYPE_SHARED
    def get_DISK_TYPE_SSH(self):
        return self.DISK_TYPE_SSH
    def set_DISK_TYPE_SSH(self, DISK_TYPE_SSH):
        self.DISK_TYPE_SSH = DISK_TYPE_SSH
    def get_DRIVER(self):
        return self.DRIVER
    def set_DRIVER(self, DRIVER):
        self.DRIVER = DRIVER
    def get_DS_MIGRATE(self):
        return self.DS_MIGRATE
    def set_DS_MIGRATE(self, DS_MIGRATE):
        self.DS_MIGRATE = DS_MIGRATE
    def get_LN_TARGET(self):
        return self.LN_TARGET
    def set_LN_TARGET(self, LN_TARGET):
        self.LN_TARGET = LN_TARGET
    def get_LN_TARGET_SHARED(self):
        return self.LN_TARGET_SHARED
    def set_LN_TARGET_SHARED(self, LN_TARGET_SHARED):
        self.LN_TARGET_SHARED = LN_TARGET_SHARED
    def get_LN_TARGET_SSH(self):
        return self.LN_TARGET_SSH
    def set_LN_TARGET_SSH(self, LN_TARGET_SSH):
        self.LN_TARGET_SSH = LN_TARGET_SSH
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PERSISTENT_SNAPSHOTS(self):
        return self.PERSISTENT_SNAPSHOTS
    def set_PERSISTENT_SNAPSHOTS(self, PERSISTENT_SNAPSHOTS):
        self.PERSISTENT_SNAPSHOTS = PERSISTENT_SNAPSHOTS
    def get_SHARED(self):
        return self.SHARED
    def set_SHARED(self, SHARED):
        self.SHARED = SHARED
    def get_TM_MAD_SYSTEM(self):
        return self.TM_MAD_SYSTEM
    def set_TM_MAD_SYSTEM(self, TM_MAD_SYSTEM):
        self.TM_MAD_SYSTEM = TM_MAD_SYSTEM
    def has__content(self):
        if (
            self.ALLOW_ORPHANS is not None or
            self.CLONE_TARGET is not None or
            self.CLONE_TARGET_SHARED is not None or
            self.CLONE_TARGET_SSH is not None or
            self.DISK_TYPE is not None or
            self.DISK_TYPE_SHARED is not None or
            self.DISK_TYPE_SSH is not None or
            self.DRIVER is not None or
            self.DS_MIGRATE is not None or
            self.LN_TARGET is not None or
            self.LN_TARGET_SHARED is not None or
            self.LN_TARGET_SSH is not None or
            self.NAME is not None or
            self.PERSISTENT_SNAPSHOTS is not None or
            self.SHARED is not None or
            self.TM_MAD_SYSTEM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TM_MAD_CONFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TM_MAD_CONFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TM_MAD_CONFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TM_MAD_CONFType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TM_MAD_CONFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TM_MAD_CONFType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TM_MAD_CONFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ALLOW_ORPHANS is not None:
            namespaceprefix_ = self.ALLOW_ORPHANS_nsprefix_ + ':' if (UseCapturedNS_ and self.ALLOW_ORPHANS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sALLOW_ORPHANS>%s</%sALLOW_ORPHANS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ALLOW_ORPHANS), input_name='ALLOW_ORPHANS')), namespaceprefix_ , eol_))
        if self.CLONE_TARGET is not None:
            namespaceprefix_ = self.CLONE_TARGET_nsprefix_ + ':' if (UseCapturedNS_ and self.CLONE_TARGET_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLONE_TARGET>%s</%sCLONE_TARGET>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CLONE_TARGET), input_name='CLONE_TARGET')), namespaceprefix_ , eol_))
        if self.CLONE_TARGET_SHARED is not None:
            namespaceprefix_ = self.CLONE_TARGET_SHARED_nsprefix_ + ':' if (UseCapturedNS_ and self.CLONE_TARGET_SHARED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLONE_TARGET_SHARED>%s</%sCLONE_TARGET_SHARED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CLONE_TARGET_SHARED), input_name='CLONE_TARGET_SHARED')), namespaceprefix_ , eol_))
        if self.CLONE_TARGET_SSH is not None:
            namespaceprefix_ = self.CLONE_TARGET_SSH_nsprefix_ + ':' if (UseCapturedNS_ and self.CLONE_TARGET_SSH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLONE_TARGET_SSH>%s</%sCLONE_TARGET_SSH>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CLONE_TARGET_SSH), input_name='CLONE_TARGET_SSH')), namespaceprefix_ , eol_))
        if self.DISK_TYPE is not None:
            namespaceprefix_ = self.DISK_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISK_TYPE>%s</%sDISK_TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DISK_TYPE), input_name='DISK_TYPE')), namespaceprefix_ , eol_))
        if self.DISK_TYPE_SHARED is not None:
            namespaceprefix_ = self.DISK_TYPE_SHARED_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_TYPE_SHARED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISK_TYPE_SHARED>%s</%sDISK_TYPE_SHARED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DISK_TYPE_SHARED), input_name='DISK_TYPE_SHARED')), namespaceprefix_ , eol_))
        if self.DISK_TYPE_SSH is not None:
            namespaceprefix_ = self.DISK_TYPE_SSH_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_TYPE_SSH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISK_TYPE_SSH>%s</%sDISK_TYPE_SSH>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DISK_TYPE_SSH), input_name='DISK_TYPE_SSH')), namespaceprefix_ , eol_))
        if self.DRIVER is not None:
            namespaceprefix_ = self.DRIVER_nsprefix_ + ':' if (UseCapturedNS_ and self.DRIVER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDRIVER>%s</%sDRIVER>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DRIVER), input_name='DRIVER')), namespaceprefix_ , eol_))
        if self.DS_MIGRATE is not None:
            namespaceprefix_ = self.DS_MIGRATE_nsprefix_ + ':' if (UseCapturedNS_ and self.DS_MIGRATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDS_MIGRATE>%s</%sDS_MIGRATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DS_MIGRATE), input_name='DS_MIGRATE')), namespaceprefix_ , eol_))
        if self.LN_TARGET is not None:
            namespaceprefix_ = self.LN_TARGET_nsprefix_ + ':' if (UseCapturedNS_ and self.LN_TARGET_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLN_TARGET>%s</%sLN_TARGET>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LN_TARGET), input_name='LN_TARGET')), namespaceprefix_ , eol_))
        if self.LN_TARGET_SHARED is not None:
            namespaceprefix_ = self.LN_TARGET_SHARED_nsprefix_ + ':' if (UseCapturedNS_ and self.LN_TARGET_SHARED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLN_TARGET_SHARED>%s</%sLN_TARGET_SHARED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LN_TARGET_SHARED), input_name='LN_TARGET_SHARED')), namespaceprefix_ , eol_))
        if self.LN_TARGET_SSH is not None:
            namespaceprefix_ = self.LN_TARGET_SSH_nsprefix_ + ':' if (UseCapturedNS_ and self.LN_TARGET_SSH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLN_TARGET_SSH>%s</%sLN_TARGET_SSH>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LN_TARGET_SSH), input_name='LN_TARGET_SSH')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PERSISTENT_SNAPSHOTS is not None:
            namespaceprefix_ = self.PERSISTENT_SNAPSHOTS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERSISTENT_SNAPSHOTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPERSISTENT_SNAPSHOTS>%s</%sPERSISTENT_SNAPSHOTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PERSISTENT_SNAPSHOTS), input_name='PERSISTENT_SNAPSHOTS')), namespaceprefix_ , eol_))
        if self.SHARED is not None:
            namespaceprefix_ = self.SHARED_nsprefix_ + ':' if (UseCapturedNS_ and self.SHARED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHARED>%s</%sSHARED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHARED), input_name='SHARED')), namespaceprefix_ , eol_))
        if self.TM_MAD_SYSTEM is not None:
            namespaceprefix_ = self.TM_MAD_SYSTEM_nsprefix_ + ':' if (UseCapturedNS_ and self.TM_MAD_SYSTEM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTM_MAD_SYSTEM>%s</%sTM_MAD_SYSTEM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TM_MAD_SYSTEM), input_name='TM_MAD_SYSTEM')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ALLOW_ORPHANS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ALLOW_ORPHANS')
            value_ = self.gds_validate_string(value_, node, 'ALLOW_ORPHANS')
            self.ALLOW_ORPHANS = value_
            self.ALLOW_ORPHANS_nsprefix_ = child_.prefix
        elif nodeName_ == 'CLONE_TARGET':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CLONE_TARGET')
            value_ = self.gds_validate_string(value_, node, 'CLONE_TARGET')
            self.CLONE_TARGET = value_
            self.CLONE_TARGET_nsprefix_ = child_.prefix
        elif nodeName_ == 'CLONE_TARGET_SHARED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CLONE_TARGET_SHARED')
            value_ = self.gds_validate_string(value_, node, 'CLONE_TARGET_SHARED')
            self.CLONE_TARGET_SHARED = value_
            self.CLONE_TARGET_SHARED_nsprefix_ = child_.prefix
        elif nodeName_ == 'CLONE_TARGET_SSH':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CLONE_TARGET_SSH')
            value_ = self.gds_validate_string(value_, node, 'CLONE_TARGET_SSH')
            self.CLONE_TARGET_SSH = value_
            self.CLONE_TARGET_SSH_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISK_TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DISK_TYPE')
            value_ = self.gds_validate_string(value_, node, 'DISK_TYPE')
            self.DISK_TYPE = value_
            self.DISK_TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISK_TYPE_SHARED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DISK_TYPE_SHARED')
            value_ = self.gds_validate_string(value_, node, 'DISK_TYPE_SHARED')
            self.DISK_TYPE_SHARED = value_
            self.DISK_TYPE_SHARED_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISK_TYPE_SSH':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DISK_TYPE_SSH')
            value_ = self.gds_validate_string(value_, node, 'DISK_TYPE_SSH')
            self.DISK_TYPE_SSH = value_
            self.DISK_TYPE_SSH_nsprefix_ = child_.prefix
        elif nodeName_ == 'DRIVER':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DRIVER')
            value_ = self.gds_validate_string(value_, node, 'DRIVER')
            self.DRIVER = value_
            self.DRIVER_nsprefix_ = child_.prefix
        elif nodeName_ == 'DS_MIGRATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DS_MIGRATE')
            value_ = self.gds_validate_string(value_, node, 'DS_MIGRATE')
            self.DS_MIGRATE = value_
            self.DS_MIGRATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'LN_TARGET':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LN_TARGET')
            value_ = self.gds_validate_string(value_, node, 'LN_TARGET')
            self.LN_TARGET = value_
            self.LN_TARGET_nsprefix_ = child_.prefix
        elif nodeName_ == 'LN_TARGET_SHARED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LN_TARGET_SHARED')
            value_ = self.gds_validate_string(value_, node, 'LN_TARGET_SHARED')
            self.LN_TARGET_SHARED = value_
            self.LN_TARGET_SHARED_nsprefix_ = child_.prefix
        elif nodeName_ == 'LN_TARGET_SSH':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LN_TARGET_SSH')
            value_ = self.gds_validate_string(value_, node, 'LN_TARGET_SSH')
            self.LN_TARGET_SSH = value_
            self.LN_TARGET_SSH_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PERSISTENT_SNAPSHOTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PERSISTENT_SNAPSHOTS')
            value_ = self.gds_validate_string(value_, node, 'PERSISTENT_SNAPSHOTS')
            self.PERSISTENT_SNAPSHOTS = value_
            self.PERSISTENT_SNAPSHOTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'SHARED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHARED')
            value_ = self.gds_validate_string(value_, node, 'SHARED')
            self.SHARED = value_
            self.SHARED_nsprefix_ = child_.prefix
        elif nodeName_ == 'TM_MAD_SYSTEM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TM_MAD_SYSTEM')
            value_ = self.gds_validate_string(value_, node, 'TM_MAD_SYSTEM')
            self.TM_MAD_SYSTEM = value_
            self.TM_MAD_SYSTEM_nsprefix_ = child_.prefix
# end class TM_MAD_CONFType


class VLAN_IDSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, RESERVED=None, START=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.RESERVED = RESERVED
        self.RESERVED_nsprefix_ = None
        self.START = START
        self.START_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VLAN_IDSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VLAN_IDSType.subclass:
            return VLAN_IDSType.subclass(*args_, **kwargs_)
        else:
            return VLAN_IDSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RESERVED(self):
        return self.RESERVED
    def set_RESERVED(self, RESERVED):
        self.RESERVED = RESERVED
    def get_START(self):
        return self.START
    def set_START(self, START):
        self.START = START
    def has__content(self):
        if (
            self.RESERVED is not None or
            self.START is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VLAN_IDSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VLAN_IDSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VLAN_IDSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VLAN_IDSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VLAN_IDSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VLAN_IDSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VLAN_IDSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RESERVED is not None:
            namespaceprefix_ = self.RESERVED_nsprefix_ + ':' if (UseCapturedNS_ and self.RESERVED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRESERVED>%s</%sRESERVED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RESERVED), input_name='RESERVED')), namespaceprefix_ , eol_))
        if self.START is not None:
            namespaceprefix_ = self.START_nsprefix_ + ':' if (UseCapturedNS_ and self.START_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTART>%s</%sSTART>%s' % (namespaceprefix_ , self.gds_format_integer(self.START, input_name='START'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RESERVED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RESERVED')
            value_ = self.gds_validate_string(value_, node, 'RESERVED')
            self.RESERVED = value_
            self.RESERVED_nsprefix_ = child_.prefix
        elif nodeName_ == 'START' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'START')
            ival_ = self.gds_validate_integer(ival_, node, 'START')
            self.START = ival_
            self.START_nsprefix_ = child_.prefix
# end class VLAN_IDSType


class VM_MADType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ARGUMENTS=None, DEFAULT=None, EXECUTABLE=None, NAME=None, SUNSTONE_NAME=None, TYPE=None, KEEP_SNAPSHOTS=None, COLD_NIC_ATTACH=None, DS_LIVE_MIGRATION=None, LIVE_RESIZE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ARGUMENTS = ARGUMENTS
        self.ARGUMENTS_nsprefix_ = None
        self.DEFAULT = DEFAULT
        self.DEFAULT_nsprefix_ = None
        self.EXECUTABLE = EXECUTABLE
        self.EXECUTABLE_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.SUNSTONE_NAME = SUNSTONE_NAME
        self.SUNSTONE_NAME_nsprefix_ = None
        self.TYPE = TYPE
        self.TYPE_nsprefix_ = None
        self.KEEP_SNAPSHOTS = KEEP_SNAPSHOTS
        self.validate_KEEP_SNAPSHOTSType(self.KEEP_SNAPSHOTS)
        self.KEEP_SNAPSHOTS_nsprefix_ = None
        self.COLD_NIC_ATTACH = COLD_NIC_ATTACH
        self.validate_COLD_NIC_ATTACHType(self.COLD_NIC_ATTACH)
        self.COLD_NIC_ATTACH_nsprefix_ = None
        self.DS_LIVE_MIGRATION = DS_LIVE_MIGRATION
        self.validate_DS_LIVE_MIGRATIONType(self.DS_LIVE_MIGRATION)
        self.DS_LIVE_MIGRATION_nsprefix_ = None
        self.LIVE_RESIZE = LIVE_RESIZE
        self.validate_LIVE_RESIZEType(self.LIVE_RESIZE)
        self.LIVE_RESIZE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_MADType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_MADType.subclass:
            return VM_MADType.subclass(*args_, **kwargs_)
        else:
            return VM_MADType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ARGUMENTS(self):
        return self.ARGUMENTS
    def set_ARGUMENTS(self, ARGUMENTS):
        self.ARGUMENTS = ARGUMENTS
    def get_DEFAULT(self):
        return self.DEFAULT
    def set_DEFAULT(self, DEFAULT):
        self.DEFAULT = DEFAULT
    def get_EXECUTABLE(self):
        return self.EXECUTABLE
    def set_EXECUTABLE(self, EXECUTABLE):
        self.EXECUTABLE = EXECUTABLE
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_SUNSTONE_NAME(self):
        return self.SUNSTONE_NAME
    def set_SUNSTONE_NAME(self, SUNSTONE_NAME):
        self.SUNSTONE_NAME = SUNSTONE_NAME
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_KEEP_SNAPSHOTS(self):
        return self.KEEP_SNAPSHOTS
    def set_KEEP_SNAPSHOTS(self, KEEP_SNAPSHOTS):
        self.KEEP_SNAPSHOTS = KEEP_SNAPSHOTS
    def get_COLD_NIC_ATTACH(self):
        return self.COLD_NIC_ATTACH
    def set_COLD_NIC_ATTACH(self, COLD_NIC_ATTACH):
        self.COLD_NIC_ATTACH = COLD_NIC_ATTACH
    def get_DS_LIVE_MIGRATION(self):
        return self.DS_LIVE_MIGRATION
    def set_DS_LIVE_MIGRATION(self, DS_LIVE_MIGRATION):
        self.DS_LIVE_MIGRATION = DS_LIVE_MIGRATION
    def get_LIVE_RESIZE(self):
        return self.LIVE_RESIZE
    def set_LIVE_RESIZE(self, LIVE_RESIZE):
        self.LIVE_RESIZE = LIVE_RESIZE
    def validate_KEEP_SNAPSHOTSType(self, value):
        result = True
        # Validate type KEEP_SNAPSHOTSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_KEEP_SNAPSHOTSType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_KEEP_SNAPSHOTSType_patterns_, ))
                result = False
        return result
    validate_KEEP_SNAPSHOTSType_patterns_ = [['^([yY][eE][sS])$', '^([nN][oO])$']]
    def validate_COLD_NIC_ATTACHType(self, value):
        result = True
        # Validate type COLD_NIC_ATTACHType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_COLD_NIC_ATTACHType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_COLD_NIC_ATTACHType_patterns_, ))
                result = False
        return result
    validate_COLD_NIC_ATTACHType_patterns_ = [['^([yY][eE][sS])$', '^([nN][oO])$']]
    def validate_DS_LIVE_MIGRATIONType(self, value):
        result = True
        # Validate type DS_LIVE_MIGRATIONType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_DS_LIVE_MIGRATIONType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_DS_LIVE_MIGRATIONType_patterns_, ))
                result = False
        return result
    validate_DS_LIVE_MIGRATIONType_patterns_ = [['^([yY][eE][sS])$', '^([nN][oO])$']]
    def validate_LIVE_RESIZEType(self, value):
        result = True
        # Validate type LIVE_RESIZEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_LIVE_RESIZEType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_LIVE_RESIZEType_patterns_, ))
                result = False
        return result
    validate_LIVE_RESIZEType_patterns_ = [['^([yY][eE][sS])$', '^([nN][oO])$']]
    def has__content(self):
        if (
            self.ARGUMENTS is not None or
            self.DEFAULT is not None or
            self.EXECUTABLE is not None or
            self.NAME is not None or
            self.SUNSTONE_NAME is not None or
            self.TYPE is not None or
            self.KEEP_SNAPSHOTS is not None or
            self.COLD_NIC_ATTACH is not None or
            self.DS_LIVE_MIGRATION is not None or
            self.LIVE_RESIZE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_MADType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_MADType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VM_MADType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VM_MADType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VM_MADType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VM_MADType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_MADType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ARGUMENTS is not None:
            namespaceprefix_ = self.ARGUMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.ARGUMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sARGUMENTS>%s</%sARGUMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ARGUMENTS), input_name='ARGUMENTS')), namespaceprefix_ , eol_))
        if self.DEFAULT is not None:
            namespaceprefix_ = self.DEFAULT_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEFAULT>%s</%sDEFAULT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DEFAULT), input_name='DEFAULT')), namespaceprefix_ , eol_))
        if self.EXECUTABLE is not None:
            namespaceprefix_ = self.EXECUTABLE_nsprefix_ + ':' if (UseCapturedNS_ and self.EXECUTABLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXECUTABLE>%s</%sEXECUTABLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EXECUTABLE), input_name='EXECUTABLE')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.SUNSTONE_NAME is not None:
            namespaceprefix_ = self.SUNSTONE_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SUNSTONE_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSUNSTONE_NAME>%s</%sSUNSTONE_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SUNSTONE_NAME), input_name='SUNSTONE_NAME')), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), namespaceprefix_ , eol_))
        if self.KEEP_SNAPSHOTS is not None:
            namespaceprefix_ = self.KEEP_SNAPSHOTS_nsprefix_ + ':' if (UseCapturedNS_ and self.KEEP_SNAPSHOTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKEEP_SNAPSHOTS>%s</%sKEEP_SNAPSHOTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.KEEP_SNAPSHOTS), input_name='KEEP_SNAPSHOTS')), namespaceprefix_ , eol_))
        if self.COLD_NIC_ATTACH is not None:
            namespaceprefix_ = self.COLD_NIC_ATTACH_nsprefix_ + ':' if (UseCapturedNS_ and self.COLD_NIC_ATTACH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOLD_NIC_ATTACH>%s</%sCOLD_NIC_ATTACH>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.COLD_NIC_ATTACH), input_name='COLD_NIC_ATTACH')), namespaceprefix_ , eol_))
        if self.DS_LIVE_MIGRATION is not None:
            namespaceprefix_ = self.DS_LIVE_MIGRATION_nsprefix_ + ':' if (UseCapturedNS_ and self.DS_LIVE_MIGRATION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDS_LIVE_MIGRATION>%s</%sDS_LIVE_MIGRATION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DS_LIVE_MIGRATION), input_name='DS_LIVE_MIGRATION')), namespaceprefix_ , eol_))
        if self.LIVE_RESIZE is not None:
            namespaceprefix_ = self.LIVE_RESIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.LIVE_RESIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLIVE_RESIZE>%s</%sLIVE_RESIZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LIVE_RESIZE), input_name='LIVE_RESIZE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ARGUMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ARGUMENTS')
            value_ = self.gds_validate_string(value_, node, 'ARGUMENTS')
            self.ARGUMENTS = value_
            self.ARGUMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEFAULT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEFAULT')
            value_ = self.gds_validate_string(value_, node, 'DEFAULT')
            self.DEFAULT = value_
            self.DEFAULT_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXECUTABLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EXECUTABLE')
            value_ = self.gds_validate_string(value_, node, 'EXECUTABLE')
            self.EXECUTABLE = value_
            self.EXECUTABLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'SUNSTONE_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SUNSTONE_NAME')
            value_ = self.gds_validate_string(value_, node, 'SUNSTONE_NAME')
            self.SUNSTONE_NAME = value_
            self.SUNSTONE_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TYPE')
            value_ = self.gds_validate_string(value_, node, 'TYPE')
            self.TYPE = value_
            self.TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'KEEP_SNAPSHOTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'KEEP_SNAPSHOTS')
            value_ = self.gds_validate_string(value_, node, 'KEEP_SNAPSHOTS')
            self.KEEP_SNAPSHOTS = value_
            self.KEEP_SNAPSHOTS_nsprefix_ = child_.prefix
            # validate type KEEP_SNAPSHOTSType
            self.validate_KEEP_SNAPSHOTSType(self.KEEP_SNAPSHOTS)
        elif nodeName_ == 'COLD_NIC_ATTACH':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'COLD_NIC_ATTACH')
            value_ = self.gds_validate_string(value_, node, 'COLD_NIC_ATTACH')
            self.COLD_NIC_ATTACH = value_
            self.COLD_NIC_ATTACH_nsprefix_ = child_.prefix
            # validate type COLD_NIC_ATTACHType
            self.validate_COLD_NIC_ATTACHType(self.COLD_NIC_ATTACH)
        elif nodeName_ == 'DS_LIVE_MIGRATION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DS_LIVE_MIGRATION')
            value_ = self.gds_validate_string(value_, node, 'DS_LIVE_MIGRATION')
            self.DS_LIVE_MIGRATION = value_
            self.DS_LIVE_MIGRATION_nsprefix_ = child_.prefix
            # validate type DS_LIVE_MIGRATIONType
            self.validate_DS_LIVE_MIGRATIONType(self.DS_LIVE_MIGRATION)
        elif nodeName_ == 'LIVE_RESIZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LIVE_RESIZE')
            value_ = self.gds_validate_string(value_, node, 'LIVE_RESIZE')
            self.LIVE_RESIZE = value_
            self.LIVE_RESIZE_nsprefix_ = child_.prefix
            # validate type LIVE_RESIZEType
            self.validate_LIVE_RESIZEType(self.LIVE_RESIZE)
# end class VM_MADType


class VNC_PORTSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, RESERVED=None, START=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.RESERVED = RESERVED
        self.RESERVED_nsprefix_ = None
        self.START = START
        self.START_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNC_PORTSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNC_PORTSType.subclass:
            return VNC_PORTSType.subclass(*args_, **kwargs_)
        else:
            return VNC_PORTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RESERVED(self):
        return self.RESERVED
    def set_RESERVED(self, RESERVED):
        self.RESERVED = RESERVED
    def get_START(self):
        return self.START
    def set_START(self, START):
        self.START = START
    def has__content(self):
        if (
            self.RESERVED is not None or
            self.START is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNC_PORTSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNC_PORTSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VNC_PORTSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VNC_PORTSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VNC_PORTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VNC_PORTSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNC_PORTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RESERVED is not None:
            namespaceprefix_ = self.RESERVED_nsprefix_ + ':' if (UseCapturedNS_ and self.RESERVED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRESERVED>%s</%sRESERVED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RESERVED), input_name='RESERVED')), namespaceprefix_ , eol_))
        if self.START is not None:
            namespaceprefix_ = self.START_nsprefix_ + ':' if (UseCapturedNS_ and self.START_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTART>%s</%sSTART>%s' % (namespaceprefix_ , self.gds_format_integer(self.START, input_name='START'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RESERVED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RESERVED')
            value_ = self.gds_validate_string(value_, node, 'RESERVED')
            self.RESERVED = value_
            self.RESERVED_nsprefix_ = child_.prefix
        elif nodeName_ == 'START' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'START')
            ival_ = self.gds_validate_integer(ival_, node, 'START')
            self.START = ival_
            self.START_nsprefix_ = child_.prefix
# end class VNC_PORTSType


class VN_MAD_CONFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BRIDGE_TYPE=None, NAME=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.BRIDGE_TYPE = BRIDGE_TYPE
        self.BRIDGE_TYPE_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VN_MAD_CONFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VN_MAD_CONFType.subclass:
            return VN_MAD_CONFType.subclass(*args_, **kwargs_)
        else:
            return VN_MAD_CONFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BRIDGE_TYPE(self):
        return self.BRIDGE_TYPE
    def set_BRIDGE_TYPE(self, BRIDGE_TYPE):
        self.BRIDGE_TYPE = BRIDGE_TYPE
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def has__content(self):
        if (
            self.BRIDGE_TYPE is not None or
            self.NAME is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VN_MAD_CONFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VN_MAD_CONFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VN_MAD_CONFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VN_MAD_CONFType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VN_MAD_CONFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VN_MAD_CONFType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VN_MAD_CONFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BRIDGE_TYPE is not None:
            namespaceprefix_ = self.BRIDGE_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.BRIDGE_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBRIDGE_TYPE>%s</%sBRIDGE_TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BRIDGE_TYPE), input_name='BRIDGE_TYPE')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BRIDGE_TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BRIDGE_TYPE')
            value_ = self.gds_validate_string(value_, node, 'BRIDGE_TYPE')
            self.BRIDGE_TYPE = value_
            self.BRIDGE_TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
# end class VN_MAD_CONFType


class VXLAN_IDSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, START=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.START = START
        self.START_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VXLAN_IDSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VXLAN_IDSType.subclass:
            return VXLAN_IDSType.subclass(*args_, **kwargs_)
        else:
            return VXLAN_IDSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_START(self):
        return self.START
    def set_START(self, START):
        self.START = START
    def has__content(self):
        if (
            self.START is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VXLAN_IDSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VXLAN_IDSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VXLAN_IDSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VXLAN_IDSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VXLAN_IDSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VXLAN_IDSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VXLAN_IDSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.START is not None:
            namespaceprefix_ = self.START_nsprefix_ + ':' if (UseCapturedNS_ and self.START_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTART>%s</%sSTART>%s' % (namespaceprefix_ , self.gds_format_integer(self.START, input_name='START'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'START' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'START')
            ival_ = self.gds_validate_integer(ival_, node, 'START')
            self.START = ival_
            self.START_nsprefix_ = child_.prefix
# end class VXLAN_IDSType


class PERMISSIONSType23(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType23)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType23.subclass:
            return PERMISSIONSType23.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType23(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType23', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType23')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONSType23':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONSType23')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONSType23', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONSType23'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType23', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONSType23


class UPDATED_VMSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATED_VMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATED_VMSType.subclass:
            return UPDATED_VMSType.subclass(*args_, **kwargs_)
        else:
            return UPDATED_VMSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='UPDATED_VMSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UPDATED_VMSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UPDATED_VMSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UPDATED_VMSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UPDATED_VMSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UPDATED_VMSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='UPDATED_VMSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class UPDATED_VMSType


class OUTDATED_VMSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OUTDATED_VMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OUTDATED_VMSType.subclass:
            return OUTDATED_VMSType.subclass(*args_, **kwargs_)
        else:
            return OUTDATED_VMSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='OUTDATED_VMSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OUTDATED_VMSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OUTDATED_VMSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OUTDATED_VMSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OUTDATED_VMSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OUTDATED_VMSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='OUTDATED_VMSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class OUTDATED_VMSType


class UPDATING_VMSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATING_VMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATING_VMSType.subclass:
            return UPDATING_VMSType.subclass(*args_, **kwargs_)
        else:
            return UPDATING_VMSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='UPDATING_VMSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UPDATING_VMSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UPDATING_VMSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UPDATING_VMSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UPDATING_VMSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UPDATING_VMSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='UPDATING_VMSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class UPDATING_VMSType


class ERROR_VMSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ERROR_VMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ERROR_VMSType.subclass:
            return ERROR_VMSType.subclass(*args_, **kwargs_)
        else:
            return ERROR_VMSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ERROR_VMSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ERROR_VMSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ERROR_VMSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ERROR_VMSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ERROR_VMSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ERROR_VMSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ERROR_VMSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class ERROR_VMSType


class TEMPLATEType24(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DESCRIPTION=None, RULE=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        if RULE is None:
            self.RULE = []
        else:
            self.RULE = RULE
        self.RULE_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEMPLATEType24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEMPLATEType24.subclass:
            return TEMPLATEType24.subclass(*args_, **kwargs_)
        else:
            return TEMPLATEType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_RULE(self):
        return self.RULE
    def set_RULE(self, RULE):
        self.RULE = RULE
    def add_RULE(self, value):
        self.RULE.append(value)
    def insert_RULE_at(self, index, value):
        self.RULE.insert(index, value)
    def replace_RULE_at(self, index, value):
        self.RULE[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.DESCRIPTION is not None or
            self.RULE or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType24', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEMPLATEType24')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEMPLATEType24':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEMPLATEType24')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEMPLATEType24', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEMPLATEType24'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType24', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        for RULE_ in self.RULE:
            namespaceprefix_ = self.RULE_nsprefix_ + ':' if (UseCapturedNS_ and self.RULE_nsprefix_) else ''
            RULE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RULE', pretty_print=pretty_print)
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'RULE':
            obj_ = RULEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RULE.append(obj_)
            obj_.original_tagname_ = 'RULE'
        else:
            content_ = self.gds_build_any(child_, 'TEMPLATEType24')
            self.anytypeobjs_.append(content_)
# end class TEMPLATEType24


class RULEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PROTOCOL=None, RULE_TYPE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PROTOCOL = PROTOCOL
        self.PROTOCOL_nsprefix_ = None
        self.RULE_TYPE = RULE_TYPE
        self.RULE_TYPE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RULEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RULEType.subclass:
            return RULEType.subclass(*args_, **kwargs_)
        else:
            return RULEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PROTOCOL(self):
        return self.PROTOCOL
    def set_PROTOCOL(self, PROTOCOL):
        self.PROTOCOL = PROTOCOL
    def get_RULE_TYPE(self):
        return self.RULE_TYPE
    def set_RULE_TYPE(self, RULE_TYPE):
        self.RULE_TYPE = RULE_TYPE
    def has__content(self):
        if (
            self.PROTOCOL is not None or
            self.RULE_TYPE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='RULEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RULEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RULEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RULEType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RULEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RULEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='RULEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PROTOCOL is not None:
            namespaceprefix_ = self.PROTOCOL_nsprefix_ + ':' if (UseCapturedNS_ and self.PROTOCOL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROTOCOL>%s</%sPROTOCOL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PROTOCOL), input_name='PROTOCOL')), namespaceprefix_ , eol_))
        if self.RULE_TYPE is not None:
            namespaceprefix_ = self.RULE_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.RULE_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRULE_TYPE>%s</%sRULE_TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RULE_TYPE), input_name='RULE_TYPE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PROTOCOL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PROTOCOL')
            value_ = self.gds_validate_string(value_, node, 'PROTOCOL')
            self.PROTOCOL = value_
            self.PROTOCOL_nsprefix_ = child_.prefix
        elif nodeName_ == 'RULE_TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RULE_TYPE')
            value_ = self.gds_validate_string(value_, node, 'RULE_TYPE')
            self.RULE_TYPE = value_
            self.RULE_TYPE_nsprefix_ = child_.prefix
# end class RULEType


class SHOWBACKType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VMID=None, VMNAME=None, UID=None, GID=None, UNAME=None, GNAME=None, YEAR=None, MONTH=None, CPU_COST=None, MEMORY_COST=None, DISK_COST=None, TOTAL_COST=None, HOURS=None, RHOURS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.VMID = VMID
        self.VMID_nsprefix_ = None
        self.VMNAME = VMNAME
        self.VMNAME_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.YEAR = YEAR
        self.YEAR_nsprefix_ = None
        self.MONTH = MONTH
        self.MONTH_nsprefix_ = None
        self.CPU_COST = CPU_COST
        self.CPU_COST_nsprefix_ = None
        self.MEMORY_COST = MEMORY_COST
        self.MEMORY_COST_nsprefix_ = None
        self.DISK_COST = DISK_COST
        self.DISK_COST_nsprefix_ = None
        self.TOTAL_COST = TOTAL_COST
        self.TOTAL_COST_nsprefix_ = None
        self.HOURS = HOURS
        self.HOURS_nsprefix_ = None
        self.RHOURS = RHOURS
        self.RHOURS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SHOWBACKType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SHOWBACKType.subclass:
            return SHOWBACKType.subclass(*args_, **kwargs_)
        else:
            return SHOWBACKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VMID(self):
        return self.VMID
    def set_VMID(self, VMID):
        self.VMID = VMID
    def get_VMNAME(self):
        return self.VMNAME
    def set_VMNAME(self, VMNAME):
        self.VMNAME = VMNAME
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_YEAR(self):
        return self.YEAR
    def set_YEAR(self, YEAR):
        self.YEAR = YEAR
    def get_MONTH(self):
        return self.MONTH
    def set_MONTH(self, MONTH):
        self.MONTH = MONTH
    def get_CPU_COST(self):
        return self.CPU_COST
    def set_CPU_COST(self, CPU_COST):
        self.CPU_COST = CPU_COST
    def get_MEMORY_COST(self):
        return self.MEMORY_COST
    def set_MEMORY_COST(self, MEMORY_COST):
        self.MEMORY_COST = MEMORY_COST
    def get_DISK_COST(self):
        return self.DISK_COST
    def set_DISK_COST(self, DISK_COST):
        self.DISK_COST = DISK_COST
    def get_TOTAL_COST(self):
        return self.TOTAL_COST
    def set_TOTAL_COST(self, TOTAL_COST):
        self.TOTAL_COST = TOTAL_COST
    def get_HOURS(self):
        return self.HOURS
    def set_HOURS(self, HOURS):
        self.HOURS = HOURS
    def get_RHOURS(self):
        return self.RHOURS
    def set_RHOURS(self, RHOURS):
        self.RHOURS = RHOURS
    def has__content(self):
        if (
            self.VMID is not None or
            self.VMNAME is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.YEAR is not None or
            self.MONTH is not None or
            self.CPU_COST is not None or
            self.MEMORY_COST is not None or
            self.DISK_COST is not None or
            self.TOTAL_COST is not None or
            self.HOURS is not None or
            self.RHOURS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SHOWBACKType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SHOWBACKType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SHOWBACKType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SHOWBACKType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SHOWBACKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SHOWBACKType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SHOWBACKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VMID is not None:
            namespaceprefix_ = self.VMID_nsprefix_ + ':' if (UseCapturedNS_ and self.VMID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMID>%s</%sVMID>%s' % (namespaceprefix_ , self.gds_format_integer(self.VMID, input_name='VMID'), namespaceprefix_ , eol_))
        if self.VMNAME is not None:
            namespaceprefix_ = self.VMNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.VMNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMNAME>%s</%sVMNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VMNAME), input_name='VMNAME')), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.YEAR is not None:
            namespaceprefix_ = self.YEAR_nsprefix_ + ':' if (UseCapturedNS_ and self.YEAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYEAR>%s</%sYEAR>%s' % (namespaceprefix_ , self.gds_format_integer(self.YEAR, input_name='YEAR'), namespaceprefix_ , eol_))
        if self.MONTH is not None:
            namespaceprefix_ = self.MONTH_nsprefix_ + ':' if (UseCapturedNS_ and self.MONTH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMONTH>%s</%sMONTH>%s' % (namespaceprefix_ , self.gds_format_integer(self.MONTH, input_name='MONTH'), namespaceprefix_ , eol_))
        if self.CPU_COST is not None:
            namespaceprefix_ = self.CPU_COST_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_COST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU_COST>%s</%sCPU_COST>%s' % (namespaceprefix_ , self.gds_format_float(self.CPU_COST, input_name='CPU_COST'), namespaceprefix_ , eol_))
        if self.MEMORY_COST is not None:
            namespaceprefix_ = self.MEMORY_COST_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_COST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY_COST>%s</%sMEMORY_COST>%s' % (namespaceprefix_ , self.gds_format_float(self.MEMORY_COST, input_name='MEMORY_COST'), namespaceprefix_ , eol_))
        if self.DISK_COST is not None:
            namespaceprefix_ = self.DISK_COST_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_COST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISK_COST>%s</%sDISK_COST>%s' % (namespaceprefix_ , self.gds_format_float(self.DISK_COST, input_name='DISK_COST'), namespaceprefix_ , eol_))
        if self.TOTAL_COST is not None:
            namespaceprefix_ = self.TOTAL_COST_nsprefix_ + ':' if (UseCapturedNS_ and self.TOTAL_COST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTOTAL_COST>%s</%sTOTAL_COST>%s' % (namespaceprefix_ , self.gds_format_float(self.TOTAL_COST, input_name='TOTAL_COST'), namespaceprefix_ , eol_))
        if self.HOURS is not None:
            namespaceprefix_ = self.HOURS_nsprefix_ + ':' if (UseCapturedNS_ and self.HOURS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHOURS>%s</%sHOURS>%s' % (namespaceprefix_ , self.gds_format_float(self.HOURS, input_name='HOURS'), namespaceprefix_ , eol_))
        if self.RHOURS is not None:
            namespaceprefix_ = self.RHOURS_nsprefix_ + ':' if (UseCapturedNS_ and self.RHOURS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRHOURS>%s</%sRHOURS>%s' % (namespaceprefix_ , self.gds_format_float(self.RHOURS, input_name='RHOURS'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VMID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VMID')
            ival_ = self.gds_validate_integer(ival_, node, 'VMID')
            self.VMID = ival_
            self.VMID_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VMNAME')
            value_ = self.gds_validate_string(value_, node, 'VMNAME')
            self.VMNAME = value_
            self.VMNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'YEAR' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'YEAR')
            ival_ = self.gds_validate_integer(ival_, node, 'YEAR')
            self.YEAR = ival_
            self.YEAR_nsprefix_ = child_.prefix
        elif nodeName_ == 'MONTH' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MONTH')
            ival_ = self.gds_validate_integer(ival_, node, 'MONTH')
            self.MONTH = ival_
            self.MONTH_nsprefix_ = child_.prefix
        elif nodeName_ == 'CPU_COST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'CPU_COST')
            fval_ = self.gds_validate_float(fval_, node, 'CPU_COST')
            self.CPU_COST = fval_
            self.CPU_COST_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY_COST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'MEMORY_COST')
            fval_ = self.gds_validate_float(fval_, node, 'MEMORY_COST')
            self.MEMORY_COST = fval_
            self.MEMORY_COST_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISK_COST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'DISK_COST')
            fval_ = self.gds_validate_float(fval_, node, 'DISK_COST')
            self.DISK_COST = fval_
            self.DISK_COST_nsprefix_ = child_.prefix
        elif nodeName_ == 'TOTAL_COST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'TOTAL_COST')
            fval_ = self.gds_validate_float(fval_, node, 'TOTAL_COST')
            self.TOTAL_COST = fval_
            self.TOTAL_COST_nsprefix_ = child_.prefix
        elif nodeName_ == 'HOURS' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'HOURS')
            fval_ = self.gds_validate_float(fval_, node, 'HOURS')
            self.HOURS = fval_
            self.HOURS_nsprefix_ = child_.prefix
        elif nodeName_ == 'RHOURS' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'RHOURS')
            fval_ = self.gds_validate_float(fval_, node, 'RHOURS')
            self.RHOURS = fval_
            self.RHOURS_nsprefix_ = child_.prefix
# end class SHOWBACKType


class USERType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, GID=None, GROUPS=None, GNAME=None, NAME=None, PASSWORD=None, AUTH_DRIVER=None, ENABLED=None, LOGIN_TOKEN=None, TEMPLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.GROUPS = GROUPS
        self.GROUPS_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PASSWORD = PASSWORD
        self.PASSWORD_nsprefix_ = None
        self.AUTH_DRIVER = AUTH_DRIVER
        self.AUTH_DRIVER_nsprefix_ = None
        self.ENABLED = ENABLED
        self.ENABLED_nsprefix_ = None
        if LOGIN_TOKEN is None:
            self.LOGIN_TOKEN = []
        else:
            self.LOGIN_TOKEN = LOGIN_TOKEN
        self.LOGIN_TOKEN_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USERType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USERType.subclass:
            return USERType.subclass(*args_, **kwargs_)
        else:
            return USERType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_GROUPS(self):
        return self.GROUPS
    def set_GROUPS(self, GROUPS):
        self.GROUPS = GROUPS
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PASSWORD(self):
        return self.PASSWORD
    def set_PASSWORD(self, PASSWORD):
        self.PASSWORD = PASSWORD
    def get_AUTH_DRIVER(self):
        return self.AUTH_DRIVER
    def set_AUTH_DRIVER(self, AUTH_DRIVER):
        self.AUTH_DRIVER = AUTH_DRIVER
    def get_ENABLED(self):
        return self.ENABLED
    def set_ENABLED(self, ENABLED):
        self.ENABLED = ENABLED
    def get_LOGIN_TOKEN(self):
        return self.LOGIN_TOKEN
    def set_LOGIN_TOKEN(self, LOGIN_TOKEN):
        self.LOGIN_TOKEN = LOGIN_TOKEN
    def add_LOGIN_TOKEN(self, value):
        self.LOGIN_TOKEN.append(value)
    def insert_LOGIN_TOKEN_at(self, index, value):
        self.LOGIN_TOKEN.insert(index, value)
    def replace_LOGIN_TOKEN_at(self, index, value):
        self.LOGIN_TOKEN[index] = value
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def has__content(self):
        if (
            self.ID is not None or
            self.GID is not None or
            self.GROUPS is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PASSWORD is not None or
            self.AUTH_DRIVER is not None or
            self.ENABLED is not None or
            self.LOGIN_TOKEN or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USERType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USERType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'USERType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USERType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='USERType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='USERType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USERType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.GROUPS is not None:
            namespaceprefix_ = self.GROUPS_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUPS_nsprefix_) else ''
            self.GROUPS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GROUPS', pretty_print=pretty_print)
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PASSWORD is not None:
            namespaceprefix_ = self.PASSWORD_nsprefix_ + ':' if (UseCapturedNS_ and self.PASSWORD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPASSWORD>%s</%sPASSWORD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PASSWORD), input_name='PASSWORD')), namespaceprefix_ , eol_))
        if self.AUTH_DRIVER is not None:
            namespaceprefix_ = self.AUTH_DRIVER_nsprefix_ + ':' if (UseCapturedNS_ and self.AUTH_DRIVER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAUTH_DRIVER>%s</%sAUTH_DRIVER>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AUTH_DRIVER), input_name='AUTH_DRIVER')), namespaceprefix_ , eol_))
        if self.ENABLED is not None:
            namespaceprefix_ = self.ENABLED_nsprefix_ + ':' if (UseCapturedNS_ and self.ENABLED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sENABLED>%s</%sENABLED>%s' % (namespaceprefix_ , self.gds_format_integer(self.ENABLED, input_name='ENABLED'), namespaceprefix_ , eol_))
        for LOGIN_TOKEN_ in self.LOGIN_TOKEN:
            namespaceprefix_ = self.LOGIN_TOKEN_nsprefix_ + ':' if (UseCapturedNS_ and self.LOGIN_TOKEN_nsprefix_) else ''
            LOGIN_TOKEN_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOGIN_TOKEN', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUPS':
            obj_ = GROUPSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GROUPS = obj_
            obj_.original_tagname_ = 'GROUPS'
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PASSWORD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PASSWORD')
            value_ = self.gds_validate_string(value_, node, 'PASSWORD')
            self.PASSWORD = value_
            self.PASSWORD_nsprefix_ = child_.prefix
        elif nodeName_ == 'AUTH_DRIVER':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AUTH_DRIVER')
            value_ = self.gds_validate_string(value_, node, 'AUTH_DRIVER')
            self.AUTH_DRIVER = value_
            self.AUTH_DRIVER_nsprefix_ = child_.prefix
        elif nodeName_ == 'ENABLED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ENABLED')
            ival_ = self.gds_validate_integer(ival_, node, 'ENABLED')
            self.ENABLED = ival_
            self.ENABLED_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOGIN_TOKEN':
            obj_ = LOGIN_TOKENType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOGIN_TOKEN.append(obj_)
            obj_.original_tagname_ = 'LOGIN_TOKEN'
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
# end class USERType


class GROUPSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GROUPSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GROUPSType.subclass:
            return GROUPSType.subclass(*args_, **kwargs_)
        else:
            return GROUPSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='GROUPSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GROUPSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GROUPSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GROUPSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GROUPSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GROUPSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='GROUPSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class GROUPSType


class LOGIN_TOKENType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, TOKEN=None, EXPIRATION_TIME=None, EGID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TOKEN = TOKEN
        self.TOKEN_nsprefix_ = None
        self.EXPIRATION_TIME = EXPIRATION_TIME
        self.EXPIRATION_TIME_nsprefix_ = None
        self.EGID = EGID
        self.EGID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOGIN_TOKENType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOGIN_TOKENType.subclass:
            return LOGIN_TOKENType.subclass(*args_, **kwargs_)
        else:
            return LOGIN_TOKENType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TOKEN(self):
        return self.TOKEN
    def set_TOKEN(self, TOKEN):
        self.TOKEN = TOKEN
    def get_EXPIRATION_TIME(self):
        return self.EXPIRATION_TIME
    def set_EXPIRATION_TIME(self, EXPIRATION_TIME):
        self.EXPIRATION_TIME = EXPIRATION_TIME
    def get_EGID(self):
        return self.EGID
    def set_EGID(self, EGID):
        self.EGID = EGID
    def has__content(self):
        if (
            self.TOKEN is not None or
            self.EXPIRATION_TIME is not None or
            self.EGID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOGIN_TOKENType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOGIN_TOKENType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LOGIN_TOKENType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LOGIN_TOKENType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LOGIN_TOKENType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LOGIN_TOKENType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOGIN_TOKENType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TOKEN is not None:
            namespaceprefix_ = self.TOKEN_nsprefix_ + ':' if (UseCapturedNS_ and self.TOKEN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTOKEN>%s</%sTOKEN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TOKEN), input_name='TOKEN')), namespaceprefix_ , eol_))
        if self.EXPIRATION_TIME is not None:
            namespaceprefix_ = self.EXPIRATION_TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.EXPIRATION_TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXPIRATION_TIME>%s</%sEXPIRATION_TIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.EXPIRATION_TIME, input_name='EXPIRATION_TIME'), namespaceprefix_ , eol_))
        if self.EGID is not None:
            namespaceprefix_ = self.EGID_nsprefix_ + ':' if (UseCapturedNS_ and self.EGID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEGID>%s</%sEGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.EGID, input_name='EGID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TOKEN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TOKEN')
            value_ = self.gds_validate_string(value_, node, 'TOKEN')
            self.TOKEN = value_
            self.TOKEN_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXPIRATION_TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'EXPIRATION_TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'EXPIRATION_TIME')
            self.EXPIRATION_TIME = ival_
            self.EXPIRATION_TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'EGID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'EGID')
            ival_ = self.gds_validate_integer(ival_, node, 'EGID')
            self.EGID = ival_
            self.EGID_nsprefix_ = child_.prefix
# end class LOGIN_TOKENType


class QUOTASType25(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.DATASTORE_QUOTA_nsprefix_ = None
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.NETWORK_QUOTA_nsprefix_ = None
        self.VM_QUOTA = VM_QUOTA
        self.VM_QUOTA_nsprefix_ = None
        self.IMAGE_QUOTA = IMAGE_QUOTA
        self.IMAGE_QUOTA_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QUOTASType25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QUOTASType25.subclass:
            return QUOTASType25.subclass(*args_, **kwargs_)
        else:
            return QUOTASType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_DATASTORE_QUOTA(self):
        return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA):
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self):
        return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA):
        self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self):
        return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA):
        self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self):
        return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA):
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def has__content(self):
        if (
            self.ID is not None or
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='QUOTASType25', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QUOTASType25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QUOTASType25':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QUOTASType25')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QUOTASType25', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QUOTASType25'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='QUOTASType25', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.DATASTORE_QUOTA is not None:
            namespaceprefix_ = self.DATASTORE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_QUOTA_nsprefix_) else ''
            self.DATASTORE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            namespaceprefix_ = self.NETWORK_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.NETWORK_QUOTA_nsprefix_) else ''
            self.NETWORK_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            namespaceprefix_ = self.VM_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_QUOTA_nsprefix_) else ''
            self.VM_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            namespaceprefix_ = self.IMAGE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_QUOTA_nsprefix_) else ''
            self.IMAGE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_QUOTA', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
# end class QUOTASType25


class DEFAULT_USER_QUOTASType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.DATASTORE_QUOTA_nsprefix_ = None
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.NETWORK_QUOTA_nsprefix_ = None
        self.VM_QUOTA = VM_QUOTA
        self.VM_QUOTA_nsprefix_ = None
        self.IMAGE_QUOTA = IMAGE_QUOTA
        self.IMAGE_QUOTA_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DEFAULT_USER_QUOTASType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DEFAULT_USER_QUOTASType.subclass:
            return DEFAULT_USER_QUOTASType.subclass(*args_, **kwargs_)
        else:
            return DEFAULT_USER_QUOTASType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATASTORE_QUOTA(self):
        return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA):
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self):
        return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA):
        self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self):
        return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA):
        self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self):
        return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA):
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def has__content(self):
        if (
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DEFAULT_USER_QUOTASType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DEFAULT_USER_QUOTASType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DEFAULT_USER_QUOTASType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DEFAULT_USER_QUOTASType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DEFAULT_USER_QUOTASType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DEFAULT_USER_QUOTASType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DEFAULT_USER_QUOTASType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DATASTORE_QUOTA is not None:
            namespaceprefix_ = self.DATASTORE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_QUOTA_nsprefix_) else ''
            self.DATASTORE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            namespaceprefix_ = self.NETWORK_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.NETWORK_QUOTA_nsprefix_) else ''
            self.NETWORK_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            namespaceprefix_ = self.VM_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_QUOTA_nsprefix_) else ''
            self.VM_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            namespaceprefix_ = self.IMAGE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_QUOTA_nsprefix_) else ''
            self.IMAGE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_QUOTA', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTAType26.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
# end class DEFAULT_USER_QUOTASType


class VM_QUOTAType26(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VM=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.VM = VM
        self.VM_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_QUOTAType26)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_QUOTAType26.subclass:
            return VM_QUOTAType26.subclass(*args_, **kwargs_)
        else:
            return VM_QUOTAType26(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VM(self):
        return self.VM
    def set_VM(self, VM):
        self.VM = VM
    def has__content(self):
        if (
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_QUOTAType26', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_QUOTAType26')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VM_QUOTAType26':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VM_QUOTAType26')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VM_QUOTAType26', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VM_QUOTAType26'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_QUOTAType26', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VM is not None:
            namespaceprefix_ = self.VM_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_nsprefix_) else ''
            self.VM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VM':
            obj_ = VMType27.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class VM_QUOTAType26


class VMType27(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CPU=None, CPU_USED=None, MEMORY=None, MEMORY_USED=None, RUNNING_CPU=None, RUNNING_CPU_USED=None, RUNNING_MEMORY=None, RUNNING_MEMORY_USED=None, RUNNING_VMS=None, RUNNING_VMS_USED=None, SYSTEM_DISK_SIZE=None, SYSTEM_DISK_SIZE_USED=None, VMS=None, VMS_USED=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CPU = CPU
        self.CPU_nsprefix_ = None
        self.CPU_USED = CPU_USED
        self.CPU_USED_nsprefix_ = None
        self.MEMORY = MEMORY
        self.MEMORY_nsprefix_ = None
        self.MEMORY_USED = MEMORY_USED
        self.MEMORY_USED_nsprefix_ = None
        self.RUNNING_CPU = RUNNING_CPU
        self.RUNNING_CPU_nsprefix_ = None
        self.RUNNING_CPU_USED = RUNNING_CPU_USED
        self.RUNNING_CPU_USED_nsprefix_ = None
        self.RUNNING_MEMORY = RUNNING_MEMORY
        self.RUNNING_MEMORY_nsprefix_ = None
        self.RUNNING_MEMORY_USED = RUNNING_MEMORY_USED
        self.RUNNING_MEMORY_USED_nsprefix_ = None
        self.RUNNING_VMS = RUNNING_VMS
        self.RUNNING_VMS_nsprefix_ = None
        self.RUNNING_VMS_USED = RUNNING_VMS_USED
        self.RUNNING_VMS_USED_nsprefix_ = None
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_nsprefix_ = None
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
        self.SYSTEM_DISK_SIZE_USED_nsprefix_ = None
        self.VMS = VMS
        self.VMS_nsprefix_ = None
        self.VMS_USED = VMS_USED
        self.VMS_USED_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType27)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType27.subclass:
            return VMType27.subclass(*args_, **kwargs_)
        else:
            return VMType27(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CPU(self):
        return self.CPU
    def set_CPU(self, CPU):
        self.CPU = CPU
    def get_CPU_USED(self):
        return self.CPU_USED
    def set_CPU_USED(self, CPU_USED):
        self.CPU_USED = CPU_USED
    def get_MEMORY(self):
        return self.MEMORY
    def set_MEMORY(self, MEMORY):
        self.MEMORY = MEMORY
    def get_MEMORY_USED(self):
        return self.MEMORY_USED
    def set_MEMORY_USED(self, MEMORY_USED):
        self.MEMORY_USED = MEMORY_USED
    def get_RUNNING_CPU(self):
        return self.RUNNING_CPU
    def set_RUNNING_CPU(self, RUNNING_CPU):
        self.RUNNING_CPU = RUNNING_CPU
    def get_RUNNING_CPU_USED(self):
        return self.RUNNING_CPU_USED
    def set_RUNNING_CPU_USED(self, RUNNING_CPU_USED):
        self.RUNNING_CPU_USED = RUNNING_CPU_USED
    def get_RUNNING_MEMORY(self):
        return self.RUNNING_MEMORY
    def set_RUNNING_MEMORY(self, RUNNING_MEMORY):
        self.RUNNING_MEMORY = RUNNING_MEMORY
    def get_RUNNING_MEMORY_USED(self):
        return self.RUNNING_MEMORY_USED
    def set_RUNNING_MEMORY_USED(self, RUNNING_MEMORY_USED):
        self.RUNNING_MEMORY_USED = RUNNING_MEMORY_USED
    def get_RUNNING_VMS(self):
        return self.RUNNING_VMS
    def set_RUNNING_VMS(self, RUNNING_VMS):
        self.RUNNING_VMS = RUNNING_VMS
    def get_RUNNING_VMS_USED(self):
        return self.RUNNING_VMS_USED
    def set_RUNNING_VMS_USED(self, RUNNING_VMS_USED):
        self.RUNNING_VMS_USED = RUNNING_VMS_USED
    def get_SYSTEM_DISK_SIZE(self):
        return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE):
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_SYSTEM_DISK_SIZE_USED(self):
        return self.SYSTEM_DISK_SIZE_USED
    def set_SYSTEM_DISK_SIZE_USED(self, SYSTEM_DISK_SIZE_USED):
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
    def get_VMS(self):
        return self.VMS
    def set_VMS(self, VMS):
        self.VMS = VMS
    def get_VMS_USED(self):
        return self.VMS_USED
    def set_VMS_USED(self, VMS_USED):
        self.VMS_USED = VMS_USED
    def has__content(self):
        if (
            self.CPU is not None or
            self.CPU_USED is not None or
            self.MEMORY is not None or
            self.MEMORY_USED is not None or
            self.RUNNING_CPU is not None or
            self.RUNNING_CPU_USED is not None or
            self.RUNNING_MEMORY is not None or
            self.RUNNING_MEMORY_USED is not None or
            self.RUNNING_VMS is not None or
            self.RUNNING_VMS_USED is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.SYSTEM_DISK_SIZE_USED is not None or
            self.VMS is not None or
            self.VMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType27', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType27')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VMType27':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VMType27')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VMType27', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VMType27'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType27', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            namespaceprefix_ = self.CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU>%s</%sCPU>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), namespaceprefix_ , eol_))
        if self.CPU_USED is not None:
            namespaceprefix_ = self.CPU_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU_USED>%s</%sCPU_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPU_USED), input_name='CPU_USED')), namespaceprefix_ , eol_))
        if self.MEMORY is not None:
            namespaceprefix_ = self.MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY>%s</%sMEMORY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), namespaceprefix_ , eol_))
        if self.MEMORY_USED is not None:
            namespaceprefix_ = self.MEMORY_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY_USED>%s</%sMEMORY_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_USED), input_name='MEMORY_USED')), namespaceprefix_ , eol_))
        if self.RUNNING_CPU is not None:
            namespaceprefix_ = self.RUNNING_CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_CPU>%s</%sRUNNING_CPU>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_CPU), input_name='RUNNING_CPU')), namespaceprefix_ , eol_))
        if self.RUNNING_CPU_USED is not None:
            namespaceprefix_ = self.RUNNING_CPU_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_CPU_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_CPU_USED>%s</%sRUNNING_CPU_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_CPU_USED), input_name='RUNNING_CPU_USED')), namespaceprefix_ , eol_))
        if self.RUNNING_MEMORY is not None:
            namespaceprefix_ = self.RUNNING_MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_MEMORY>%s</%sRUNNING_MEMORY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_MEMORY), input_name='RUNNING_MEMORY')), namespaceprefix_ , eol_))
        if self.RUNNING_MEMORY_USED is not None:
            namespaceprefix_ = self.RUNNING_MEMORY_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_MEMORY_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_MEMORY_USED>%s</%sRUNNING_MEMORY_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_MEMORY_USED), input_name='RUNNING_MEMORY_USED')), namespaceprefix_ , eol_))
        if self.RUNNING_VMS is not None:
            namespaceprefix_ = self.RUNNING_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_VMS>%s</%sRUNNING_VMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_VMS), input_name='RUNNING_VMS')), namespaceprefix_ , eol_))
        if self.RUNNING_VMS_USED is not None:
            namespaceprefix_ = self.RUNNING_VMS_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_VMS_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_VMS_USED>%s</%sRUNNING_VMS_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_VMS_USED), input_name='RUNNING_VMS_USED')), namespaceprefix_ , eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            namespaceprefix_ = self.SYSTEM_DISK_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SYSTEM_DISK_SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYSTEM_DISK_SIZE>%s</%sSYSTEM_DISK_SIZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE), input_name='SYSTEM_DISK_SIZE')), namespaceprefix_ , eol_))
        if self.SYSTEM_DISK_SIZE_USED is not None:
            namespaceprefix_ = self.SYSTEM_DISK_SIZE_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.SYSTEM_DISK_SIZE_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYSTEM_DISK_SIZE_USED>%s</%sSYSTEM_DISK_SIZE_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE_USED), input_name='SYSTEM_DISK_SIZE_USED')), namespaceprefix_ , eol_))
        if self.VMS is not None:
            namespaceprefix_ = self.VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMS>%s</%sVMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VMS), input_name='VMS')), namespaceprefix_ , eol_))
        if self.VMS_USED is not None:
            namespaceprefix_ = self.VMS_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMS_USED>%s</%sVMS_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VMS_USED), input_name='VMS_USED')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CPU':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPU')
            value_ = self.gds_validate_string(value_, node, 'CPU')
            self.CPU = value_
            self.CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'CPU_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPU_USED')
            value_ = self.gds_validate_string(value_, node, 'CPU_USED')
            self.CPU_USED = value_
            self.CPU_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY')
            value_ = self.gds_validate_string(value_, node, 'MEMORY')
            self.MEMORY = value_
            self.MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY_USED')
            value_ = self.gds_validate_string(value_, node, 'MEMORY_USED')
            self.MEMORY_USED = value_
            self.MEMORY_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_CPU':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_CPU')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_CPU')
            self.RUNNING_CPU = value_
            self.RUNNING_CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_CPU_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_CPU_USED')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_CPU_USED')
            self.RUNNING_CPU_USED = value_
            self.RUNNING_CPU_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_MEMORY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_MEMORY')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_MEMORY')
            self.RUNNING_MEMORY = value_
            self.RUNNING_MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_MEMORY_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_MEMORY_USED')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_MEMORY_USED')
            self.RUNNING_MEMORY_USED = value_
            self.RUNNING_MEMORY_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_VMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_VMS')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_VMS')
            self.RUNNING_VMS = value_
            self.RUNNING_VMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_VMS_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_VMS_USED')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_VMS_USED')
            self.RUNNING_VMS_USED = value_
            self.RUNNING_VMS_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYSTEM_DISK_SIZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SYSTEM_DISK_SIZE')
            value_ = self.gds_validate_string(value_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = value_
            self.SYSTEM_DISK_SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYSTEM_DISK_SIZE_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SYSTEM_DISK_SIZE_USED')
            value_ = self.gds_validate_string(value_, node, 'SYSTEM_DISK_SIZE_USED')
            self.SYSTEM_DISK_SIZE_USED = value_
            self.SYSTEM_DISK_SIZE_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VMS')
            value_ = self.gds_validate_string(value_, node, 'VMS')
            self.VMS = value_
            self.VMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMS_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VMS_USED')
            value_ = self.gds_validate_string(value_, node, 'VMS_USED')
            self.VMS_USED = value_
            self.VMS_USED_nsprefix_ = child_.prefix
# end class VMType27


class GROUPSType28(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GROUPSType28)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GROUPSType28.subclass:
            return GROUPSType28.subclass(*args_, **kwargs_)
        else:
            return GROUPSType28(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='GROUPSType28', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GROUPSType28')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GROUPSType28':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GROUPSType28')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GROUPSType28', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GROUPSType28'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='GROUPSType28', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class GROUPSType28


class LOGIN_TOKENType29(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, TOKEN=None, EXPIRATION_TIME=None, EGID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TOKEN = TOKEN
        self.TOKEN_nsprefix_ = None
        self.EXPIRATION_TIME = EXPIRATION_TIME
        self.EXPIRATION_TIME_nsprefix_ = None
        self.EGID = EGID
        self.EGID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOGIN_TOKENType29)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOGIN_TOKENType29.subclass:
            return LOGIN_TOKENType29.subclass(*args_, **kwargs_)
        else:
            return LOGIN_TOKENType29(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TOKEN(self):
        return self.TOKEN
    def set_TOKEN(self, TOKEN):
        self.TOKEN = TOKEN
    def get_EXPIRATION_TIME(self):
        return self.EXPIRATION_TIME
    def set_EXPIRATION_TIME(self, EXPIRATION_TIME):
        self.EXPIRATION_TIME = EXPIRATION_TIME
    def get_EGID(self):
        return self.EGID
    def set_EGID(self, EGID):
        self.EGID = EGID
    def has__content(self):
        if (
            self.TOKEN is not None or
            self.EXPIRATION_TIME is not None or
            self.EGID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOGIN_TOKENType29', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOGIN_TOKENType29')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LOGIN_TOKENType29':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LOGIN_TOKENType29')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LOGIN_TOKENType29', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LOGIN_TOKENType29'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOGIN_TOKENType29', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TOKEN is not None:
            namespaceprefix_ = self.TOKEN_nsprefix_ + ':' if (UseCapturedNS_ and self.TOKEN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTOKEN>%s</%sTOKEN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TOKEN), input_name='TOKEN')), namespaceprefix_ , eol_))
        if self.EXPIRATION_TIME is not None:
            namespaceprefix_ = self.EXPIRATION_TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.EXPIRATION_TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXPIRATION_TIME>%s</%sEXPIRATION_TIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.EXPIRATION_TIME, input_name='EXPIRATION_TIME'), namespaceprefix_ , eol_))
        if self.EGID is not None:
            namespaceprefix_ = self.EGID_nsprefix_ + ':' if (UseCapturedNS_ and self.EGID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEGID>%s</%sEGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.EGID, input_name='EGID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TOKEN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TOKEN')
            value_ = self.gds_validate_string(value_, node, 'TOKEN')
            self.TOKEN = value_
            self.TOKEN_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXPIRATION_TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'EXPIRATION_TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'EXPIRATION_TIME')
            self.EXPIRATION_TIME = ival_
            self.EXPIRATION_TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'EGID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'EGID')
            ival_ = self.gds_validate_integer(ival_, node, 'EGID')
            self.EGID = ival_
            self.EGID_nsprefix_ = child_.prefix
# end class LOGIN_TOKENType29


class DEFAULT_USER_QUOTASType30(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.DATASTORE_QUOTA_nsprefix_ = None
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.NETWORK_QUOTA_nsprefix_ = None
        self.VM_QUOTA = VM_QUOTA
        self.VM_QUOTA_nsprefix_ = None
        self.IMAGE_QUOTA = IMAGE_QUOTA
        self.IMAGE_QUOTA_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DEFAULT_USER_QUOTASType30)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DEFAULT_USER_QUOTASType30.subclass:
            return DEFAULT_USER_QUOTASType30.subclass(*args_, **kwargs_)
        else:
            return DEFAULT_USER_QUOTASType30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATASTORE_QUOTA(self):
        return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA):
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self):
        return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA):
        self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self):
        return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA):
        self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self):
        return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA):
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def has__content(self):
        if (
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DEFAULT_USER_QUOTASType30', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DEFAULT_USER_QUOTASType30')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DEFAULT_USER_QUOTASType30':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DEFAULT_USER_QUOTASType30')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DEFAULT_USER_QUOTASType30', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DEFAULT_USER_QUOTASType30'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DEFAULT_USER_QUOTASType30', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DATASTORE_QUOTA is not None:
            namespaceprefix_ = self.DATASTORE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_QUOTA_nsprefix_) else ''
            self.DATASTORE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            namespaceprefix_ = self.NETWORK_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.NETWORK_QUOTA_nsprefix_) else ''
            self.NETWORK_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            namespaceprefix_ = self.VM_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_QUOTA_nsprefix_) else ''
            self.VM_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            namespaceprefix_ = self.IMAGE_QUOTA_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_QUOTA_nsprefix_) else ''
            self.IMAGE_QUOTA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_QUOTA', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTAType31.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
# end class DEFAULT_USER_QUOTASType30


class VM_QUOTAType31(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VM=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.VM = VM
        self.VM_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_QUOTAType31)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_QUOTAType31.subclass:
            return VM_QUOTAType31.subclass(*args_, **kwargs_)
        else:
            return VM_QUOTAType31(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VM(self):
        return self.VM
    def set_VM(self, VM):
        self.VM = VM
    def has__content(self):
        if (
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_QUOTAType31', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_QUOTAType31')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VM_QUOTAType31':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VM_QUOTAType31')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VM_QUOTAType31', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VM_QUOTAType31'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VM_QUOTAType31', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VM is not None:
            namespaceprefix_ = self.VM_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_nsprefix_) else ''
            self.VM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VM', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VM':
            obj_ = VMType32.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class VM_QUOTAType31


class VMType32(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CPU=None, CPU_USED=None, MEMORY=None, MEMORY_USED=None, RUNNING_CPU=None, RUNNING_CPU_USED=None, RUNNING_MEMORY=None, RUNNING_MEMORY_USED=None, RUNNING_VMS=None, RUNNING_VMS_USED=None, SYSTEM_DISK_SIZE=None, SYSTEM_DISK_SIZE_USED=None, VMS=None, VMS_USED=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CPU = CPU
        self.CPU_nsprefix_ = None
        self.CPU_USED = CPU_USED
        self.CPU_USED_nsprefix_ = None
        self.MEMORY = MEMORY
        self.MEMORY_nsprefix_ = None
        self.MEMORY_USED = MEMORY_USED
        self.MEMORY_USED_nsprefix_ = None
        self.RUNNING_CPU = RUNNING_CPU
        self.RUNNING_CPU_nsprefix_ = None
        self.RUNNING_CPU_USED = RUNNING_CPU_USED
        self.RUNNING_CPU_USED_nsprefix_ = None
        self.RUNNING_MEMORY = RUNNING_MEMORY
        self.RUNNING_MEMORY_nsprefix_ = None
        self.RUNNING_MEMORY_USED = RUNNING_MEMORY_USED
        self.RUNNING_MEMORY_USED_nsprefix_ = None
        self.RUNNING_VMS = RUNNING_VMS
        self.RUNNING_VMS_nsprefix_ = None
        self.RUNNING_VMS_USED = RUNNING_VMS_USED
        self.RUNNING_VMS_USED_nsprefix_ = None
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_nsprefix_ = None
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
        self.SYSTEM_DISK_SIZE_USED_nsprefix_ = None
        self.VMS = VMS
        self.VMS_nsprefix_ = None
        self.VMS_USED = VMS_USED
        self.VMS_USED_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType32.subclass:
            return VMType32.subclass(*args_, **kwargs_)
        else:
            return VMType32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CPU(self):
        return self.CPU
    def set_CPU(self, CPU):
        self.CPU = CPU
    def get_CPU_USED(self):
        return self.CPU_USED
    def set_CPU_USED(self, CPU_USED):
        self.CPU_USED = CPU_USED
    def get_MEMORY(self):
        return self.MEMORY
    def set_MEMORY(self, MEMORY):
        self.MEMORY = MEMORY
    def get_MEMORY_USED(self):
        return self.MEMORY_USED
    def set_MEMORY_USED(self, MEMORY_USED):
        self.MEMORY_USED = MEMORY_USED
    def get_RUNNING_CPU(self):
        return self.RUNNING_CPU
    def set_RUNNING_CPU(self, RUNNING_CPU):
        self.RUNNING_CPU = RUNNING_CPU
    def get_RUNNING_CPU_USED(self):
        return self.RUNNING_CPU_USED
    def set_RUNNING_CPU_USED(self, RUNNING_CPU_USED):
        self.RUNNING_CPU_USED = RUNNING_CPU_USED
    def get_RUNNING_MEMORY(self):
        return self.RUNNING_MEMORY
    def set_RUNNING_MEMORY(self, RUNNING_MEMORY):
        self.RUNNING_MEMORY = RUNNING_MEMORY
    def get_RUNNING_MEMORY_USED(self):
        return self.RUNNING_MEMORY_USED
    def set_RUNNING_MEMORY_USED(self, RUNNING_MEMORY_USED):
        self.RUNNING_MEMORY_USED = RUNNING_MEMORY_USED
    def get_RUNNING_VMS(self):
        return self.RUNNING_VMS
    def set_RUNNING_VMS(self, RUNNING_VMS):
        self.RUNNING_VMS = RUNNING_VMS
    def get_RUNNING_VMS_USED(self):
        return self.RUNNING_VMS_USED
    def set_RUNNING_VMS_USED(self, RUNNING_VMS_USED):
        self.RUNNING_VMS_USED = RUNNING_VMS_USED
    def get_SYSTEM_DISK_SIZE(self):
        return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE):
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_SYSTEM_DISK_SIZE_USED(self):
        return self.SYSTEM_DISK_SIZE_USED
    def set_SYSTEM_DISK_SIZE_USED(self, SYSTEM_DISK_SIZE_USED):
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
    def get_VMS(self):
        return self.VMS
    def set_VMS(self, VMS):
        self.VMS = VMS
    def get_VMS_USED(self):
        return self.VMS_USED
    def set_VMS_USED(self, VMS_USED):
        self.VMS_USED = VMS_USED
    def has__content(self):
        if (
            self.CPU is not None or
            self.CPU_USED is not None or
            self.MEMORY is not None or
            self.MEMORY_USED is not None or
            self.RUNNING_CPU is not None or
            self.RUNNING_CPU_USED is not None or
            self.RUNNING_MEMORY is not None or
            self.RUNNING_MEMORY_USED is not None or
            self.RUNNING_VMS is not None or
            self.RUNNING_VMS_USED is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.SYSTEM_DISK_SIZE_USED is not None or
            self.VMS is not None or
            self.VMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType32', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType32')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VMType32':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VMType32')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VMType32', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VMType32'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType32', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            namespaceprefix_ = self.CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU>%s</%sCPU>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), namespaceprefix_ , eol_))
        if self.CPU_USED is not None:
            namespaceprefix_ = self.CPU_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU_USED>%s</%sCPU_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPU_USED), input_name='CPU_USED')), namespaceprefix_ , eol_))
        if self.MEMORY is not None:
            namespaceprefix_ = self.MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY>%s</%sMEMORY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), namespaceprefix_ , eol_))
        if self.MEMORY_USED is not None:
            namespaceprefix_ = self.MEMORY_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY_USED>%s</%sMEMORY_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_USED), input_name='MEMORY_USED')), namespaceprefix_ , eol_))
        if self.RUNNING_CPU is not None:
            namespaceprefix_ = self.RUNNING_CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_CPU>%s</%sRUNNING_CPU>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_CPU), input_name='RUNNING_CPU')), namespaceprefix_ , eol_))
        if self.RUNNING_CPU_USED is not None:
            namespaceprefix_ = self.RUNNING_CPU_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_CPU_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_CPU_USED>%s</%sRUNNING_CPU_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_CPU_USED), input_name='RUNNING_CPU_USED')), namespaceprefix_ , eol_))
        if self.RUNNING_MEMORY is not None:
            namespaceprefix_ = self.RUNNING_MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_MEMORY>%s</%sRUNNING_MEMORY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_MEMORY), input_name='RUNNING_MEMORY')), namespaceprefix_ , eol_))
        if self.RUNNING_MEMORY_USED is not None:
            namespaceprefix_ = self.RUNNING_MEMORY_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_MEMORY_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_MEMORY_USED>%s</%sRUNNING_MEMORY_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_MEMORY_USED), input_name='RUNNING_MEMORY_USED')), namespaceprefix_ , eol_))
        if self.RUNNING_VMS is not None:
            namespaceprefix_ = self.RUNNING_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_VMS>%s</%sRUNNING_VMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_VMS), input_name='RUNNING_VMS')), namespaceprefix_ , eol_))
        if self.RUNNING_VMS_USED is not None:
            namespaceprefix_ = self.RUNNING_VMS_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNING_VMS_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRUNNING_VMS_USED>%s</%sRUNNING_VMS_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RUNNING_VMS_USED), input_name='RUNNING_VMS_USED')), namespaceprefix_ , eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            namespaceprefix_ = self.SYSTEM_DISK_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SYSTEM_DISK_SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYSTEM_DISK_SIZE>%s</%sSYSTEM_DISK_SIZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE), input_name='SYSTEM_DISK_SIZE')), namespaceprefix_ , eol_))
        if self.SYSTEM_DISK_SIZE_USED is not None:
            namespaceprefix_ = self.SYSTEM_DISK_SIZE_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.SYSTEM_DISK_SIZE_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYSTEM_DISK_SIZE_USED>%s</%sSYSTEM_DISK_SIZE_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE_USED), input_name='SYSTEM_DISK_SIZE_USED')), namespaceprefix_ , eol_))
        if self.VMS is not None:
            namespaceprefix_ = self.VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMS>%s</%sVMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VMS), input_name='VMS')), namespaceprefix_ , eol_))
        if self.VMS_USED is not None:
            namespaceprefix_ = self.VMS_USED_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_USED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMS_USED>%s</%sVMS_USED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VMS_USED), input_name='VMS_USED')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CPU':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPU')
            value_ = self.gds_validate_string(value_, node, 'CPU')
            self.CPU = value_
            self.CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'CPU_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPU_USED')
            value_ = self.gds_validate_string(value_, node, 'CPU_USED')
            self.CPU_USED = value_
            self.CPU_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY')
            value_ = self.gds_validate_string(value_, node, 'MEMORY')
            self.MEMORY = value_
            self.MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY_USED')
            value_ = self.gds_validate_string(value_, node, 'MEMORY_USED')
            self.MEMORY_USED = value_
            self.MEMORY_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_CPU':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_CPU')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_CPU')
            self.RUNNING_CPU = value_
            self.RUNNING_CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_CPU_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_CPU_USED')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_CPU_USED')
            self.RUNNING_CPU_USED = value_
            self.RUNNING_CPU_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_MEMORY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_MEMORY')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_MEMORY')
            self.RUNNING_MEMORY = value_
            self.RUNNING_MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_MEMORY_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_MEMORY_USED')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_MEMORY_USED')
            self.RUNNING_MEMORY_USED = value_
            self.RUNNING_MEMORY_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_VMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_VMS')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_VMS')
            self.RUNNING_VMS = value_
            self.RUNNING_VMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'RUNNING_VMS_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RUNNING_VMS_USED')
            value_ = self.gds_validate_string(value_, node, 'RUNNING_VMS_USED')
            self.RUNNING_VMS_USED = value_
            self.RUNNING_VMS_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYSTEM_DISK_SIZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SYSTEM_DISK_SIZE')
            value_ = self.gds_validate_string(value_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = value_
            self.SYSTEM_DISK_SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYSTEM_DISK_SIZE_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SYSTEM_DISK_SIZE_USED')
            value_ = self.gds_validate_string(value_, node, 'SYSTEM_DISK_SIZE_USED')
            self.SYSTEM_DISK_SIZE_USED = value_
            self.SYSTEM_DISK_SIZE_USED_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VMS')
            value_ = self.gds_validate_string(value_, node, 'VMS')
            self.VMS = value_
            self.VMS_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMS_USED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VMS_USED')
            value_ = self.gds_validate_string(value_, node, 'VMS_USED')
            self.VMS_USED = value_
            self.VMS_USED_nsprefix_ = child_.prefix
# end class VMType32


class GROUPSType33(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GROUPSType33)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GROUPSType33.subclass:
            return GROUPSType33.subclass(*args_, **kwargs_)
        else:
            return GROUPSType33(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='GROUPSType33', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GROUPSType33')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GROUPSType33':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GROUPSType33')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GROUPSType33', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GROUPSType33'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='GROUPSType33', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class GROUPSType33


class CLUSTERSType34(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CLUSTER=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CLUSTER is None:
            self.CLUSTER = []
        else:
            self.CLUSTER = CLUSTER
        self.CLUSTER_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTERSType34)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTERSType34.subclass:
            return CLUSTERSType34.subclass(*args_, **kwargs_)
        else:
            return CLUSTERSType34(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CLUSTER(self):
        return self.CLUSTER
    def set_CLUSTER(self, CLUSTER):
        self.CLUSTER = CLUSTER
    def add_CLUSTER(self, value):
        self.CLUSTER.append(value)
    def insert_CLUSTER_at(self, index, value):
        self.CLUSTER.insert(index, value)
    def replace_CLUSTER_at(self, index, value):
        self.CLUSTER[index] = value
    def has__content(self):
        if (
            self.CLUSTER
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTERSType34', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTERSType34')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CLUSTERSType34':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CLUSTERSType34')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CLUSTERSType34', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CLUSTERSType34'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTERSType34', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CLUSTER_ in self.CLUSTER:
            namespaceprefix_ = self.CLUSTER_nsprefix_ + ':' if (UseCapturedNS_ and self.CLUSTER_nsprefix_) else ''
            CLUSTER_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CLUSTER', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CLUSTER':
            obj_ = CLUSTERType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CLUSTER.append(obj_)
            obj_.original_tagname_ = 'CLUSTER'
# end class CLUSTERSType34


class CLUSTERType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ZONE_ID=None, CLUSTER_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ZONE_ID = ZONE_ID
        self.ZONE_ID_nsprefix_ = None
        self.CLUSTER_ID = CLUSTER_ID
        self.CLUSTER_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTERType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTERType.subclass:
            return CLUSTERType.subclass(*args_, **kwargs_)
        else:
            return CLUSTERType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ZONE_ID(self):
        return self.ZONE_ID
    def set_ZONE_ID(self, ZONE_ID):
        self.ZONE_ID = ZONE_ID
    def get_CLUSTER_ID(self):
        return self.CLUSTER_ID
    def set_CLUSTER_ID(self, CLUSTER_ID):
        self.CLUSTER_ID = CLUSTER_ID
    def has__content(self):
        if (
            self.ZONE_ID is not None or
            self.CLUSTER_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTERType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTERType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CLUSTERType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CLUSTERType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CLUSTERType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CLUSTERType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTERType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZONE_ID is not None:
            namespaceprefix_ = self.ZONE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ZONE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZONE_ID>%s</%sZONE_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ZONE_ID, input_name='ZONE_ID'), namespaceprefix_ , eol_))
        if self.CLUSTER_ID is not None:
            namespaceprefix_ = self.CLUSTER_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.CLUSTER_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLUSTER_ID>%s</%sCLUSTER_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.CLUSTER_ID, input_name='CLUSTER_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ZONE_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ZONE_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ZONE_ID')
            self.ZONE_ID = ival_
            self.ZONE_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'CLUSTER_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CLUSTER_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'CLUSTER_ID')
            self.CLUSTER_ID = ival_
            self.CLUSTER_ID_nsprefix_ = child_.prefix
# end class CLUSTERType


class HOSTSType35(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, HOST=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if HOST is None:
            self.HOST = []
        else:
            self.HOST = HOST
        self.HOST_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOSTSType35)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOSTSType35.subclass:
            return HOSTSType35.subclass(*args_, **kwargs_)
        else:
            return HOSTSType35(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HOST(self):
        return self.HOST
    def set_HOST(self, HOST):
        self.HOST = HOST
    def add_HOST(self, value):
        self.HOST.append(value)
    def insert_HOST_at(self, index, value):
        self.HOST.insert(index, value)
    def replace_HOST_at(self, index, value):
        self.HOST[index] = value
    def has__content(self):
        if (
            self.HOST
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOSTSType35', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOSTSType35')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HOSTSType35':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HOSTSType35')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HOSTSType35', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HOSTSType35'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOSTSType35', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HOST_ in self.HOST:
            namespaceprefix_ = self.HOST_nsprefix_ + ':' if (UseCapturedNS_ and self.HOST_nsprefix_) else ''
            HOST_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HOST', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HOST':
            obj_ = HOSTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HOST.append(obj_)
            obj_.original_tagname_ = 'HOST'
# end class HOSTSType35


class HOSTType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ZONE_ID=None, HOST_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ZONE_ID = ZONE_ID
        self.ZONE_ID_nsprefix_ = None
        self.HOST_ID = HOST_ID
        self.HOST_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOSTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOSTType.subclass:
            return HOSTType.subclass(*args_, **kwargs_)
        else:
            return HOSTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ZONE_ID(self):
        return self.ZONE_ID
    def set_ZONE_ID(self, ZONE_ID):
        self.ZONE_ID = ZONE_ID
    def get_HOST_ID(self):
        return self.HOST_ID
    def set_HOST_ID(self, HOST_ID):
        self.HOST_ID = HOST_ID
    def has__content(self):
        if (
            self.ZONE_ID is not None or
            self.HOST_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOSTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOSTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HOSTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HOSTType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HOSTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HOSTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HOSTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZONE_ID is not None:
            namespaceprefix_ = self.ZONE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ZONE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZONE_ID>%s</%sZONE_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ZONE_ID, input_name='ZONE_ID'), namespaceprefix_ , eol_))
        if self.HOST_ID is not None:
            namespaceprefix_ = self.HOST_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.HOST_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHOST_ID>%s</%sHOST_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.HOST_ID, input_name='HOST_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ZONE_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ZONE_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ZONE_ID')
            self.ZONE_ID = ival_
            self.ZONE_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'HOST_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'HOST_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'HOST_ID')
            self.HOST_ID = ival_
            self.HOST_ID_nsprefix_ = child_.prefix
# end class HOSTType


class DATASTORESType36(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATASTORE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DATASTORE is None:
            self.DATASTORE = []
        else:
            self.DATASTORE = DATASTORE
        self.DATASTORE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORESType36)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORESType36.subclass:
            return DATASTORESType36.subclass(*args_, **kwargs_)
        else:
            return DATASTORESType36(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATASTORE(self):
        return self.DATASTORE
    def set_DATASTORE(self, DATASTORE):
        self.DATASTORE = DATASTORE
    def add_DATASTORE(self, value):
        self.DATASTORE.append(value)
    def insert_DATASTORE_at(self, index, value):
        self.DATASTORE.insert(index, value)
    def replace_DATASTORE_at(self, index, value):
        self.DATASTORE[index] = value
    def has__content(self):
        if (
            self.DATASTORE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORESType36', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORESType36')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATASTORESType36':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATASTORESType36')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATASTORESType36', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATASTORESType36'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTORESType36', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASTORE_ in self.DATASTORE:
            namespaceprefix_ = self.DATASTORE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_nsprefix_) else ''
            DATASTORE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASTORE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATASTORE':
            obj_ = DATASTOREType37.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASTORE.append(obj_)
            obj_.original_tagname_ = 'DATASTORE'
# end class DATASTORESType36


class DATASTOREType37(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ZONE_ID=None, DATASTORE_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ZONE_ID = ZONE_ID
        self.ZONE_ID_nsprefix_ = None
        self.DATASTORE_ID = DATASTORE_ID
        self.DATASTORE_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTOREType37)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTOREType37.subclass:
            return DATASTOREType37.subclass(*args_, **kwargs_)
        else:
            return DATASTOREType37(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ZONE_ID(self):
        return self.ZONE_ID
    def set_ZONE_ID(self, ZONE_ID):
        self.ZONE_ID = ZONE_ID
    def get_DATASTORE_ID(self):
        return self.DATASTORE_ID
    def set_DATASTORE_ID(self, DATASTORE_ID):
        self.DATASTORE_ID = DATASTORE_ID
    def has__content(self):
        if (
            self.ZONE_ID is not None or
            self.DATASTORE_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTOREType37', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTOREType37')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATASTOREType37':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATASTOREType37')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATASTOREType37', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATASTOREType37'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DATASTOREType37', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZONE_ID is not None:
            namespaceprefix_ = self.ZONE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ZONE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZONE_ID>%s</%sZONE_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ZONE_ID, input_name='ZONE_ID'), namespaceprefix_ , eol_))
        if self.DATASTORE_ID is not None:
            namespaceprefix_ = self.DATASTORE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASTORE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATASTORE_ID>%s</%sDATASTORE_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.DATASTORE_ID, input_name='DATASTORE_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ZONE_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ZONE_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ZONE_ID')
            self.ZONE_ID = ival_
            self.ZONE_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATASTORE_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DATASTORE_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'DATASTORE_ID')
            self.DATASTORE_ID = ival_
            self.DATASTORE_ID_nsprefix_ = child_.prefix
# end class DATASTOREType37


class VNETSType38(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VNET=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if VNET is None:
            self.VNET = []
        else:
            self.VNET = VNET
        self.VNET_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNETSType38)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNETSType38.subclass:
            return VNETSType38.subclass(*args_, **kwargs_)
        else:
            return VNETSType38(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VNET(self):
        return self.VNET
    def set_VNET(self, VNET):
        self.VNET = VNET
    def add_VNET(self, value):
        self.VNET.append(value)
    def insert_VNET_at(self, index, value):
        self.VNET.insert(index, value)
    def replace_VNET_at(self, index, value):
        self.VNET[index] = value
    def has__content(self):
        if (
            self.VNET
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNETSType38', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNETSType38')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VNETSType38':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VNETSType38')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VNETSType38', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VNETSType38'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNETSType38', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VNET_ in self.VNET:
            namespaceprefix_ = self.VNET_nsprefix_ + ':' if (UseCapturedNS_ and self.VNET_nsprefix_) else ''
            VNET_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VNET', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VNET':
            obj_ = VNETType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VNET.append(obj_)
            obj_.original_tagname_ = 'VNET'
# end class VNETSType38


class VNETType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ZONE_ID=None, VNET_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ZONE_ID = ZONE_ID
        self.ZONE_ID_nsprefix_ = None
        self.VNET_ID = VNET_ID
        self.VNET_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNETType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNETType.subclass:
            return VNETType.subclass(*args_, **kwargs_)
        else:
            return VNETType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ZONE_ID(self):
        return self.ZONE_ID
    def set_ZONE_ID(self, ZONE_ID):
        self.ZONE_ID = ZONE_ID
    def get_VNET_ID(self):
        return self.VNET_ID
    def set_VNET_ID(self, VNET_ID):
        self.VNET_ID = VNET_ID
    def has__content(self):
        if (
            self.ZONE_ID is not None or
            self.VNET_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNETType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNETType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VNETType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VNETType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VNETType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VNETType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNETType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZONE_ID is not None:
            namespaceprefix_ = self.ZONE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ZONE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZONE_ID>%s</%sZONE_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ZONE_ID, input_name='ZONE_ID'), namespaceprefix_ , eol_))
        if self.VNET_ID is not None:
            namespaceprefix_ = self.VNET_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.VNET_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVNET_ID>%s</%sVNET_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.VNET_ID, input_name='VNET_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ZONE_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ZONE_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ZONE_ID')
            self.ZONE_ID = ival_
            self.ZONE_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'VNET_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VNET_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'VNET_ID')
            self.VNET_ID = ival_
            self.VNET_ID_nsprefix_ = child_.prefix
# end class VNETType


class PERMISSIONSType39(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType39)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType39.subclass:
            return PERMISSIONSType39.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType39(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType39', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType39')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONSType39':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONSType39')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONSType39', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONSType39'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType39', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONSType39


class LOCKType40(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LOCKED=None, OWNER=None, TIME=None, REQ_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LOCKED = LOCKED
        self.LOCKED_nsprefix_ = None
        self.OWNER = OWNER
        self.OWNER_nsprefix_ = None
        self.TIME = TIME
        self.TIME_nsprefix_ = None
        self.REQ_ID = REQ_ID
        self.REQ_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOCKType40)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOCKType40.subclass:
            return LOCKType40.subclass(*args_, **kwargs_)
        else:
            return LOCKType40(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LOCKED(self):
        return self.LOCKED
    def set_LOCKED(self, LOCKED):
        self.LOCKED = LOCKED
    def get_OWNER(self):
        return self.OWNER
    def set_OWNER(self, OWNER):
        self.OWNER = OWNER
    def get_TIME(self):
        return self.TIME
    def set_TIME(self, TIME):
        self.TIME = TIME
    def get_REQ_ID(self):
        return self.REQ_ID
    def set_REQ_ID(self, REQ_ID):
        self.REQ_ID = REQ_ID
    def has__content(self):
        if (
            self.LOCKED is not None or
            self.OWNER is not None or
            self.TIME is not None or
            self.REQ_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType40', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOCKType40')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LOCKType40':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LOCKType40')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LOCKType40', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LOCKType40'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType40', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LOCKED is not None:
            namespaceprefix_ = self.LOCKED_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCKED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOCKED>%s</%sLOCKED>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOCKED, input_name='LOCKED'), namespaceprefix_ , eol_))
        if self.OWNER is not None:
            namespaceprefix_ = self.OWNER_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER>%s</%sOWNER>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER, input_name='OWNER'), namespaceprefix_ , eol_))
        if self.TIME is not None:
            namespaceprefix_ = self.TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIME>%s</%sTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIME, input_name='TIME'), namespaceprefix_ , eol_))
        if self.REQ_ID is not None:
            namespaceprefix_ = self.REQ_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.REQ_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREQ_ID>%s</%sREQ_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.REQ_ID, input_name='REQ_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LOCKED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOCKED')
            ival_ = self.gds_validate_integer(ival_, node, 'LOCKED')
            self.LOCKED = ival_
            self.LOCKED_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER')
            self.OWNER = ival_
            self.OWNER_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'TIME')
            self.TIME = ival_
            self.TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'REQ_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REQ_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'REQ_ID')
            self.REQ_ID = ival_
            self.REQ_ID_nsprefix_ = child_.prefix
# end class LOCKType40


class ROLESType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ROLE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ROLE is None:
            self.ROLE = []
        else:
            self.ROLE = ROLE
        self.ROLE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ROLESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ROLESType.subclass:
            return ROLESType.subclass(*args_, **kwargs_)
        else:
            return ROLESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ROLE(self):
        return self.ROLE
    def set_ROLE(self, ROLE):
        self.ROLE = ROLE
    def add_ROLE(self, value):
        self.ROLE.append(value)
    def insert_ROLE_at(self, index, value):
        self.ROLE.insert(index, value)
    def replace_ROLE_at(self, index, value):
        self.ROLE[index] = value
    def has__content(self):
        if (
            self.ROLE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ROLESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ROLESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ROLESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ROLESType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ROLESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ROLESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ROLESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ROLE_ in self.ROLE:
            namespaceprefix_ = self.ROLE_nsprefix_ + ':' if (UseCapturedNS_ and self.ROLE_nsprefix_) else ''
            ROLE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ROLE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ROLE':
            obj_ = ROLEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ROLE.append(obj_)
            obj_.original_tagname_ = 'ROLE'
# end class ROLESType


class ROLEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, HOST_AFFINED=None, HOST_ANTI_AFFINED=None, ID=None, NAME=None, POLICY=None, VMS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.HOST_AFFINED = HOST_AFFINED
        self.HOST_AFFINED_nsprefix_ = None
        self.HOST_ANTI_AFFINED = HOST_ANTI_AFFINED
        self.HOST_ANTI_AFFINED_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.POLICY = POLICY
        self.POLICY_nsprefix_ = None
        self.VMS = VMS
        self.VMS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ROLEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ROLEType.subclass:
            return ROLEType.subclass(*args_, **kwargs_)
        else:
            return ROLEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HOST_AFFINED(self):
        return self.HOST_AFFINED
    def set_HOST_AFFINED(self, HOST_AFFINED):
        self.HOST_AFFINED = HOST_AFFINED
    def get_HOST_ANTI_AFFINED(self):
        return self.HOST_ANTI_AFFINED
    def set_HOST_ANTI_AFFINED(self, HOST_ANTI_AFFINED):
        self.HOST_ANTI_AFFINED = HOST_ANTI_AFFINED
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_POLICY(self):
        return self.POLICY
    def set_POLICY(self, POLICY):
        self.POLICY = POLICY
    def get_VMS(self):
        return self.VMS
    def set_VMS(self, VMS):
        self.VMS = VMS
    def has__content(self):
        if (
            self.HOST_AFFINED is not None or
            self.HOST_ANTI_AFFINED is not None or
            self.ID is not None or
            self.NAME is not None or
            self.POLICY is not None or
            self.VMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ROLEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ROLEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ROLEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ROLEType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ROLEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ROLEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ROLEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HOST_AFFINED is not None:
            namespaceprefix_ = self.HOST_AFFINED_nsprefix_ + ':' if (UseCapturedNS_ and self.HOST_AFFINED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHOST_AFFINED>%s</%sHOST_AFFINED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.HOST_AFFINED), input_name='HOST_AFFINED')), namespaceprefix_ , eol_))
        if self.HOST_ANTI_AFFINED is not None:
            namespaceprefix_ = self.HOST_ANTI_AFFINED_nsprefix_ + ':' if (UseCapturedNS_ and self.HOST_ANTI_AFFINED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHOST_ANTI_AFFINED>%s</%sHOST_ANTI_AFFINED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.HOST_ANTI_AFFINED), input_name='HOST_ANTI_AFFINED')), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.POLICY is not None:
            namespaceprefix_ = self.POLICY_nsprefix_ + ':' if (UseCapturedNS_ and self.POLICY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPOLICY>%s</%sPOLICY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.POLICY), input_name='POLICY')), namespaceprefix_ , eol_))
        if self.VMS is not None:
            namespaceprefix_ = self.VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.VMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMS>%s</%sVMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VMS), input_name='VMS')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HOST_AFFINED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'HOST_AFFINED')
            value_ = self.gds_validate_string(value_, node, 'HOST_AFFINED')
            self.HOST_AFFINED = value_
            self.HOST_AFFINED_nsprefix_ = child_.prefix
        elif nodeName_ == 'HOST_ANTI_AFFINED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'HOST_ANTI_AFFINED')
            value_ = self.gds_validate_string(value_, node, 'HOST_ANTI_AFFINED')
            self.HOST_ANTI_AFFINED = value_
            self.HOST_ANTI_AFFINED_nsprefix_ = child_.prefix
        elif nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'POLICY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'POLICY')
            value_ = self.gds_validate_string(value_, node, 'POLICY')
            self.POLICY = value_
            self.POLICY_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VMS')
            value_ = self.gds_validate_string(value_, node, 'VMS')
            self.VMS = value_
            self.VMS_nsprefix_ = child_.prefix
# end class ROLEType


class VMType41(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, LAST_POLL=None, STATE=None, LCM_STATE=None, RESCHED=None, STIME=None, ETIME=None, DEPLOY_ID=None, TEMPLATE=None, MONITORING=None, USER_TEMPLATE=None, HISTORY_RECORDS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.LAST_POLL = LAST_POLL
        self.LAST_POLL_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.LCM_STATE = LCM_STATE
        self.LCM_STATE_nsprefix_ = None
        self.RESCHED = RESCHED
        self.RESCHED_nsprefix_ = None
        self.STIME = STIME
        self.STIME_nsprefix_ = None
        self.ETIME = ETIME
        self.ETIME_nsprefix_ = None
        self.DEPLOY_ID = DEPLOY_ID
        self.DEPLOY_ID_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.MONITORING = MONITORING
        self.MONITORING_nsprefix_ = None
        self.USER_TEMPLATE = USER_TEMPLATE
        self.USER_TEMPLATE_nsprefix_ = None
        self.HISTORY_RECORDS = HISTORY_RECORDS
        self.HISTORY_RECORDS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType41)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType41.subclass:
            return VMType41.subclass(*args_, **kwargs_)
        else:
            return VMType41(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_LAST_POLL(self):
        return self.LAST_POLL
    def set_LAST_POLL(self, LAST_POLL):
        self.LAST_POLL = LAST_POLL
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_LCM_STATE(self):
        return self.LCM_STATE
    def set_LCM_STATE(self, LCM_STATE):
        self.LCM_STATE = LCM_STATE
    def get_RESCHED(self):
        return self.RESCHED
    def set_RESCHED(self, RESCHED):
        self.RESCHED = RESCHED
    def get_STIME(self):
        return self.STIME
    def set_STIME(self, STIME):
        self.STIME = STIME
    def get_ETIME(self):
        return self.ETIME
    def set_ETIME(self, ETIME):
        self.ETIME = ETIME
    def get_DEPLOY_ID(self):
        return self.DEPLOY_ID
    def set_DEPLOY_ID(self, DEPLOY_ID):
        self.DEPLOY_ID = DEPLOY_ID
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_MONITORING(self):
        return self.MONITORING
    def set_MONITORING(self, MONITORING):
        self.MONITORING = MONITORING
    def get_USER_TEMPLATE(self):
        return self.USER_TEMPLATE
    def set_USER_TEMPLATE(self, USER_TEMPLATE):
        self.USER_TEMPLATE = USER_TEMPLATE
    def get_HISTORY_RECORDS(self):
        return self.HISTORY_RECORDS
    def set_HISTORY_RECORDS(self, HISTORY_RECORDS):
        self.HISTORY_RECORDS = HISTORY_RECORDS
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.LAST_POLL is not None or
            self.STATE is not None or
            self.LCM_STATE is not None or
            self.RESCHED is not None or
            self.STIME is not None or
            self.ETIME is not None or
            self.DEPLOY_ID is not None or
            self.TEMPLATE is not None or
            self.MONITORING is not None or
            self.USER_TEMPLATE is not None or
            self.HISTORY_RECORDS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType41', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType41')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VMType41':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VMType41')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VMType41', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VMType41'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMType41', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.LAST_POLL is not None:
            namespaceprefix_ = self.LAST_POLL_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_POLL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_POLL>%s</%sLAST_POLL>%s' % (namespaceprefix_ , self.gds_format_integer(self.LAST_POLL, input_name='LAST_POLL'), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.LCM_STATE is not None:
            namespaceprefix_ = self.LCM_STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.LCM_STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLCM_STATE>%s</%sLCM_STATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.LCM_STATE, input_name='LCM_STATE'), namespaceprefix_ , eol_))
        if self.RESCHED is not None:
            namespaceprefix_ = self.RESCHED_nsprefix_ + ':' if (UseCapturedNS_ and self.RESCHED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRESCHED>%s</%sRESCHED>%s' % (namespaceprefix_ , self.gds_format_integer(self.RESCHED, input_name='RESCHED'), namespaceprefix_ , eol_))
        if self.STIME is not None:
            namespaceprefix_ = self.STIME_nsprefix_ + ':' if (UseCapturedNS_ and self.STIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTIME>%s</%sSTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.STIME, input_name='STIME'), namespaceprefix_ , eol_))
        if self.ETIME is not None:
            namespaceprefix_ = self.ETIME_nsprefix_ + ':' if (UseCapturedNS_ and self.ETIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sETIME>%s</%sETIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.ETIME, input_name='ETIME'), namespaceprefix_ , eol_))
        if self.DEPLOY_ID is not None:
            namespaceprefix_ = self.DEPLOY_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.DEPLOY_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDEPLOY_ID>%s</%sDEPLOY_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DEPLOY_ID), input_name='DEPLOY_ID')), namespaceprefix_ , eol_))
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            self.TEMPLATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEMPLATE', pretty_print=pretty_print)
        if self.MONITORING is not None:
            namespaceprefix_ = self.MONITORING_nsprefix_ + ':' if (UseCapturedNS_ and self.MONITORING_nsprefix_) else ''
            self.MONITORING.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MONITORING', pretty_print=pretty_print)
        if self.USER_TEMPLATE is not None:
            namespaceprefix_ = self.USER_TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.USER_TEMPLATE_nsprefix_) else ''
            self.USER_TEMPLATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='USER_TEMPLATE', pretty_print=pretty_print)
        if self.HISTORY_RECORDS is not None:
            namespaceprefix_ = self.HISTORY_RECORDS_nsprefix_ + ':' if (UseCapturedNS_ and self.HISTORY_RECORDS_nsprefix_) else ''
            self.HISTORY_RECORDS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HISTORY_RECORDS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'LAST_POLL' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LAST_POLL')
            ival_ = self.gds_validate_integer(ival_, node, 'LAST_POLL')
            self.LAST_POLL = ival_
            self.LAST_POLL_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'LCM_STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LCM_STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'LCM_STATE')
            self.LCM_STATE = ival_
            self.LCM_STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'RESCHED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RESCHED')
            ival_ = self.gds_validate_integer(ival_, node, 'RESCHED')
            self.RESCHED = ival_
            self.RESCHED_nsprefix_ = child_.prefix
        elif nodeName_ == 'STIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STIME')
            ival_ = self.gds_validate_integer(ival_, node, 'STIME')
            self.STIME = ival_
            self.STIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'ETIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ETIME')
            ival_ = self.gds_validate_integer(ival_, node, 'ETIME')
            self.ETIME = ival_
            self.ETIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'DEPLOY_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DEPLOY_ID')
            value_ = self.gds_validate_string(value_, node, 'DEPLOY_ID')
            self.DEPLOY_ID = value_
            self.DEPLOY_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'TEMPLATE':
            obj_ = TEMPLATEType42.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEMPLATE = obj_
            obj_.original_tagname_ = 'TEMPLATE'
        elif nodeName_ == 'MONITORING':
            obj_ = MONITORINGType43.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MONITORING = obj_
            obj_.original_tagname_ = 'MONITORING'
        elif nodeName_ == 'USER_TEMPLATE':
            obj_ = USER_TEMPLATEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.USER_TEMPLATE = obj_
            obj_.original_tagname_ = 'USER_TEMPLATE'
        elif nodeName_ == 'HISTORY_RECORDS':
            obj_ = HISTORY_RECORDSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HISTORY_RECORDS = obj_
            obj_.original_tagname_ = 'HISTORY_RECORDS'
# end class VMType41


class TEMPLATEType42(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CPU=None, MEMORY=None, VCPU=None, DISK=None, NIC=None, GRAPHICS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CPU = CPU
        self.CPU_nsprefix_ = None
        self.MEMORY = MEMORY
        self.MEMORY_nsprefix_ = None
        self.VCPU = VCPU
        self.VCPU_nsprefix_ = None
        if DISK is None:
            self.DISK = []
        else:
            self.DISK = DISK
        self.DISK_nsprefix_ = None
        if NIC is None:
            self.NIC = []
        else:
            self.NIC = NIC
        self.NIC_nsprefix_ = None
        self.GRAPHICS = GRAPHICS
        self.GRAPHICS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEMPLATEType42)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEMPLATEType42.subclass:
            return TEMPLATEType42.subclass(*args_, **kwargs_)
        else:
            return TEMPLATEType42(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CPU(self):
        return self.CPU
    def set_CPU(self, CPU):
        self.CPU = CPU
    def get_MEMORY(self):
        return self.MEMORY
    def set_MEMORY(self, MEMORY):
        self.MEMORY = MEMORY
    def get_VCPU(self):
        return self.VCPU
    def set_VCPU(self, VCPU):
        self.VCPU = VCPU
    def get_DISK(self):
        return self.DISK
    def set_DISK(self, DISK):
        self.DISK = DISK
    def add_DISK(self, value):
        self.DISK.append(value)
    def insert_DISK_at(self, index, value):
        self.DISK.insert(index, value)
    def replace_DISK_at(self, index, value):
        self.DISK[index] = value
    def get_NIC(self):
        return self.NIC
    def set_NIC(self, NIC):
        self.NIC = NIC
    def add_NIC(self, value):
        self.NIC.append(value)
    def insert_NIC_at(self, index, value):
        self.NIC.insert(index, value)
    def replace_NIC_at(self, index, value):
        self.NIC[index] = value
    def get_GRAPHICS(self):
        return self.GRAPHICS
    def set_GRAPHICS(self, GRAPHICS):
        self.GRAPHICS = GRAPHICS
    def has__content(self):
        if (
            self.CPU is not None or
            self.MEMORY is not None or
            self.VCPU is not None or
            self.DISK or
            self.NIC or
            self.GRAPHICS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType42', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEMPLATEType42')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEMPLATEType42':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEMPLATEType42')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEMPLATEType42', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEMPLATEType42'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType42', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            namespaceprefix_ = self.CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU>%s</%sCPU>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), namespaceprefix_ , eol_))
        if self.MEMORY is not None:
            namespaceprefix_ = self.MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY>%s</%sMEMORY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), namespaceprefix_ , eol_))
        if self.VCPU is not None:
            namespaceprefix_ = self.VCPU_nsprefix_ + ':' if (UseCapturedNS_ and self.VCPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVCPU>%s</%sVCPU>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VCPU), input_name='VCPU')), namespaceprefix_ , eol_))
        for DISK_ in self.DISK:
            namespaceprefix_ = self.DISK_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_nsprefix_) else ''
            DISK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DISK', pretty_print=pretty_print)
        for NIC_ in self.NIC:
            namespaceprefix_ = self.NIC_nsprefix_ + ':' if (UseCapturedNS_ and self.NIC_nsprefix_) else ''
            NIC_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NIC', pretty_print=pretty_print)
        if self.GRAPHICS is not None:
            namespaceprefix_ = self.GRAPHICS_nsprefix_ + ':' if (UseCapturedNS_ and self.GRAPHICS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGRAPHICS>%s</%sGRAPHICS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GRAPHICS), input_name='GRAPHICS')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CPU':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPU')
            value_ = self.gds_validate_string(value_, node, 'CPU')
            self.CPU = value_
            self.CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY')
            value_ = self.gds_validate_string(value_, node, 'MEMORY')
            self.MEMORY = value_
            self.MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'VCPU':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VCPU')
            value_ = self.gds_validate_string(value_, node, 'VCPU')
            self.VCPU = value_
            self.VCPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISK':
            obj_ = DISKType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DISK.append(obj_)
            obj_.original_tagname_ = 'DISK'
        elif nodeName_ == 'NIC':
            obj_ = NICType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NIC.append(obj_)
            obj_.original_tagname_ = 'NIC'
        elif nodeName_ == 'GRAPHICS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GRAPHICS')
            value_ = self.gds_validate_string(value_, node, 'GRAPHICS')
            self.GRAPHICS = value_
            self.GRAPHICS_nsprefix_ = child_.prefix
# end class TEMPLATEType42


class GRAPHICS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GRAPHICS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GRAPHICS.subclass:
            return GRAPHICS.subclass(*args_, **kwargs_)
        else:
            return GRAPHICS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GRAPHICS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GRAPHICS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GRAPHICS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GRAPHICS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GRAPHICS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GRAPHICS'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GRAPHICS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class GRAPHICS


class DISKType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DISKType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DISKType.subclass:
            return DISKType.subclass(*args_, **kwargs_)
        else:
            return DISKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DISKType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DISKType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DISKType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DISKType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DISKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DISKType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DISKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'DISKType')
        self.anytypeobjs_.append(content_)
# end class DISKType


class NICType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NICType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NICType.subclass:
            return NICType.subclass(*args_, **kwargs_)
        else:
            return NICType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NICType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NICType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NICType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NICType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NICType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NICType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NICType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'NICType')
        self.anytypeobjs_.append(content_)
# end class NICType


class MONITORINGType43(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MONITORINGType43)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MONITORINGType43.subclass:
            return MONITORINGType43.subclass(*args_, **kwargs_)
        else:
            return MONITORINGType43(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MONITORINGType43', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MONITORINGType43')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MONITORINGType43':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MONITORINGType43')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MONITORINGType43', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MONITORINGType43'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MONITORINGType43', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'MONITORINGType43')
        self.anytypeobjs_.append(content_)
# end class MONITORINGType43


class USER_TEMPLATEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LABELS=None, ERROR=None, SCHED_MESSAGE=None, SCHED_RANK=None, SCHED_DS_RANK=None, SCHED_REQUIREMENTS=None, SCHED_DS_REQUIREMENTS=None, USER_PRIORITY=None, SCHED_ACTION=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LABELS = LABELS
        self.LABELS_nsprefix_ = None
        self.ERROR = ERROR
        self.ERROR_nsprefix_ = None
        self.SCHED_MESSAGE = SCHED_MESSAGE
        self.SCHED_MESSAGE_nsprefix_ = None
        self.SCHED_RANK = SCHED_RANK
        self.SCHED_RANK_nsprefix_ = None
        self.SCHED_DS_RANK = SCHED_DS_RANK
        self.SCHED_DS_RANK_nsprefix_ = None
        self.SCHED_REQUIREMENTS = SCHED_REQUIREMENTS
        self.SCHED_REQUIREMENTS_nsprefix_ = None
        self.SCHED_DS_REQUIREMENTS = SCHED_DS_REQUIREMENTS
        self.SCHED_DS_REQUIREMENTS_nsprefix_ = None
        self.USER_PRIORITY = USER_PRIORITY
        self.USER_PRIORITY_nsprefix_ = None
        if SCHED_ACTION is None:
            self.SCHED_ACTION = []
        else:
            self.SCHED_ACTION = SCHED_ACTION
        self.SCHED_ACTION_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USER_TEMPLATEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USER_TEMPLATEType.subclass:
            return USER_TEMPLATEType.subclass(*args_, **kwargs_)
        else:
            return USER_TEMPLATEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LABELS(self):
        return self.LABELS
    def set_LABELS(self, LABELS):
        self.LABELS = LABELS
    def get_ERROR(self):
        return self.ERROR
    def set_ERROR(self, ERROR):
        self.ERROR = ERROR
    def get_SCHED_MESSAGE(self):
        return self.SCHED_MESSAGE
    def set_SCHED_MESSAGE(self, SCHED_MESSAGE):
        self.SCHED_MESSAGE = SCHED_MESSAGE
    def get_SCHED_RANK(self):
        return self.SCHED_RANK
    def set_SCHED_RANK(self, SCHED_RANK):
        self.SCHED_RANK = SCHED_RANK
    def get_SCHED_DS_RANK(self):
        return self.SCHED_DS_RANK
    def set_SCHED_DS_RANK(self, SCHED_DS_RANK):
        self.SCHED_DS_RANK = SCHED_DS_RANK
    def get_SCHED_REQUIREMENTS(self):
        return self.SCHED_REQUIREMENTS
    def set_SCHED_REQUIREMENTS(self, SCHED_REQUIREMENTS):
        self.SCHED_REQUIREMENTS = SCHED_REQUIREMENTS
    def get_SCHED_DS_REQUIREMENTS(self):
        return self.SCHED_DS_REQUIREMENTS
    def set_SCHED_DS_REQUIREMENTS(self, SCHED_DS_REQUIREMENTS):
        self.SCHED_DS_REQUIREMENTS = SCHED_DS_REQUIREMENTS
    def get_USER_PRIORITY(self):
        return self.USER_PRIORITY
    def set_USER_PRIORITY(self, USER_PRIORITY):
        self.USER_PRIORITY = USER_PRIORITY
    def get_SCHED_ACTION(self):
        return self.SCHED_ACTION
    def set_SCHED_ACTION(self, SCHED_ACTION):
        self.SCHED_ACTION = SCHED_ACTION
    def add_SCHED_ACTION(self, value):
        self.SCHED_ACTION.append(value)
    def insert_SCHED_ACTION_at(self, index, value):
        self.SCHED_ACTION.insert(index, value)
    def replace_SCHED_ACTION_at(self, index, value):
        self.SCHED_ACTION[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.LABELS is not None or
            self.ERROR is not None or
            self.SCHED_MESSAGE is not None or
            self.SCHED_RANK is not None or
            self.SCHED_DS_RANK is not None or
            self.SCHED_REQUIREMENTS is not None or
            self.SCHED_DS_REQUIREMENTS is not None or
            self.USER_PRIORITY is not None or
            self.SCHED_ACTION or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USER_TEMPLATEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USER_TEMPLATEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'USER_TEMPLATEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USER_TEMPLATEType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='USER_TEMPLATEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='USER_TEMPLATEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USER_TEMPLATEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABELS is not None:
            namespaceprefix_ = self.LABELS_nsprefix_ + ':' if (UseCapturedNS_ and self.LABELS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABELS>%s</%sLABELS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LABELS), input_name='LABELS')), namespaceprefix_ , eol_))
        if self.ERROR is not None:
            namespaceprefix_ = self.ERROR_nsprefix_ + ':' if (UseCapturedNS_ and self.ERROR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sERROR>%s</%sERROR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ERROR), input_name='ERROR')), namespaceprefix_ , eol_))
        if self.SCHED_MESSAGE is not None:
            namespaceprefix_ = self.SCHED_MESSAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_MESSAGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCHED_MESSAGE>%s</%sSCHED_MESSAGE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCHED_MESSAGE), input_name='SCHED_MESSAGE')), namespaceprefix_ , eol_))
        if self.SCHED_RANK is not None:
            namespaceprefix_ = self.SCHED_RANK_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_RANK_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCHED_RANK>%s</%sSCHED_RANK>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCHED_RANK), input_name='SCHED_RANK')), namespaceprefix_ , eol_))
        if self.SCHED_DS_RANK is not None:
            namespaceprefix_ = self.SCHED_DS_RANK_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_DS_RANK_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCHED_DS_RANK>%s</%sSCHED_DS_RANK>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCHED_DS_RANK), input_name='SCHED_DS_RANK')), namespaceprefix_ , eol_))
        if self.SCHED_REQUIREMENTS is not None:
            namespaceprefix_ = self.SCHED_REQUIREMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_REQUIREMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCHED_REQUIREMENTS>%s</%sSCHED_REQUIREMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCHED_REQUIREMENTS), input_name='SCHED_REQUIREMENTS')), namespaceprefix_ , eol_))
        if self.SCHED_DS_REQUIREMENTS is not None:
            namespaceprefix_ = self.SCHED_DS_REQUIREMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_DS_REQUIREMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCHED_DS_REQUIREMENTS>%s</%sSCHED_DS_REQUIREMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCHED_DS_REQUIREMENTS), input_name='SCHED_DS_REQUIREMENTS')), namespaceprefix_ , eol_))
        if self.USER_PRIORITY is not None:
            namespaceprefix_ = self.USER_PRIORITY_nsprefix_ + ':' if (UseCapturedNS_ and self.USER_PRIORITY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSER_PRIORITY>%s</%sUSER_PRIORITY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.USER_PRIORITY), input_name='USER_PRIORITY')), namespaceprefix_ , eol_))
        for SCHED_ACTION_ in self.SCHED_ACTION:
            namespaceprefix_ = self.SCHED_ACTION_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_ACTION_nsprefix_) else ''
            SCHED_ACTION_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SCHED_ACTION', pretty_print=pretty_print)
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LABELS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LABELS')
            value_ = self.gds_validate_string(value_, node, 'LABELS')
            self.LABELS = value_
            self.LABELS_nsprefix_ = child_.prefix
        elif nodeName_ == 'ERROR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ERROR')
            value_ = self.gds_validate_string(value_, node, 'ERROR')
            self.ERROR = value_
            self.ERROR_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHED_MESSAGE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCHED_MESSAGE')
            value_ = self.gds_validate_string(value_, node, 'SCHED_MESSAGE')
            self.SCHED_MESSAGE = value_
            self.SCHED_MESSAGE_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHED_RANK':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCHED_RANK')
            value_ = self.gds_validate_string(value_, node, 'SCHED_RANK')
            self.SCHED_RANK = value_
            self.SCHED_RANK_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHED_DS_RANK':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCHED_DS_RANK')
            value_ = self.gds_validate_string(value_, node, 'SCHED_DS_RANK')
            self.SCHED_DS_RANK = value_
            self.SCHED_DS_RANK_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHED_REQUIREMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCHED_REQUIREMENTS')
            value_ = self.gds_validate_string(value_, node, 'SCHED_REQUIREMENTS')
            self.SCHED_REQUIREMENTS = value_
            self.SCHED_REQUIREMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHED_DS_REQUIREMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCHED_DS_REQUIREMENTS')
            value_ = self.gds_validate_string(value_, node, 'SCHED_DS_REQUIREMENTS')
            self.SCHED_DS_REQUIREMENTS = value_
            self.SCHED_DS_REQUIREMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'USER_PRIORITY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'USER_PRIORITY')
            value_ = self.gds_validate_string(value_, node, 'USER_PRIORITY')
            self.USER_PRIORITY = value_
            self.USER_PRIORITY_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHED_ACTION':
            obj_ = SCHED_ACTIONType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SCHED_ACTION.append(obj_)
            obj_.original_tagname_ = 'SCHED_ACTION'
        else:
            content_ = self.gds_build_any(child_, 'USER_TEMPLATEType')
            self.anytypeobjs_.append(content_)
# end class USER_TEMPLATEType


class SCHED_ACTIONType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SCHED_ACTIONType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SCHED_ACTIONType.subclass:
            return SCHED_ACTIONType.subclass(*args_, **kwargs_)
        else:
            return SCHED_ACTIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def has__content(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SCHED_ACTIONType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SCHED_ACTIONType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SCHED_ACTIONType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SCHED_ACTIONType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SCHED_ACTIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SCHED_ACTIONType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SCHED_ACTIONType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'SCHED_ACTIONType')
        self.set_anytypeobjs_(content_)
# end class SCHED_ACTIONType


class HISTORY_RECORDSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, HISTORY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if HISTORY is None:
            self.HISTORY = []
        else:
            self.HISTORY = HISTORY
        self.HISTORY_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HISTORY_RECORDSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HISTORY_RECORDSType.subclass:
            return HISTORY_RECORDSType.subclass(*args_, **kwargs_)
        else:
            return HISTORY_RECORDSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HISTORY(self):
        return self.HISTORY
    def set_HISTORY(self, HISTORY):
        self.HISTORY = HISTORY
    def add_HISTORY(self, value):
        self.HISTORY.append(value)
    def insert_HISTORY_at(self, index, value):
        self.HISTORY.insert(index, value)
    def replace_HISTORY_at(self, index, value):
        self.HISTORY[index] = value
    def has__content(self):
        if (
            self.HISTORY
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HISTORY_RECORDSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HISTORY_RECORDSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HISTORY_RECORDSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HISTORY_RECORDSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HISTORY_RECORDSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HISTORY_RECORDSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HISTORY_RECORDSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HISTORY_ in self.HISTORY:
            namespaceprefix_ = self.HISTORY_nsprefix_ + ':' if (UseCapturedNS_ and self.HISTORY_nsprefix_) else ''
            HISTORY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HISTORY', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HISTORY':
            obj_ = HISTORYType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HISTORY.append(obj_)
            obj_.original_tagname_ = 'HISTORY'
# end class HISTORY_RECORDSType


class HISTORYType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OID=None, SEQ=None, HOSTNAME=None, HID=None, CID=None, DS_ID=None, VM_MAD=None, TM_MAD=None, ACTION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OID = OID
        self.OID_nsprefix_ = None
        self.SEQ = SEQ
        self.SEQ_nsprefix_ = None
        self.HOSTNAME = HOSTNAME
        self.HOSTNAME_nsprefix_ = None
        self.HID = HID
        self.HID_nsprefix_ = None
        self.CID = CID
        self.CID_nsprefix_ = None
        self.DS_ID = DS_ID
        self.DS_ID_nsprefix_ = None
        self.VM_MAD = VM_MAD
        self.VM_MAD_nsprefix_ = None
        self.TM_MAD = TM_MAD
        self.TM_MAD_nsprefix_ = None
        self.ACTION = ACTION
        self.ACTION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HISTORYType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HISTORYType.subclass:
            return HISTORYType.subclass(*args_, **kwargs_)
        else:
            return HISTORYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OID(self):
        return self.OID
    def set_OID(self, OID):
        self.OID = OID
    def get_SEQ(self):
        return self.SEQ
    def set_SEQ(self, SEQ):
        self.SEQ = SEQ
    def get_HOSTNAME(self):
        return self.HOSTNAME
    def set_HOSTNAME(self, HOSTNAME):
        self.HOSTNAME = HOSTNAME
    def get_HID(self):
        return self.HID
    def set_HID(self, HID):
        self.HID = HID
    def get_CID(self):
        return self.CID
    def set_CID(self, CID):
        self.CID = CID
    def get_DS_ID(self):
        return self.DS_ID
    def set_DS_ID(self, DS_ID):
        self.DS_ID = DS_ID
    def get_VM_MAD(self):
        return self.VM_MAD
    def set_VM_MAD(self, VM_MAD):
        self.VM_MAD = VM_MAD
    def get_TM_MAD(self):
        return self.TM_MAD
    def set_TM_MAD(self, TM_MAD):
        self.TM_MAD = TM_MAD
    def get_ACTION(self):
        return self.ACTION
    def set_ACTION(self, ACTION):
        self.ACTION = ACTION
    def has__content(self):
        if (
            self.OID is not None or
            self.SEQ is not None or
            self.HOSTNAME is not None or
            self.HID is not None or
            self.CID is not None or
            self.DS_ID is not None or
            self.VM_MAD is not None or
            self.TM_MAD is not None or
            self.ACTION is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HISTORYType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HISTORYType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HISTORYType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HISTORYType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HISTORYType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HISTORYType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HISTORYType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OID is not None:
            namespaceprefix_ = self.OID_nsprefix_ + ':' if (UseCapturedNS_ and self.OID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOID>%s</%sOID>%s' % (namespaceprefix_ , self.gds_format_integer(self.OID, input_name='OID'), namespaceprefix_ , eol_))
        if self.SEQ is not None:
            namespaceprefix_ = self.SEQ_nsprefix_ + ':' if (UseCapturedNS_ and self.SEQ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSEQ>%s</%sSEQ>%s' % (namespaceprefix_ , self.gds_format_integer(self.SEQ, input_name='SEQ'), namespaceprefix_ , eol_))
        if self.HOSTNAME is not None:
            namespaceprefix_ = self.HOSTNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.HOSTNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHOSTNAME>%s</%sHOSTNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.HOSTNAME), input_name='HOSTNAME')), namespaceprefix_ , eol_))
        if self.HID is not None:
            namespaceprefix_ = self.HID_nsprefix_ + ':' if (UseCapturedNS_ and self.HID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHID>%s</%sHID>%s' % (namespaceprefix_ , self.gds_format_integer(self.HID, input_name='HID'), namespaceprefix_ , eol_))
        if self.CID is not None:
            namespaceprefix_ = self.CID_nsprefix_ + ':' if (UseCapturedNS_ and self.CID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCID>%s</%sCID>%s' % (namespaceprefix_ , self.gds_format_integer(self.CID, input_name='CID'), namespaceprefix_ , eol_))
        if self.DS_ID is not None:
            namespaceprefix_ = self.DS_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.DS_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDS_ID>%s</%sDS_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.DS_ID, input_name='DS_ID'), namespaceprefix_ , eol_))
        if self.VM_MAD is not None:
            namespaceprefix_ = self.VM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM_MAD>%s</%sVM_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VM_MAD), input_name='VM_MAD')), namespaceprefix_ , eol_))
        if self.TM_MAD is not None:
            namespaceprefix_ = self.TM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.TM_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTM_MAD>%s</%sTM_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TM_MAD), input_name='TM_MAD')), namespaceprefix_ , eol_))
        if self.ACTION is not None:
            namespaceprefix_ = self.ACTION_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACTION>%s</%sACTION>%s' % (namespaceprefix_ , self.gds_format_integer(self.ACTION, input_name='ACTION'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OID')
            ival_ = self.gds_validate_integer(ival_, node, 'OID')
            self.OID = ival_
            self.OID_nsprefix_ = child_.prefix
        elif nodeName_ == 'SEQ' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SEQ')
            ival_ = self.gds_validate_integer(ival_, node, 'SEQ')
            self.SEQ = ival_
            self.SEQ_nsprefix_ = child_.prefix
        elif nodeName_ == 'HOSTNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'HOSTNAME')
            value_ = self.gds_validate_string(value_, node, 'HOSTNAME')
            self.HOSTNAME = value_
            self.HOSTNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'HID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'HID')
            ival_ = self.gds_validate_integer(ival_, node, 'HID')
            self.HID = ival_
            self.HID_nsprefix_ = child_.prefix
        elif nodeName_ == 'CID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CID')
            ival_ = self.gds_validate_integer(ival_, node, 'CID')
            self.CID = ival_
            self.CID_nsprefix_ = child_.prefix
        elif nodeName_ == 'DS_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DS_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'DS_ID')
            self.DS_ID = ival_
            self.DS_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'VM_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VM_MAD')
            value_ = self.gds_validate_string(value_, node, 'VM_MAD')
            self.VM_MAD = value_
            self.VM_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'TM_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TM_MAD')
            value_ = self.gds_validate_string(value_, node, 'TM_MAD')
            self.TM_MAD = value_
            self.TM_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'ACTION' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ACTION')
            ival_ = self.gds_validate_integer(ival_, node, 'ACTION')
            self.ACTION = ival_
            self.ACTION_nsprefix_ = child_.prefix
# end class HISTORYType


class LOCKType44(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LOCKED=None, OWNER=None, TIME=None, REQ_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LOCKED = LOCKED
        self.LOCKED_nsprefix_ = None
        self.OWNER = OWNER
        self.OWNER_nsprefix_ = None
        self.TIME = TIME
        self.TIME_nsprefix_ = None
        self.REQ_ID = REQ_ID
        self.REQ_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOCKType44)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOCKType44.subclass:
            return LOCKType44.subclass(*args_, **kwargs_)
        else:
            return LOCKType44(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LOCKED(self):
        return self.LOCKED
    def set_LOCKED(self, LOCKED):
        self.LOCKED = LOCKED
    def get_OWNER(self):
        return self.OWNER
    def set_OWNER(self, OWNER):
        self.OWNER = OWNER
    def get_TIME(self):
        return self.TIME
    def set_TIME(self, TIME):
        self.TIME = TIME
    def get_REQ_ID(self):
        return self.REQ_ID
    def set_REQ_ID(self, REQ_ID):
        self.REQ_ID = REQ_ID
    def has__content(self):
        if (
            self.LOCKED is not None or
            self.OWNER is not None or
            self.TIME is not None or
            self.REQ_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType44', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOCKType44')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LOCKType44':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LOCKType44')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LOCKType44', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LOCKType44'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType44', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LOCKED is not None:
            namespaceprefix_ = self.LOCKED_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCKED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOCKED>%s</%sLOCKED>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOCKED, input_name='LOCKED'), namespaceprefix_ , eol_))
        if self.OWNER is not None:
            namespaceprefix_ = self.OWNER_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER>%s</%sOWNER>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER, input_name='OWNER'), namespaceprefix_ , eol_))
        if self.TIME is not None:
            namespaceprefix_ = self.TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIME>%s</%sTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIME, input_name='TIME'), namespaceprefix_ , eol_))
        if self.REQ_ID is not None:
            namespaceprefix_ = self.REQ_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.REQ_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREQ_ID>%s</%sREQ_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.REQ_ID, input_name='REQ_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LOCKED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOCKED')
            ival_ = self.gds_validate_integer(ival_, node, 'LOCKED')
            self.LOCKED = ival_
            self.LOCKED_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER')
            self.OWNER = ival_
            self.OWNER_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'TIME')
            self.TIME = ival_
            self.TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'REQ_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REQ_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'REQ_ID')
            self.REQ_ID = ival_
            self.REQ_ID_nsprefix_ = child_.prefix
# end class LOCKType44


class PERMISSIONSType45(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType45)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType45.subclass:
            return PERMISSIONSType45.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType45(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType45', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType45')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONSType45':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONSType45')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONSType45', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONSType45'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType45', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONSType45


class TEMPLATEType46(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEMPLATEType46)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEMPLATEType46.subclass:
            return TEMPLATEType46.subclass(*args_, **kwargs_)
        else:
            return TEMPLATEType46(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType46', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEMPLATEType46')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEMPLATEType46':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEMPLATEType46')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEMPLATEType46', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEMPLATEType46'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType46', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'TEMPLATEType46')
        self.anytypeobjs_.append(content_)
# end class TEMPLATEType46


class MONITORINGType47(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CPU=None, CPU_FORECAST=None, CPU_FORECAST_FAR=None, DISKRDBYTES=None, DISKRDBYTES_BW=None, DISKRDBYTES_BW_FORECAST=None, DISKRDBYTES_BW_FORECAST_FAR=None, DISKRDIOPS=None, DISKRDIOPS_BW=None, DISKRDIOPS_BW_FORECAST=None, DISKRDIOPS_BW_FORECAST_FAR=None, DISKWRBYTES=None, DISKWRBYTES_BW=None, DISKWRBYTES_BW_FORECAST=None, DISKWRBYTES_BW_FORECAST_FAR=None, DISKWRIOPS=None, DISKWRIOPS_BW=None, DISKWRIOPS_BW_FORECAST=None, DISKWRIOPS_BW_FORECAST_FAR=None, DISK_SIZE=None, ID=None, MEMORY=None, NETRX=None, NETRX_BW=None, NETRX_BW_FORECAST=None, NETRX_BW_FORECAST_FAR=None, NETTX=None, NETTX_BW=None, NETTX_BW_FORECAST=None, NETTX_BW_FORECAST_FAR=None, TIMESTAMP=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CPU = CPU
        self.CPU_nsprefix_ = None
        self.CPU_FORECAST = CPU_FORECAST
        self.CPU_FORECAST_nsprefix_ = None
        self.CPU_FORECAST_FAR = CPU_FORECAST_FAR
        self.CPU_FORECAST_FAR_nsprefix_ = None
        self.DISKRDBYTES = DISKRDBYTES
        self.DISKRDBYTES_nsprefix_ = None
        self.DISKRDBYTES_BW = DISKRDBYTES_BW
        self.DISKRDBYTES_BW_nsprefix_ = None
        self.DISKRDBYTES_BW_FORECAST = DISKRDBYTES_BW_FORECAST
        self.DISKRDBYTES_BW_FORECAST_nsprefix_ = None
        self.DISKRDBYTES_BW_FORECAST_FAR = DISKRDBYTES_BW_FORECAST_FAR
        self.DISKRDBYTES_BW_FORECAST_FAR_nsprefix_ = None
        self.DISKRDIOPS = DISKRDIOPS
        self.DISKRDIOPS_nsprefix_ = None
        self.DISKRDIOPS_BW = DISKRDIOPS_BW
        self.DISKRDIOPS_BW_nsprefix_ = None
        self.DISKRDIOPS_BW_FORECAST = DISKRDIOPS_BW_FORECAST
        self.DISKRDIOPS_BW_FORECAST_nsprefix_ = None
        self.DISKRDIOPS_BW_FORECAST_FAR = DISKRDIOPS_BW_FORECAST_FAR
        self.DISKRDIOPS_BW_FORECAST_FAR_nsprefix_ = None
        self.DISKWRBYTES = DISKWRBYTES
        self.DISKWRBYTES_nsprefix_ = None
        self.DISKWRBYTES_BW = DISKWRBYTES_BW
        self.DISKWRBYTES_BW_nsprefix_ = None
        self.DISKWRBYTES_BW_FORECAST = DISKWRBYTES_BW_FORECAST
        self.DISKWRBYTES_BW_FORECAST_nsprefix_ = None
        self.DISKWRBYTES_BW_FORECAST_FAR = DISKWRBYTES_BW_FORECAST_FAR
        self.DISKWRBYTES_BW_FORECAST_FAR_nsprefix_ = None
        self.DISKWRIOPS = DISKWRIOPS
        self.DISKWRIOPS_nsprefix_ = None
        self.DISKWRIOPS_BW = DISKWRIOPS_BW
        self.DISKWRIOPS_BW_nsprefix_ = None
        self.DISKWRIOPS_BW_FORECAST = DISKWRIOPS_BW_FORECAST
        self.DISKWRIOPS_BW_FORECAST_nsprefix_ = None
        self.DISKWRIOPS_BW_FORECAST_FAR = DISKWRIOPS_BW_FORECAST_FAR
        self.DISKWRIOPS_BW_FORECAST_FAR_nsprefix_ = None
        if DISK_SIZE is None:
            self.DISK_SIZE = []
        else:
            self.DISK_SIZE = DISK_SIZE
        self.DISK_SIZE_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.MEMORY = MEMORY
        self.MEMORY_nsprefix_ = None
        self.NETRX = NETRX
        self.NETRX_nsprefix_ = None
        self.NETRX_BW = NETRX_BW
        self.NETRX_BW_nsprefix_ = None
        self.NETRX_BW_FORECAST = NETRX_BW_FORECAST
        self.NETRX_BW_FORECAST_nsprefix_ = None
        self.NETRX_BW_FORECAST_FAR = NETRX_BW_FORECAST_FAR
        self.NETRX_BW_FORECAST_FAR_nsprefix_ = None
        self.NETTX = NETTX
        self.NETTX_nsprefix_ = None
        self.NETTX_BW = NETTX_BW
        self.NETTX_BW_nsprefix_ = None
        self.NETTX_BW_FORECAST = NETTX_BW_FORECAST
        self.NETTX_BW_FORECAST_nsprefix_ = None
        self.NETTX_BW_FORECAST_FAR = NETTX_BW_FORECAST_FAR
        self.NETTX_BW_FORECAST_FAR_nsprefix_ = None
        self.TIMESTAMP = TIMESTAMP
        self.TIMESTAMP_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MONITORINGType47)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MONITORINGType47.subclass:
            return MONITORINGType47.subclass(*args_, **kwargs_)
        else:
            return MONITORINGType47(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CPU(self):
        return self.CPU
    def set_CPU(self, CPU):
        self.CPU = CPU
    def get_CPU_FORECAST(self):
        return self.CPU_FORECAST
    def set_CPU_FORECAST(self, CPU_FORECAST):
        self.CPU_FORECAST = CPU_FORECAST
    def get_CPU_FORECAST_FAR(self):
        return self.CPU_FORECAST_FAR
    def set_CPU_FORECAST_FAR(self, CPU_FORECAST_FAR):
        self.CPU_FORECAST_FAR = CPU_FORECAST_FAR
    def get_DISKRDBYTES(self):
        return self.DISKRDBYTES
    def set_DISKRDBYTES(self, DISKRDBYTES):
        self.DISKRDBYTES = DISKRDBYTES
    def get_DISKRDBYTES_BW(self):
        return self.DISKRDBYTES_BW
    def set_DISKRDBYTES_BW(self, DISKRDBYTES_BW):
        self.DISKRDBYTES_BW = DISKRDBYTES_BW
    def get_DISKRDBYTES_BW_FORECAST(self):
        return self.DISKRDBYTES_BW_FORECAST
    def set_DISKRDBYTES_BW_FORECAST(self, DISKRDBYTES_BW_FORECAST):
        self.DISKRDBYTES_BW_FORECAST = DISKRDBYTES_BW_FORECAST
    def get_DISKRDBYTES_BW_FORECAST_FAR(self):
        return self.DISKRDBYTES_BW_FORECAST_FAR
    def set_DISKRDBYTES_BW_FORECAST_FAR(self, DISKRDBYTES_BW_FORECAST_FAR):
        self.DISKRDBYTES_BW_FORECAST_FAR = DISKRDBYTES_BW_FORECAST_FAR
    def get_DISKRDIOPS(self):
        return self.DISKRDIOPS
    def set_DISKRDIOPS(self, DISKRDIOPS):
        self.DISKRDIOPS = DISKRDIOPS
    def get_DISKRDIOPS_BW(self):
        return self.DISKRDIOPS_BW
    def set_DISKRDIOPS_BW(self, DISKRDIOPS_BW):
        self.DISKRDIOPS_BW = DISKRDIOPS_BW
    def get_DISKRDIOPS_BW_FORECAST(self):
        return self.DISKRDIOPS_BW_FORECAST
    def set_DISKRDIOPS_BW_FORECAST(self, DISKRDIOPS_BW_FORECAST):
        self.DISKRDIOPS_BW_FORECAST = DISKRDIOPS_BW_FORECAST
    def get_DISKRDIOPS_BW_FORECAST_FAR(self):
        return self.DISKRDIOPS_BW_FORECAST_FAR
    def set_DISKRDIOPS_BW_FORECAST_FAR(self, DISKRDIOPS_BW_FORECAST_FAR):
        self.DISKRDIOPS_BW_FORECAST_FAR = DISKRDIOPS_BW_FORECAST_FAR
    def get_DISKWRBYTES(self):
        return self.DISKWRBYTES
    def set_DISKWRBYTES(self, DISKWRBYTES):
        self.DISKWRBYTES = DISKWRBYTES
    def get_DISKWRBYTES_BW(self):
        return self.DISKWRBYTES_BW
    def set_DISKWRBYTES_BW(self, DISKWRBYTES_BW):
        self.DISKWRBYTES_BW = DISKWRBYTES_BW
    def get_DISKWRBYTES_BW_FORECAST(self):
        return self.DISKWRBYTES_BW_FORECAST
    def set_DISKWRBYTES_BW_FORECAST(self, DISKWRBYTES_BW_FORECAST):
        self.DISKWRBYTES_BW_FORECAST = DISKWRBYTES_BW_FORECAST
    def get_DISKWRBYTES_BW_FORECAST_FAR(self):
        return self.DISKWRBYTES_BW_FORECAST_FAR
    def set_DISKWRBYTES_BW_FORECAST_FAR(self, DISKWRBYTES_BW_FORECAST_FAR):
        self.DISKWRBYTES_BW_FORECAST_FAR = DISKWRBYTES_BW_FORECAST_FAR
    def get_DISKWRIOPS(self):
        return self.DISKWRIOPS
    def set_DISKWRIOPS(self, DISKWRIOPS):
        self.DISKWRIOPS = DISKWRIOPS
    def get_DISKWRIOPS_BW(self):
        return self.DISKWRIOPS_BW
    def set_DISKWRIOPS_BW(self, DISKWRIOPS_BW):
        self.DISKWRIOPS_BW = DISKWRIOPS_BW
    def get_DISKWRIOPS_BW_FORECAST(self):
        return self.DISKWRIOPS_BW_FORECAST
    def set_DISKWRIOPS_BW_FORECAST(self, DISKWRIOPS_BW_FORECAST):
        self.DISKWRIOPS_BW_FORECAST = DISKWRIOPS_BW_FORECAST
    def get_DISKWRIOPS_BW_FORECAST_FAR(self):
        return self.DISKWRIOPS_BW_FORECAST_FAR
    def set_DISKWRIOPS_BW_FORECAST_FAR(self, DISKWRIOPS_BW_FORECAST_FAR):
        self.DISKWRIOPS_BW_FORECAST_FAR = DISKWRIOPS_BW_FORECAST_FAR
    def get_DISK_SIZE(self):
        return self.DISK_SIZE
    def set_DISK_SIZE(self, DISK_SIZE):
        self.DISK_SIZE = DISK_SIZE
    def add_DISK_SIZE(self, value):
        self.DISK_SIZE.append(value)
    def insert_DISK_SIZE_at(self, index, value):
        self.DISK_SIZE.insert(index, value)
    def replace_DISK_SIZE_at(self, index, value):
        self.DISK_SIZE[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_MEMORY(self):
        return self.MEMORY
    def set_MEMORY(self, MEMORY):
        self.MEMORY = MEMORY
    def get_NETRX(self):
        return self.NETRX
    def set_NETRX(self, NETRX):
        self.NETRX = NETRX
    def get_NETRX_BW(self):
        return self.NETRX_BW
    def set_NETRX_BW(self, NETRX_BW):
        self.NETRX_BW = NETRX_BW
    def get_NETRX_BW_FORECAST(self):
        return self.NETRX_BW_FORECAST
    def set_NETRX_BW_FORECAST(self, NETRX_BW_FORECAST):
        self.NETRX_BW_FORECAST = NETRX_BW_FORECAST
    def get_NETRX_BW_FORECAST_FAR(self):
        return self.NETRX_BW_FORECAST_FAR
    def set_NETRX_BW_FORECAST_FAR(self, NETRX_BW_FORECAST_FAR):
        self.NETRX_BW_FORECAST_FAR = NETRX_BW_FORECAST_FAR
    def get_NETTX(self):
        return self.NETTX
    def set_NETTX(self, NETTX):
        self.NETTX = NETTX
    def get_NETTX_BW(self):
        return self.NETTX_BW
    def set_NETTX_BW(self, NETTX_BW):
        self.NETTX_BW = NETTX_BW
    def get_NETTX_BW_FORECAST(self):
        return self.NETTX_BW_FORECAST
    def set_NETTX_BW_FORECAST(self, NETTX_BW_FORECAST):
        self.NETTX_BW_FORECAST = NETTX_BW_FORECAST
    def get_NETTX_BW_FORECAST_FAR(self):
        return self.NETTX_BW_FORECAST_FAR
    def set_NETTX_BW_FORECAST_FAR(self, NETTX_BW_FORECAST_FAR):
        self.NETTX_BW_FORECAST_FAR = NETTX_BW_FORECAST_FAR
    def get_TIMESTAMP(self):
        return self.TIMESTAMP
    def set_TIMESTAMP(self, TIMESTAMP):
        self.TIMESTAMP = TIMESTAMP
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.CPU is not None or
            self.CPU_FORECAST is not None or
            self.CPU_FORECAST_FAR is not None or
            self.DISKRDBYTES is not None or
            self.DISKRDBYTES_BW is not None or
            self.DISKRDBYTES_BW_FORECAST is not None or
            self.DISKRDBYTES_BW_FORECAST_FAR is not None or
            self.DISKRDIOPS is not None or
            self.DISKRDIOPS_BW is not None or
            self.DISKRDIOPS_BW_FORECAST is not None or
            self.DISKRDIOPS_BW_FORECAST_FAR is not None or
            self.DISKWRBYTES is not None or
            self.DISKWRBYTES_BW is not None or
            self.DISKWRBYTES_BW_FORECAST is not None or
            self.DISKWRBYTES_BW_FORECAST_FAR is not None or
            self.DISKWRIOPS is not None or
            self.DISKWRIOPS_BW is not None or
            self.DISKWRIOPS_BW_FORECAST is not None or
            self.DISKWRIOPS_BW_FORECAST_FAR is not None or
            self.DISK_SIZE or
            self.ID is not None or
            self.MEMORY is not None or
            self.NETRX is not None or
            self.NETRX_BW is not None or
            self.NETRX_BW_FORECAST is not None or
            self.NETRX_BW_FORECAST_FAR is not None or
            self.NETTX is not None or
            self.NETTX_BW is not None or
            self.NETTX_BW_FORECAST is not None or
            self.NETTX_BW_FORECAST_FAR is not None or
            self.TIMESTAMP is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MONITORINGType47', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MONITORINGType47')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MONITORINGType47':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MONITORINGType47')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MONITORINGType47', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MONITORINGType47'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='MONITORINGType47', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            namespaceprefix_ = self.CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU>%s</%sCPU>%s' % (namespaceprefix_ , self.gds_format_decimal(self.CPU, input_name='CPU'), namespaceprefix_ , eol_))
        if self.CPU_FORECAST is not None:
            namespaceprefix_ = self.CPU_FORECAST_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_FORECAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU_FORECAST>%s</%sCPU_FORECAST>%s' % (namespaceprefix_ , self.gds_format_decimal(self.CPU_FORECAST, input_name='CPU_FORECAST'), namespaceprefix_ , eol_))
        if self.CPU_FORECAST_FAR is not None:
            namespaceprefix_ = self.CPU_FORECAST_FAR_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_FORECAST_FAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU_FORECAST_FAR>%s</%sCPU_FORECAST_FAR>%s' % (namespaceprefix_ , self.gds_format_decimal(self.CPU_FORECAST_FAR, input_name='CPU_FORECAST_FAR'), namespaceprefix_ , eol_))
        if self.DISKRDBYTES is not None:
            namespaceprefix_ = self.DISKRDBYTES_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKRDBYTES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKRDBYTES>%s</%sDISKRDBYTES>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKRDBYTES, input_name='DISKRDBYTES'), namespaceprefix_ , eol_))
        if self.DISKRDBYTES_BW is not None:
            namespaceprefix_ = self.DISKRDBYTES_BW_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKRDBYTES_BW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKRDBYTES_BW>%s</%sDISKRDBYTES_BW>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKRDBYTES_BW, input_name='DISKRDBYTES_BW'), namespaceprefix_ , eol_))
        if self.DISKRDBYTES_BW_FORECAST is not None:
            namespaceprefix_ = self.DISKRDBYTES_BW_FORECAST_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKRDBYTES_BW_FORECAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKRDBYTES_BW_FORECAST>%s</%sDISKRDBYTES_BW_FORECAST>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKRDBYTES_BW_FORECAST, input_name='DISKRDBYTES_BW_FORECAST'), namespaceprefix_ , eol_))
        if self.DISKRDBYTES_BW_FORECAST_FAR is not None:
            namespaceprefix_ = self.DISKRDBYTES_BW_FORECAST_FAR_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKRDBYTES_BW_FORECAST_FAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKRDBYTES_BW_FORECAST_FAR>%s</%sDISKRDBYTES_BW_FORECAST_FAR>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKRDBYTES_BW_FORECAST_FAR, input_name='DISKRDBYTES_BW_FORECAST_FAR'), namespaceprefix_ , eol_))
        if self.DISKRDIOPS is not None:
            namespaceprefix_ = self.DISKRDIOPS_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKRDIOPS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKRDIOPS>%s</%sDISKRDIOPS>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKRDIOPS, input_name='DISKRDIOPS'), namespaceprefix_ , eol_))
        if self.DISKRDIOPS_BW is not None:
            namespaceprefix_ = self.DISKRDIOPS_BW_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKRDIOPS_BW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKRDIOPS_BW>%s</%sDISKRDIOPS_BW>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKRDIOPS_BW, input_name='DISKRDIOPS_BW'), namespaceprefix_ , eol_))
        if self.DISKRDIOPS_BW_FORECAST is not None:
            namespaceprefix_ = self.DISKRDIOPS_BW_FORECAST_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKRDIOPS_BW_FORECAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKRDIOPS_BW_FORECAST>%s</%sDISKRDIOPS_BW_FORECAST>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKRDIOPS_BW_FORECAST, input_name='DISKRDIOPS_BW_FORECAST'), namespaceprefix_ , eol_))
        if self.DISKRDIOPS_BW_FORECAST_FAR is not None:
            namespaceprefix_ = self.DISKRDIOPS_BW_FORECAST_FAR_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKRDIOPS_BW_FORECAST_FAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKRDIOPS_BW_FORECAST_FAR>%s</%sDISKRDIOPS_BW_FORECAST_FAR>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKRDIOPS_BW_FORECAST_FAR, input_name='DISKRDIOPS_BW_FORECAST_FAR'), namespaceprefix_ , eol_))
        if self.DISKWRBYTES is not None:
            namespaceprefix_ = self.DISKWRBYTES_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKWRBYTES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKWRBYTES>%s</%sDISKWRBYTES>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKWRBYTES, input_name='DISKWRBYTES'), namespaceprefix_ , eol_))
        if self.DISKWRBYTES_BW is not None:
            namespaceprefix_ = self.DISKWRBYTES_BW_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKWRBYTES_BW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKWRBYTES_BW>%s</%sDISKWRBYTES_BW>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKWRBYTES_BW, input_name='DISKWRBYTES_BW'), namespaceprefix_ , eol_))
        if self.DISKWRBYTES_BW_FORECAST is not None:
            namespaceprefix_ = self.DISKWRBYTES_BW_FORECAST_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKWRBYTES_BW_FORECAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKWRBYTES_BW_FORECAST>%s</%sDISKWRBYTES_BW_FORECAST>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKWRBYTES_BW_FORECAST, input_name='DISKWRBYTES_BW_FORECAST'), namespaceprefix_ , eol_))
        if self.DISKWRBYTES_BW_FORECAST_FAR is not None:
            namespaceprefix_ = self.DISKWRBYTES_BW_FORECAST_FAR_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKWRBYTES_BW_FORECAST_FAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKWRBYTES_BW_FORECAST_FAR>%s</%sDISKWRBYTES_BW_FORECAST_FAR>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKWRBYTES_BW_FORECAST_FAR, input_name='DISKWRBYTES_BW_FORECAST_FAR'), namespaceprefix_ , eol_))
        if self.DISKWRIOPS is not None:
            namespaceprefix_ = self.DISKWRIOPS_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKWRIOPS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKWRIOPS>%s</%sDISKWRIOPS>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKWRIOPS, input_name='DISKWRIOPS'), namespaceprefix_ , eol_))
        if self.DISKWRIOPS_BW is not None:
            namespaceprefix_ = self.DISKWRIOPS_BW_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKWRIOPS_BW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKWRIOPS_BW>%s</%sDISKWRIOPS_BW>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKWRIOPS_BW, input_name='DISKWRIOPS_BW'), namespaceprefix_ , eol_))
        if self.DISKWRIOPS_BW_FORECAST is not None:
            namespaceprefix_ = self.DISKWRIOPS_BW_FORECAST_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKWRIOPS_BW_FORECAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKWRIOPS_BW_FORECAST>%s</%sDISKWRIOPS_BW_FORECAST>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKWRIOPS_BW_FORECAST, input_name='DISKWRIOPS_BW_FORECAST'), namespaceprefix_ , eol_))
        if self.DISKWRIOPS_BW_FORECAST_FAR is not None:
            namespaceprefix_ = self.DISKWRIOPS_BW_FORECAST_FAR_nsprefix_ + ':' if (UseCapturedNS_ and self.DISKWRIOPS_BW_FORECAST_FAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISKWRIOPS_BW_FORECAST_FAR>%s</%sDISKWRIOPS_BW_FORECAST_FAR>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DISKWRIOPS_BW_FORECAST_FAR, input_name='DISKWRIOPS_BW_FORECAST_FAR'), namespaceprefix_ , eol_))
        for DISK_SIZE_ in self.DISK_SIZE:
            namespaceprefix_ = self.DISK_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_SIZE_nsprefix_) else ''
            DISK_SIZE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DISK_SIZE', pretty_print=pretty_print)
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.MEMORY is not None:
            namespaceprefix_ = self.MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY>%s</%sMEMORY>%s' % (namespaceprefix_ , self.gds_format_decimal(self.MEMORY, input_name='MEMORY'), namespaceprefix_ , eol_))
        if self.NETRX is not None:
            namespaceprefix_ = self.NETRX_nsprefix_ + ':' if (UseCapturedNS_ and self.NETRX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETRX>%s</%sNETRX>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETRX, input_name='NETRX'), namespaceprefix_ , eol_))
        if self.NETRX_BW is not None:
            namespaceprefix_ = self.NETRX_BW_nsprefix_ + ':' if (UseCapturedNS_ and self.NETRX_BW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETRX_BW>%s</%sNETRX_BW>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETRX_BW, input_name='NETRX_BW'), namespaceprefix_ , eol_))
        if self.NETRX_BW_FORECAST is not None:
            namespaceprefix_ = self.NETRX_BW_FORECAST_nsprefix_ + ':' if (UseCapturedNS_ and self.NETRX_BW_FORECAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETRX_BW_FORECAST>%s</%sNETRX_BW_FORECAST>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETRX_BW_FORECAST, input_name='NETRX_BW_FORECAST'), namespaceprefix_ , eol_))
        if self.NETRX_BW_FORECAST_FAR is not None:
            namespaceprefix_ = self.NETRX_BW_FORECAST_FAR_nsprefix_ + ':' if (UseCapturedNS_ and self.NETRX_BW_FORECAST_FAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETRX_BW_FORECAST_FAR>%s</%sNETRX_BW_FORECAST_FAR>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETRX_BW_FORECAST_FAR, input_name='NETRX_BW_FORECAST_FAR'), namespaceprefix_ , eol_))
        if self.NETTX is not None:
            namespaceprefix_ = self.NETTX_nsprefix_ + ':' if (UseCapturedNS_ and self.NETTX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETTX>%s</%sNETTX>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETTX, input_name='NETTX'), namespaceprefix_ , eol_))
        if self.NETTX_BW is not None:
            namespaceprefix_ = self.NETTX_BW_nsprefix_ + ':' if (UseCapturedNS_ and self.NETTX_BW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETTX_BW>%s</%sNETTX_BW>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETTX_BW, input_name='NETTX_BW'), namespaceprefix_ , eol_))
        if self.NETTX_BW_FORECAST is not None:
            namespaceprefix_ = self.NETTX_BW_FORECAST_nsprefix_ + ':' if (UseCapturedNS_ and self.NETTX_BW_FORECAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETTX_BW_FORECAST>%s</%sNETTX_BW_FORECAST>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETTX_BW_FORECAST, input_name='NETTX_BW_FORECAST'), namespaceprefix_ , eol_))
        if self.NETTX_BW_FORECAST_FAR is not None:
            namespaceprefix_ = self.NETTX_BW_FORECAST_FAR_nsprefix_ + ':' if (UseCapturedNS_ and self.NETTX_BW_FORECAST_FAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETTX_BW_FORECAST_FAR>%s</%sNETTX_BW_FORECAST_FAR>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NETTX_BW_FORECAST_FAR, input_name='NETTX_BW_FORECAST_FAR'), namespaceprefix_ , eol_))
        if self.TIMESTAMP is not None:
            namespaceprefix_ = self.TIMESTAMP_nsprefix_ + ':' if (UseCapturedNS_ and self.TIMESTAMP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIMESTAMP>%s</%sTIMESTAMP>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIMESTAMP, input_name='TIMESTAMP'), namespaceprefix_ , eol_))
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CPU' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'CPU')
            fval_ = self.gds_validate_decimal(fval_, node, 'CPU')
            self.CPU = fval_
            self.CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'CPU_FORECAST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'CPU_FORECAST')
            fval_ = self.gds_validate_decimal(fval_, node, 'CPU_FORECAST')
            self.CPU_FORECAST = fval_
            self.CPU_FORECAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'CPU_FORECAST_FAR' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'CPU_FORECAST_FAR')
            fval_ = self.gds_validate_decimal(fval_, node, 'CPU_FORECAST_FAR')
            self.CPU_FORECAST_FAR = fval_
            self.CPU_FORECAST_FAR_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKRDBYTES' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKRDBYTES')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKRDBYTES')
            self.DISKRDBYTES = fval_
            self.DISKRDBYTES_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKRDBYTES_BW' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKRDBYTES_BW')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKRDBYTES_BW')
            self.DISKRDBYTES_BW = fval_
            self.DISKRDBYTES_BW_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKRDBYTES_BW_FORECAST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKRDBYTES_BW_FORECAST')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKRDBYTES_BW_FORECAST')
            self.DISKRDBYTES_BW_FORECAST = fval_
            self.DISKRDBYTES_BW_FORECAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKRDBYTES_BW_FORECAST_FAR' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKRDBYTES_BW_FORECAST_FAR')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKRDBYTES_BW_FORECAST_FAR')
            self.DISKRDBYTES_BW_FORECAST_FAR = fval_
            self.DISKRDBYTES_BW_FORECAST_FAR_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKRDIOPS' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKRDIOPS')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKRDIOPS')
            self.DISKRDIOPS = fval_
            self.DISKRDIOPS_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKRDIOPS_BW' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKRDIOPS_BW')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKRDIOPS_BW')
            self.DISKRDIOPS_BW = fval_
            self.DISKRDIOPS_BW_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKRDIOPS_BW_FORECAST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKRDIOPS_BW_FORECAST')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKRDIOPS_BW_FORECAST')
            self.DISKRDIOPS_BW_FORECAST = fval_
            self.DISKRDIOPS_BW_FORECAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKRDIOPS_BW_FORECAST_FAR' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKRDIOPS_BW_FORECAST_FAR')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKRDIOPS_BW_FORECAST_FAR')
            self.DISKRDIOPS_BW_FORECAST_FAR = fval_
            self.DISKRDIOPS_BW_FORECAST_FAR_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKWRBYTES' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKWRBYTES')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKWRBYTES')
            self.DISKWRBYTES = fval_
            self.DISKWRBYTES_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKWRBYTES_BW' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKWRBYTES_BW')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKWRBYTES_BW')
            self.DISKWRBYTES_BW = fval_
            self.DISKWRBYTES_BW_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKWRBYTES_BW_FORECAST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKWRBYTES_BW_FORECAST')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKWRBYTES_BW_FORECAST')
            self.DISKWRBYTES_BW_FORECAST = fval_
            self.DISKWRBYTES_BW_FORECAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKWRBYTES_BW_FORECAST_FAR' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKWRBYTES_BW_FORECAST_FAR')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKWRBYTES_BW_FORECAST_FAR')
            self.DISKWRBYTES_BW_FORECAST_FAR = fval_
            self.DISKWRBYTES_BW_FORECAST_FAR_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKWRIOPS' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKWRIOPS')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKWRIOPS')
            self.DISKWRIOPS = fval_
            self.DISKWRIOPS_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKWRIOPS_BW' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKWRIOPS_BW')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKWRIOPS_BW')
            self.DISKWRIOPS_BW = fval_
            self.DISKWRIOPS_BW_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKWRIOPS_BW_FORECAST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKWRIOPS_BW_FORECAST')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKWRIOPS_BW_FORECAST')
            self.DISKWRIOPS_BW_FORECAST = fval_
            self.DISKWRIOPS_BW_FORECAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISKWRIOPS_BW_FORECAST_FAR' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DISKWRIOPS_BW_FORECAST_FAR')
            fval_ = self.gds_validate_decimal(fval_, node, 'DISKWRIOPS_BW_FORECAST_FAR')
            self.DISKWRIOPS_BW_FORECAST_FAR = fval_
            self.DISKWRIOPS_BW_FORECAST_FAR_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISK_SIZE':
            obj_ = DISK_SIZEType48.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DISK_SIZE.append(obj_)
            obj_.original_tagname_ = 'DISK_SIZE'
        elif nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'MEMORY')
            fval_ = self.gds_validate_decimal(fval_, node, 'MEMORY')
            self.MEMORY = fval_
            self.MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETRX' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETRX')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETRX')
            self.NETRX = fval_
            self.NETRX_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETRX_BW' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETRX_BW')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETRX_BW')
            self.NETRX_BW = fval_
            self.NETRX_BW_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETRX_BW_FORECAST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETRX_BW_FORECAST')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETRX_BW_FORECAST')
            self.NETRX_BW_FORECAST = fval_
            self.NETRX_BW_FORECAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETRX_BW_FORECAST_FAR' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETRX_BW_FORECAST_FAR')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETRX_BW_FORECAST_FAR')
            self.NETRX_BW_FORECAST_FAR = fval_
            self.NETRX_BW_FORECAST_FAR_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETTX' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETTX')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETTX')
            self.NETTX = fval_
            self.NETTX_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETTX_BW' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETTX_BW')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETTX_BW')
            self.NETTX_BW = fval_
            self.NETTX_BW_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETTX_BW_FORECAST' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETTX_BW_FORECAST')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETTX_BW_FORECAST')
            self.NETTX_BW_FORECAST = fval_
            self.NETTX_BW_FORECAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETTX_BW_FORECAST_FAR' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NETTX_BW_FORECAST_FAR')
            fval_ = self.gds_validate_decimal(fval_, node, 'NETTX_BW_FORECAST_FAR')
            self.NETTX_BW_FORECAST_FAR = fval_
            self.NETTX_BW_FORECAST_FAR_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIMESTAMP' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIMESTAMP')
            ival_ = self.gds_validate_integer(ival_, node, 'TIMESTAMP')
            self.TIMESTAMP = ival_
            self.TIMESTAMP_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'MONITORINGType47')
            self.anytypeobjs_.append(content_)
# end class MONITORINGType47


class DISK_SIZEType48(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, SIZE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.SIZE = SIZE
        self.SIZE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DISK_SIZEType48)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DISK_SIZEType48.subclass:
            return DISK_SIZEType48.subclass(*args_, **kwargs_)
        else:
            return DISK_SIZEType48(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def has__content(self):
        if (
            self.ID is not None or
            self.SIZE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DISK_SIZEType48', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DISK_SIZEType48')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DISK_SIZEType48':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DISK_SIZEType48')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DISK_SIZEType48', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DISK_SIZEType48'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DISK_SIZEType48', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.SIZE is not None:
            namespaceprefix_ = self.SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE>%s</%sSIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.SIZE, input_name='SIZE'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
            self.SIZE_nsprefix_ = child_.prefix
# end class DISK_SIZEType48


class TEMPLATEType49(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, AUTOMATIC_DS_REQUIREMENTS=None, AUTOMATIC_NIC_REQUIREMENTS=None, AUTOMATIC_REQUIREMENTS=None, CLONING_TEMPLATE_ID=None, CONTEXT=None, CPU=None, CPU_COST=None, DISK=None, DISK_COST=None, EMULATOR=None, FEATURES=None, HYPERV_OPTIONS=None, GRAPHICS=None, VIDEO=None, IMPORTED=None, INPUT=None, MEMORY=None, MEMORY_COST=None, MEMORY_MAX=None, MEMORY_SLOTS=None, MEMORY_RESIZE_MODE=None, NIC=None, NIC_ALIAS=None, NIC_DEFAULT=None, NUMA_NODE=None, OS=None, PCI=None, RAW=None, SECURITY_GROUP_RULE=None, SNAPSHOT=None, SPICE_OPTIONS=None, SUBMIT_ON_HOLD=None, TEMPLATE_ID=None, TM_MAD_SYSTEM=None, TOPOLOGY=None, TPM=None, VCPU=None, VCPU_MAX=None, VMGROUP=None, VMID=None, VROUTER_ID=None, VROUTER_KEEPALIVED_ID=None, VROUTER_KEEPALIVED_PASSWORD=None, SCHED_ACTION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AUTOMATIC_DS_REQUIREMENTS = AUTOMATIC_DS_REQUIREMENTS
        self.AUTOMATIC_DS_REQUIREMENTS_nsprefix_ = None
        self.AUTOMATIC_NIC_REQUIREMENTS = AUTOMATIC_NIC_REQUIREMENTS
        self.AUTOMATIC_NIC_REQUIREMENTS_nsprefix_ = None
        self.AUTOMATIC_REQUIREMENTS = AUTOMATIC_REQUIREMENTS
        self.AUTOMATIC_REQUIREMENTS_nsprefix_ = None
        self.CLONING_TEMPLATE_ID = CLONING_TEMPLATE_ID
        self.CLONING_TEMPLATE_ID_nsprefix_ = None
        self.CONTEXT = CONTEXT
        self.CONTEXT_nsprefix_ = None
        self.CPU = CPU
        self.CPU_nsprefix_ = None
        self.CPU_COST = CPU_COST
        self.CPU_COST_nsprefix_ = None
        if DISK is None:
            self.DISK = []
        else:
            self.DISK = DISK
        self.DISK_nsprefix_ = None
        self.DISK_COST = DISK_COST
        self.DISK_COST_nsprefix_ = None
        self.EMULATOR = EMULATOR
        self.EMULATOR_nsprefix_ = None
        self.FEATURES = FEATURES
        self.FEATURES_nsprefix_ = None
        self.HYPERV_OPTIONS = HYPERV_OPTIONS
        self.HYPERV_OPTIONS_nsprefix_ = None
        self.GRAPHICS = GRAPHICS
        self.GRAPHICS_nsprefix_ = None
        self.VIDEO = VIDEO
        self.VIDEO_nsprefix_ = None
        self.IMPORTED = IMPORTED
        self.IMPORTED_nsprefix_ = None
        self.INPUT = INPUT
        self.INPUT_nsprefix_ = None
        self.MEMORY = MEMORY
        self.MEMORY_nsprefix_ = None
        self.MEMORY_COST = MEMORY_COST
        self.MEMORY_COST_nsprefix_ = None
        self.MEMORY_MAX = MEMORY_MAX
        self.MEMORY_MAX_nsprefix_ = None
        self.MEMORY_SLOTS = MEMORY_SLOTS
        self.MEMORY_SLOTS_nsprefix_ = None
        self.MEMORY_RESIZE_MODE = MEMORY_RESIZE_MODE
        self.MEMORY_RESIZE_MODE_nsprefix_ = None
        if NIC is None:
            self.NIC = []
        else:
            self.NIC = NIC
        self.NIC_nsprefix_ = None
        if NIC_ALIAS is None:
            self.NIC_ALIAS = []
        else:
            self.NIC_ALIAS = NIC_ALIAS
        self.NIC_ALIAS_nsprefix_ = None
        self.NIC_DEFAULT = NIC_DEFAULT
        self.NIC_DEFAULT_nsprefix_ = None
        self.NUMA_NODE = NUMA_NODE
        self.NUMA_NODE_nsprefix_ = None
        self.OS = OS
        self.OS_nsprefix_ = None
        if PCI is None:
            self.PCI = []
        else:
            self.PCI = PCI
        self.PCI_nsprefix_ = None
        self.RAW = RAW
        self.RAW_nsprefix_ = None
        if SECURITY_GROUP_RULE is None:
            self.SECURITY_GROUP_RULE = []
        else:
            self.SECURITY_GROUP_RULE = SECURITY_GROUP_RULE
        self.SECURITY_GROUP_RULE_nsprefix_ = None
        if SNAPSHOT is None:
            self.SNAPSHOT = []
        else:
            self.SNAPSHOT = SNAPSHOT
        self.SNAPSHOT_nsprefix_ = None
        self.SPICE_OPTIONS = SPICE_OPTIONS
        self.SPICE_OPTIONS_nsprefix_ = None
        self.SUBMIT_ON_HOLD = SUBMIT_ON_HOLD
        self.SUBMIT_ON_HOLD_nsprefix_ = None
        self.TEMPLATE_ID = TEMPLATE_ID
        self.TEMPLATE_ID_nsprefix_ = None
        self.TM_MAD_SYSTEM = TM_MAD_SYSTEM
        self.TM_MAD_SYSTEM_nsprefix_ = None
        self.TOPOLOGY = TOPOLOGY
        self.TOPOLOGY_nsprefix_ = None
        self.TPM = TPM
        self.TPM_nsprefix_ = None
        self.VCPU = VCPU
        self.VCPU_nsprefix_ = None
        self.VCPU_MAX = VCPU_MAX
        self.VCPU_MAX_nsprefix_ = None
        self.VMGROUP = VMGROUP
        self.VMGROUP_nsprefix_ = None
        self.VMID = VMID
        self.VMID_nsprefix_ = None
        self.VROUTER_ID = VROUTER_ID
        self.VROUTER_ID_nsprefix_ = None
        self.VROUTER_KEEPALIVED_ID = VROUTER_KEEPALIVED_ID
        self.VROUTER_KEEPALIVED_ID_nsprefix_ = None
        self.VROUTER_KEEPALIVED_PASSWORD = VROUTER_KEEPALIVED_PASSWORD
        self.VROUTER_KEEPALIVED_PASSWORD_nsprefix_ = None
        if SCHED_ACTION is None:
            self.SCHED_ACTION = []
        else:
            self.SCHED_ACTION = SCHED_ACTION
        self.SCHED_ACTION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEMPLATEType49)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEMPLATEType49.subclass:
            return TEMPLATEType49.subclass(*args_, **kwargs_)
        else:
            return TEMPLATEType49(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AUTOMATIC_DS_REQUIREMENTS(self):
        return self.AUTOMATIC_DS_REQUIREMENTS
    def set_AUTOMATIC_DS_REQUIREMENTS(self, AUTOMATIC_DS_REQUIREMENTS):
        self.AUTOMATIC_DS_REQUIREMENTS = AUTOMATIC_DS_REQUIREMENTS
    def get_AUTOMATIC_NIC_REQUIREMENTS(self):
        return self.AUTOMATIC_NIC_REQUIREMENTS
    def set_AUTOMATIC_NIC_REQUIREMENTS(self, AUTOMATIC_NIC_REQUIREMENTS):
        self.AUTOMATIC_NIC_REQUIREMENTS = AUTOMATIC_NIC_REQUIREMENTS
    def get_AUTOMATIC_REQUIREMENTS(self):
        return self.AUTOMATIC_REQUIREMENTS
    def set_AUTOMATIC_REQUIREMENTS(self, AUTOMATIC_REQUIREMENTS):
        self.AUTOMATIC_REQUIREMENTS = AUTOMATIC_REQUIREMENTS
    def get_CLONING_TEMPLATE_ID(self):
        return self.CLONING_TEMPLATE_ID
    def set_CLONING_TEMPLATE_ID(self, CLONING_TEMPLATE_ID):
        self.CLONING_TEMPLATE_ID = CLONING_TEMPLATE_ID
    def get_CONTEXT(self):
        return self.CONTEXT
    def set_CONTEXT(self, CONTEXT):
        self.CONTEXT = CONTEXT
    def get_CPU(self):
        return self.CPU
    def set_CPU(self, CPU):
        self.CPU = CPU
    def get_CPU_COST(self):
        return self.CPU_COST
    def set_CPU_COST(self, CPU_COST):
        self.CPU_COST = CPU_COST
    def get_DISK(self):
        return self.DISK
    def set_DISK(self, DISK):
        self.DISK = DISK
    def add_DISK(self, value):
        self.DISK.append(value)
    def insert_DISK_at(self, index, value):
        self.DISK.insert(index, value)
    def replace_DISK_at(self, index, value):
        self.DISK[index] = value
    def get_DISK_COST(self):
        return self.DISK_COST
    def set_DISK_COST(self, DISK_COST):
        self.DISK_COST = DISK_COST
    def get_EMULATOR(self):
        return self.EMULATOR
    def set_EMULATOR(self, EMULATOR):
        self.EMULATOR = EMULATOR
    def get_FEATURES(self):
        return self.FEATURES
    def set_FEATURES(self, FEATURES):
        self.FEATURES = FEATURES
    def get_HYPERV_OPTIONS(self):
        return self.HYPERV_OPTIONS
    def set_HYPERV_OPTIONS(self, HYPERV_OPTIONS):
        self.HYPERV_OPTIONS = HYPERV_OPTIONS
    def get_GRAPHICS(self):
        return self.GRAPHICS
    def set_GRAPHICS(self, GRAPHICS):
        self.GRAPHICS = GRAPHICS
    def get_VIDEO(self):
        return self.VIDEO
    def set_VIDEO(self, VIDEO):
        self.VIDEO = VIDEO
    def get_IMPORTED(self):
        return self.IMPORTED
    def set_IMPORTED(self, IMPORTED):
        self.IMPORTED = IMPORTED
    def get_INPUT(self):
        return self.INPUT
    def set_INPUT(self, INPUT):
        self.INPUT = INPUT
    def get_MEMORY(self):
        return self.MEMORY
    def set_MEMORY(self, MEMORY):
        self.MEMORY = MEMORY
    def get_MEMORY_COST(self):
        return self.MEMORY_COST
    def set_MEMORY_COST(self, MEMORY_COST):
        self.MEMORY_COST = MEMORY_COST
    def get_MEMORY_MAX(self):
        return self.MEMORY_MAX
    def set_MEMORY_MAX(self, MEMORY_MAX):
        self.MEMORY_MAX = MEMORY_MAX
    def get_MEMORY_SLOTS(self):
        return self.MEMORY_SLOTS
    def set_MEMORY_SLOTS(self, MEMORY_SLOTS):
        self.MEMORY_SLOTS = MEMORY_SLOTS
    def get_MEMORY_RESIZE_MODE(self):
        return self.MEMORY_RESIZE_MODE
    def set_MEMORY_RESIZE_MODE(self, MEMORY_RESIZE_MODE):
        self.MEMORY_RESIZE_MODE = MEMORY_RESIZE_MODE
    def get_NIC(self):
        return self.NIC
    def set_NIC(self, NIC):
        self.NIC = NIC
    def add_NIC(self, value):
        self.NIC.append(value)
    def insert_NIC_at(self, index, value):
        self.NIC.insert(index, value)
    def replace_NIC_at(self, index, value):
        self.NIC[index] = value
    def get_NIC_ALIAS(self):
        return self.NIC_ALIAS
    def set_NIC_ALIAS(self, NIC_ALIAS):
        self.NIC_ALIAS = NIC_ALIAS
    def add_NIC_ALIAS(self, value):
        self.NIC_ALIAS.append(value)
    def insert_NIC_ALIAS_at(self, index, value):
        self.NIC_ALIAS.insert(index, value)
    def replace_NIC_ALIAS_at(self, index, value):
        self.NIC_ALIAS[index] = value
    def get_NIC_DEFAULT(self):
        return self.NIC_DEFAULT
    def set_NIC_DEFAULT(self, NIC_DEFAULT):
        self.NIC_DEFAULT = NIC_DEFAULT
    def get_NUMA_NODE(self):
        return self.NUMA_NODE
    def set_NUMA_NODE(self, NUMA_NODE):
        self.NUMA_NODE = NUMA_NODE
    def get_OS(self):
        return self.OS
    def set_OS(self, OS):
        self.OS = OS
    def get_PCI(self):
        return self.PCI
    def set_PCI(self, PCI):
        self.PCI = PCI
    def add_PCI(self, value):
        self.PCI.append(value)
    def insert_PCI_at(self, index, value):
        self.PCI.insert(index, value)
    def replace_PCI_at(self, index, value):
        self.PCI[index] = value
    def get_RAW(self):
        return self.RAW
    def set_RAW(self, RAW):
        self.RAW = RAW
    def get_SECURITY_GROUP_RULE(self):
        return self.SECURITY_GROUP_RULE
    def set_SECURITY_GROUP_RULE(self, SECURITY_GROUP_RULE):
        self.SECURITY_GROUP_RULE = SECURITY_GROUP_RULE
    def add_SECURITY_GROUP_RULE(self, value):
        self.SECURITY_GROUP_RULE.append(value)
    def insert_SECURITY_GROUP_RULE_at(self, index, value):
        self.SECURITY_GROUP_RULE.insert(index, value)
    def replace_SECURITY_GROUP_RULE_at(self, index, value):
        self.SECURITY_GROUP_RULE[index] = value
    def get_SNAPSHOT(self):
        return self.SNAPSHOT
    def set_SNAPSHOT(self, SNAPSHOT):
        self.SNAPSHOT = SNAPSHOT
    def add_SNAPSHOT(self, value):
        self.SNAPSHOT.append(value)
    def insert_SNAPSHOT_at(self, index, value):
        self.SNAPSHOT.insert(index, value)
    def replace_SNAPSHOT_at(self, index, value):
        self.SNAPSHOT[index] = value
    def get_SPICE_OPTIONS(self):
        return self.SPICE_OPTIONS
    def set_SPICE_OPTIONS(self, SPICE_OPTIONS):
        self.SPICE_OPTIONS = SPICE_OPTIONS
    def get_SUBMIT_ON_HOLD(self):
        return self.SUBMIT_ON_HOLD
    def set_SUBMIT_ON_HOLD(self, SUBMIT_ON_HOLD):
        self.SUBMIT_ON_HOLD = SUBMIT_ON_HOLD
    def get_TEMPLATE_ID(self):
        return self.TEMPLATE_ID
    def set_TEMPLATE_ID(self, TEMPLATE_ID):
        self.TEMPLATE_ID = TEMPLATE_ID
    def get_TM_MAD_SYSTEM(self):
        return self.TM_MAD_SYSTEM
    def set_TM_MAD_SYSTEM(self, TM_MAD_SYSTEM):
        self.TM_MAD_SYSTEM = TM_MAD_SYSTEM
    def get_TOPOLOGY(self):
        return self.TOPOLOGY
    def set_TOPOLOGY(self, TOPOLOGY):
        self.TOPOLOGY = TOPOLOGY
    def get_TPM(self):
        return self.TPM
    def set_TPM(self, TPM):
        self.TPM = TPM
    def get_VCPU(self):
        return self.VCPU
    def set_VCPU(self, VCPU):
        self.VCPU = VCPU
    def get_VCPU_MAX(self):
        return self.VCPU_MAX
    def set_VCPU_MAX(self, VCPU_MAX):
        self.VCPU_MAX = VCPU_MAX
    def get_VMGROUP(self):
        return self.VMGROUP
    def set_VMGROUP(self, VMGROUP):
        self.VMGROUP = VMGROUP
    def get_VMID(self):
        return self.VMID
    def set_VMID(self, VMID):
        self.VMID = VMID
    def get_VROUTER_ID(self):
        return self.VROUTER_ID
    def set_VROUTER_ID(self, VROUTER_ID):
        self.VROUTER_ID = VROUTER_ID
    def get_VROUTER_KEEPALIVED_ID(self):
        return self.VROUTER_KEEPALIVED_ID
    def set_VROUTER_KEEPALIVED_ID(self, VROUTER_KEEPALIVED_ID):
        self.VROUTER_KEEPALIVED_ID = VROUTER_KEEPALIVED_ID
    def get_VROUTER_KEEPALIVED_PASSWORD(self):
        return self.VROUTER_KEEPALIVED_PASSWORD
    def set_VROUTER_KEEPALIVED_PASSWORD(self, VROUTER_KEEPALIVED_PASSWORD):
        self.VROUTER_KEEPALIVED_PASSWORD = VROUTER_KEEPALIVED_PASSWORD
    def get_SCHED_ACTION(self):
        return self.SCHED_ACTION
    def set_SCHED_ACTION(self, SCHED_ACTION):
        self.SCHED_ACTION = SCHED_ACTION
    def add_SCHED_ACTION(self, value):
        self.SCHED_ACTION.append(value)
    def insert_SCHED_ACTION_at(self, index, value):
        self.SCHED_ACTION.insert(index, value)
    def replace_SCHED_ACTION_at(self, index, value):
        self.SCHED_ACTION[index] = value
    def has__content(self):
        if (
            self.AUTOMATIC_DS_REQUIREMENTS is not None or
            self.AUTOMATIC_NIC_REQUIREMENTS is not None or
            self.AUTOMATIC_REQUIREMENTS is not None or
            self.CLONING_TEMPLATE_ID is not None or
            self.CONTEXT is not None or
            self.CPU is not None or
            self.CPU_COST is not None or
            self.DISK or
            self.DISK_COST is not None or
            self.EMULATOR is not None or
            self.FEATURES is not None or
            self.HYPERV_OPTIONS is not None or
            self.GRAPHICS is not None or
            self.VIDEO is not None or
            self.IMPORTED is not None or
            self.INPUT is not None or
            self.MEMORY is not None or
            self.MEMORY_COST is not None or
            self.MEMORY_MAX is not None or
            self.MEMORY_SLOTS is not None or
            self.MEMORY_RESIZE_MODE is not None or
            self.NIC or
            self.NIC_ALIAS or
            self.NIC_DEFAULT is not None or
            self.NUMA_NODE is not None or
            self.OS is not None or
            self.PCI or
            self.RAW is not None or
            self.SECURITY_GROUP_RULE or
            self.SNAPSHOT or
            self.SPICE_OPTIONS is not None or
            self.SUBMIT_ON_HOLD is not None or
            self.TEMPLATE_ID is not None or
            self.TM_MAD_SYSTEM is not None or
            self.TOPOLOGY is not None or
            self.TPM is not None or
            self.VCPU is not None or
            self.VCPU_MAX is not None or
            self.VMGROUP is not None or
            self.VMID is not None or
            self.VROUTER_ID is not None or
            self.VROUTER_KEEPALIVED_ID is not None or
            self.VROUTER_KEEPALIVED_PASSWORD is not None or
            self.SCHED_ACTION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType49', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEMPLATEType49')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEMPLATEType49':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEMPLATEType49')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEMPLATEType49', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEMPLATEType49'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType49', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AUTOMATIC_DS_REQUIREMENTS is not None:
            namespaceprefix_ = self.AUTOMATIC_DS_REQUIREMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.AUTOMATIC_DS_REQUIREMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAUTOMATIC_DS_REQUIREMENTS>%s</%sAUTOMATIC_DS_REQUIREMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AUTOMATIC_DS_REQUIREMENTS), input_name='AUTOMATIC_DS_REQUIREMENTS')), namespaceprefix_ , eol_))
        if self.AUTOMATIC_NIC_REQUIREMENTS is not None:
            namespaceprefix_ = self.AUTOMATIC_NIC_REQUIREMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.AUTOMATIC_NIC_REQUIREMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAUTOMATIC_NIC_REQUIREMENTS>%s</%sAUTOMATIC_NIC_REQUIREMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AUTOMATIC_NIC_REQUIREMENTS), input_name='AUTOMATIC_NIC_REQUIREMENTS')), namespaceprefix_ , eol_))
        if self.AUTOMATIC_REQUIREMENTS is not None:
            namespaceprefix_ = self.AUTOMATIC_REQUIREMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.AUTOMATIC_REQUIREMENTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAUTOMATIC_REQUIREMENTS>%s</%sAUTOMATIC_REQUIREMENTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AUTOMATIC_REQUIREMENTS), input_name='AUTOMATIC_REQUIREMENTS')), namespaceprefix_ , eol_))
        if self.CLONING_TEMPLATE_ID is not None:
            namespaceprefix_ = self.CLONING_TEMPLATE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.CLONING_TEMPLATE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLONING_TEMPLATE_ID>%s</%sCLONING_TEMPLATE_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CLONING_TEMPLATE_ID), input_name='CLONING_TEMPLATE_ID')), namespaceprefix_ , eol_))
        if self.CONTEXT is not None:
            namespaceprefix_ = self.CONTEXT_nsprefix_ + ':' if (UseCapturedNS_ and self.CONTEXT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCONTEXT>%s</%sCONTEXT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CONTEXT), input_name='CONTEXT')), namespaceprefix_ , eol_))
        if self.CPU is not None:
            namespaceprefix_ = self.CPU_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU>%s</%sCPU>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), namespaceprefix_ , eol_))
        if self.CPU_COST is not None:
            namespaceprefix_ = self.CPU_COST_nsprefix_ + ':' if (UseCapturedNS_ and self.CPU_COST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPU_COST>%s</%sCPU_COST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPU_COST), input_name='CPU_COST')), namespaceprefix_ , eol_))
        for DISK_ in self.DISK:
            namespaceprefix_ = self.DISK_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_nsprefix_) else ''
            DISK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DISK', pretty_print=pretty_print)
        if self.DISK_COST is not None:
            namespaceprefix_ = self.DISK_COST_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_COST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISK_COST>%s</%sDISK_COST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DISK_COST), input_name='DISK_COST')), namespaceprefix_ , eol_))
        if self.EMULATOR is not None:
            namespaceprefix_ = self.EMULATOR_nsprefix_ + ':' if (UseCapturedNS_ and self.EMULATOR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEMULATOR>%s</%sEMULATOR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EMULATOR), input_name='EMULATOR')), namespaceprefix_ , eol_))
        if self.FEATURES is not None:
            namespaceprefix_ = self.FEATURES_nsprefix_ + ':' if (UseCapturedNS_ and self.FEATURES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFEATURES>%s</%sFEATURES>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FEATURES), input_name='FEATURES')), namespaceprefix_ , eol_))
        if self.HYPERV_OPTIONS is not None:
            namespaceprefix_ = self.HYPERV_OPTIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.HYPERV_OPTIONS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHYPERV_OPTIONS>%s</%sHYPERV_OPTIONS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.HYPERV_OPTIONS), input_name='HYPERV_OPTIONS')), namespaceprefix_ , eol_))
        if self.GRAPHICS is not None:
            namespaceprefix_ = self.GRAPHICS_nsprefix_ + ':' if (UseCapturedNS_ and self.GRAPHICS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGRAPHICS>%s</%sGRAPHICS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GRAPHICS), input_name='GRAPHICS')), namespaceprefix_ , eol_))
        if self.VIDEO is not None:
            namespaceprefix_ = self.VIDEO_nsprefix_ + ':' if (UseCapturedNS_ and self.VIDEO_nsprefix_) else ''
            self.VIDEO.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VIDEO', pretty_print=pretty_print)
        if self.IMPORTED is not None:
            namespaceprefix_ = self.IMPORTED_nsprefix_ + ':' if (UseCapturedNS_ and self.IMPORTED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIMPORTED>%s</%sIMPORTED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IMPORTED), input_name='IMPORTED')), namespaceprefix_ , eol_))
        if self.INPUT is not None:
            namespaceprefix_ = self.INPUT_nsprefix_ + ':' if (UseCapturedNS_ and self.INPUT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINPUT>%s</%sINPUT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INPUT), input_name='INPUT')), namespaceprefix_ , eol_))
        if self.MEMORY is not None:
            namespaceprefix_ = self.MEMORY_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY>%s</%sMEMORY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), namespaceprefix_ , eol_))
        if self.MEMORY_COST is not None:
            namespaceprefix_ = self.MEMORY_COST_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_COST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY_COST>%s</%sMEMORY_COST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_COST), input_name='MEMORY_COST')), namespaceprefix_ , eol_))
        if self.MEMORY_MAX is not None:
            namespaceprefix_ = self.MEMORY_MAX_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_MAX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY_MAX>%s</%sMEMORY_MAX>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_MAX), input_name='MEMORY_MAX')), namespaceprefix_ , eol_))
        if self.MEMORY_SLOTS is not None:
            namespaceprefix_ = self.MEMORY_SLOTS_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_SLOTS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY_SLOTS>%s</%sMEMORY_SLOTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_SLOTS), input_name='MEMORY_SLOTS')), namespaceprefix_ , eol_))
        if self.MEMORY_RESIZE_MODE is not None:
            namespaceprefix_ = self.MEMORY_RESIZE_MODE_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMORY_RESIZE_MODE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEMORY_RESIZE_MODE>%s</%sMEMORY_RESIZE_MODE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_RESIZE_MODE), input_name='MEMORY_RESIZE_MODE')), namespaceprefix_ , eol_))
        for NIC_ in self.NIC:
            namespaceprefix_ = self.NIC_nsprefix_ + ':' if (UseCapturedNS_ and self.NIC_nsprefix_) else ''
            NIC_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NIC', pretty_print=pretty_print)
        for NIC_ALIAS_ in self.NIC_ALIAS:
            namespaceprefix_ = self.NIC_ALIAS_nsprefix_ + ':' if (UseCapturedNS_ and self.NIC_ALIAS_nsprefix_) else ''
            NIC_ALIAS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NIC_ALIAS', pretty_print=pretty_print)
        if self.NIC_DEFAULT is not None:
            namespaceprefix_ = self.NIC_DEFAULT_nsprefix_ + ':' if (UseCapturedNS_ and self.NIC_DEFAULT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNIC_DEFAULT>%s</%sNIC_DEFAULT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NIC_DEFAULT), input_name='NIC_DEFAULT')), namespaceprefix_ , eol_))
        if self.NUMA_NODE is not None:
            namespaceprefix_ = self.NUMA_NODE_nsprefix_ + ':' if (UseCapturedNS_ and self.NUMA_NODE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNUMA_NODE>%s</%sNUMA_NODE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NUMA_NODE), input_name='NUMA_NODE')), namespaceprefix_ , eol_))
        if self.OS is not None:
            namespaceprefix_ = self.OS_nsprefix_ + ':' if (UseCapturedNS_ and self.OS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOS>%s</%sOS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OS), input_name='OS')), namespaceprefix_ , eol_))
        for PCI_ in self.PCI:
            namespaceprefix_ = self.PCI_nsprefix_ + ':' if (UseCapturedNS_ and self.PCI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPCI>%s</%sPCI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(PCI_), input_name='PCI')), namespaceprefix_ , eol_))
        if self.RAW is not None:
            namespaceprefix_ = self.RAW_nsprefix_ + ':' if (UseCapturedNS_ and self.RAW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRAW>%s</%sRAW>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RAW), input_name='RAW')), namespaceprefix_ , eol_))
        for SECURITY_GROUP_RULE_ in self.SECURITY_GROUP_RULE:
            namespaceprefix_ = self.SECURITY_GROUP_RULE_nsprefix_ + ':' if (UseCapturedNS_ and self.SECURITY_GROUP_RULE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSECURITY_GROUP_RULE>%s</%sSECURITY_GROUP_RULE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(SECURITY_GROUP_RULE_), input_name='SECURITY_GROUP_RULE')), namespaceprefix_ , eol_))
        for SNAPSHOT_ in self.SNAPSHOT:
            namespaceprefix_ = self.SNAPSHOT_nsprefix_ + ':' if (UseCapturedNS_ and self.SNAPSHOT_nsprefix_) else ''
            SNAPSHOT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SNAPSHOT', pretty_print=pretty_print)
        if self.SPICE_OPTIONS is not None:
            namespaceprefix_ = self.SPICE_OPTIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.SPICE_OPTIONS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSPICE_OPTIONS>%s</%sSPICE_OPTIONS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SPICE_OPTIONS), input_name='SPICE_OPTIONS')), namespaceprefix_ , eol_))
        if self.SUBMIT_ON_HOLD is not None:
            namespaceprefix_ = self.SUBMIT_ON_HOLD_nsprefix_ + ':' if (UseCapturedNS_ and self.SUBMIT_ON_HOLD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSUBMIT_ON_HOLD>%s</%sSUBMIT_ON_HOLD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SUBMIT_ON_HOLD), input_name='SUBMIT_ON_HOLD')), namespaceprefix_ , eol_))
        if self.TEMPLATE_ID is not None:
            namespaceprefix_ = self.TEMPLATE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE_ID>%s</%sTEMPLATE_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE_ID), input_name='TEMPLATE_ID')), namespaceprefix_ , eol_))
        if self.TM_MAD_SYSTEM is not None:
            namespaceprefix_ = self.TM_MAD_SYSTEM_nsprefix_ + ':' if (UseCapturedNS_ and self.TM_MAD_SYSTEM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTM_MAD_SYSTEM>%s</%sTM_MAD_SYSTEM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TM_MAD_SYSTEM), input_name='TM_MAD_SYSTEM')), namespaceprefix_ , eol_))
        if self.TOPOLOGY is not None:
            namespaceprefix_ = self.TOPOLOGY_nsprefix_ + ':' if (UseCapturedNS_ and self.TOPOLOGY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTOPOLOGY>%s</%sTOPOLOGY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TOPOLOGY), input_name='TOPOLOGY')), namespaceprefix_ , eol_))
        if self.TPM is not None:
            namespaceprefix_ = self.TPM_nsprefix_ + ':' if (UseCapturedNS_ and self.TPM_nsprefix_) else ''
            self.TPM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TPM', pretty_print=pretty_print)
        if self.VCPU is not None:
            namespaceprefix_ = self.VCPU_nsprefix_ + ':' if (UseCapturedNS_ and self.VCPU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVCPU>%s</%sVCPU>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VCPU), input_name='VCPU')), namespaceprefix_ , eol_))
        if self.VCPU_MAX is not None:
            namespaceprefix_ = self.VCPU_MAX_nsprefix_ + ':' if (UseCapturedNS_ and self.VCPU_MAX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVCPU_MAX>%s</%sVCPU_MAX>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VCPU_MAX), input_name='VCPU_MAX')), namespaceprefix_ , eol_))
        if self.VMGROUP is not None:
            namespaceprefix_ = self.VMGROUP_nsprefix_ + ':' if (UseCapturedNS_ and self.VMGROUP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMGROUP>%s</%sVMGROUP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VMGROUP), input_name='VMGROUP')), namespaceprefix_ , eol_))
        if self.VMID is not None:
            namespaceprefix_ = self.VMID_nsprefix_ + ':' if (UseCapturedNS_ and self.VMID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVMID>%s</%sVMID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VMID), input_name='VMID')), namespaceprefix_ , eol_))
        if self.VROUTER_ID is not None:
            namespaceprefix_ = self.VROUTER_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.VROUTER_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVROUTER_ID>%s</%sVROUTER_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VROUTER_ID), input_name='VROUTER_ID')), namespaceprefix_ , eol_))
        if self.VROUTER_KEEPALIVED_ID is not None:
            namespaceprefix_ = self.VROUTER_KEEPALIVED_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.VROUTER_KEEPALIVED_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVROUTER_KEEPALIVED_ID>%s</%sVROUTER_KEEPALIVED_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VROUTER_KEEPALIVED_ID), input_name='VROUTER_KEEPALIVED_ID')), namespaceprefix_ , eol_))
        if self.VROUTER_KEEPALIVED_PASSWORD is not None:
            namespaceprefix_ = self.VROUTER_KEEPALIVED_PASSWORD_nsprefix_ + ':' if (UseCapturedNS_ and self.VROUTER_KEEPALIVED_PASSWORD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVROUTER_KEEPALIVED_PASSWORD>%s</%sVROUTER_KEEPALIVED_PASSWORD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VROUTER_KEEPALIVED_PASSWORD), input_name='VROUTER_KEEPALIVED_PASSWORD')), namespaceprefix_ , eol_))
        for SCHED_ACTION_ in self.SCHED_ACTION:
            namespaceprefix_ = self.SCHED_ACTION_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHED_ACTION_nsprefix_) else ''
            SCHED_ACTION_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SCHED_ACTION', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AUTOMATIC_DS_REQUIREMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AUTOMATIC_DS_REQUIREMENTS')
            value_ = self.gds_validate_string(value_, node, 'AUTOMATIC_DS_REQUIREMENTS')
            self.AUTOMATIC_DS_REQUIREMENTS = value_
            self.AUTOMATIC_DS_REQUIREMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'AUTOMATIC_NIC_REQUIREMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AUTOMATIC_NIC_REQUIREMENTS')
            value_ = self.gds_validate_string(value_, node, 'AUTOMATIC_NIC_REQUIREMENTS')
            self.AUTOMATIC_NIC_REQUIREMENTS = value_
            self.AUTOMATIC_NIC_REQUIREMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'AUTOMATIC_REQUIREMENTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AUTOMATIC_REQUIREMENTS')
            value_ = self.gds_validate_string(value_, node, 'AUTOMATIC_REQUIREMENTS')
            self.AUTOMATIC_REQUIREMENTS = value_
            self.AUTOMATIC_REQUIREMENTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'CLONING_TEMPLATE_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CLONING_TEMPLATE_ID')
            value_ = self.gds_validate_string(value_, node, 'CLONING_TEMPLATE_ID')
            self.CLONING_TEMPLATE_ID = value_
            self.CLONING_TEMPLATE_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'CONTEXT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CONTEXT')
            value_ = self.gds_validate_string(value_, node, 'CONTEXT')
            self.CONTEXT = value_
            self.CONTEXT_nsprefix_ = child_.prefix
        elif nodeName_ == 'CPU':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPU')
            value_ = self.gds_validate_string(value_, node, 'CPU')
            self.CPU = value_
            self.CPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'CPU_COST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPU_COST')
            value_ = self.gds_validate_string(value_, node, 'CPU_COST')
            self.CPU_COST = value_
            self.CPU_COST_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISK':
            obj_ = DISKType50.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DISK.append(obj_)
            obj_.original_tagname_ = 'DISK'
        elif nodeName_ == 'DISK_COST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DISK_COST')
            value_ = self.gds_validate_string(value_, node, 'DISK_COST')
            self.DISK_COST = value_
            self.DISK_COST_nsprefix_ = child_.prefix
        elif nodeName_ == 'EMULATOR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EMULATOR')
            value_ = self.gds_validate_string(value_, node, 'EMULATOR')
            self.EMULATOR = value_
            self.EMULATOR_nsprefix_ = child_.prefix
        elif nodeName_ == 'FEATURES':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FEATURES')
            value_ = self.gds_validate_string(value_, node, 'FEATURES')
            self.FEATURES = value_
            self.FEATURES_nsprefix_ = child_.prefix
        elif nodeName_ == 'HYPERV_OPTIONS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'HYPERV_OPTIONS')
            value_ = self.gds_validate_string(value_, node, 'HYPERV_OPTIONS')
            self.HYPERV_OPTIONS = value_
            self.HYPERV_OPTIONS_nsprefix_ = child_.prefix
        elif nodeName_ == 'GRAPHICS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GRAPHICS')
            value_ = self.gds_validate_string(value_, node, 'GRAPHICS')
            self.GRAPHICS = value_
            self.GRAPHICS_nsprefix_ = child_.prefix
        elif nodeName_ == 'VIDEO':
            obj_ = VIDEOType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VIDEO = obj_
            obj_.original_tagname_ = 'VIDEO'
        elif nodeName_ == 'IMPORTED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IMPORTED')
            value_ = self.gds_validate_string(value_, node, 'IMPORTED')
            self.IMPORTED = value_
            self.IMPORTED_nsprefix_ = child_.prefix
        elif nodeName_ == 'INPUT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INPUT')
            value_ = self.gds_validate_string(value_, node, 'INPUT')
            self.INPUT = value_
            self.INPUT_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY')
            value_ = self.gds_validate_string(value_, node, 'MEMORY')
            self.MEMORY = value_
            self.MEMORY_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY_COST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY_COST')
            value_ = self.gds_validate_string(value_, node, 'MEMORY_COST')
            self.MEMORY_COST = value_
            self.MEMORY_COST_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY_MAX':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY_MAX')
            value_ = self.gds_validate_string(value_, node, 'MEMORY_MAX')
            self.MEMORY_MAX = value_
            self.MEMORY_MAX_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY_SLOTS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY_SLOTS')
            value_ = self.gds_validate_string(value_, node, 'MEMORY_SLOTS')
            self.MEMORY_SLOTS = value_
            self.MEMORY_SLOTS_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEMORY_RESIZE_MODE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEMORY_RESIZE_MODE')
            value_ = self.gds_validate_string(value_, node, 'MEMORY_RESIZE_MODE')
            self.MEMORY_RESIZE_MODE = value_
            self.MEMORY_RESIZE_MODE_nsprefix_ = child_.prefix
        elif nodeName_ == 'NIC':
            obj_ = NICType51.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NIC.append(obj_)
            obj_.original_tagname_ = 'NIC'
        elif nodeName_ == 'NIC_ALIAS':
            obj_ = NIC_ALIASType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NIC_ALIAS.append(obj_)
            obj_.original_tagname_ = 'NIC_ALIAS'
        elif nodeName_ == 'NIC_DEFAULT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NIC_DEFAULT')
            value_ = self.gds_validate_string(value_, node, 'NIC_DEFAULT')
            self.NIC_DEFAULT = value_
            self.NIC_DEFAULT_nsprefix_ = child_.prefix
        elif nodeName_ == 'NUMA_NODE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NUMA_NODE')
            value_ = self.gds_validate_string(value_, node, 'NUMA_NODE')
            self.NUMA_NODE = value_
            self.NUMA_NODE_nsprefix_ = child_.prefix
        elif nodeName_ == 'OS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OS')
            value_ = self.gds_validate_string(value_, node, 'OS')
            self.OS = value_
            self.OS_nsprefix_ = child_.prefix
        elif nodeName_ == 'PCI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PCI')
            value_ = self.gds_validate_string(value_, node, 'PCI')
            self.PCI.append(value_)
            self.PCI_nsprefix_ = child_.prefix
        elif nodeName_ == 'RAW':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RAW')
            value_ = self.gds_validate_string(value_, node, 'RAW')
            self.RAW = value_
            self.RAW_nsprefix_ = child_.prefix
        elif nodeName_ == 'SECURITY_GROUP_RULE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SECURITY_GROUP_RULE')
            value_ = self.gds_validate_string(value_, node, 'SECURITY_GROUP_RULE')
            self.SECURITY_GROUP_RULE.append(value_)
            self.SECURITY_GROUP_RULE_nsprefix_ = child_.prefix
        elif nodeName_ == 'SNAPSHOT':
            obj_ = SNAPSHOTType52.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SNAPSHOT.append(obj_)
            obj_.original_tagname_ = 'SNAPSHOT'
        elif nodeName_ == 'SPICE_OPTIONS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SPICE_OPTIONS')
            value_ = self.gds_validate_string(value_, node, 'SPICE_OPTIONS')
            self.SPICE_OPTIONS = value_
            self.SPICE_OPTIONS_nsprefix_ = child_.prefix
        elif nodeName_ == 'SUBMIT_ON_HOLD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SUBMIT_ON_HOLD')
            value_ = self.gds_validate_string(value_, node, 'SUBMIT_ON_HOLD')
            self.SUBMIT_ON_HOLD = value_
            self.SUBMIT_ON_HOLD_nsprefix_ = child_.prefix
        elif nodeName_ == 'TEMPLATE_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE_ID')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE_ID')
            self.TEMPLATE_ID = value_
            self.TEMPLATE_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'TM_MAD_SYSTEM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TM_MAD_SYSTEM')
            value_ = self.gds_validate_string(value_, node, 'TM_MAD_SYSTEM')
            self.TM_MAD_SYSTEM = value_
            self.TM_MAD_SYSTEM_nsprefix_ = child_.prefix
        elif nodeName_ == 'TOPOLOGY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TOPOLOGY')
            value_ = self.gds_validate_string(value_, node, 'TOPOLOGY')
            self.TOPOLOGY = value_
            self.TOPOLOGY_nsprefix_ = child_.prefix
        elif nodeName_ == 'TPM':
            obj_ = TPMType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TPM = obj_
            obj_.original_tagname_ = 'TPM'
        elif nodeName_ == 'VCPU':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VCPU')
            value_ = self.gds_validate_string(value_, node, 'VCPU')
            self.VCPU = value_
            self.VCPU_nsprefix_ = child_.prefix
        elif nodeName_ == 'VCPU_MAX':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VCPU_MAX')
            value_ = self.gds_validate_string(value_, node, 'VCPU_MAX')
            self.VCPU_MAX = value_
            self.VCPU_MAX_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMGROUP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VMGROUP')
            value_ = self.gds_validate_string(value_, node, 'VMGROUP')
            self.VMGROUP = value_
            self.VMGROUP_nsprefix_ = child_.prefix
        elif nodeName_ == 'VMID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VMID')
            value_ = self.gds_validate_string(value_, node, 'VMID')
            self.VMID = value_
            self.VMID_nsprefix_ = child_.prefix
        elif nodeName_ == 'VROUTER_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VROUTER_ID')
            value_ = self.gds_validate_string(value_, node, 'VROUTER_ID')
            self.VROUTER_ID = value_
            self.VROUTER_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'VROUTER_KEEPALIVED_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VROUTER_KEEPALIVED_ID')
            value_ = self.gds_validate_string(value_, node, 'VROUTER_KEEPALIVED_ID')
            self.VROUTER_KEEPALIVED_ID = value_
            self.VROUTER_KEEPALIVED_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'VROUTER_KEEPALIVED_PASSWORD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VROUTER_KEEPALIVED_PASSWORD')
            value_ = self.gds_validate_string(value_, node, 'VROUTER_KEEPALIVED_PASSWORD')
            self.VROUTER_KEEPALIVED_PASSWORD = value_
            self.VROUTER_KEEPALIVED_PASSWORD_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHED_ACTION':
            obj_ = SCHED_ACTION.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SCHED_ACTION.append(obj_)
            obj_.original_tagname_ = 'SCHED_ACTION'
# end class TEMPLATEType49


class CONTEXT(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CONTEXT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CONTEXT.subclass:
            return CONTEXT.subclass(*args_, **kwargs_)
        else:
            return CONTEXT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CONTEXT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CONTEXT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CONTEXT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CONTEXT')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CONTEXT', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CONTEXT'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CONTEXT', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CONTEXT


class FEATURES(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FEATURES)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FEATURES.subclass:
            return FEATURES.subclass(*args_, **kwargs_)
        else:
            return FEATURES(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FEATURES', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FEATURES')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FEATURES':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FEATURES')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FEATURES', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FEATURES'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FEATURES', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FEATURES


class HYPERV_OPTIONS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HYPERV_OPTIONS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HYPERV_OPTIONS.subclass:
            return HYPERV_OPTIONS.subclass(*args_, **kwargs_)
        else:
            return HYPERV_OPTIONS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HYPERV_OPTIONS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HYPERV_OPTIONS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HYPERV_OPTIONS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HYPERV_OPTIONS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HYPERV_OPTIONS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HYPERV_OPTIONS'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HYPERV_OPTIONS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class HYPERV_OPTIONS


class INPUT(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INPUT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INPUT.subclass:
            return INPUT.subclass(*args_, **kwargs_)
        else:
            return INPUT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='INPUT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INPUT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'INPUT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INPUT')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='INPUT', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='INPUT'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='INPUT', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class INPUT


class NIC_DEFAULT(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NIC_DEFAULT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NIC_DEFAULT.subclass:
            return NIC_DEFAULT.subclass(*args_, **kwargs_)
        else:
            return NIC_DEFAULT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NIC_DEFAULT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NIC_DEFAULT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NIC_DEFAULT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NIC_DEFAULT')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NIC_DEFAULT', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NIC_DEFAULT'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NIC_DEFAULT', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NIC_DEFAULT


class NUMA_NODE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NUMA_NODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NUMA_NODE.subclass:
            return NUMA_NODE.subclass(*args_, **kwargs_)
        else:
            return NUMA_NODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NUMA_NODE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NUMA_NODE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NUMA_NODE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NUMA_NODE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NUMA_NODE', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NUMA_NODE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NUMA_NODE', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NUMA_NODE


class OS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OS.subclass:
            return OS.subclass(*args_, **kwargs_)
        else:
            return OS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OS'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class OS


class PCI(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PCI)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PCI.subclass:
            return PCI.subclass(*args_, **kwargs_)
        else:
            return PCI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PCI', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PCI')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PCI':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PCI')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PCI', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PCI'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PCI', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PCI


class RAW(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RAW)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RAW.subclass:
            return RAW.subclass(*args_, **kwargs_)
        else:
            return RAW(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RAW', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RAW')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RAW':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RAW')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RAW', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RAW'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RAW', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RAW


class SECURITY_GROUP_RULE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURITY_GROUP_RULE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURITY_GROUP_RULE.subclass:
            return SECURITY_GROUP_RULE.subclass(*args_, **kwargs_)
        else:
            return SECURITY_GROUP_RULE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SECURITY_GROUP_RULE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SECURITY_GROUP_RULE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SECURITY_GROUP_RULE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SECURITY_GROUP_RULE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SECURITY_GROUP_RULE', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SECURITY_GROUP_RULE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SECURITY_GROUP_RULE', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SECURITY_GROUP_RULE


class SPICE_OPTIONS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SPICE_OPTIONS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SPICE_OPTIONS.subclass:
            return SPICE_OPTIONS.subclass(*args_, **kwargs_)
        else:
            return SPICE_OPTIONS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SPICE_OPTIONS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SPICE_OPTIONS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SPICE_OPTIONS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SPICE_OPTIONS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SPICE_OPTIONS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SPICE_OPTIONS'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SPICE_OPTIONS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SPICE_OPTIONS


class TOPOLOGY(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TOPOLOGY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TOPOLOGY.subclass:
            return TOPOLOGY.subclass(*args_, **kwargs_)
        else:
            return TOPOLOGY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TOPOLOGY', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TOPOLOGY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TOPOLOGY':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TOPOLOGY')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TOPOLOGY', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TOPOLOGY'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TOPOLOGY', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TOPOLOGY


class VMGROUP(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMGROUP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMGROUP.subclass:
            return VMGROUP.subclass(*args_, **kwargs_)
        else:
            return VMGROUP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VMGROUP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMGROUP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VMGROUP':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VMGROUP')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VMGROUP', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VMGROUP'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VMGROUP', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class VMGROUP


class DISKType50(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DISKType50)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DISKType50.subclass:
            return DISKType50.subclass(*args_, **kwargs_)
        else:
            return DISKType50(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DISKType50', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DISKType50')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DISKType50':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DISKType50')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DISKType50', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DISKType50'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='DISKType50', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'DISKType50')
        self.anytypeobjs_.append(content_)
# end class DISKType50


class VIDEOType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, TYPE=None, IOMMU=None, ATS=None, VRAM=None, RESOLUTION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TYPE = TYPE
        self.TYPE_nsprefix_ = None
        self.IOMMU = IOMMU
        self.IOMMU_nsprefix_ = None
        self.ATS = ATS
        self.ATS_nsprefix_ = None
        self.VRAM = VRAM
        self.VRAM_nsprefix_ = None
        self.RESOLUTION = RESOLUTION
        self.RESOLUTION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VIDEOType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VIDEOType.subclass:
            return VIDEOType.subclass(*args_, **kwargs_)
        else:
            return VIDEOType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_IOMMU(self):
        return self.IOMMU
    def set_IOMMU(self, IOMMU):
        self.IOMMU = IOMMU
    def get_ATS(self):
        return self.ATS
    def set_ATS(self, ATS):
        self.ATS = ATS
    def get_VRAM(self):
        return self.VRAM
    def set_VRAM(self, VRAM):
        self.VRAM = VRAM
    def get_RESOLUTION(self):
        return self.RESOLUTION
    def set_RESOLUTION(self, RESOLUTION):
        self.RESOLUTION = RESOLUTION
    def has__content(self):
        if (
            self.TYPE is not None or
            self.IOMMU is not None or
            self.ATS is not None or
            self.VRAM is not None or
            self.RESOLUTION is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VIDEOType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VIDEOType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VIDEOType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VIDEOType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VIDEOType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VIDEOType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VIDEOType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), namespaceprefix_ , eol_))
        if self.IOMMU is not None:
            namespaceprefix_ = self.IOMMU_nsprefix_ + ':' if (UseCapturedNS_ and self.IOMMU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIOMMU>%s</%sIOMMU>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IOMMU), input_name='IOMMU')), namespaceprefix_ , eol_))
        if self.ATS is not None:
            namespaceprefix_ = self.ATS_nsprefix_ + ':' if (UseCapturedNS_ and self.ATS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sATS>%s</%sATS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ATS), input_name='ATS')), namespaceprefix_ , eol_))
        if self.VRAM is not None:
            namespaceprefix_ = self.VRAM_nsprefix_ + ':' if (UseCapturedNS_ and self.VRAM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVRAM>%s</%sVRAM>%s' % (namespaceprefix_ , self.gds_format_integer(self.VRAM, input_name='VRAM'), namespaceprefix_ , eol_))
        if self.RESOLUTION is not None:
            namespaceprefix_ = self.RESOLUTION_nsprefix_ + ':' if (UseCapturedNS_ and self.RESOLUTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRESOLUTION>%s</%sRESOLUTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RESOLUTION), input_name='RESOLUTION')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TYPE')
            value_ = self.gds_validate_string(value_, node, 'TYPE')
            self.TYPE = value_
            self.TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'IOMMU':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IOMMU')
            value_ = self.gds_validate_string(value_, node, 'IOMMU')
            self.IOMMU = value_
            self.IOMMU_nsprefix_ = child_.prefix
        elif nodeName_ == 'ATS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ATS')
            value_ = self.gds_validate_string(value_, node, 'ATS')
            self.ATS = value_
            self.ATS_nsprefix_ = child_.prefix
        elif nodeName_ == 'VRAM' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VRAM')
            ival_ = self.gds_validate_integer(ival_, node, 'VRAM')
            self.VRAM = ival_
            self.VRAM_nsprefix_ = child_.prefix
        elif nodeName_ == 'RESOLUTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RESOLUTION')
            value_ = self.gds_validate_string(value_, node, 'RESOLUTION')
            self.RESOLUTION = value_
            self.RESOLUTION_nsprefix_ = child_.prefix
# end class VIDEOType


class NICType51(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NICType51)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NICType51.subclass:
            return NICType51.subclass(*args_, **kwargs_)
        else:
            return NICType51(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NICType51', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NICType51')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NICType51':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NICType51')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NICType51', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NICType51'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NICType51', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'NICType51')
        self.anytypeobjs_.append(content_)
# end class NICType51


class NIC_ALIASType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ALIAS_ID=None, PARENT=None, PARENT_ID=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ALIAS_ID = ALIAS_ID
        self.ALIAS_ID_nsprefix_ = None
        self.PARENT = PARENT
        self.PARENT_nsprefix_ = None
        self.PARENT_ID = PARENT_ID
        self.PARENT_ID_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NIC_ALIASType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NIC_ALIASType.subclass:
            return NIC_ALIASType.subclass(*args_, **kwargs_)
        else:
            return NIC_ALIASType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ALIAS_ID(self):
        return self.ALIAS_ID
    def set_ALIAS_ID(self, ALIAS_ID):
        self.ALIAS_ID = ALIAS_ID
    def get_PARENT(self):
        return self.PARENT
    def set_PARENT(self, PARENT):
        self.PARENT = PARENT
    def get_PARENT_ID(self):
        return self.PARENT_ID
    def set_PARENT_ID(self, PARENT_ID):
        self.PARENT_ID = PARENT_ID
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.ALIAS_ID is not None or
            self.PARENT is not None or
            self.PARENT_ID is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NIC_ALIASType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NIC_ALIASType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NIC_ALIASType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NIC_ALIASType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NIC_ALIASType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NIC_ALIASType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='NIC_ALIASType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ALIAS_ID is not None:
            namespaceprefix_ = self.ALIAS_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ALIAS_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sALIAS_ID>%s</%sALIAS_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ALIAS_ID), input_name='ALIAS_ID')), namespaceprefix_ , eol_))
        if self.PARENT is not None:
            namespaceprefix_ = self.PARENT_nsprefix_ + ':' if (UseCapturedNS_ and self.PARENT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPARENT>%s</%sPARENT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PARENT), input_name='PARENT')), namespaceprefix_ , eol_))
        if self.PARENT_ID is not None:
            namespaceprefix_ = self.PARENT_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.PARENT_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPARENT_ID>%s</%sPARENT_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PARENT_ID), input_name='PARENT_ID')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ALIAS_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ALIAS_ID')
            value_ = self.gds_validate_string(value_, node, 'ALIAS_ID')
            self.ALIAS_ID = value_
            self.ALIAS_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'PARENT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PARENT')
            value_ = self.gds_validate_string(value_, node, 'PARENT')
            self.PARENT = value_
            self.PARENT_nsprefix_ = child_.prefix
        elif nodeName_ == 'PARENT_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PARENT_ID')
            value_ = self.gds_validate_string(value_, node, 'PARENT_ID')
            self.PARENT_ID = value_
            self.PARENT_ID_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'NIC_ALIASType')
            self.anytypeobjs_.append(content_)
# end class NIC_ALIASType


class SNAPSHOTType52(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ACTION=None, ACTIVE=None, HYPERVISOR_ID=None, NAME=None, SNAPSHOT_ID=None, SYSTEM_DISK_SIZE=None, TIME=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ACTION = ACTION
        self.ACTION_nsprefix_ = None
        self.ACTIVE = ACTIVE
        self.ACTIVE_nsprefix_ = None
        self.HYPERVISOR_ID = HYPERVISOR_ID
        self.HYPERVISOR_ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.SNAPSHOT_ID = SNAPSHOT_ID
        self.SNAPSHOT_ID_nsprefix_ = None
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_nsprefix_ = None
        self.TIME = TIME
        self.TIME_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SNAPSHOTType52)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SNAPSHOTType52.subclass:
            return SNAPSHOTType52.subclass(*args_, **kwargs_)
        else:
            return SNAPSHOTType52(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ACTION(self):
        return self.ACTION
    def set_ACTION(self, ACTION):
        self.ACTION = ACTION
    def get_ACTIVE(self):
        return self.ACTIVE
    def set_ACTIVE(self, ACTIVE):
        self.ACTIVE = ACTIVE
    def get_HYPERVISOR_ID(self):
        return self.HYPERVISOR_ID
    def set_HYPERVISOR_ID(self, HYPERVISOR_ID):
        self.HYPERVISOR_ID = HYPERVISOR_ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_SNAPSHOT_ID(self):
        return self.SNAPSHOT_ID
    def set_SNAPSHOT_ID(self, SNAPSHOT_ID):
        self.SNAPSHOT_ID = SNAPSHOT_ID
    def get_SYSTEM_DISK_SIZE(self):
        return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE):
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_TIME(self):
        return self.TIME
    def set_TIME(self, TIME):
        self.TIME = TIME
    def has__content(self):
        if (
            self.ACTION is not None or
            self.ACTIVE is not None or
            self.HYPERVISOR_ID is not None or
            self.NAME is not None or
            self.SNAPSHOT_ID is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.TIME is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTType52', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SNAPSHOTType52')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SNAPSHOTType52':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SNAPSHOTType52')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SNAPSHOTType52', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SNAPSHOTType52'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTType52', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ACTION is not None:
            namespaceprefix_ = self.ACTION_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACTION>%s</%sACTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ACTION), input_name='ACTION')), namespaceprefix_ , eol_))
        if self.ACTIVE is not None:
            namespaceprefix_ = self.ACTIVE_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTIVE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACTIVE>%s</%sACTIVE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ACTIVE), input_name='ACTIVE')), namespaceprefix_ , eol_))
        if self.HYPERVISOR_ID is not None:
            namespaceprefix_ = self.HYPERVISOR_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.HYPERVISOR_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHYPERVISOR_ID>%s</%sHYPERVISOR_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.HYPERVISOR_ID), input_name='HYPERVISOR_ID')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.SNAPSHOT_ID is not None:
            namespaceprefix_ = self.SNAPSHOT_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.SNAPSHOT_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSNAPSHOT_ID>%s</%sSNAPSHOT_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SNAPSHOT_ID), input_name='SNAPSHOT_ID')), namespaceprefix_ , eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            namespaceprefix_ = self.SYSTEM_DISK_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SYSTEM_DISK_SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYSTEM_DISK_SIZE>%s</%sSYSTEM_DISK_SIZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE), input_name='SYSTEM_DISK_SIZE')), namespaceprefix_ , eol_))
        if self.TIME is not None:
            namespaceprefix_ = self.TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIME>%s</%sTIME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TIME), input_name='TIME')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ACTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ACTION')
            value_ = self.gds_validate_string(value_, node, 'ACTION')
            self.ACTION = value_
            self.ACTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'ACTIVE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ACTIVE')
            value_ = self.gds_validate_string(value_, node, 'ACTIVE')
            self.ACTIVE = value_
            self.ACTIVE_nsprefix_ = child_.prefix
        elif nodeName_ == 'HYPERVISOR_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'HYPERVISOR_ID')
            value_ = self.gds_validate_string(value_, node, 'HYPERVISOR_ID')
            self.HYPERVISOR_ID = value_
            self.HYPERVISOR_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'SNAPSHOT_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SNAPSHOT_ID')
            value_ = self.gds_validate_string(value_, node, 'SNAPSHOT_ID')
            self.SNAPSHOT_ID = value_
            self.SNAPSHOT_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYSTEM_DISK_SIZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SYSTEM_DISK_SIZE')
            value_ = self.gds_validate_string(value_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = value_
            self.SYSTEM_DISK_SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TIME')
            value_ = self.gds_validate_string(value_, node, 'TIME')
            self.TIME = value_
            self.TIME_nsprefix_ = child_.prefix
# end class SNAPSHOTType52


class TPMType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, MODEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MODEL = MODEL
        self.MODEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TPMType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TPMType.subclass:
            return TPMType.subclass(*args_, **kwargs_)
        else:
            return TPMType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MODEL(self):
        return self.MODEL
    def set_MODEL(self, MODEL):
        self.MODEL = MODEL
    def has__content(self):
        if (
            self.MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TPMType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TPMType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TPMType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TPMType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TPMType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TPMType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TPMType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MODEL is not None:
            namespaceprefix_ = self.MODEL_nsprefix_ + ':' if (UseCapturedNS_ and self.MODEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMODEL>%s</%sMODEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MODEL), input_name='MODEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MODEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MODEL')
            value_ = self.gds_validate_string(value_, node, 'MODEL')
            self.MODEL = value_
            self.MODEL_nsprefix_ = child_.prefix
# end class TPMType


class USER_TEMPLATEType53(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USER_TEMPLATEType53)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USER_TEMPLATEType53.subclass:
            return USER_TEMPLATEType53.subclass(*args_, **kwargs_)
        else:
            return USER_TEMPLATEType53(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USER_TEMPLATEType53', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USER_TEMPLATEType53')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'USER_TEMPLATEType53':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USER_TEMPLATEType53')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='USER_TEMPLATEType53', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='USER_TEMPLATEType53'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='USER_TEMPLATEType53', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'USER_TEMPLATEType53')
        self.anytypeobjs_.append(content_)
# end class USER_TEMPLATEType53


class HISTORY_RECORDSType54(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, HISTORY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if HISTORY is None:
            self.HISTORY = []
        else:
            self.HISTORY = HISTORY
        self.HISTORY_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HISTORY_RECORDSType54)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HISTORY_RECORDSType54.subclass:
            return HISTORY_RECORDSType54.subclass(*args_, **kwargs_)
        else:
            return HISTORY_RECORDSType54(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HISTORY(self):
        return self.HISTORY
    def set_HISTORY(self, HISTORY):
        self.HISTORY = HISTORY
    def add_HISTORY(self, value):
        self.HISTORY.append(value)
    def insert_HISTORY_at(self, index, value):
        self.HISTORY.insert(index, value)
    def replace_HISTORY_at(self, index, value):
        self.HISTORY[index] = value
    def has__content(self):
        if (
            self.HISTORY
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HISTORY_RECORDSType54', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HISTORY_RECORDSType54')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HISTORY_RECORDSType54':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HISTORY_RECORDSType54')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HISTORY_RECORDSType54', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HISTORY_RECORDSType54'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HISTORY_RECORDSType54', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HISTORY_ in self.HISTORY:
            namespaceprefix_ = self.HISTORY_nsprefix_ + ':' if (UseCapturedNS_ and self.HISTORY_nsprefix_) else ''
            HISTORY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HISTORY', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HISTORY':
            obj_ = HISTORYType55.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HISTORY.append(obj_)
            obj_.original_tagname_ = 'HISTORY'
# end class HISTORY_RECORDSType54


class HISTORYType55(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OID=None, SEQ=None, HOSTNAME=None, HID=None, CID=None, STIME=None, ETIME=None, VM_MAD=None, TM_MAD=None, DS_ID=None, PLAN_ID=None, ACTION_ID=None, PSTIME=None, PETIME=None, RSTIME=None, RETIME=None, ESTIME=None, EETIME=None, ACTION=None, UID=None, GID=None, REQUEST_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OID = OID
        self.OID_nsprefix_ = None
        self.SEQ = SEQ
        self.SEQ_nsprefix_ = None
        self.HOSTNAME = HOSTNAME
        self.HOSTNAME_nsprefix_ = None
        self.HID = HID
        self.HID_nsprefix_ = None
        self.CID = CID
        self.CID_nsprefix_ = None
        self.STIME = STIME
        self.STIME_nsprefix_ = None
        self.ETIME = ETIME
        self.ETIME_nsprefix_ = None
        self.VM_MAD = VM_MAD
        self.VM_MAD_nsprefix_ = None
        self.TM_MAD = TM_MAD
        self.TM_MAD_nsprefix_ = None
        self.DS_ID = DS_ID
        self.DS_ID_nsprefix_ = None
        self.PLAN_ID = PLAN_ID
        self.PLAN_ID_nsprefix_ = None
        self.ACTION_ID = ACTION_ID
        self.ACTION_ID_nsprefix_ = None
        self.PSTIME = PSTIME
        self.PSTIME_nsprefix_ = None
        self.PETIME = PETIME
        self.PETIME_nsprefix_ = None
        self.RSTIME = RSTIME
        self.RSTIME_nsprefix_ = None
        self.RETIME = RETIME
        self.RETIME_nsprefix_ = None
        self.ESTIME = ESTIME
        self.ESTIME_nsprefix_ = None
        self.EETIME = EETIME
        self.EETIME_nsprefix_ = None
        self.ACTION = ACTION
        self.ACTION_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.REQUEST_ID = REQUEST_ID
        self.REQUEST_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HISTORYType55)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HISTORYType55.subclass:
            return HISTORYType55.subclass(*args_, **kwargs_)
        else:
            return HISTORYType55(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OID(self):
        return self.OID
    def set_OID(self, OID):
        self.OID = OID
    def get_SEQ(self):
        return self.SEQ
    def set_SEQ(self, SEQ):
        self.SEQ = SEQ
    def get_HOSTNAME(self):
        return self.HOSTNAME
    def set_HOSTNAME(self, HOSTNAME):
        self.HOSTNAME = HOSTNAME
    def get_HID(self):
        return self.HID
    def set_HID(self, HID):
        self.HID = HID
    def get_CID(self):
        return self.CID
    def set_CID(self, CID):
        self.CID = CID
    def get_STIME(self):
        return self.STIME
    def set_STIME(self, STIME):
        self.STIME = STIME
    def get_ETIME(self):
        return self.ETIME
    def set_ETIME(self, ETIME):
        self.ETIME = ETIME
    def get_VM_MAD(self):
        return self.VM_MAD
    def set_VM_MAD(self, VM_MAD):
        self.VM_MAD = VM_MAD
    def get_TM_MAD(self):
        return self.TM_MAD
    def set_TM_MAD(self, TM_MAD):
        self.TM_MAD = TM_MAD
    def get_DS_ID(self):
        return self.DS_ID
    def set_DS_ID(self, DS_ID):
        self.DS_ID = DS_ID
    def get_PLAN_ID(self):
        return self.PLAN_ID
    def set_PLAN_ID(self, PLAN_ID):
        self.PLAN_ID = PLAN_ID
    def get_ACTION_ID(self):
        return self.ACTION_ID
    def set_ACTION_ID(self, ACTION_ID):
        self.ACTION_ID = ACTION_ID
    def get_PSTIME(self):
        return self.PSTIME
    def set_PSTIME(self, PSTIME):
        self.PSTIME = PSTIME
    def get_PETIME(self):
        return self.PETIME
    def set_PETIME(self, PETIME):
        self.PETIME = PETIME
    def get_RSTIME(self):
        return self.RSTIME
    def set_RSTIME(self, RSTIME):
        self.RSTIME = RSTIME
    def get_RETIME(self):
        return self.RETIME
    def set_RETIME(self, RETIME):
        self.RETIME = RETIME
    def get_ESTIME(self):
        return self.ESTIME
    def set_ESTIME(self, ESTIME):
        self.ESTIME = ESTIME
    def get_EETIME(self):
        return self.EETIME
    def set_EETIME(self, EETIME):
        self.EETIME = EETIME
    def get_ACTION(self):
        return self.ACTION
    def set_ACTION(self, ACTION):
        self.ACTION = ACTION
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_REQUEST_ID(self):
        return self.REQUEST_ID
    def set_REQUEST_ID(self, REQUEST_ID):
        self.REQUEST_ID = REQUEST_ID
    def has__content(self):
        if (
            self.OID is not None or
            self.SEQ is not None or
            self.HOSTNAME is not None or
            self.HID is not None or
            self.CID is not None or
            self.STIME is not None or
            self.ETIME is not None or
            self.VM_MAD is not None or
            self.TM_MAD is not None or
            self.DS_ID is not None or
            self.PLAN_ID is not None or
            self.ACTION_ID is not None or
            self.PSTIME is not None or
            self.PETIME is not None or
            self.RSTIME is not None or
            self.RETIME is not None or
            self.ESTIME is not None or
            self.EETIME is not None or
            self.ACTION is not None or
            self.UID is not None or
            self.GID is not None or
            self.REQUEST_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HISTORYType55', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HISTORYType55')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HISTORYType55':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HISTORYType55')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HISTORYType55', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HISTORYType55'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='HISTORYType55', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OID is not None:
            namespaceprefix_ = self.OID_nsprefix_ + ':' if (UseCapturedNS_ and self.OID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOID>%s</%sOID>%s' % (namespaceprefix_ , self.gds_format_integer(self.OID, input_name='OID'), namespaceprefix_ , eol_))
        if self.SEQ is not None:
            namespaceprefix_ = self.SEQ_nsprefix_ + ':' if (UseCapturedNS_ and self.SEQ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSEQ>%s</%sSEQ>%s' % (namespaceprefix_ , self.gds_format_integer(self.SEQ, input_name='SEQ'), namespaceprefix_ , eol_))
        if self.HOSTNAME is not None:
            namespaceprefix_ = self.HOSTNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.HOSTNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHOSTNAME>%s</%sHOSTNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.HOSTNAME), input_name='HOSTNAME')), namespaceprefix_ , eol_))
        if self.HID is not None:
            namespaceprefix_ = self.HID_nsprefix_ + ':' if (UseCapturedNS_ and self.HID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHID>%s</%sHID>%s' % (namespaceprefix_ , self.gds_format_integer(self.HID, input_name='HID'), namespaceprefix_ , eol_))
        if self.CID is not None:
            namespaceprefix_ = self.CID_nsprefix_ + ':' if (UseCapturedNS_ and self.CID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCID>%s</%sCID>%s' % (namespaceprefix_ , self.gds_format_integer(self.CID, input_name='CID'), namespaceprefix_ , eol_))
        if self.STIME is not None:
            namespaceprefix_ = self.STIME_nsprefix_ + ':' if (UseCapturedNS_ and self.STIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTIME>%s</%sSTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.STIME, input_name='STIME'), namespaceprefix_ , eol_))
        if self.ETIME is not None:
            namespaceprefix_ = self.ETIME_nsprefix_ + ':' if (UseCapturedNS_ and self.ETIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sETIME>%s</%sETIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.ETIME, input_name='ETIME'), namespaceprefix_ , eol_))
        if self.VM_MAD is not None:
            namespaceprefix_ = self.VM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM_MAD>%s</%sVM_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VM_MAD), input_name='VM_MAD')), namespaceprefix_ , eol_))
        if self.TM_MAD is not None:
            namespaceprefix_ = self.TM_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.TM_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTM_MAD>%s</%sTM_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TM_MAD), input_name='TM_MAD')), namespaceprefix_ , eol_))
        if self.DS_ID is not None:
            namespaceprefix_ = self.DS_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.DS_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDS_ID>%s</%sDS_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.DS_ID, input_name='DS_ID'), namespaceprefix_ , eol_))
        if self.PLAN_ID is not None:
            namespaceprefix_ = self.PLAN_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.PLAN_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPLAN_ID>%s</%sPLAN_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.PLAN_ID, input_name='PLAN_ID'), namespaceprefix_ , eol_))
        if self.ACTION_ID is not None:
            namespaceprefix_ = self.ACTION_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTION_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACTION_ID>%s</%sACTION_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ACTION_ID, input_name='ACTION_ID'), namespaceprefix_ , eol_))
        if self.PSTIME is not None:
            namespaceprefix_ = self.PSTIME_nsprefix_ + ':' if (UseCapturedNS_ and self.PSTIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPSTIME>%s</%sPSTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.PSTIME, input_name='PSTIME'), namespaceprefix_ , eol_))
        if self.PETIME is not None:
            namespaceprefix_ = self.PETIME_nsprefix_ + ':' if (UseCapturedNS_ and self.PETIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPETIME>%s</%sPETIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.PETIME, input_name='PETIME'), namespaceprefix_ , eol_))
        if self.RSTIME is not None:
            namespaceprefix_ = self.RSTIME_nsprefix_ + ':' if (UseCapturedNS_ and self.RSTIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRSTIME>%s</%sRSTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.RSTIME, input_name='RSTIME'), namespaceprefix_ , eol_))
        if self.RETIME is not None:
            namespaceprefix_ = self.RETIME_nsprefix_ + ':' if (UseCapturedNS_ and self.RETIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRETIME>%s</%sRETIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.RETIME, input_name='RETIME'), namespaceprefix_ , eol_))
        if self.ESTIME is not None:
            namespaceprefix_ = self.ESTIME_nsprefix_ + ':' if (UseCapturedNS_ and self.ESTIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sESTIME>%s</%sESTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.ESTIME, input_name='ESTIME'), namespaceprefix_ , eol_))
        if self.EETIME is not None:
            namespaceprefix_ = self.EETIME_nsprefix_ + ':' if (UseCapturedNS_ and self.EETIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEETIME>%s</%sEETIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.EETIME, input_name='EETIME'), namespaceprefix_ , eol_))
        if self.ACTION is not None:
            namespaceprefix_ = self.ACTION_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACTION>%s</%sACTION>%s' % (namespaceprefix_ , self.gds_format_integer(self.ACTION, input_name='ACTION'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.REQUEST_ID is not None:
            namespaceprefix_ = self.REQUEST_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.REQUEST_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREQUEST_ID>%s</%sREQUEST_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.REQUEST_ID), input_name='REQUEST_ID')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OID')
            ival_ = self.gds_validate_integer(ival_, node, 'OID')
            self.OID = ival_
            self.OID_nsprefix_ = child_.prefix
        elif nodeName_ == 'SEQ' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SEQ')
            ival_ = self.gds_validate_integer(ival_, node, 'SEQ')
            self.SEQ = ival_
            self.SEQ_nsprefix_ = child_.prefix
        elif nodeName_ == 'HOSTNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'HOSTNAME')
            value_ = self.gds_validate_string(value_, node, 'HOSTNAME')
            self.HOSTNAME = value_
            self.HOSTNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'HID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'HID')
            ival_ = self.gds_validate_integer(ival_, node, 'HID')
            self.HID = ival_
            self.HID_nsprefix_ = child_.prefix
        elif nodeName_ == 'CID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CID')
            ival_ = self.gds_validate_integer(ival_, node, 'CID')
            self.CID = ival_
            self.CID_nsprefix_ = child_.prefix
        elif nodeName_ == 'STIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STIME')
            ival_ = self.gds_validate_integer(ival_, node, 'STIME')
            self.STIME = ival_
            self.STIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'ETIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ETIME')
            ival_ = self.gds_validate_integer(ival_, node, 'ETIME')
            self.ETIME = ival_
            self.ETIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'VM_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VM_MAD')
            value_ = self.gds_validate_string(value_, node, 'VM_MAD')
            self.VM_MAD = value_
            self.VM_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'TM_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TM_MAD')
            value_ = self.gds_validate_string(value_, node, 'TM_MAD')
            self.TM_MAD = value_
            self.TM_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'DS_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DS_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'DS_ID')
            self.DS_ID = ival_
            self.DS_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'PLAN_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PLAN_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'PLAN_ID')
            self.PLAN_ID = ival_
            self.PLAN_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'ACTION_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ACTION_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ACTION_ID')
            self.ACTION_ID = ival_
            self.ACTION_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'PSTIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PSTIME')
            ival_ = self.gds_validate_integer(ival_, node, 'PSTIME')
            self.PSTIME = ival_
            self.PSTIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PETIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PETIME')
            ival_ = self.gds_validate_integer(ival_, node, 'PETIME')
            self.PETIME = ival_
            self.PETIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'RSTIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RSTIME')
            ival_ = self.gds_validate_integer(ival_, node, 'RSTIME')
            self.RSTIME = ival_
            self.RSTIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'RETIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RETIME')
            ival_ = self.gds_validate_integer(ival_, node, 'RETIME')
            self.RETIME = ival_
            self.RETIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'ESTIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ESTIME')
            ival_ = self.gds_validate_integer(ival_, node, 'ESTIME')
            self.ESTIME = ival_
            self.ESTIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'EETIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'EETIME')
            ival_ = self.gds_validate_integer(ival_, node, 'EETIME')
            self.EETIME = ival_
            self.EETIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'ACTION' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ACTION')
            ival_ = self.gds_validate_integer(ival_, node, 'ACTION')
            self.ACTION = ival_
            self.ACTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'REQUEST_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'REQUEST_ID')
            value_ = self.gds_validate_string(value_, node, 'REQUEST_ID')
            self.REQUEST_ID = value_
            self.REQUEST_ID_nsprefix_ = child_.prefix
# end class HISTORYType55


class SNAPSHOTSType56(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ALLOW_ORPHANS=None, CURRENT_BASE=None, DISK_ID=None, NEXT_SNAPSHOT=None, SNAPSHOT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ALLOW_ORPHANS = ALLOW_ORPHANS
        self.ALLOW_ORPHANS_nsprefix_ = None
        self.CURRENT_BASE = CURRENT_BASE
        self.CURRENT_BASE_nsprefix_ = None
        self.DISK_ID = DISK_ID
        self.DISK_ID_nsprefix_ = None
        self.NEXT_SNAPSHOT = NEXT_SNAPSHOT
        self.NEXT_SNAPSHOT_nsprefix_ = None
        if SNAPSHOT is None:
            self.SNAPSHOT = []
        else:
            self.SNAPSHOT = SNAPSHOT
        self.SNAPSHOT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SNAPSHOTSType56)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SNAPSHOTSType56.subclass:
            return SNAPSHOTSType56.subclass(*args_, **kwargs_)
        else:
            return SNAPSHOTSType56(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ALLOW_ORPHANS(self):
        return self.ALLOW_ORPHANS
    def set_ALLOW_ORPHANS(self, ALLOW_ORPHANS):
        self.ALLOW_ORPHANS = ALLOW_ORPHANS
    def get_CURRENT_BASE(self):
        return self.CURRENT_BASE
    def set_CURRENT_BASE(self, CURRENT_BASE):
        self.CURRENT_BASE = CURRENT_BASE
    def get_DISK_ID(self):
        return self.DISK_ID
    def set_DISK_ID(self, DISK_ID):
        self.DISK_ID = DISK_ID
    def get_NEXT_SNAPSHOT(self):
        return self.NEXT_SNAPSHOT
    def set_NEXT_SNAPSHOT(self, NEXT_SNAPSHOT):
        self.NEXT_SNAPSHOT = NEXT_SNAPSHOT
    def get_SNAPSHOT(self):
        return self.SNAPSHOT
    def set_SNAPSHOT(self, SNAPSHOT):
        self.SNAPSHOT = SNAPSHOT
    def add_SNAPSHOT(self, value):
        self.SNAPSHOT.append(value)
    def insert_SNAPSHOT_at(self, index, value):
        self.SNAPSHOT.insert(index, value)
    def replace_SNAPSHOT_at(self, index, value):
        self.SNAPSHOT[index] = value
    def has__content(self):
        if (
            self.ALLOW_ORPHANS is not None or
            self.CURRENT_BASE is not None or
            self.DISK_ID is not None or
            self.NEXT_SNAPSHOT is not None or
            self.SNAPSHOT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTSType56', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SNAPSHOTSType56')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SNAPSHOTSType56':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SNAPSHOTSType56')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SNAPSHOTSType56', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SNAPSHOTSType56'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTSType56', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ALLOW_ORPHANS is not None:
            namespaceprefix_ = self.ALLOW_ORPHANS_nsprefix_ + ':' if (UseCapturedNS_ and self.ALLOW_ORPHANS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sALLOW_ORPHANS>%s</%sALLOW_ORPHANS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ALLOW_ORPHANS), input_name='ALLOW_ORPHANS')), namespaceprefix_ , eol_))
        if self.CURRENT_BASE is not None:
            namespaceprefix_ = self.CURRENT_BASE_nsprefix_ + ':' if (UseCapturedNS_ and self.CURRENT_BASE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCURRENT_BASE>%s</%sCURRENT_BASE>%s' % (namespaceprefix_ , self.gds_format_integer(self.CURRENT_BASE, input_name='CURRENT_BASE'), namespaceprefix_ , eol_))
        if self.DISK_ID is not None:
            namespaceprefix_ = self.DISK_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.DISK_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDISK_ID>%s</%sDISK_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.DISK_ID, input_name='DISK_ID'), namespaceprefix_ , eol_))
        if self.NEXT_SNAPSHOT is not None:
            namespaceprefix_ = self.NEXT_SNAPSHOT_nsprefix_ + ':' if (UseCapturedNS_ and self.NEXT_SNAPSHOT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNEXT_SNAPSHOT>%s</%sNEXT_SNAPSHOT>%s' % (namespaceprefix_ , self.gds_format_integer(self.NEXT_SNAPSHOT, input_name='NEXT_SNAPSHOT'), namespaceprefix_ , eol_))
        for SNAPSHOT_ in self.SNAPSHOT:
            namespaceprefix_ = self.SNAPSHOT_nsprefix_ + ':' if (UseCapturedNS_ and self.SNAPSHOT_nsprefix_) else ''
            SNAPSHOT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SNAPSHOT', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ALLOW_ORPHANS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ALLOW_ORPHANS')
            value_ = self.gds_validate_string(value_, node, 'ALLOW_ORPHANS')
            self.ALLOW_ORPHANS = value_
            self.ALLOW_ORPHANS_nsprefix_ = child_.prefix
        elif nodeName_ == 'CURRENT_BASE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CURRENT_BASE')
            ival_ = self.gds_validate_integer(ival_, node, 'CURRENT_BASE')
            self.CURRENT_BASE = ival_
            self.CURRENT_BASE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DISK_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DISK_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'DISK_ID')
            self.DISK_ID = ival_
            self.DISK_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NEXT_SNAPSHOT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NEXT_SNAPSHOT')
            ival_ = self.gds_validate_integer(ival_, node, 'NEXT_SNAPSHOT')
            self.NEXT_SNAPSHOT = ival_
            self.NEXT_SNAPSHOT_nsprefix_ = child_.prefix
        elif nodeName_ == 'SNAPSHOT':
            obj_ = SNAPSHOTType57.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SNAPSHOT.append(obj_)
            obj_.original_tagname_ = 'SNAPSHOT'
# end class SNAPSHOTSType56


class SNAPSHOTType57(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ACTIVE=None, CHILDREN=None, DATE=None, ID=None, NAME=None, PARENT=None, SIZE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ACTIVE = ACTIVE
        self.ACTIVE_nsprefix_ = None
        self.CHILDREN = CHILDREN
        self.CHILDREN_nsprefix_ = None
        self.DATE = DATE
        self.DATE_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PARENT = PARENT
        self.PARENT_nsprefix_ = None
        self.SIZE = SIZE
        self.SIZE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SNAPSHOTType57)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SNAPSHOTType57.subclass:
            return SNAPSHOTType57.subclass(*args_, **kwargs_)
        else:
            return SNAPSHOTType57(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ACTIVE(self):
        return self.ACTIVE
    def set_ACTIVE(self, ACTIVE):
        self.ACTIVE = ACTIVE
    def get_CHILDREN(self):
        return self.CHILDREN
    def set_CHILDREN(self, CHILDREN):
        self.CHILDREN = CHILDREN
    def get_DATE(self):
        return self.DATE
    def set_DATE(self, DATE):
        self.DATE = DATE
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PARENT(self):
        return self.PARENT
    def set_PARENT(self, PARENT):
        self.PARENT = PARENT
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def has__content(self):
        if (
            self.ACTIVE is not None or
            self.CHILDREN is not None or
            self.DATE is not None or
            self.ID is not None or
            self.NAME is not None or
            self.PARENT is not None or
            self.SIZE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTType57', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SNAPSHOTType57')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SNAPSHOTType57':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SNAPSHOTType57')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SNAPSHOTType57', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SNAPSHOTType57'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SNAPSHOTType57', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ACTIVE is not None:
            namespaceprefix_ = self.ACTIVE_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTIVE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACTIVE>%s</%sACTIVE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ACTIVE), input_name='ACTIVE')), namespaceprefix_ , eol_))
        if self.CHILDREN is not None:
            namespaceprefix_ = self.CHILDREN_nsprefix_ + ':' if (UseCapturedNS_ and self.CHILDREN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCHILDREN>%s</%sCHILDREN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CHILDREN), input_name='CHILDREN')), namespaceprefix_ , eol_))
        if self.DATE is not None:
            namespaceprefix_ = self.DATE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATE>%s</%sDATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.DATE, input_name='DATE'), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PARENT is not None:
            namespaceprefix_ = self.PARENT_nsprefix_ + ':' if (UseCapturedNS_ and self.PARENT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPARENT>%s</%sPARENT>%s' % (namespaceprefix_ , self.gds_format_integer(self.PARENT, input_name='PARENT'), namespaceprefix_ , eol_))
        if self.SIZE is not None:
            namespaceprefix_ = self.SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE>%s</%sSIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.SIZE, input_name='SIZE'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ACTIVE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ACTIVE')
            value_ = self.gds_validate_string(value_, node, 'ACTIVE')
            self.ACTIVE = value_
            self.ACTIVE_nsprefix_ = child_.prefix
        elif nodeName_ == 'CHILDREN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CHILDREN')
            value_ = self.gds_validate_string(value_, node, 'CHILDREN')
            self.CHILDREN = value_
            self.CHILDREN_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DATE')
            ival_ = self.gds_validate_integer(ival_, node, 'DATE')
            self.DATE = ival_
            self.DATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PARENT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PARENT')
            ival_ = self.gds_validate_integer(ival_, node, 'PARENT')
            self.PARENT = ival_
            self.PARENT_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
            self.SIZE_nsprefix_ = child_.prefix
# end class SNAPSHOTType57


class BACKUPSType58(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BACKUP_CONFIG=None, BACKUP_IDS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.BACKUP_CONFIG = BACKUP_CONFIG
        self.BACKUP_CONFIG_nsprefix_ = None
        self.BACKUP_IDS = BACKUP_IDS
        self.BACKUP_IDS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BACKUPSType58)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BACKUPSType58.subclass:
            return BACKUPSType58.subclass(*args_, **kwargs_)
        else:
            return BACKUPSType58(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BACKUP_CONFIG(self):
        return self.BACKUP_CONFIG
    def set_BACKUP_CONFIG(self, BACKUP_CONFIG):
        self.BACKUP_CONFIG = BACKUP_CONFIG
    def get_BACKUP_IDS(self):
        return self.BACKUP_IDS
    def set_BACKUP_IDS(self, BACKUP_IDS):
        self.BACKUP_IDS = BACKUP_IDS
    def has__content(self):
        if (
            self.BACKUP_CONFIG is not None or
            self.BACKUP_IDS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUPSType58', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BACKUPSType58')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BACKUPSType58':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BACKUPSType58')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BACKUPSType58', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BACKUPSType58'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUPSType58', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BACKUP_CONFIG is not None:
            namespaceprefix_ = self.BACKUP_CONFIG_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUP_CONFIG_nsprefix_) else ''
            self.BACKUP_CONFIG.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BACKUP_CONFIG', pretty_print=pretty_print)
        if self.BACKUP_IDS is not None:
            namespaceprefix_ = self.BACKUP_IDS_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUP_IDS_nsprefix_) else ''
            self.BACKUP_IDS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BACKUP_IDS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BACKUP_CONFIG':
            obj_ = BACKUP_CONFIGType59.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BACKUP_CONFIG = obj_
            obj_.original_tagname_ = 'BACKUP_CONFIG'
        elif nodeName_ == 'BACKUP_IDS':
            obj_ = IDS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BACKUP_IDS = obj_
            obj_.original_tagname_ = 'BACKUP_IDS'
# end class BACKUPSType58


class BACKUP_CONFIGType59(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BACKUP_JOB_ID=None, BACKUP_VOLATILE=None, FS_FREEZE=None, INCREMENTAL_BACKUP_ID=None, INCREMENT_MODE=None, KEEP_LAST=None, LAST_BACKUP_ID=None, LAST_BACKUP_SIZE=None, LAST_BRIDGE=None, LAST_DATASTORE_ID=None, LAST_INCREMENT_ID=None, MODE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.BACKUP_JOB_ID = BACKUP_JOB_ID
        self.BACKUP_JOB_ID_nsprefix_ = None
        self.BACKUP_VOLATILE = BACKUP_VOLATILE
        self.BACKUP_VOLATILE_nsprefix_ = None
        self.FS_FREEZE = FS_FREEZE
        self.FS_FREEZE_nsprefix_ = None
        self.INCREMENTAL_BACKUP_ID = INCREMENTAL_BACKUP_ID
        self.INCREMENTAL_BACKUP_ID_nsprefix_ = None
        self.INCREMENT_MODE = INCREMENT_MODE
        self.INCREMENT_MODE_nsprefix_ = None
        self.KEEP_LAST = KEEP_LAST
        self.KEEP_LAST_nsprefix_ = None
        self.LAST_BACKUP_ID = LAST_BACKUP_ID
        self.LAST_BACKUP_ID_nsprefix_ = None
        self.LAST_BACKUP_SIZE = LAST_BACKUP_SIZE
        self.LAST_BACKUP_SIZE_nsprefix_ = None
        self.LAST_BRIDGE = LAST_BRIDGE
        self.LAST_BRIDGE_nsprefix_ = None
        self.LAST_DATASTORE_ID = LAST_DATASTORE_ID
        self.LAST_DATASTORE_ID_nsprefix_ = None
        self.LAST_INCREMENT_ID = LAST_INCREMENT_ID
        self.LAST_INCREMENT_ID_nsprefix_ = None
        self.MODE = MODE
        self.MODE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BACKUP_CONFIGType59)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BACKUP_CONFIGType59.subclass:
            return BACKUP_CONFIGType59.subclass(*args_, **kwargs_)
        else:
            return BACKUP_CONFIGType59(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BACKUP_JOB_ID(self):
        return self.BACKUP_JOB_ID
    def set_BACKUP_JOB_ID(self, BACKUP_JOB_ID):
        self.BACKUP_JOB_ID = BACKUP_JOB_ID
    def get_BACKUP_VOLATILE(self):
        return self.BACKUP_VOLATILE
    def set_BACKUP_VOLATILE(self, BACKUP_VOLATILE):
        self.BACKUP_VOLATILE = BACKUP_VOLATILE
    def get_FS_FREEZE(self):
        return self.FS_FREEZE
    def set_FS_FREEZE(self, FS_FREEZE):
        self.FS_FREEZE = FS_FREEZE
    def get_INCREMENTAL_BACKUP_ID(self):
        return self.INCREMENTAL_BACKUP_ID
    def set_INCREMENTAL_BACKUP_ID(self, INCREMENTAL_BACKUP_ID):
        self.INCREMENTAL_BACKUP_ID = INCREMENTAL_BACKUP_ID
    def get_INCREMENT_MODE(self):
        return self.INCREMENT_MODE
    def set_INCREMENT_MODE(self, INCREMENT_MODE):
        self.INCREMENT_MODE = INCREMENT_MODE
    def get_KEEP_LAST(self):
        return self.KEEP_LAST
    def set_KEEP_LAST(self, KEEP_LAST):
        self.KEEP_LAST = KEEP_LAST
    def get_LAST_BACKUP_ID(self):
        return self.LAST_BACKUP_ID
    def set_LAST_BACKUP_ID(self, LAST_BACKUP_ID):
        self.LAST_BACKUP_ID = LAST_BACKUP_ID
    def get_LAST_BACKUP_SIZE(self):
        return self.LAST_BACKUP_SIZE
    def set_LAST_BACKUP_SIZE(self, LAST_BACKUP_SIZE):
        self.LAST_BACKUP_SIZE = LAST_BACKUP_SIZE
    def get_LAST_BRIDGE(self):
        return self.LAST_BRIDGE
    def set_LAST_BRIDGE(self, LAST_BRIDGE):
        self.LAST_BRIDGE = LAST_BRIDGE
    def get_LAST_DATASTORE_ID(self):
        return self.LAST_DATASTORE_ID
    def set_LAST_DATASTORE_ID(self, LAST_DATASTORE_ID):
        self.LAST_DATASTORE_ID = LAST_DATASTORE_ID
    def get_LAST_INCREMENT_ID(self):
        return self.LAST_INCREMENT_ID
    def set_LAST_INCREMENT_ID(self, LAST_INCREMENT_ID):
        self.LAST_INCREMENT_ID = LAST_INCREMENT_ID
    def get_MODE(self):
        return self.MODE
    def set_MODE(self, MODE):
        self.MODE = MODE
    def has__content(self):
        if (
            self.BACKUP_JOB_ID is not None or
            self.BACKUP_VOLATILE is not None or
            self.FS_FREEZE is not None or
            self.INCREMENTAL_BACKUP_ID is not None or
            self.INCREMENT_MODE is not None or
            self.KEEP_LAST is not None or
            self.LAST_BACKUP_ID is not None or
            self.LAST_BACKUP_SIZE is not None or
            self.LAST_BRIDGE is not None or
            self.LAST_DATASTORE_ID is not None or
            self.LAST_INCREMENT_ID is not None or
            self.MODE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUP_CONFIGType59', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BACKUP_CONFIGType59')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BACKUP_CONFIGType59':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BACKUP_CONFIGType59')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BACKUP_CONFIGType59', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BACKUP_CONFIGType59'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='BACKUP_CONFIGType59', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BACKUP_JOB_ID is not None:
            namespaceprefix_ = self.BACKUP_JOB_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUP_JOB_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBACKUP_JOB_ID>%s</%sBACKUP_JOB_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BACKUP_JOB_ID), input_name='BACKUP_JOB_ID')), namespaceprefix_ , eol_))
        if self.BACKUP_VOLATILE is not None:
            namespaceprefix_ = self.BACKUP_VOLATILE_nsprefix_ + ':' if (UseCapturedNS_ and self.BACKUP_VOLATILE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBACKUP_VOLATILE>%s</%sBACKUP_VOLATILE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BACKUP_VOLATILE), input_name='BACKUP_VOLATILE')), namespaceprefix_ , eol_))
        if self.FS_FREEZE is not None:
            namespaceprefix_ = self.FS_FREEZE_nsprefix_ + ':' if (UseCapturedNS_ and self.FS_FREEZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFS_FREEZE>%s</%sFS_FREEZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FS_FREEZE), input_name='FS_FREEZE')), namespaceprefix_ , eol_))
        if self.INCREMENTAL_BACKUP_ID is not None:
            namespaceprefix_ = self.INCREMENTAL_BACKUP_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.INCREMENTAL_BACKUP_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINCREMENTAL_BACKUP_ID>%s</%sINCREMENTAL_BACKUP_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INCREMENTAL_BACKUP_ID), input_name='INCREMENTAL_BACKUP_ID')), namespaceprefix_ , eol_))
        if self.INCREMENT_MODE is not None:
            namespaceprefix_ = self.INCREMENT_MODE_nsprefix_ + ':' if (UseCapturedNS_ and self.INCREMENT_MODE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINCREMENT_MODE>%s</%sINCREMENT_MODE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INCREMENT_MODE), input_name='INCREMENT_MODE')), namespaceprefix_ , eol_))
        if self.KEEP_LAST is not None:
            namespaceprefix_ = self.KEEP_LAST_nsprefix_ + ':' if (UseCapturedNS_ and self.KEEP_LAST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKEEP_LAST>%s</%sKEEP_LAST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.KEEP_LAST), input_name='KEEP_LAST')), namespaceprefix_ , eol_))
        if self.LAST_BACKUP_ID is not None:
            namespaceprefix_ = self.LAST_BACKUP_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_BACKUP_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_BACKUP_ID>%s</%sLAST_BACKUP_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LAST_BACKUP_ID), input_name='LAST_BACKUP_ID')), namespaceprefix_ , eol_))
        if self.LAST_BACKUP_SIZE is not None:
            namespaceprefix_ = self.LAST_BACKUP_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_BACKUP_SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_BACKUP_SIZE>%s</%sLAST_BACKUP_SIZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LAST_BACKUP_SIZE), input_name='LAST_BACKUP_SIZE')), namespaceprefix_ , eol_))
        if self.LAST_BRIDGE is not None:
            namespaceprefix_ = self.LAST_BRIDGE_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_BRIDGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_BRIDGE>%s</%sLAST_BRIDGE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LAST_BRIDGE), input_name='LAST_BRIDGE')), namespaceprefix_ , eol_))
        if self.LAST_DATASTORE_ID is not None:
            namespaceprefix_ = self.LAST_DATASTORE_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_DATASTORE_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_DATASTORE_ID>%s</%sLAST_DATASTORE_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LAST_DATASTORE_ID), input_name='LAST_DATASTORE_ID')), namespaceprefix_ , eol_))
        if self.LAST_INCREMENT_ID is not None:
            namespaceprefix_ = self.LAST_INCREMENT_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.LAST_INCREMENT_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLAST_INCREMENT_ID>%s</%sLAST_INCREMENT_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LAST_INCREMENT_ID), input_name='LAST_INCREMENT_ID')), namespaceprefix_ , eol_))
        if self.MODE is not None:
            namespaceprefix_ = self.MODE_nsprefix_ + ':' if (UseCapturedNS_ and self.MODE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMODE>%s</%sMODE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MODE), input_name='MODE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BACKUP_JOB_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BACKUP_JOB_ID')
            value_ = self.gds_validate_string(value_, node, 'BACKUP_JOB_ID')
            self.BACKUP_JOB_ID = value_
            self.BACKUP_JOB_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'BACKUP_VOLATILE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BACKUP_VOLATILE')
            value_ = self.gds_validate_string(value_, node, 'BACKUP_VOLATILE')
            self.BACKUP_VOLATILE = value_
            self.BACKUP_VOLATILE_nsprefix_ = child_.prefix
        elif nodeName_ == 'FS_FREEZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FS_FREEZE')
            value_ = self.gds_validate_string(value_, node, 'FS_FREEZE')
            self.FS_FREEZE = value_
            self.FS_FREEZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'INCREMENTAL_BACKUP_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INCREMENTAL_BACKUP_ID')
            value_ = self.gds_validate_string(value_, node, 'INCREMENTAL_BACKUP_ID')
            self.INCREMENTAL_BACKUP_ID = value_
            self.INCREMENTAL_BACKUP_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'INCREMENT_MODE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INCREMENT_MODE')
            value_ = self.gds_validate_string(value_, node, 'INCREMENT_MODE')
            self.INCREMENT_MODE = value_
            self.INCREMENT_MODE_nsprefix_ = child_.prefix
        elif nodeName_ == 'KEEP_LAST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'KEEP_LAST')
            value_ = self.gds_validate_string(value_, node, 'KEEP_LAST')
            self.KEEP_LAST = value_
            self.KEEP_LAST_nsprefix_ = child_.prefix
        elif nodeName_ == 'LAST_BACKUP_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LAST_BACKUP_ID')
            value_ = self.gds_validate_string(value_, node, 'LAST_BACKUP_ID')
            self.LAST_BACKUP_ID = value_
            self.LAST_BACKUP_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'LAST_BACKUP_SIZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LAST_BACKUP_SIZE')
            value_ = self.gds_validate_string(value_, node, 'LAST_BACKUP_SIZE')
            self.LAST_BACKUP_SIZE = value_
            self.LAST_BACKUP_SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'LAST_BRIDGE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LAST_BRIDGE')
            value_ = self.gds_validate_string(value_, node, 'LAST_BRIDGE')
            self.LAST_BRIDGE = value_
            self.LAST_BRIDGE_nsprefix_ = child_.prefix
        elif nodeName_ == 'LAST_DATASTORE_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LAST_DATASTORE_ID')
            value_ = self.gds_validate_string(value_, node, 'LAST_DATASTORE_ID')
            self.LAST_DATASTORE_ID = value_
            self.LAST_DATASTORE_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'LAST_INCREMENT_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LAST_INCREMENT_ID')
            value_ = self.gds_validate_string(value_, node, 'LAST_INCREMENT_ID')
            self.LAST_INCREMENT_ID = value_
            self.LAST_INCREMENT_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'MODE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MODE')
            value_ = self.gds_validate_string(value_, node, 'MODE')
            self.MODE = value_
            self.MODE_nsprefix_ = child_.prefix
# end class BACKUP_CONFIGType59


class VNETType60(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, CLUSTERS=None, BRIDGE=None, BRIDGE_TYPE=None, STATE=None, PREV_STATE=None, PARENT_NETWORK_ID=None, VN_MAD=None, PHYDEV=None, VLAN_ID=None, OUTER_VLAN_ID=None, VLAN_ID_AUTOMATIC=None, OUTER_VLAN_ID_AUTOMATIC=None, USED_LEASES=None, VROUTERS=None, UPDATED_VMS=None, OUTDATED_VMS=None, UPDATING_VMS=None, ERROR_VMS=None, TEMPLATE=None, AR_POOL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.UID = UID
        self.UID_nsprefix_ = None
        self.GID = GID
        self.GID_nsprefix_ = None
        self.UNAME = UNAME
        self.UNAME_nsprefix_ = None
        self.GNAME = GNAME
        self.GNAME_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PERMISSIONS = PERMISSIONS
        self.PERMISSIONS_nsprefix_ = None
        self.CLUSTERS = CLUSTERS
        self.CLUSTERS_nsprefix_ = None
        self.BRIDGE = BRIDGE
        self.BRIDGE_nsprefix_ = None
        self.BRIDGE_TYPE = BRIDGE_TYPE
        self.BRIDGE_TYPE_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.PREV_STATE = PREV_STATE
        self.PREV_STATE_nsprefix_ = None
        self.PARENT_NETWORK_ID = PARENT_NETWORK_ID
        self.PARENT_NETWORK_ID_nsprefix_ = None
        self.VN_MAD = VN_MAD
        self.VN_MAD_nsprefix_ = None
        self.PHYDEV = PHYDEV
        self.PHYDEV_nsprefix_ = None
        self.VLAN_ID = VLAN_ID
        self.VLAN_ID_nsprefix_ = None
        self.OUTER_VLAN_ID = OUTER_VLAN_ID
        self.OUTER_VLAN_ID_nsprefix_ = None
        self.VLAN_ID_AUTOMATIC = VLAN_ID_AUTOMATIC
        self.VLAN_ID_AUTOMATIC_nsprefix_ = None
        self.OUTER_VLAN_ID_AUTOMATIC = OUTER_VLAN_ID_AUTOMATIC
        self.OUTER_VLAN_ID_AUTOMATIC_nsprefix_ = None
        self.USED_LEASES = USED_LEASES
        self.USED_LEASES_nsprefix_ = None
        self.VROUTERS = VROUTERS
        self.VROUTERS_nsprefix_ = None
        self.UPDATED_VMS = UPDATED_VMS
        self.UPDATED_VMS_nsprefix_ = None
        self.OUTDATED_VMS = OUTDATED_VMS
        self.OUTDATED_VMS_nsprefix_ = None
        self.UPDATING_VMS = UPDATING_VMS
        self.UPDATING_VMS_nsprefix_ = None
        self.ERROR_VMS = ERROR_VMS
        self.ERROR_VMS_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.AR_POOL = AR_POOL
        self.AR_POOL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNETType60)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNETType60.subclass:
            return VNETType60.subclass(*args_, **kwargs_)
        else:
            return VNETType60(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_UID(self):
        return self.UID
    def set_UID(self, UID):
        self.UID = UID
    def get_GID(self):
        return self.GID
    def set_GID(self, GID):
        self.GID = GID
    def get_UNAME(self):
        return self.UNAME
    def set_UNAME(self, UNAME):
        self.UNAME = UNAME
    def get_GNAME(self):
        return self.GNAME
    def set_GNAME(self, GNAME):
        self.GNAME = GNAME
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PERMISSIONS(self):
        return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS):
        self.PERMISSIONS = PERMISSIONS
    def get_CLUSTERS(self):
        return self.CLUSTERS
    def set_CLUSTERS(self, CLUSTERS):
        self.CLUSTERS = CLUSTERS
    def get_BRIDGE(self):
        return self.BRIDGE
    def set_BRIDGE(self, BRIDGE):
        self.BRIDGE = BRIDGE
    def get_BRIDGE_TYPE(self):
        return self.BRIDGE_TYPE
    def set_BRIDGE_TYPE(self, BRIDGE_TYPE):
        self.BRIDGE_TYPE = BRIDGE_TYPE
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_PREV_STATE(self):
        return self.PREV_STATE
    def set_PREV_STATE(self, PREV_STATE):
        self.PREV_STATE = PREV_STATE
    def get_PARENT_NETWORK_ID(self):
        return self.PARENT_NETWORK_ID
    def set_PARENT_NETWORK_ID(self, PARENT_NETWORK_ID):
        self.PARENT_NETWORK_ID = PARENT_NETWORK_ID
    def get_VN_MAD(self):
        return self.VN_MAD
    def set_VN_MAD(self, VN_MAD):
        self.VN_MAD = VN_MAD
    def get_PHYDEV(self):
        return self.PHYDEV
    def set_PHYDEV(self, PHYDEV):
        self.PHYDEV = PHYDEV
    def get_VLAN_ID(self):
        return self.VLAN_ID
    def set_VLAN_ID(self, VLAN_ID):
        self.VLAN_ID = VLAN_ID
    def get_OUTER_VLAN_ID(self):
        return self.OUTER_VLAN_ID
    def set_OUTER_VLAN_ID(self, OUTER_VLAN_ID):
        self.OUTER_VLAN_ID = OUTER_VLAN_ID
    def get_VLAN_ID_AUTOMATIC(self):
        return self.VLAN_ID_AUTOMATIC
    def set_VLAN_ID_AUTOMATIC(self, VLAN_ID_AUTOMATIC):
        self.VLAN_ID_AUTOMATIC = VLAN_ID_AUTOMATIC
    def get_OUTER_VLAN_ID_AUTOMATIC(self):
        return self.OUTER_VLAN_ID_AUTOMATIC
    def set_OUTER_VLAN_ID_AUTOMATIC(self, OUTER_VLAN_ID_AUTOMATIC):
        self.OUTER_VLAN_ID_AUTOMATIC = OUTER_VLAN_ID_AUTOMATIC
    def get_USED_LEASES(self):
        return self.USED_LEASES
    def set_USED_LEASES(self, USED_LEASES):
        self.USED_LEASES = USED_LEASES
    def get_VROUTERS(self):
        return self.VROUTERS
    def set_VROUTERS(self, VROUTERS):
        self.VROUTERS = VROUTERS
    def get_UPDATED_VMS(self):
        return self.UPDATED_VMS
    def set_UPDATED_VMS(self, UPDATED_VMS):
        self.UPDATED_VMS = UPDATED_VMS
    def get_OUTDATED_VMS(self):
        return self.OUTDATED_VMS
    def set_OUTDATED_VMS(self, OUTDATED_VMS):
        self.OUTDATED_VMS = OUTDATED_VMS
    def get_UPDATING_VMS(self):
        return self.UPDATING_VMS
    def set_UPDATING_VMS(self, UPDATING_VMS):
        self.UPDATING_VMS = UPDATING_VMS
    def get_ERROR_VMS(self):
        return self.ERROR_VMS
    def set_ERROR_VMS(self, ERROR_VMS):
        self.ERROR_VMS = ERROR_VMS
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_AR_POOL(self):
        return self.AR_POOL
    def set_AR_POOL(self, AR_POOL):
        self.AR_POOL = AR_POOL
    def has__content(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.CLUSTERS is not None or
            self.BRIDGE is not None or
            self.BRIDGE_TYPE is not None or
            self.STATE is not None or
            self.PREV_STATE is not None or
            self.PARENT_NETWORK_ID is not None or
            self.VN_MAD is not None or
            self.PHYDEV is not None or
            self.VLAN_ID is not None or
            self.OUTER_VLAN_ID is not None or
            self.VLAN_ID_AUTOMATIC is not None or
            self.OUTER_VLAN_ID_AUTOMATIC is not None or
            self.USED_LEASES is not None or
            self.VROUTERS is not None or
            self.UPDATED_VMS is not None or
            self.OUTDATED_VMS is not None or
            self.UPDATING_VMS is not None or
            self.ERROR_VMS is not None or
            self.TEMPLATE is not None or
            self.AR_POOL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNETType60', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNETType60')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VNETType60':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VNETType60')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VNETType60', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VNETType60'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VNETType60', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ':' if (UseCapturedNS_ and self.UID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUID>%s</%sUID>%s' % (namespaceprefix_ , self.gds_format_integer(self.UID, input_name='UID'), namespaceprefix_ , eol_))
        if self.GID is not None:
            namespaceprefix_ = self.GID_nsprefix_ + ':' if (UseCapturedNS_ and self.GID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGID>%s</%sGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.GID, input_name='GID'), namespaceprefix_ , eol_))
        if self.UNAME is not None:
            namespaceprefix_ = self.UNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.UNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNAME>%s</%sUNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), namespaceprefix_ , eol_))
        if self.GNAME is not None:
            namespaceprefix_ = self.GNAME_nsprefix_ + ':' if (UseCapturedNS_ and self.GNAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGNAME>%s</%sGNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PERMISSIONS is not None:
            namespaceprefix_ = self.PERMISSIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.PERMISSIONS_nsprefix_) else ''
            self.PERMISSIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PERMISSIONS', pretty_print=pretty_print)
        if self.CLUSTERS is not None:
            namespaceprefix_ = self.CLUSTERS_nsprefix_ + ':' if (UseCapturedNS_ and self.CLUSTERS_nsprefix_) else ''
            self.CLUSTERS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CLUSTERS', pretty_print=pretty_print)
        if self.BRIDGE is not None:
            namespaceprefix_ = self.BRIDGE_nsprefix_ + ':' if (UseCapturedNS_ and self.BRIDGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBRIDGE>%s</%sBRIDGE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BRIDGE), input_name='BRIDGE')), namespaceprefix_ , eol_))
        if self.BRIDGE_TYPE is not None:
            namespaceprefix_ = self.BRIDGE_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.BRIDGE_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBRIDGE_TYPE>%s</%sBRIDGE_TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BRIDGE_TYPE), input_name='BRIDGE_TYPE')), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.PREV_STATE is not None:
            namespaceprefix_ = self.PREV_STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.PREV_STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREV_STATE>%s</%sPREV_STATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.PREV_STATE, input_name='PREV_STATE'), namespaceprefix_ , eol_))
        if self.PARENT_NETWORK_ID is not None:
            namespaceprefix_ = self.PARENT_NETWORK_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.PARENT_NETWORK_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPARENT_NETWORK_ID>%s</%sPARENT_NETWORK_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PARENT_NETWORK_ID), input_name='PARENT_NETWORK_ID')), namespaceprefix_ , eol_))
        if self.VN_MAD is not None:
            namespaceprefix_ = self.VN_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.VN_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVN_MAD>%s</%sVN_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VN_MAD), input_name='VN_MAD')), namespaceprefix_ , eol_))
        if self.PHYDEV is not None:
            namespaceprefix_ = self.PHYDEV_nsprefix_ + ':' if (UseCapturedNS_ and self.PHYDEV_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPHYDEV>%s</%sPHYDEV>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PHYDEV), input_name='PHYDEV')), namespaceprefix_ , eol_))
        if self.VLAN_ID is not None:
            namespaceprefix_ = self.VLAN_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.VLAN_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVLAN_ID>%s</%sVLAN_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VLAN_ID), input_name='VLAN_ID')), namespaceprefix_ , eol_))
        if self.OUTER_VLAN_ID is not None:
            namespaceprefix_ = self.OUTER_VLAN_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.OUTER_VLAN_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOUTER_VLAN_ID>%s</%sOUTER_VLAN_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OUTER_VLAN_ID), input_name='OUTER_VLAN_ID')), namespaceprefix_ , eol_))
        if self.VLAN_ID_AUTOMATIC is not None:
            namespaceprefix_ = self.VLAN_ID_AUTOMATIC_nsprefix_ + ':' if (UseCapturedNS_ and self.VLAN_ID_AUTOMATIC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVLAN_ID_AUTOMATIC>%s</%sVLAN_ID_AUTOMATIC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VLAN_ID_AUTOMATIC), input_name='VLAN_ID_AUTOMATIC')), namespaceprefix_ , eol_))
        if self.OUTER_VLAN_ID_AUTOMATIC is not None:
            namespaceprefix_ = self.OUTER_VLAN_ID_AUTOMATIC_nsprefix_ + ':' if (UseCapturedNS_ and self.OUTER_VLAN_ID_AUTOMATIC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOUTER_VLAN_ID_AUTOMATIC>%s</%sOUTER_VLAN_ID_AUTOMATIC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OUTER_VLAN_ID_AUTOMATIC), input_name='OUTER_VLAN_ID_AUTOMATIC')), namespaceprefix_ , eol_))
        if self.USED_LEASES is not None:
            namespaceprefix_ = self.USED_LEASES_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_LEASES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED_LEASES>%s</%sUSED_LEASES>%s' % (namespaceprefix_ , self.gds_format_integer(self.USED_LEASES, input_name='USED_LEASES'), namespaceprefix_ , eol_))
        if self.VROUTERS is not None:
            namespaceprefix_ = self.VROUTERS_nsprefix_ + ':' if (UseCapturedNS_ and self.VROUTERS_nsprefix_) else ''
            self.VROUTERS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VROUTERS', pretty_print=pretty_print)
        if self.UPDATED_VMS is not None:
            namespaceprefix_ = self.UPDATED_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.UPDATED_VMS_nsprefix_) else ''
            self.UPDATED_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UPDATED_VMS', pretty_print=pretty_print)
        if self.OUTDATED_VMS is not None:
            namespaceprefix_ = self.OUTDATED_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.OUTDATED_VMS_nsprefix_) else ''
            self.OUTDATED_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OUTDATED_VMS', pretty_print=pretty_print)
        if self.UPDATING_VMS is not None:
            namespaceprefix_ = self.UPDATING_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.UPDATING_VMS_nsprefix_) else ''
            self.UPDATING_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UPDATING_VMS', pretty_print=pretty_print)
        if self.ERROR_VMS is not None:
            namespaceprefix_ = self.ERROR_VMS_nsprefix_ + ':' if (UseCapturedNS_ and self.ERROR_VMS_nsprefix_) else ''
            self.ERROR_VMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ERROR_VMS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTEMPLATE>%s</%sTEMPLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), namespaceprefix_ , eol_))
        if self.AR_POOL is not None:
            namespaceprefix_ = self.AR_POOL_nsprefix_ + ':' if (UseCapturedNS_ and self.AR_POOL_nsprefix_) else ''
            self.AR_POOL.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AR_POOL', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UID')
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
            self.UID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GID')
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
            self.GID_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNAME')
            value_ = self.gds_validate_string(value_, node, 'UNAME')
            self.UNAME = value_
            self.UNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'GNAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GNAME')
            value_ = self.gds_validate_string(value_, node, 'GNAME')
            self.GNAME = value_
            self.GNAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType61.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'CLUSTERS':
            obj_ = CLUSTERSType62.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CLUSTERS = obj_
            obj_.original_tagname_ = 'CLUSTERS'
        elif nodeName_ == 'BRIDGE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BRIDGE')
            value_ = self.gds_validate_string(value_, node, 'BRIDGE')
            self.BRIDGE = value_
            self.BRIDGE_nsprefix_ = child_.prefix
        elif nodeName_ == 'BRIDGE_TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BRIDGE_TYPE')
            value_ = self.gds_validate_string(value_, node, 'BRIDGE_TYPE')
            self.BRIDGE_TYPE = value_
            self.BRIDGE_TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PREV_STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PREV_STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'PREV_STATE')
            self.PREV_STATE = ival_
            self.PREV_STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PARENT_NETWORK_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PARENT_NETWORK_ID')
            value_ = self.gds_validate_string(value_, node, 'PARENT_NETWORK_ID')
            self.PARENT_NETWORK_ID = value_
            self.PARENT_NETWORK_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'VN_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VN_MAD')
            value_ = self.gds_validate_string(value_, node, 'VN_MAD')
            self.VN_MAD = value_
            self.VN_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'PHYDEV':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PHYDEV')
            value_ = self.gds_validate_string(value_, node, 'PHYDEV')
            self.PHYDEV = value_
            self.PHYDEV_nsprefix_ = child_.prefix
        elif nodeName_ == 'VLAN_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VLAN_ID')
            value_ = self.gds_validate_string(value_, node, 'VLAN_ID')
            self.VLAN_ID = value_
            self.VLAN_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'OUTER_VLAN_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OUTER_VLAN_ID')
            value_ = self.gds_validate_string(value_, node, 'OUTER_VLAN_ID')
            self.OUTER_VLAN_ID = value_
            self.OUTER_VLAN_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'VLAN_ID_AUTOMATIC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VLAN_ID_AUTOMATIC')
            value_ = self.gds_validate_string(value_, node, 'VLAN_ID_AUTOMATIC')
            self.VLAN_ID_AUTOMATIC = value_
            self.VLAN_ID_AUTOMATIC_nsprefix_ = child_.prefix
        elif nodeName_ == 'OUTER_VLAN_ID_AUTOMATIC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OUTER_VLAN_ID_AUTOMATIC')
            value_ = self.gds_validate_string(value_, node, 'OUTER_VLAN_ID_AUTOMATIC')
            self.OUTER_VLAN_ID_AUTOMATIC = value_
            self.OUTER_VLAN_ID_AUTOMATIC_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED_LEASES' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'USED_LEASES')
            ival_ = self.gds_validate_integer(ival_, node, 'USED_LEASES')
            self.USED_LEASES = ival_
            self.USED_LEASES_nsprefix_ = child_.prefix
        elif nodeName_ == 'VROUTERS':
            obj_ = VROUTERSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VROUTERS = obj_
            obj_.original_tagname_ = 'VROUTERS'
        elif nodeName_ == 'UPDATED_VMS':
            obj_ = UPDATED_VMSType63.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UPDATED_VMS = obj_
            obj_.original_tagname_ = 'UPDATED_VMS'
        elif nodeName_ == 'OUTDATED_VMS':
            obj_ = OUTDATED_VMSType64.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OUTDATED_VMS = obj_
            obj_.original_tagname_ = 'OUTDATED_VMS'
        elif nodeName_ == 'UPDATING_VMS':
            obj_ = UPDATING_VMSType65.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UPDATING_VMS = obj_
            obj_.original_tagname_ = 'UPDATING_VMS'
        elif nodeName_ == 'ERROR_VMS':
            obj_ = ERROR_VMSType66.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ERROR_VMS = obj_
            obj_.original_tagname_ = 'ERROR_VMS'
        elif nodeName_ == 'TEMPLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TEMPLATE')
            value_ = self.gds_validate_string(value_, node, 'TEMPLATE')
            self.TEMPLATE = value_
            self.TEMPLATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'AR_POOL':
            obj_ = AR_POOLType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AR_POOL = obj_
            obj_.original_tagname_ = 'AR_POOL'
# end class VNETType60


class PERMISSIONSType61(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType61)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType61.subclass:
            return PERMISSIONSType61.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType61(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType61', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType61')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONSType61':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONSType61')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONSType61', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONSType61'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType61', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONSType61


class CLUSTERSType62(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTERSType62)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTERSType62.subclass:
            return CLUSTERSType62.subclass(*args_, **kwargs_)
        else:
            return CLUSTERSType62(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTERSType62', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTERSType62')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CLUSTERSType62':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CLUSTERSType62')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CLUSTERSType62', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CLUSTERSType62'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTERSType62', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class CLUSTERSType62


class VROUTERSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VROUTERSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VROUTERSType.subclass:
            return VROUTERSType.subclass(*args_, **kwargs_)
        else:
            return VROUTERSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VROUTERSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VROUTERSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VROUTERSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VROUTERSType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VROUTERSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VROUTERSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VROUTERSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class VROUTERSType


class UPDATED_VMSType63(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATED_VMSType63)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATED_VMSType63.subclass:
            return UPDATED_VMSType63.subclass(*args_, **kwargs_)
        else:
            return UPDATED_VMSType63(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='UPDATED_VMSType63', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UPDATED_VMSType63')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UPDATED_VMSType63':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UPDATED_VMSType63')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UPDATED_VMSType63', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UPDATED_VMSType63'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='UPDATED_VMSType63', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class UPDATED_VMSType63


class OUTDATED_VMSType64(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OUTDATED_VMSType64)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OUTDATED_VMSType64.subclass:
            return OUTDATED_VMSType64.subclass(*args_, **kwargs_)
        else:
            return OUTDATED_VMSType64(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='OUTDATED_VMSType64', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OUTDATED_VMSType64')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OUTDATED_VMSType64':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OUTDATED_VMSType64')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OUTDATED_VMSType64', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OUTDATED_VMSType64'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='OUTDATED_VMSType64', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class OUTDATED_VMSType64


class UPDATING_VMSType65(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATING_VMSType65)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATING_VMSType65.subclass:
            return UPDATING_VMSType65.subclass(*args_, **kwargs_)
        else:
            return UPDATING_VMSType65(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='UPDATING_VMSType65', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UPDATING_VMSType65')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UPDATING_VMSType65':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UPDATING_VMSType65')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UPDATING_VMSType65', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UPDATING_VMSType65'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='UPDATING_VMSType65', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class UPDATING_VMSType65


class ERROR_VMSType66(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ERROR_VMSType66)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ERROR_VMSType66.subclass:
            return ERROR_VMSType66.subclass(*args_, **kwargs_)
        else:
            return ERROR_VMSType66(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ERROR_VMSType66', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ERROR_VMSType66')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ERROR_VMSType66':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ERROR_VMSType66')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ERROR_VMSType66', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ERROR_VMSType66'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ERROR_VMSType66', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class ERROR_VMSType66


class AR_POOLType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, AR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if AR is None:
            self.AR = []
        else:
            self.AR = AR
        self.AR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AR_POOLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AR_POOLType.subclass:
            return AR_POOLType.subclass(*args_, **kwargs_)
        else:
            return AR_POOLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AR(self):
        return self.AR
    def set_AR(self, AR):
        self.AR = AR
    def add_AR(self, value):
        self.AR.append(value)
    def insert_AR_at(self, index, value):
        self.AR.insert(index, value)
    def replace_AR_at(self, index, value):
        self.AR[index] = value
    def has__content(self):
        if (
            self.AR
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='AR_POOLType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AR_POOLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AR_POOLType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AR_POOLType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AR_POOLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AR_POOLType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='AR_POOLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AR_ in self.AR:
            namespaceprefix_ = self.AR_nsprefix_ + ':' if (UseCapturedNS_ and self.AR_nsprefix_) else ''
            AR_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AR', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AR':
            obj_ = ARType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AR.append(obj_)
            obj_.original_tagname_ = 'AR'
# end class AR_POOLType


class ARType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ALLOCATED=None, AR_ID=None, GLOBAL_PREFIX=None, IP=None, MAC=None, PARENT_NETWORK_AR_ID=None, SIZE=None, TYPE=None, ULA_PREFIX=None, VN_MAD=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ALLOCATED = ALLOCATED
        self.ALLOCATED_nsprefix_ = None
        self.AR_ID = AR_ID
        self.AR_ID_nsprefix_ = None
        self.GLOBAL_PREFIX = GLOBAL_PREFIX
        self.GLOBAL_PREFIX_nsprefix_ = None
        self.IP = IP
        self.IP_nsprefix_ = None
        self.MAC = MAC
        self.MAC_nsprefix_ = None
        self.PARENT_NETWORK_AR_ID = PARENT_NETWORK_AR_ID
        self.PARENT_NETWORK_AR_ID_nsprefix_ = None
        self.SIZE = SIZE
        self.SIZE_nsprefix_ = None
        self.TYPE = TYPE
        self.TYPE_nsprefix_ = None
        self.ULA_PREFIX = ULA_PREFIX
        self.ULA_PREFIX_nsprefix_ = None
        self.VN_MAD = VN_MAD
        self.VN_MAD_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ARType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ARType.subclass:
            return ARType.subclass(*args_, **kwargs_)
        else:
            return ARType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ALLOCATED(self):
        return self.ALLOCATED
    def set_ALLOCATED(self, ALLOCATED):
        self.ALLOCATED = ALLOCATED
    def get_AR_ID(self):
        return self.AR_ID
    def set_AR_ID(self, AR_ID):
        self.AR_ID = AR_ID
    def get_GLOBAL_PREFIX(self):
        return self.GLOBAL_PREFIX
    def set_GLOBAL_PREFIX(self, GLOBAL_PREFIX):
        self.GLOBAL_PREFIX = GLOBAL_PREFIX
    def get_IP(self):
        return self.IP
    def set_IP(self, IP):
        self.IP = IP
    def get_MAC(self):
        return self.MAC
    def set_MAC(self, MAC):
        self.MAC = MAC
    def get_PARENT_NETWORK_AR_ID(self):
        return self.PARENT_NETWORK_AR_ID
    def set_PARENT_NETWORK_AR_ID(self, PARENT_NETWORK_AR_ID):
        self.PARENT_NETWORK_AR_ID = PARENT_NETWORK_AR_ID
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_ULA_PREFIX(self):
        return self.ULA_PREFIX
    def set_ULA_PREFIX(self, ULA_PREFIX):
        self.ULA_PREFIX = ULA_PREFIX
    def get_VN_MAD(self):
        return self.VN_MAD
    def set_VN_MAD(self, VN_MAD):
        self.VN_MAD = VN_MAD
    def has__content(self):
        if (
            self.ALLOCATED is not None or
            self.AR_ID is not None or
            self.GLOBAL_PREFIX is not None or
            self.IP is not None or
            self.MAC is not None or
            self.PARENT_NETWORK_AR_ID is not None or
            self.SIZE is not None or
            self.TYPE is not None or
            self.ULA_PREFIX is not None or
            self.VN_MAD is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ARType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ARType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ARType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ARType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ARType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ARType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ARType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ALLOCATED is not None:
            namespaceprefix_ = self.ALLOCATED_nsprefix_ + ':' if (UseCapturedNS_ and self.ALLOCATED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sALLOCATED>%s</%sALLOCATED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ALLOCATED), input_name='ALLOCATED')), namespaceprefix_ , eol_))
        if self.AR_ID is not None:
            namespaceprefix_ = self.AR_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.AR_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAR_ID>%s</%sAR_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AR_ID), input_name='AR_ID')), namespaceprefix_ , eol_))
        if self.GLOBAL_PREFIX is not None:
            namespaceprefix_ = self.GLOBAL_PREFIX_nsprefix_ + ':' if (UseCapturedNS_ and self.GLOBAL_PREFIX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGLOBAL_PREFIX>%s</%sGLOBAL_PREFIX>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GLOBAL_PREFIX), input_name='GLOBAL_PREFIX')), namespaceprefix_ , eol_))
        if self.IP is not None:
            namespaceprefix_ = self.IP_nsprefix_ + ':' if (UseCapturedNS_ and self.IP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP>%s</%sIP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP), input_name='IP')), namespaceprefix_ , eol_))
        if self.MAC is not None:
            namespaceprefix_ = self.MAC_nsprefix_ + ':' if (UseCapturedNS_ and self.MAC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAC>%s</%sMAC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MAC), input_name='MAC')), namespaceprefix_ , eol_))
        if self.PARENT_NETWORK_AR_ID is not None:
            namespaceprefix_ = self.PARENT_NETWORK_AR_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.PARENT_NETWORK_AR_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPARENT_NETWORK_AR_ID>%s</%sPARENT_NETWORK_AR_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PARENT_NETWORK_AR_ID), input_name='PARENT_NETWORK_AR_ID')), namespaceprefix_ , eol_))
        if self.SIZE is not None:
            namespaceprefix_ = self.SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE>%s</%sSIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.SIZE, input_name='SIZE'), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), namespaceprefix_ , eol_))
        if self.ULA_PREFIX is not None:
            namespaceprefix_ = self.ULA_PREFIX_nsprefix_ + ':' if (UseCapturedNS_ and self.ULA_PREFIX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sULA_PREFIX>%s</%sULA_PREFIX>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ULA_PREFIX), input_name='ULA_PREFIX')), namespaceprefix_ , eol_))
        if self.VN_MAD is not None:
            namespaceprefix_ = self.VN_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.VN_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVN_MAD>%s</%sVN_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VN_MAD), input_name='VN_MAD')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ALLOCATED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ALLOCATED')
            value_ = self.gds_validate_string(value_, node, 'ALLOCATED')
            self.ALLOCATED = value_
            self.ALLOCATED_nsprefix_ = child_.prefix
        elif nodeName_ == 'AR_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AR_ID')
            value_ = self.gds_validate_string(value_, node, 'AR_ID')
            self.AR_ID = value_
            self.AR_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GLOBAL_PREFIX':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GLOBAL_PREFIX')
            value_ = self.gds_validate_string(value_, node, 'GLOBAL_PREFIX')
            self.GLOBAL_PREFIX = value_
            self.GLOBAL_PREFIX_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP')
            value_ = self.gds_validate_string(value_, node, 'IP')
            self.IP = value_
            self.IP_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MAC')
            value_ = self.gds_validate_string(value_, node, 'MAC')
            self.MAC = value_
            self.MAC_nsprefix_ = child_.prefix
        elif nodeName_ == 'PARENT_NETWORK_AR_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PARENT_NETWORK_AR_ID')
            value_ = self.gds_validate_string(value_, node, 'PARENT_NETWORK_AR_ID')
            self.PARENT_NETWORK_AR_ID = value_
            self.PARENT_NETWORK_AR_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
            self.SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TYPE')
            value_ = self.gds_validate_string(value_, node, 'TYPE')
            self.TYPE = value_
            self.TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'ULA_PREFIX':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ULA_PREFIX')
            value_ = self.gds_validate_string(value_, node, 'ULA_PREFIX')
            self.ULA_PREFIX = value_
            self.ULA_PREFIX_nsprefix_ = child_.prefix
        elif nodeName_ == 'VN_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VN_MAD')
            value_ = self.gds_validate_string(value_, node, 'VN_MAD')
            self.VN_MAD = value_
            self.VN_MAD_nsprefix_ = child_.prefix
# end class ARType


class LOCKType67(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LOCKED=None, OWNER=None, TIME=None, REQ_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LOCKED = LOCKED
        self.LOCKED_nsprefix_ = None
        self.OWNER = OWNER
        self.OWNER_nsprefix_ = None
        self.TIME = TIME
        self.TIME_nsprefix_ = None
        self.REQ_ID = REQ_ID
        self.REQ_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOCKType67)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOCKType67.subclass:
            return LOCKType67.subclass(*args_, **kwargs_)
        else:
            return LOCKType67(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LOCKED(self):
        return self.LOCKED
    def set_LOCKED(self, LOCKED):
        self.LOCKED = LOCKED
    def get_OWNER(self):
        return self.OWNER
    def set_OWNER(self, OWNER):
        self.OWNER = OWNER
    def get_TIME(self):
        return self.TIME
    def set_TIME(self, TIME):
        self.TIME = TIME
    def get_REQ_ID(self):
        return self.REQ_ID
    def set_REQ_ID(self, REQ_ID):
        self.REQ_ID = REQ_ID
    def has__content(self):
        if (
            self.LOCKED is not None or
            self.OWNER is not None or
            self.TIME is not None or
            self.REQ_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType67', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOCKType67')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LOCKType67':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LOCKType67')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LOCKType67', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LOCKType67'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType67', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LOCKED is not None:
            namespaceprefix_ = self.LOCKED_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCKED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOCKED>%s</%sLOCKED>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOCKED, input_name='LOCKED'), namespaceprefix_ , eol_))
        if self.OWNER is not None:
            namespaceprefix_ = self.OWNER_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER>%s</%sOWNER>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER, input_name='OWNER'), namespaceprefix_ , eol_))
        if self.TIME is not None:
            namespaceprefix_ = self.TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIME>%s</%sTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIME, input_name='TIME'), namespaceprefix_ , eol_))
        if self.REQ_ID is not None:
            namespaceprefix_ = self.REQ_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.REQ_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREQ_ID>%s</%sREQ_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.REQ_ID, input_name='REQ_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LOCKED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOCKED')
            ival_ = self.gds_validate_integer(ival_, node, 'LOCKED')
            self.LOCKED = ival_
            self.LOCKED_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER')
            self.OWNER = ival_
            self.OWNER_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'TIME')
            self.TIME = ival_
            self.TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'REQ_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REQ_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'REQ_ID')
            self.REQ_ID = ival_
            self.REQ_ID_nsprefix_ = child_.prefix
# end class LOCKType67


class PERMISSIONSType68(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType68)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType68.subclass:
            return PERMISSIONSType68.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType68(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType68', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType68')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONSType68':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONSType68')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONSType68', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONSType68'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType68', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONSType68


class CLUSTERSType69(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTERSType69)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTERSType69.subclass:
            return CLUSTERSType69.subclass(*args_, **kwargs_)
        else:
            return CLUSTERSType69(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTERSType69', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTERSType69')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CLUSTERSType69':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CLUSTERSType69')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CLUSTERSType69', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CLUSTERSType69'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='CLUSTERSType69', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class CLUSTERSType69


class VROUTERSType70(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VROUTERSType70)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VROUTERSType70.subclass:
            return VROUTERSType70.subclass(*args_, **kwargs_)
        else:
            return VROUTERSType70(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VROUTERSType70', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VROUTERSType70')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VROUTERSType70':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VROUTERSType70')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VROUTERSType70', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VROUTERSType70'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VROUTERSType70', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class VROUTERSType70


class UPDATED_VMSType71(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATED_VMSType71)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATED_VMSType71.subclass:
            return UPDATED_VMSType71.subclass(*args_, **kwargs_)
        else:
            return UPDATED_VMSType71(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='UPDATED_VMSType71', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UPDATED_VMSType71')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UPDATED_VMSType71':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UPDATED_VMSType71')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UPDATED_VMSType71', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UPDATED_VMSType71'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='UPDATED_VMSType71', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class UPDATED_VMSType71


class OUTDATED_VMSType72(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OUTDATED_VMSType72)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OUTDATED_VMSType72.subclass:
            return OUTDATED_VMSType72.subclass(*args_, **kwargs_)
        else:
            return OUTDATED_VMSType72(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='OUTDATED_VMSType72', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OUTDATED_VMSType72')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OUTDATED_VMSType72':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OUTDATED_VMSType72')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OUTDATED_VMSType72', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OUTDATED_VMSType72'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='OUTDATED_VMSType72', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class OUTDATED_VMSType72


class UPDATING_VMSType73(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATING_VMSType73)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATING_VMSType73.subclass:
            return UPDATING_VMSType73.subclass(*args_, **kwargs_)
        else:
            return UPDATING_VMSType73(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='UPDATING_VMSType73', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UPDATING_VMSType73')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UPDATING_VMSType73':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UPDATING_VMSType73')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UPDATING_VMSType73', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UPDATING_VMSType73'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='UPDATING_VMSType73', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class UPDATING_VMSType73


class ERROR_VMSType74(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ERROR_VMSType74)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ERROR_VMSType74.subclass:
            return ERROR_VMSType74.subclass(*args_, **kwargs_)
        else:
            return ERROR_VMSType74(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ERROR_VMSType74', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ERROR_VMSType74')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ERROR_VMSType74':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ERROR_VMSType74')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ERROR_VMSType74', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ERROR_VMSType74'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ERROR_VMSType74', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class ERROR_VMSType74


class TEMPLATEType75(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DNS=None, GATEWAY=None, GATEWAY6=None, GUEST_MTU=None, IP6_METHOD=None, IP6_METRIC=None, METHOD=None, METRIC=None, NETWORK_ADDRESS=None, NETWORK_MASK=None, SEARCH_DOMAIN=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DNS = DNS
        self.DNS_nsprefix_ = None
        self.GATEWAY = GATEWAY
        self.GATEWAY_nsprefix_ = None
        self.GATEWAY6 = GATEWAY6
        self.GATEWAY6_nsprefix_ = None
        self.GUEST_MTU = GUEST_MTU
        self.GUEST_MTU_nsprefix_ = None
        self.IP6_METHOD = IP6_METHOD
        self.IP6_METHOD_nsprefix_ = None
        self.IP6_METRIC = IP6_METRIC
        self.IP6_METRIC_nsprefix_ = None
        self.METHOD = METHOD
        self.METHOD_nsprefix_ = None
        self.METRIC = METRIC
        self.METRIC_nsprefix_ = None
        self.NETWORK_ADDRESS = NETWORK_ADDRESS
        self.NETWORK_ADDRESS_nsprefix_ = None
        self.NETWORK_MASK = NETWORK_MASK
        self.NETWORK_MASK_nsprefix_ = None
        self.SEARCH_DOMAIN = SEARCH_DOMAIN
        self.SEARCH_DOMAIN_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEMPLATEType75)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEMPLATEType75.subclass:
            return TEMPLATEType75.subclass(*args_, **kwargs_)
        else:
            return TEMPLATEType75(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DNS(self):
        return self.DNS
    def set_DNS(self, DNS):
        self.DNS = DNS
    def get_GATEWAY(self):
        return self.GATEWAY
    def set_GATEWAY(self, GATEWAY):
        self.GATEWAY = GATEWAY
    def get_GATEWAY6(self):
        return self.GATEWAY6
    def set_GATEWAY6(self, GATEWAY6):
        self.GATEWAY6 = GATEWAY6
    def get_GUEST_MTU(self):
        return self.GUEST_MTU
    def set_GUEST_MTU(self, GUEST_MTU):
        self.GUEST_MTU = GUEST_MTU
    def get_IP6_METHOD(self):
        return self.IP6_METHOD
    def set_IP6_METHOD(self, IP6_METHOD):
        self.IP6_METHOD = IP6_METHOD
    def get_IP6_METRIC(self):
        return self.IP6_METRIC
    def set_IP6_METRIC(self, IP6_METRIC):
        self.IP6_METRIC = IP6_METRIC
    def get_METHOD(self):
        return self.METHOD
    def set_METHOD(self, METHOD):
        self.METHOD = METHOD
    def get_METRIC(self):
        return self.METRIC
    def set_METRIC(self, METRIC):
        self.METRIC = METRIC
    def get_NETWORK_ADDRESS(self):
        return self.NETWORK_ADDRESS
    def set_NETWORK_ADDRESS(self, NETWORK_ADDRESS):
        self.NETWORK_ADDRESS = NETWORK_ADDRESS
    def get_NETWORK_MASK(self):
        return self.NETWORK_MASK
    def set_NETWORK_MASK(self, NETWORK_MASK):
        self.NETWORK_MASK = NETWORK_MASK
    def get_SEARCH_DOMAIN(self):
        return self.SEARCH_DOMAIN
    def set_SEARCH_DOMAIN(self, SEARCH_DOMAIN):
        self.SEARCH_DOMAIN = SEARCH_DOMAIN
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.DNS is not None or
            self.GATEWAY is not None or
            self.GATEWAY6 is not None or
            self.GUEST_MTU is not None or
            self.IP6_METHOD is not None or
            self.IP6_METRIC is not None or
            self.METHOD is not None or
            self.METRIC is not None or
            self.NETWORK_ADDRESS is not None or
            self.NETWORK_MASK is not None or
            self.SEARCH_DOMAIN is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType75', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEMPLATEType75')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEMPLATEType75':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEMPLATEType75')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEMPLATEType75', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEMPLATEType75'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType75', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DNS is not None:
            namespaceprefix_ = self.DNS_nsprefix_ + ':' if (UseCapturedNS_ and self.DNS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDNS>%s</%sDNS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DNS), input_name='DNS')), namespaceprefix_ , eol_))
        if self.GATEWAY is not None:
            namespaceprefix_ = self.GATEWAY_nsprefix_ + ':' if (UseCapturedNS_ and self.GATEWAY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGATEWAY>%s</%sGATEWAY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GATEWAY), input_name='GATEWAY')), namespaceprefix_ , eol_))
        if self.GATEWAY6 is not None:
            namespaceprefix_ = self.GATEWAY6_nsprefix_ + ':' if (UseCapturedNS_ and self.GATEWAY6_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGATEWAY6>%s</%sGATEWAY6>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GATEWAY6), input_name='GATEWAY6')), namespaceprefix_ , eol_))
        if self.GUEST_MTU is not None:
            namespaceprefix_ = self.GUEST_MTU_nsprefix_ + ':' if (UseCapturedNS_ and self.GUEST_MTU_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGUEST_MTU>%s</%sGUEST_MTU>%s' % (namespaceprefix_ , self.gds_format_integer(self.GUEST_MTU, input_name='GUEST_MTU'), namespaceprefix_ , eol_))
        if self.IP6_METHOD is not None:
            namespaceprefix_ = self.IP6_METHOD_nsprefix_ + ':' if (UseCapturedNS_ and self.IP6_METHOD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP6_METHOD>%s</%sIP6_METHOD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP6_METHOD), input_name='IP6_METHOD')), namespaceprefix_ , eol_))
        if self.IP6_METRIC is not None:
            namespaceprefix_ = self.IP6_METRIC_nsprefix_ + ':' if (UseCapturedNS_ and self.IP6_METRIC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP6_METRIC>%s</%sIP6_METRIC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP6_METRIC), input_name='IP6_METRIC')), namespaceprefix_ , eol_))
        if self.METHOD is not None:
            namespaceprefix_ = self.METHOD_nsprefix_ + ':' if (UseCapturedNS_ and self.METHOD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMETHOD>%s</%sMETHOD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.METHOD), input_name='METHOD')), namespaceprefix_ , eol_))
        if self.METRIC is not None:
            namespaceprefix_ = self.METRIC_nsprefix_ + ':' if (UseCapturedNS_ and self.METRIC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMETRIC>%s</%sMETRIC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.METRIC), input_name='METRIC')), namespaceprefix_ , eol_))
        if self.NETWORK_ADDRESS is not None:
            namespaceprefix_ = self.NETWORK_ADDRESS_nsprefix_ + ':' if (UseCapturedNS_ and self.NETWORK_ADDRESS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETWORK_ADDRESS>%s</%sNETWORK_ADDRESS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NETWORK_ADDRESS), input_name='NETWORK_ADDRESS')), namespaceprefix_ , eol_))
        if self.NETWORK_MASK is not None:
            namespaceprefix_ = self.NETWORK_MASK_nsprefix_ + ':' if (UseCapturedNS_ and self.NETWORK_MASK_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNETWORK_MASK>%s</%sNETWORK_MASK>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NETWORK_MASK), input_name='NETWORK_MASK')), namespaceprefix_ , eol_))
        if self.SEARCH_DOMAIN is not None:
            namespaceprefix_ = self.SEARCH_DOMAIN_nsprefix_ + ':' if (UseCapturedNS_ and self.SEARCH_DOMAIN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSEARCH_DOMAIN>%s</%sSEARCH_DOMAIN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SEARCH_DOMAIN), input_name='SEARCH_DOMAIN')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DNS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DNS')
            value_ = self.gds_validate_string(value_, node, 'DNS')
            self.DNS = value_
            self.DNS_nsprefix_ = child_.prefix
        elif nodeName_ == 'GATEWAY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GATEWAY')
            value_ = self.gds_validate_string(value_, node, 'GATEWAY')
            self.GATEWAY = value_
            self.GATEWAY_nsprefix_ = child_.prefix
        elif nodeName_ == 'GATEWAY6':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GATEWAY6')
            value_ = self.gds_validate_string(value_, node, 'GATEWAY6')
            self.GATEWAY6 = value_
            self.GATEWAY6_nsprefix_ = child_.prefix
        elif nodeName_ == 'GUEST_MTU' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GUEST_MTU')
            ival_ = self.gds_validate_integer(ival_, node, 'GUEST_MTU')
            self.GUEST_MTU = ival_
            self.GUEST_MTU_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP6_METHOD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP6_METHOD')
            value_ = self.gds_validate_string(value_, node, 'IP6_METHOD')
            self.IP6_METHOD = value_
            self.IP6_METHOD_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP6_METRIC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP6_METRIC')
            value_ = self.gds_validate_string(value_, node, 'IP6_METRIC')
            self.IP6_METRIC = value_
            self.IP6_METRIC_nsprefix_ = child_.prefix
        elif nodeName_ == 'METHOD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'METHOD')
            value_ = self.gds_validate_string(value_, node, 'METHOD')
            self.METHOD = value_
            self.METHOD_nsprefix_ = child_.prefix
        elif nodeName_ == 'METRIC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'METRIC')
            value_ = self.gds_validate_string(value_, node, 'METRIC')
            self.METRIC = value_
            self.METRIC_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETWORK_ADDRESS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NETWORK_ADDRESS')
            value_ = self.gds_validate_string(value_, node, 'NETWORK_ADDRESS')
            self.NETWORK_ADDRESS = value_
            self.NETWORK_ADDRESS_nsprefix_ = child_.prefix
        elif nodeName_ == 'NETWORK_MASK':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NETWORK_MASK')
            value_ = self.gds_validate_string(value_, node, 'NETWORK_MASK')
            self.NETWORK_MASK = value_
            self.NETWORK_MASK_nsprefix_ = child_.prefix
        elif nodeName_ == 'SEARCH_DOMAIN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SEARCH_DOMAIN')
            value_ = self.gds_validate_string(value_, node, 'SEARCH_DOMAIN')
            self.SEARCH_DOMAIN = value_
            self.SEARCH_DOMAIN_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'TEMPLATEType75')
            self.anytypeobjs_.append(content_)
# end class TEMPLATEType75


class AR_POOLType76(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, AR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if AR is None:
            self.AR = []
        else:
            self.AR = AR
        self.AR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AR_POOLType76)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AR_POOLType76.subclass:
            return AR_POOLType76.subclass(*args_, **kwargs_)
        else:
            return AR_POOLType76(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AR(self):
        return self.AR
    def set_AR(self, AR):
        self.AR = AR
    def add_AR(self, value):
        self.AR.append(value)
    def insert_AR_at(self, index, value):
        self.AR.insert(index, value)
    def replace_AR_at(self, index, value):
        self.AR[index] = value
    def has__content(self):
        if (
            self.AR
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='AR_POOLType76', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AR_POOLType76')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AR_POOLType76':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AR_POOLType76')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AR_POOLType76', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AR_POOLType76'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='AR_POOLType76', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AR_ in self.AR:
            namespaceprefix_ = self.AR_nsprefix_ + ':' if (UseCapturedNS_ and self.AR_nsprefix_) else ''
            AR_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AR', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AR':
            obj_ = ARType77.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AR.append(obj_)
            obj_.original_tagname_ = 'AR'
# end class AR_POOLType76


class ARType77(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, AR_ID=None, GLOBAL_PREFIX=None, IP=None, MAC=None, PARENT_NETWORK_AR_ID=None, SIZE=None, TYPE=None, ULA_PREFIX=None, VN_MAD=None, MAC_END=None, IP_END=None, IP6_ULA=None, IP6_ULA_END=None, IP6_GLOBAL=None, IP6_GLOBAL_END=None, IP6=None, IP6_END=None, PORT_START=None, PORT_SIZE=None, USED_LEASES=None, LEASES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AR_ID = AR_ID
        self.AR_ID_nsprefix_ = None
        self.GLOBAL_PREFIX = GLOBAL_PREFIX
        self.GLOBAL_PREFIX_nsprefix_ = None
        self.IP = IP
        self.IP_nsprefix_ = None
        self.MAC = MAC
        self.MAC_nsprefix_ = None
        self.PARENT_NETWORK_AR_ID = PARENT_NETWORK_AR_ID
        self.PARENT_NETWORK_AR_ID_nsprefix_ = None
        self.SIZE = SIZE
        self.SIZE_nsprefix_ = None
        self.TYPE = TYPE
        self.TYPE_nsprefix_ = None
        self.ULA_PREFIX = ULA_PREFIX
        self.ULA_PREFIX_nsprefix_ = None
        self.VN_MAD = VN_MAD
        self.VN_MAD_nsprefix_ = None
        self.MAC_END = MAC_END
        self.MAC_END_nsprefix_ = None
        self.IP_END = IP_END
        self.IP_END_nsprefix_ = None
        self.IP6_ULA = IP6_ULA
        self.IP6_ULA_nsprefix_ = None
        self.IP6_ULA_END = IP6_ULA_END
        self.IP6_ULA_END_nsprefix_ = None
        self.IP6_GLOBAL = IP6_GLOBAL
        self.IP6_GLOBAL_nsprefix_ = None
        self.IP6_GLOBAL_END = IP6_GLOBAL_END
        self.IP6_GLOBAL_END_nsprefix_ = None
        self.IP6 = IP6
        self.IP6_nsprefix_ = None
        self.IP6_END = IP6_END
        self.IP6_END_nsprefix_ = None
        self.PORT_START = PORT_START
        self.PORT_START_nsprefix_ = None
        self.PORT_SIZE = PORT_SIZE
        self.PORT_SIZE_nsprefix_ = None
        self.USED_LEASES = USED_LEASES
        self.USED_LEASES_nsprefix_ = None
        self.LEASES = LEASES
        self.LEASES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ARType77)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ARType77.subclass:
            return ARType77.subclass(*args_, **kwargs_)
        else:
            return ARType77(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AR_ID(self):
        return self.AR_ID
    def set_AR_ID(self, AR_ID):
        self.AR_ID = AR_ID
    def get_GLOBAL_PREFIX(self):
        return self.GLOBAL_PREFIX
    def set_GLOBAL_PREFIX(self, GLOBAL_PREFIX):
        self.GLOBAL_PREFIX = GLOBAL_PREFIX
    def get_IP(self):
        return self.IP
    def set_IP(self, IP):
        self.IP = IP
    def get_MAC(self):
        return self.MAC
    def set_MAC(self, MAC):
        self.MAC = MAC
    def get_PARENT_NETWORK_AR_ID(self):
        return self.PARENT_NETWORK_AR_ID
    def set_PARENT_NETWORK_AR_ID(self, PARENT_NETWORK_AR_ID):
        self.PARENT_NETWORK_AR_ID = PARENT_NETWORK_AR_ID
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_ULA_PREFIX(self):
        return self.ULA_PREFIX
    def set_ULA_PREFIX(self, ULA_PREFIX):
        self.ULA_PREFIX = ULA_PREFIX
    def get_VN_MAD(self):
        return self.VN_MAD
    def set_VN_MAD(self, VN_MAD):
        self.VN_MAD = VN_MAD
    def get_MAC_END(self):
        return self.MAC_END
    def set_MAC_END(self, MAC_END):
        self.MAC_END = MAC_END
    def get_IP_END(self):
        return self.IP_END
    def set_IP_END(self, IP_END):
        self.IP_END = IP_END
    def get_IP6_ULA(self):
        return self.IP6_ULA
    def set_IP6_ULA(self, IP6_ULA):
        self.IP6_ULA = IP6_ULA
    def get_IP6_ULA_END(self):
        return self.IP6_ULA_END
    def set_IP6_ULA_END(self, IP6_ULA_END):
        self.IP6_ULA_END = IP6_ULA_END
    def get_IP6_GLOBAL(self):
        return self.IP6_GLOBAL
    def set_IP6_GLOBAL(self, IP6_GLOBAL):
        self.IP6_GLOBAL = IP6_GLOBAL
    def get_IP6_GLOBAL_END(self):
        return self.IP6_GLOBAL_END
    def set_IP6_GLOBAL_END(self, IP6_GLOBAL_END):
        self.IP6_GLOBAL_END = IP6_GLOBAL_END
    def get_IP6(self):
        return self.IP6
    def set_IP6(self, IP6):
        self.IP6 = IP6
    def get_IP6_END(self):
        return self.IP6_END
    def set_IP6_END(self, IP6_END):
        self.IP6_END = IP6_END
    def get_PORT_START(self):
        return self.PORT_START
    def set_PORT_START(self, PORT_START):
        self.PORT_START = PORT_START
    def get_PORT_SIZE(self):
        return self.PORT_SIZE
    def set_PORT_SIZE(self, PORT_SIZE):
        self.PORT_SIZE = PORT_SIZE
    def get_USED_LEASES(self):
        return self.USED_LEASES
    def set_USED_LEASES(self, USED_LEASES):
        self.USED_LEASES = USED_LEASES
    def get_LEASES(self):
        return self.LEASES
    def set_LEASES(self, LEASES):
        self.LEASES = LEASES
    def has__content(self):
        if (
            self.AR_ID is not None or
            self.GLOBAL_PREFIX is not None or
            self.IP is not None or
            self.MAC is not None or
            self.PARENT_NETWORK_AR_ID is not None or
            self.SIZE is not None or
            self.TYPE is not None or
            self.ULA_PREFIX is not None or
            self.VN_MAD is not None or
            self.MAC_END is not None or
            self.IP_END is not None or
            self.IP6_ULA is not None or
            self.IP6_ULA_END is not None or
            self.IP6_GLOBAL is not None or
            self.IP6_GLOBAL_END is not None or
            self.IP6 is not None or
            self.IP6_END is not None or
            self.PORT_START is not None or
            self.PORT_SIZE is not None or
            self.USED_LEASES is not None or
            self.LEASES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ARType77', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ARType77')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ARType77':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ARType77')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ARType77', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ARType77'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ARType77', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AR_ID is not None:
            namespaceprefix_ = self.AR_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.AR_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAR_ID>%s</%sAR_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AR_ID), input_name='AR_ID')), namespaceprefix_ , eol_))
        if self.GLOBAL_PREFIX is not None:
            namespaceprefix_ = self.GLOBAL_PREFIX_nsprefix_ + ':' if (UseCapturedNS_ and self.GLOBAL_PREFIX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGLOBAL_PREFIX>%s</%sGLOBAL_PREFIX>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GLOBAL_PREFIX), input_name='GLOBAL_PREFIX')), namespaceprefix_ , eol_))
        if self.IP is not None:
            namespaceprefix_ = self.IP_nsprefix_ + ':' if (UseCapturedNS_ and self.IP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP>%s</%sIP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP), input_name='IP')), namespaceprefix_ , eol_))
        if self.MAC is not None:
            namespaceprefix_ = self.MAC_nsprefix_ + ':' if (UseCapturedNS_ and self.MAC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAC>%s</%sMAC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MAC), input_name='MAC')), namespaceprefix_ , eol_))
        if self.PARENT_NETWORK_AR_ID is not None:
            namespaceprefix_ = self.PARENT_NETWORK_AR_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.PARENT_NETWORK_AR_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPARENT_NETWORK_AR_ID>%s</%sPARENT_NETWORK_AR_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PARENT_NETWORK_AR_ID), input_name='PARENT_NETWORK_AR_ID')), namespaceprefix_ , eol_))
        if self.SIZE is not None:
            namespaceprefix_ = self.SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSIZE>%s</%sSIZE>%s' % (namespaceprefix_ , self.gds_format_integer(self.SIZE, input_name='SIZE'), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), namespaceprefix_ , eol_))
        if self.ULA_PREFIX is not None:
            namespaceprefix_ = self.ULA_PREFIX_nsprefix_ + ':' if (UseCapturedNS_ and self.ULA_PREFIX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sULA_PREFIX>%s</%sULA_PREFIX>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ULA_PREFIX), input_name='ULA_PREFIX')), namespaceprefix_ , eol_))
        if self.VN_MAD is not None:
            namespaceprefix_ = self.VN_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.VN_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVN_MAD>%s</%sVN_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VN_MAD), input_name='VN_MAD')), namespaceprefix_ , eol_))
        if self.MAC_END is not None:
            namespaceprefix_ = self.MAC_END_nsprefix_ + ':' if (UseCapturedNS_ and self.MAC_END_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAC_END>%s</%sMAC_END>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MAC_END), input_name='MAC_END')), namespaceprefix_ , eol_))
        if self.IP_END is not None:
            namespaceprefix_ = self.IP_END_nsprefix_ + ':' if (UseCapturedNS_ and self.IP_END_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP_END>%s</%sIP_END>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP_END), input_name='IP_END')), namespaceprefix_ , eol_))
        if self.IP6_ULA is not None:
            namespaceprefix_ = self.IP6_ULA_nsprefix_ + ':' if (UseCapturedNS_ and self.IP6_ULA_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP6_ULA>%s</%sIP6_ULA>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP6_ULA), input_name='IP6_ULA')), namespaceprefix_ , eol_))
        if self.IP6_ULA_END is not None:
            namespaceprefix_ = self.IP6_ULA_END_nsprefix_ + ':' if (UseCapturedNS_ and self.IP6_ULA_END_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP6_ULA_END>%s</%sIP6_ULA_END>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP6_ULA_END), input_name='IP6_ULA_END')), namespaceprefix_ , eol_))
        if self.IP6_GLOBAL is not None:
            namespaceprefix_ = self.IP6_GLOBAL_nsprefix_ + ':' if (UseCapturedNS_ and self.IP6_GLOBAL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP6_GLOBAL>%s</%sIP6_GLOBAL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP6_GLOBAL), input_name='IP6_GLOBAL')), namespaceprefix_ , eol_))
        if self.IP6_GLOBAL_END is not None:
            namespaceprefix_ = self.IP6_GLOBAL_END_nsprefix_ + ':' if (UseCapturedNS_ and self.IP6_GLOBAL_END_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP6_GLOBAL_END>%s</%sIP6_GLOBAL_END>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP6_GLOBAL_END), input_name='IP6_GLOBAL_END')), namespaceprefix_ , eol_))
        if self.IP6 is not None:
            namespaceprefix_ = self.IP6_nsprefix_ + ':' if (UseCapturedNS_ and self.IP6_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP6>%s</%sIP6>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP6), input_name='IP6')), namespaceprefix_ , eol_))
        if self.IP6_END is not None:
            namespaceprefix_ = self.IP6_END_nsprefix_ + ':' if (UseCapturedNS_ and self.IP6_END_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP6_END>%s</%sIP6_END>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP6_END), input_name='IP6_END')), namespaceprefix_ , eol_))
        if self.PORT_START is not None:
            namespaceprefix_ = self.PORT_START_nsprefix_ + ':' if (UseCapturedNS_ and self.PORT_START_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPORT_START>%s</%sPORT_START>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PORT_START), input_name='PORT_START')), namespaceprefix_ , eol_))
        if self.PORT_SIZE is not None:
            namespaceprefix_ = self.PORT_SIZE_nsprefix_ + ':' if (UseCapturedNS_ and self.PORT_SIZE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPORT_SIZE>%s</%sPORT_SIZE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PORT_SIZE), input_name='PORT_SIZE')), namespaceprefix_ , eol_))
        if self.USED_LEASES is not None:
            namespaceprefix_ = self.USED_LEASES_nsprefix_ + ':' if (UseCapturedNS_ and self.USED_LEASES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUSED_LEASES>%s</%sUSED_LEASES>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.USED_LEASES), input_name='USED_LEASES')), namespaceprefix_ , eol_))
        if self.LEASES is not None:
            namespaceprefix_ = self.LEASES_nsprefix_ + ':' if (UseCapturedNS_ and self.LEASES_nsprefix_) else ''
            self.LEASES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LEASES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AR_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AR_ID')
            value_ = self.gds_validate_string(value_, node, 'AR_ID')
            self.AR_ID = value_
            self.AR_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'GLOBAL_PREFIX':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GLOBAL_PREFIX')
            value_ = self.gds_validate_string(value_, node, 'GLOBAL_PREFIX')
            self.GLOBAL_PREFIX = value_
            self.GLOBAL_PREFIX_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP')
            value_ = self.gds_validate_string(value_, node, 'IP')
            self.IP = value_
            self.IP_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MAC')
            value_ = self.gds_validate_string(value_, node, 'MAC')
            self.MAC = value_
            self.MAC_nsprefix_ = child_.prefix
        elif nodeName_ == 'PARENT_NETWORK_AR_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PARENT_NETWORK_AR_ID')
            value_ = self.gds_validate_string(value_, node, 'PARENT_NETWORK_AR_ID')
            self.PARENT_NETWORK_AR_ID = value_
            self.PARENT_NETWORK_AR_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'SIZE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SIZE')
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
            self.SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TYPE')
            value_ = self.gds_validate_string(value_, node, 'TYPE')
            self.TYPE = value_
            self.TYPE_nsprefix_ = child_.prefix
        elif nodeName_ == 'ULA_PREFIX':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ULA_PREFIX')
            value_ = self.gds_validate_string(value_, node, 'ULA_PREFIX')
            self.ULA_PREFIX = value_
            self.ULA_PREFIX_nsprefix_ = child_.prefix
        elif nodeName_ == 'VN_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VN_MAD')
            value_ = self.gds_validate_string(value_, node, 'VN_MAD')
            self.VN_MAD = value_
            self.VN_MAD_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAC_END':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MAC_END')
            value_ = self.gds_validate_string(value_, node, 'MAC_END')
            self.MAC_END = value_
            self.MAC_END_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP_END':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP_END')
            value_ = self.gds_validate_string(value_, node, 'IP_END')
            self.IP_END = value_
            self.IP_END_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP6_ULA':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP6_ULA')
            value_ = self.gds_validate_string(value_, node, 'IP6_ULA')
            self.IP6_ULA = value_
            self.IP6_ULA_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP6_ULA_END':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP6_ULA_END')
            value_ = self.gds_validate_string(value_, node, 'IP6_ULA_END')
            self.IP6_ULA_END = value_
            self.IP6_ULA_END_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP6_GLOBAL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP6_GLOBAL')
            value_ = self.gds_validate_string(value_, node, 'IP6_GLOBAL')
            self.IP6_GLOBAL = value_
            self.IP6_GLOBAL_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP6_GLOBAL_END':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP6_GLOBAL_END')
            value_ = self.gds_validate_string(value_, node, 'IP6_GLOBAL_END')
            self.IP6_GLOBAL_END = value_
            self.IP6_GLOBAL_END_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP6':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP6')
            value_ = self.gds_validate_string(value_, node, 'IP6')
            self.IP6 = value_
            self.IP6_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP6_END':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP6_END')
            value_ = self.gds_validate_string(value_, node, 'IP6_END')
            self.IP6_END = value_
            self.IP6_END_nsprefix_ = child_.prefix
        elif nodeName_ == 'PORT_START':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PORT_START')
            value_ = self.gds_validate_string(value_, node, 'PORT_START')
            self.PORT_START = value_
            self.PORT_START_nsprefix_ = child_.prefix
        elif nodeName_ == 'PORT_SIZE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PORT_SIZE')
            value_ = self.gds_validate_string(value_, node, 'PORT_SIZE')
            self.PORT_SIZE = value_
            self.PORT_SIZE_nsprefix_ = child_.prefix
        elif nodeName_ == 'USED_LEASES':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'USED_LEASES')
            value_ = self.gds_validate_string(value_, node, 'USED_LEASES')
            self.USED_LEASES = value_
            self.USED_LEASES_nsprefix_ = child_.prefix
        elif nodeName_ == 'LEASES':
            obj_ = LEASESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LEASES = obj_
            obj_.original_tagname_ = 'LEASES'
# end class ARType77


class LEASESType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LEASE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if LEASE is None:
            self.LEASE = []
        else:
            self.LEASE = LEASE
        self.LEASE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LEASESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LEASESType.subclass:
            return LEASESType.subclass(*args_, **kwargs_)
        else:
            return LEASESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LEASE(self):
        return self.LEASE
    def set_LEASE(self, LEASE):
        self.LEASE = LEASE
    def add_LEASE(self, value):
        self.LEASE.append(value)
    def insert_LEASE_at(self, index, value):
        self.LEASE.insert(index, value)
    def replace_LEASE_at(self, index, value):
        self.LEASE[index] = value
    def has__content(self):
        if (
            self.LEASE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LEASESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LEASESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LEASESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LEASESType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LEASESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LEASESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LEASESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LEASE_ in self.LEASE:
            namespaceprefix_ = self.LEASE_nsprefix_ + ':' if (UseCapturedNS_ and self.LEASE_nsprefix_) else ''
            LEASE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LEASE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LEASE':
            obj_ = LEASEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LEASE.append(obj_)
            obj_.original_tagname_ = 'LEASE'
# end class LEASESType


class LEASEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IP=None, IP6=None, IP6_GLOBAL=None, IP6_LINK=None, IP6_ULA=None, MAC=None, VM=None, VNET=None, VROUTER=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.IP = IP
        self.IP_nsprefix_ = None
        self.IP6 = IP6
        self.IP6_nsprefix_ = None
        self.IP6_GLOBAL = IP6_GLOBAL
        self.IP6_GLOBAL_nsprefix_ = None
        self.IP6_LINK = IP6_LINK
        self.IP6_LINK_nsprefix_ = None
        self.IP6_ULA = IP6_ULA
        self.IP6_ULA_nsprefix_ = None
        self.MAC = MAC
        self.MAC_nsprefix_ = None
        self.VM = VM
        self.VM_nsprefix_ = None
        self.VNET = VNET
        self.VNET_nsprefix_ = None
        self.VROUTER = VROUTER
        self.VROUTER_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LEASEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LEASEType.subclass:
            return LEASEType.subclass(*args_, **kwargs_)
        else:
            return LEASEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IP(self):
        return self.IP
    def set_IP(self, IP):
        self.IP = IP
    def get_IP6(self):
        return self.IP6
    def set_IP6(self, IP6):
        self.IP6 = IP6
    def get_IP6_GLOBAL(self):
        return self.IP6_GLOBAL
    def set_IP6_GLOBAL(self, IP6_GLOBAL):
        self.IP6_GLOBAL = IP6_GLOBAL
    def get_IP6_LINK(self):
        return self.IP6_LINK
    def set_IP6_LINK(self, IP6_LINK):
        self.IP6_LINK = IP6_LINK
    def get_IP6_ULA(self):
        return self.IP6_ULA
    def set_IP6_ULA(self, IP6_ULA):
        self.IP6_ULA = IP6_ULA
    def get_MAC(self):
        return self.MAC
    def set_MAC(self, MAC):
        self.MAC = MAC
    def get_VM(self):
        return self.VM
    def set_VM(self, VM):
        self.VM = VM
    def get_VNET(self):
        return self.VNET
    def set_VNET(self, VNET):
        self.VNET = VNET
    def get_VROUTER(self):
        return self.VROUTER
    def set_VROUTER(self, VROUTER):
        self.VROUTER = VROUTER
    def has__content(self):
        if (
            self.IP is not None or
            self.IP6 is not None or
            self.IP6_GLOBAL is not None or
            self.IP6_LINK is not None or
            self.IP6_ULA is not None or
            self.MAC is not None or
            self.VM is not None or
            self.VNET is not None or
            self.VROUTER is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LEASEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LEASEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LEASEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LEASEType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LEASEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LEASEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LEASEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IP is not None:
            namespaceprefix_ = self.IP_nsprefix_ + ':' if (UseCapturedNS_ and self.IP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP>%s</%sIP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP), input_name='IP')), namespaceprefix_ , eol_))
        if self.IP6 is not None:
            namespaceprefix_ = self.IP6_nsprefix_ + ':' if (UseCapturedNS_ and self.IP6_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP6>%s</%sIP6>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP6), input_name='IP6')), namespaceprefix_ , eol_))
        if self.IP6_GLOBAL is not None:
            namespaceprefix_ = self.IP6_GLOBAL_nsprefix_ + ':' if (UseCapturedNS_ and self.IP6_GLOBAL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP6_GLOBAL>%s</%sIP6_GLOBAL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP6_GLOBAL), input_name='IP6_GLOBAL')), namespaceprefix_ , eol_))
        if self.IP6_LINK is not None:
            namespaceprefix_ = self.IP6_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.IP6_LINK_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP6_LINK>%s</%sIP6_LINK>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP6_LINK), input_name='IP6_LINK')), namespaceprefix_ , eol_))
        if self.IP6_ULA is not None:
            namespaceprefix_ = self.IP6_ULA_nsprefix_ + ':' if (UseCapturedNS_ and self.IP6_ULA_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIP6_ULA>%s</%sIP6_ULA>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IP6_ULA), input_name='IP6_ULA')), namespaceprefix_ , eol_))
        if self.MAC is not None:
            namespaceprefix_ = self.MAC_nsprefix_ + ':' if (UseCapturedNS_ and self.MAC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAC>%s</%sMAC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MAC), input_name='MAC')), namespaceprefix_ , eol_))
        if self.VM is not None:
            namespaceprefix_ = self.VM_nsprefix_ + ':' if (UseCapturedNS_ and self.VM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVM>%s</%sVM>%s' % (namespaceprefix_ , self.gds_format_integer(self.VM, input_name='VM'), namespaceprefix_ , eol_))
        if self.VNET is not None:
            namespaceprefix_ = self.VNET_nsprefix_ + ':' if (UseCapturedNS_ and self.VNET_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVNET>%s</%sVNET>%s' % (namespaceprefix_ , self.gds_format_integer(self.VNET, input_name='VNET'), namespaceprefix_ , eol_))
        if self.VROUTER is not None:
            namespaceprefix_ = self.VROUTER_nsprefix_ + ':' if (UseCapturedNS_ and self.VROUTER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVROUTER>%s</%sVROUTER>%s' % (namespaceprefix_ , self.gds_format_integer(self.VROUTER, input_name='VROUTER'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP')
            value_ = self.gds_validate_string(value_, node, 'IP')
            self.IP = value_
            self.IP_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP6':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP6')
            value_ = self.gds_validate_string(value_, node, 'IP6')
            self.IP6 = value_
            self.IP6_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP6_GLOBAL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP6_GLOBAL')
            value_ = self.gds_validate_string(value_, node, 'IP6_GLOBAL')
            self.IP6_GLOBAL = value_
            self.IP6_GLOBAL_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP6_LINK':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP6_LINK')
            value_ = self.gds_validate_string(value_, node, 'IP6_LINK')
            self.IP6_LINK = value_
            self.IP6_LINK_nsprefix_ = child_.prefix
        elif nodeName_ == 'IP6_ULA':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IP6_ULA')
            value_ = self.gds_validate_string(value_, node, 'IP6_ULA')
            self.IP6_ULA = value_
            self.IP6_ULA_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MAC')
            value_ = self.gds_validate_string(value_, node, 'MAC')
            self.MAC = value_
            self.MAC_nsprefix_ = child_.prefix
        elif nodeName_ == 'VM' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VM')
            ival_ = self.gds_validate_integer(ival_, node, 'VM')
            self.VM = ival_
            self.VM_nsprefix_ = child_.prefix
        elif nodeName_ == 'VNET' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VNET')
            ival_ = self.gds_validate_integer(ival_, node, 'VNET')
            self.VNET = ival_
            self.VNET_nsprefix_ = child_.prefix
        elif nodeName_ == 'VROUTER' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VROUTER')
            ival_ = self.gds_validate_integer(ival_, node, 'VROUTER')
            self.VROUTER = ival_
            self.VROUTER_nsprefix_ = child_.prefix
# end class LEASEType


class LOCKType78(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LOCKED=None, OWNER=None, TIME=None, REQ_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LOCKED = LOCKED
        self.LOCKED_nsprefix_ = None
        self.OWNER = OWNER
        self.OWNER_nsprefix_ = None
        self.TIME = TIME
        self.TIME_nsprefix_ = None
        self.REQ_ID = REQ_ID
        self.REQ_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOCKType78)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOCKType78.subclass:
            return LOCKType78.subclass(*args_, **kwargs_)
        else:
            return LOCKType78(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LOCKED(self):
        return self.LOCKED
    def set_LOCKED(self, LOCKED):
        self.LOCKED = LOCKED
    def get_OWNER(self):
        return self.OWNER
    def set_OWNER(self, OWNER):
        self.OWNER = OWNER
    def get_TIME(self):
        return self.TIME
    def set_TIME(self, TIME):
        self.TIME = TIME
    def get_REQ_ID(self):
        return self.REQ_ID
    def set_REQ_ID(self, REQ_ID):
        self.REQ_ID = REQ_ID
    def has__content(self):
        if (
            self.LOCKED is not None or
            self.OWNER is not None or
            self.TIME is not None or
            self.REQ_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType78', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOCKType78')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LOCKType78':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LOCKType78')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LOCKType78', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LOCKType78'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType78', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LOCKED is not None:
            namespaceprefix_ = self.LOCKED_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCKED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOCKED>%s</%sLOCKED>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOCKED, input_name='LOCKED'), namespaceprefix_ , eol_))
        if self.OWNER is not None:
            namespaceprefix_ = self.OWNER_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER>%s</%sOWNER>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER, input_name='OWNER'), namespaceprefix_ , eol_))
        if self.TIME is not None:
            namespaceprefix_ = self.TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIME>%s</%sTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIME, input_name='TIME'), namespaceprefix_ , eol_))
        if self.REQ_ID is not None:
            namespaceprefix_ = self.REQ_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.REQ_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREQ_ID>%s</%sREQ_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.REQ_ID, input_name='REQ_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LOCKED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOCKED')
            ival_ = self.gds_validate_integer(ival_, node, 'LOCKED')
            self.LOCKED = ival_
            self.LOCKED_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER')
            self.OWNER = ival_
            self.OWNER_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'TIME')
            self.TIME = ival_
            self.TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'REQ_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REQ_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'REQ_ID')
            self.REQ_ID = ival_
            self.REQ_ID_nsprefix_ = child_.prefix
# end class LOCKType78


class PERMISSIONSType79(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType79)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType79.subclass:
            return PERMISSIONSType79.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType79(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType79', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType79')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONSType79':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONSType79')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONSType79', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONSType79'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType79', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONSType79


class TEMPLATEType80(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VN_MAD=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.VN_MAD = VN_MAD
        self.VN_MAD_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEMPLATEType80)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEMPLATEType80.subclass:
            return TEMPLATEType80.subclass(*args_, **kwargs_)
        else:
            return TEMPLATEType80(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VN_MAD(self):
        return self.VN_MAD
    def set_VN_MAD(self, VN_MAD):
        self.VN_MAD = VN_MAD
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.VN_MAD is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType80', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEMPLATEType80')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEMPLATEType80':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEMPLATEType80')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEMPLATEType80', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEMPLATEType80'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType80', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VN_MAD is not None:
            namespaceprefix_ = self.VN_MAD_nsprefix_ + ':' if (UseCapturedNS_ and self.VN_MAD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVN_MAD>%s</%sVN_MAD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VN_MAD), input_name='VN_MAD')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VN_MAD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VN_MAD')
            value_ = self.gds_validate_string(value_, node, 'VN_MAD')
            self.VN_MAD = value_
            self.VN_MAD_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'TEMPLATEType80')
            self.anytypeobjs_.append(content_)
# end class TEMPLATEType80


class PERMISSIONSType81(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_U_nsprefix_ = None
        self.OWNER_M = OWNER_M
        self.OWNER_M_nsprefix_ = None
        self.OWNER_A = OWNER_A
        self.OWNER_A_nsprefix_ = None
        self.GROUP_U = GROUP_U
        self.GROUP_U_nsprefix_ = None
        self.GROUP_M = GROUP_M
        self.GROUP_M_nsprefix_ = None
        self.GROUP_A = GROUP_A
        self.GROUP_A_nsprefix_ = None
        self.OTHER_U = OTHER_U
        self.OTHER_U_nsprefix_ = None
        self.OTHER_M = OTHER_M
        self.OTHER_M_nsprefix_ = None
        self.OTHER_A = OTHER_A
        self.OTHER_A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType81)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType81.subclass:
            return PERMISSIONSType81.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType81(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OWNER_U(self):
        return self.OWNER_U
    def set_OWNER_U(self, OWNER_U):
        self.OWNER_U = OWNER_U
    def get_OWNER_M(self):
        return self.OWNER_M
    def set_OWNER_M(self, OWNER_M):
        self.OWNER_M = OWNER_M
    def get_OWNER_A(self):
        return self.OWNER_A
    def set_OWNER_A(self, OWNER_A):
        self.OWNER_A = OWNER_A
    def get_GROUP_U(self):
        return self.GROUP_U
    def set_GROUP_U(self, GROUP_U):
        self.GROUP_U = GROUP_U
    def get_GROUP_M(self):
        return self.GROUP_M
    def set_GROUP_M(self, GROUP_M):
        self.GROUP_M = GROUP_M
    def get_GROUP_A(self):
        return self.GROUP_A
    def set_GROUP_A(self, GROUP_A):
        self.GROUP_A = GROUP_A
    def get_OTHER_U(self):
        return self.OTHER_U
    def set_OTHER_U(self, OTHER_U):
        self.OTHER_U = OTHER_U
    def get_OTHER_M(self):
        return self.OTHER_M
    def set_OTHER_M(self, OTHER_M):
        self.OTHER_M = OTHER_M
    def get_OTHER_A(self):
        return self.OTHER_A
    def set_OTHER_A(self, OTHER_A):
        self.OTHER_A = OTHER_A
    def has__content(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType81', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType81')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PERMISSIONSType81':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PERMISSIONSType81')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PERMISSIONSType81', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PERMISSIONSType81'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='PERMISSIONSType81', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            namespaceprefix_ = self.OWNER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_U>%s</%sOWNER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), namespaceprefix_ , eol_))
        if self.OWNER_M is not None:
            namespaceprefix_ = self.OWNER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_M>%s</%sOWNER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), namespaceprefix_ , eol_))
        if self.OWNER_A is not None:
            namespaceprefix_ = self.OWNER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER_A>%s</%sOWNER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), namespaceprefix_ , eol_))
        if self.GROUP_U is not None:
            namespaceprefix_ = self.GROUP_U_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_U>%s</%sGROUP_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), namespaceprefix_ , eol_))
        if self.GROUP_M is not None:
            namespaceprefix_ = self.GROUP_M_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_M>%s</%sGROUP_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), namespaceprefix_ , eol_))
        if self.GROUP_A is not None:
            namespaceprefix_ = self.GROUP_A_nsprefix_ + ':' if (UseCapturedNS_ and self.GROUP_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROUP_A>%s</%sGROUP_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), namespaceprefix_ , eol_))
        if self.OTHER_U is not None:
            namespaceprefix_ = self.OTHER_U_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_U_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_U>%s</%sOTHER_U>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), namespaceprefix_ , eol_))
        if self.OTHER_M is not None:
            namespaceprefix_ = self.OTHER_M_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_M_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_M>%s</%sOTHER_M>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), namespaceprefix_ , eol_))
        if self.OTHER_A is not None:
            namespaceprefix_ = self.OTHER_A_nsprefix_ + ':' if (UseCapturedNS_ and self.OTHER_A_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTHER_A>%s</%sOTHER_A>%s' % (namespaceprefix_ , self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OWNER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
            self.OWNER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
            self.OWNER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
            self.OWNER_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_U')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
            self.GROUP_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_M')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
            self.GROUP_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROUP_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GROUP_A')
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
            self.GROUP_A_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_U' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_U')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
            self.OTHER_U_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_M' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_M')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
            self.OTHER_M_nsprefix_ = child_.prefix
        elif nodeName_ == 'OTHER_A' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OTHER_A')
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
            self.OTHER_A_nsprefix_ = child_.prefix
# end class PERMISSIONSType81


class LOCKType82(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LOCKED=None, OWNER=None, TIME=None, REQ_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LOCKED = LOCKED
        self.LOCKED_nsprefix_ = None
        self.OWNER = OWNER
        self.OWNER_nsprefix_ = None
        self.TIME = TIME
        self.TIME_nsprefix_ = None
        self.REQ_ID = REQ_ID
        self.REQ_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOCKType82)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOCKType82.subclass:
            return LOCKType82.subclass(*args_, **kwargs_)
        else:
            return LOCKType82(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LOCKED(self):
        return self.LOCKED
    def set_LOCKED(self, LOCKED):
        self.LOCKED = LOCKED
    def get_OWNER(self):
        return self.OWNER
    def set_OWNER(self, OWNER):
        self.OWNER = OWNER
    def get_TIME(self):
        return self.TIME
    def set_TIME(self, TIME):
        self.TIME = TIME
    def get_REQ_ID(self):
        return self.REQ_ID
    def set_REQ_ID(self, REQ_ID):
        self.REQ_ID = REQ_ID
    def has__content(self):
        if (
            self.LOCKED is not None or
            self.OWNER is not None or
            self.TIME is not None or
            self.REQ_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType82', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOCKType82')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LOCKType82':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LOCKType82')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LOCKType82', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LOCKType82'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='LOCKType82', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LOCKED is not None:
            namespaceprefix_ = self.LOCKED_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCKED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOCKED>%s</%sLOCKED>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOCKED, input_name='LOCKED'), namespaceprefix_ , eol_))
        if self.OWNER is not None:
            namespaceprefix_ = self.OWNER_nsprefix_ + ':' if (UseCapturedNS_ and self.OWNER_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOWNER>%s</%sOWNER>%s' % (namespaceprefix_ , self.gds_format_integer(self.OWNER, input_name='OWNER'), namespaceprefix_ , eol_))
        if self.TIME is not None:
            namespaceprefix_ = self.TIME_nsprefix_ + ':' if (UseCapturedNS_ and self.TIME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTIME>%s</%sTIME>%s' % (namespaceprefix_ , self.gds_format_integer(self.TIME, input_name='TIME'), namespaceprefix_ , eol_))
        if self.REQ_ID is not None:
            namespaceprefix_ = self.REQ_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.REQ_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREQ_ID>%s</%sREQ_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.REQ_ID, input_name='REQ_ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LOCKED' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOCKED')
            ival_ = self.gds_validate_integer(ival_, node, 'LOCKED')
            self.LOCKED = ival_
            self.LOCKED_nsprefix_ = child_.prefix
        elif nodeName_ == 'OWNER' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'OWNER')
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER')
            self.OWNER = ival_
            self.OWNER_nsprefix_ = child_.prefix
        elif nodeName_ == 'TIME' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TIME')
            ival_ = self.gds_validate_integer(ival_, node, 'TIME')
            self.TIME = ival_
            self.TIME_nsprefix_ = child_.prefix
        elif nodeName_ == 'REQ_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'REQ_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'REQ_ID')
            self.REQ_ID = ival_
            self.REQ_ID_nsprefix_ = child_.prefix
# end class LOCKType82


class VMSType83(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
        self.ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMSType83)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMSType83.subclass:
            return VMSType83.subclass(*args_, **kwargs_)
        else:
            return VMSType83(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def add_ID(self, value):
        self.ID.append(value)
    def insert_ID_at(self, index, value):
        self.ID.insert(index, value)
    def replace_ID_at(self, index, value):
        self.ID[index] = value
    def has__content(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMSType83', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMSType83')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VMSType83':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VMSType83')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VMSType83', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VMSType83'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='VMSType83', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(ID_, input_name='ID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
            self.ID_nsprefix_ = child_.prefix
# end class VMSType83


class ZONEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, NAME=None, STATE=None, TEMPLATE=None, SERVER_POOL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.TEMPLATE = TEMPLATE
        self.TEMPLATE_nsprefix_ = None
        self.SERVER_POOL = SERVER_POOL
        self.SERVER_POOL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ZONEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZONEType.subclass:
            return ZONEType.subclass(*args_, **kwargs_)
        else:
            return ZONEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_TEMPLATE(self):
        return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE):
        self.TEMPLATE = TEMPLATE
    def get_SERVER_POOL(self):
        return self.SERVER_POOL
    def set_SERVER_POOL(self, SERVER_POOL):
        self.SERVER_POOL = SERVER_POOL
    def has__content(self):
        if (
            self.ID is not None or
            self.NAME is not None or
            self.STATE is not None or
            self.TEMPLATE is not None or
            self.SERVER_POOL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ZONEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ZONEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ZONEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ZONEType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ZONEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ZONEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='ZONEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.TEMPLATE is not None:
            namespaceprefix_ = self.TEMPLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEMPLATE_nsprefix_) else ''
            self.TEMPLATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEMPLATE', pretty_print=pretty_print)
        if self.SERVER_POOL is not None:
            namespaceprefix_ = self.SERVER_POOL_nsprefix_ + ':' if (UseCapturedNS_ and self.SERVER_POOL_nsprefix_) else ''
            self.SERVER_POOL.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SERVER_POOL', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'TEMPLATE':
            obj_ = TEMPLATEType84.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEMPLATE = obj_
            obj_.original_tagname_ = 'TEMPLATE'
        elif nodeName_ == 'SERVER_POOL':
            obj_ = SERVER_POOLType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SERVER_POOL = obj_
            obj_.original_tagname_ = 'SERVER_POOL'
# end class ZONEType


class TEMPLATEType84(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ENDPOINT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ENDPOINT = ENDPOINT
        self.ENDPOINT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEMPLATEType84)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEMPLATEType84.subclass:
            return TEMPLATEType84.subclass(*args_, **kwargs_)
        else:
            return TEMPLATEType84(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ENDPOINT(self):
        return self.ENDPOINT
    def set_ENDPOINT(self, ENDPOINT):
        self.ENDPOINT = ENDPOINT
    def has__content(self):
        if (
            self.ENDPOINT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType84', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEMPLATEType84')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEMPLATEType84':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEMPLATEType84')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEMPLATEType84', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEMPLATEType84'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType84', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ENDPOINT is not None:
            namespaceprefix_ = self.ENDPOINT_nsprefix_ + ':' if (UseCapturedNS_ and self.ENDPOINT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sENDPOINT>%s</%sENDPOINT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ENDPOINT), input_name='ENDPOINT')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ENDPOINT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ENDPOINT')
            value_ = self.gds_validate_string(value_, node, 'ENDPOINT')
            self.ENDPOINT = value_
            self.ENDPOINT_nsprefix_ = child_.prefix
# end class TEMPLATEType84


class SERVER_POOLType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SERVER=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SERVER is None:
            self.SERVER = []
        else:
            self.SERVER = SERVER
        self.SERVER_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SERVER_POOLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SERVER_POOLType.subclass:
            return SERVER_POOLType.subclass(*args_, **kwargs_)
        else:
            return SERVER_POOLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SERVER(self):
        return self.SERVER
    def set_SERVER(self, SERVER):
        self.SERVER = SERVER
    def add_SERVER(self, value):
        self.SERVER.append(value)
    def insert_SERVER_at(self, index, value):
        self.SERVER.insert(index, value)
    def replace_SERVER_at(self, index, value):
        self.SERVER[index] = value
    def has__content(self):
        if (
            self.SERVER
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SERVER_POOLType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SERVER_POOLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SERVER_POOLType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SERVER_POOLType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SERVER_POOLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SERVER_POOLType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SERVER_POOLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SERVER_ in self.SERVER:
            namespaceprefix_ = self.SERVER_nsprefix_ + ':' if (UseCapturedNS_ and self.SERVER_nsprefix_) else ''
            SERVER_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SERVER', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SERVER':
            obj_ = SERVERType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SERVER.append(obj_)
            obj_.original_tagname_ = 'SERVER'
# end class SERVER_POOLType


class SERVERType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ENDPOINT=None, ID=None, NAME=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ENDPOINT = ENDPOINT
        self.ENDPOINT_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SERVERType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SERVERType.subclass:
            return SERVERType.subclass(*args_, **kwargs_)
        else:
            return SERVERType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ENDPOINT(self):
        return self.ENDPOINT
    def set_ENDPOINT(self, ENDPOINT):
        self.ENDPOINT = ENDPOINT
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def has__content(self):
        if (
            self.ENDPOINT is not None or
            self.ID is not None or
            self.NAME is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SERVERType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SERVERType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SERVERType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SERVERType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SERVERType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SERVERType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SERVERType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ENDPOINT is not None:
            namespaceprefix_ = self.ENDPOINT_nsprefix_ + ':' if (UseCapturedNS_ and self.ENDPOINT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sENDPOINT>%s</%sENDPOINT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ENDPOINT), input_name='ENDPOINT')), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ENDPOINT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ENDPOINT')
            value_ = self.gds_validate_string(value_, node, 'ENDPOINT')
            self.ENDPOINT = value_
            self.ENDPOINT_nsprefix_ = child_.prefix
        elif nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
# end class SERVERType


class TEMPLATEType85(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ENDPOINT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ENDPOINT = ENDPOINT
        self.ENDPOINT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEMPLATEType85)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEMPLATEType85.subclass:
            return TEMPLATEType85.subclass(*args_, **kwargs_)
        else:
            return TEMPLATEType85(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ENDPOINT(self):
        return self.ENDPOINT
    def set_ENDPOINT(self, ENDPOINT):
        self.ENDPOINT = ENDPOINT
    def has__content(self):
        if (
            self.ENDPOINT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType85', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEMPLATEType85')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEMPLATEType85':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEMPLATEType85')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEMPLATEType85', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEMPLATEType85'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='TEMPLATEType85', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ENDPOINT is not None:
            namespaceprefix_ = self.ENDPOINT_nsprefix_ + ':' if (UseCapturedNS_ and self.ENDPOINT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sENDPOINT>%s</%sENDPOINT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ENDPOINT), input_name='ENDPOINT')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ENDPOINT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ENDPOINT')
            value_ = self.gds_validate_string(value_, node, 'ENDPOINT')
            self.ENDPOINT = value_
            self.ENDPOINT_nsprefix_ = child_.prefix
# end class TEMPLATEType85


class SERVER_POOLType86(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SERVER=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SERVER is None:
            self.SERVER = []
        else:
            self.SERVER = SERVER
        self.SERVER_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SERVER_POOLType86)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SERVER_POOLType86.subclass:
            return SERVER_POOLType86.subclass(*args_, **kwargs_)
        else:
            return SERVER_POOLType86(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SERVER(self):
        return self.SERVER
    def set_SERVER(self, SERVER):
        self.SERVER = SERVER
    def add_SERVER(self, value):
        self.SERVER.append(value)
    def insert_SERVER_at(self, index, value):
        self.SERVER.insert(index, value)
    def replace_SERVER_at(self, index, value):
        self.SERVER[index] = value
    def has__content(self):
        if (
            self.SERVER
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SERVER_POOLType86', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SERVER_POOLType86')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SERVER_POOLType86':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SERVER_POOLType86')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SERVER_POOLType86', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SERVER_POOLType86'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SERVER_POOLType86', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SERVER_ in self.SERVER:
            namespaceprefix_ = self.SERVER_nsprefix_ + ':' if (UseCapturedNS_ and self.SERVER_nsprefix_) else ''
            SERVER_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SERVER', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SERVER':
            obj_ = SERVERType87.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SERVER.append(obj_)
            obj_.original_tagname_ = 'SERVER'
# end class SERVER_POOLType86


class SERVERType87(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ENDPOINT=None, ID=None, NAME=None, STATE=None, TERM=None, VOTEDFOR=None, COMMIT=None, LOG_INDEX=None, FEDLOG_INDEX=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ENDPOINT = ENDPOINT
        self.ENDPOINT_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.STATE = STATE
        self.STATE_nsprefix_ = None
        self.TERM = TERM
        self.TERM_nsprefix_ = None
        self.VOTEDFOR = VOTEDFOR
        self.VOTEDFOR_nsprefix_ = None
        self.COMMIT = COMMIT
        self.COMMIT_nsprefix_ = None
        self.LOG_INDEX = LOG_INDEX
        self.LOG_INDEX_nsprefix_ = None
        self.FEDLOG_INDEX = FEDLOG_INDEX
        self.FEDLOG_INDEX_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SERVERType87)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SERVERType87.subclass:
            return SERVERType87.subclass(*args_, **kwargs_)
        else:
            return SERVERType87(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ENDPOINT(self):
        return self.ENDPOINT
    def set_ENDPOINT(self, ENDPOINT):
        self.ENDPOINT = ENDPOINT
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_STATE(self):
        return self.STATE
    def set_STATE(self, STATE):
        self.STATE = STATE
    def get_TERM(self):
        return self.TERM
    def set_TERM(self, TERM):
        self.TERM = TERM
    def get_VOTEDFOR(self):
        return self.VOTEDFOR
    def set_VOTEDFOR(self, VOTEDFOR):
        self.VOTEDFOR = VOTEDFOR
    def get_COMMIT(self):
        return self.COMMIT
    def set_COMMIT(self, COMMIT):
        self.COMMIT = COMMIT
    def get_LOG_INDEX(self):
        return self.LOG_INDEX
    def set_LOG_INDEX(self, LOG_INDEX):
        self.LOG_INDEX = LOG_INDEX
    def get_FEDLOG_INDEX(self):
        return self.FEDLOG_INDEX
    def set_FEDLOG_INDEX(self, FEDLOG_INDEX):
        self.FEDLOG_INDEX = FEDLOG_INDEX
    def has__content(self):
        if (
            self.ENDPOINT is not None or
            self.ID is not None or
            self.NAME is not None or
            self.STATE is not None or
            self.TERM is not None or
            self.VOTEDFOR is not None or
            self.COMMIT is not None or
            self.LOG_INDEX is not None or
            self.FEDLOG_INDEX is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SERVERType87', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SERVERType87')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SERVERType87':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SERVERType87')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SERVERType87', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SERVERType87'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://opennebula.org/XMLSchema" ', name_='SERVERType87', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ENDPOINT is not None:
            namespaceprefix_ = self.ENDPOINT_nsprefix_ + ':' if (UseCapturedNS_ and self.ENDPOINT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sENDPOINT>%s</%sENDPOINT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ENDPOINT), input_name='ENDPOINT')), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.STATE is not None:
            namespaceprefix_ = self.STATE_nsprefix_ + ':' if (UseCapturedNS_ and self.STATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTATE>%s</%sSTATE>%s' % (namespaceprefix_ , self.gds_format_integer(self.STATE, input_name='STATE'), namespaceprefix_ , eol_))
        if self.TERM is not None:
            namespaceprefix_ = self.TERM_nsprefix_ + ':' if (UseCapturedNS_ and self.TERM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTERM>%s</%sTERM>%s' % (namespaceprefix_ , self.gds_format_integer(self.TERM, input_name='TERM'), namespaceprefix_ , eol_))
        if self.VOTEDFOR is not None:
            namespaceprefix_ = self.VOTEDFOR_nsprefix_ + ':' if (UseCapturedNS_ and self.VOTEDFOR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVOTEDFOR>%s</%sVOTEDFOR>%s' % (namespaceprefix_ , self.gds_format_integer(self.VOTEDFOR, input_name='VOTEDFOR'), namespaceprefix_ , eol_))
        if self.COMMIT is not None:
            namespaceprefix_ = self.COMMIT_nsprefix_ + ':' if (UseCapturedNS_ and self.COMMIT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOMMIT>%s</%sCOMMIT>%s' % (namespaceprefix_ , self.gds_format_integer(self.COMMIT, input_name='COMMIT'), namespaceprefix_ , eol_))
        if self.LOG_INDEX is not None:
            namespaceprefix_ = self.LOG_INDEX_nsprefix_ + ':' if (UseCapturedNS_ and self.LOG_INDEX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOG_INDEX>%s</%sLOG_INDEX>%s' % (namespaceprefix_ , self.gds_format_integer(self.LOG_INDEX, input_name='LOG_INDEX'), namespaceprefix_ , eol_))
        if self.FEDLOG_INDEX is not None:
            namespaceprefix_ = self.FEDLOG_INDEX_nsprefix_ + ':' if (UseCapturedNS_ and self.FEDLOG_INDEX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFEDLOG_INDEX>%s</%sFEDLOG_INDEX>%s' % (namespaceprefix_ , self.gds_format_integer(self.FEDLOG_INDEX, input_name='FEDLOG_INDEX'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ENDPOINT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ENDPOINT')
            value_ = self.gds_validate_string(value_, node, 'ENDPOINT')
            self.ENDPOINT = value_
            self.ENDPOINT_nsprefix_ = child_.prefix
        elif nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'STATE' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'STATE')
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
            self.STATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'TERM' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TERM')
            ival_ = self.gds_validate_integer(ival_, node, 'TERM')
            self.TERM = ival_
            self.TERM_nsprefix_ = child_.prefix
        elif nodeName_ == 'VOTEDFOR' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VOTEDFOR')
            ival_ = self.gds_validate_integer(ival_, node, 'VOTEDFOR')
            self.VOTEDFOR = ival_
            self.VOTEDFOR_nsprefix_ = child_.prefix
        elif nodeName_ == 'COMMIT' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'COMMIT')
            ival_ = self.gds_validate_integer(ival_, node, 'COMMIT')
            self.COMMIT = ival_
            self.COMMIT_nsprefix_ = child_.prefix
        elif nodeName_ == 'LOG_INDEX' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LOG_INDEX')
            ival_ = self.gds_validate_integer(ival_, node, 'LOG_INDEX')
            self.LOG_INDEX = ival_
            self.LOG_INDEX_nsprefix_ = child_.prefix
        elif nodeName_ == 'FEDLOG_INDEX' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'FEDLOG_INDEX')
            ival_ = self.gds_validate_integer(ival_, node, 'FEDLOG_INDEX')
            self.FEDLOG_INDEX = ival_
            self.FEDLOG_INDEX_nsprefix_ = child_.prefix
# end class SERVERType87


#
# End data representation classes.
#


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'HISTORY_RECORDS'
        rootClass = HISTORY_RECORDS
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_=namespacedefs,
##             pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'HISTORY_RECORDS'
        rootClass = HISTORY_RECORDS
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         content = etree_.tostring(
##             rootElement, pretty_print=True,
##             xml_declaration=True, encoding="utf-8")
##         sys.stdout.write(str(content))
##         sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'HISTORY_RECORDS'
        rootClass = HISTORY_RECORDS
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'HISTORY_RECORDS'
        rootClass = HISTORY_RECORDS
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         sys.stdout.write('#from supbind import *\n\n')
##         sys.stdout.write('import supbind as model_\n\n')
##         sys.stdout.write('rootObj = model_.rootClass(\n')
##         rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##         sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://opennebula.org/XMLSchema': [('LOCK',
                                      '../../../share/doc/xsd/shared.xsd',
                                      'CT'),
                                     ('PERMISSIONS',
                                      '../../../share/doc/xsd/shared.xsd',
                                      'CT'),
                                     ('IDS',
                                      '../../../share/doc/xsd/shared.xsd',
                                      'CT'),
                                     ('SCHED_ACTION',
                                      '../../../share/doc/xsd/shared.xsd',
                                      'CT'),
                                     ('DATASTORE_QUOTA',
                                      '../../../share/doc/xsd/shared.xsd',
                                      'CT'),
                                     ('NETWORK_QUOTA',
                                      '../../../share/doc/xsd/shared.xsd',
                                      'CT'),
                                     ('VM_QUOTA',
                                      '../../../share/doc/xsd/shared.xsd',
                                      'CT'),
                                     ('IMAGE_QUOTA',
                                      '../../../share/doc/xsd/shared.xsd',
                                      'CT')]}

__all__ = [
    "ACLType",
    "ACL_POOL",
    "ACTIONType",
    "ADMINSType",
    "ADMINSType6",
    "ARType",
    "ARType77",
    "AR_POOLType",
    "AR_POOLType76",
    "AUTH_MADType",
    "AUTH_MAD_CONFType",
    "BACKUPJOB",
    "BACKUPJOB_POOL",
    "BACKUPSType",
    "BACKUPSType58",
    "BACKUP_CONFIGType",
    "BACKUP_CONFIGType59",
    "BACKUP_IDSType",
    "BACKUP_INCREMENTSType",
    "CALL_INFO",
    "CAPACITYType",
    "CLUSTER",
    "CLUSTERSType",
    "CLUSTERSType34",
    "CLUSTERSType62",
    "CLUSTERSType69",
    "CLUSTERType",
    "CLUSTER_POOL",
    "CONTEXT",
    "COREType",
    "DATASTORE",
    "DATASTORESType",
    "DATASTORESType11",
    "DATASTORESType36",
    "DATASTOREType",
    "DATASTOREType37",
    "DATASTORE_MADType",
    "DATASTORE_POOL",
    "DATASTORE_QUOTA",
    "DBType",
    "DEFAULT_COSTType",
    "DEFAULT_GROUP_QUOTASType",
    "DEFAULT_GROUP_QUOTASType7",
    "DEFAULT_USER_QUOTASType",
    "DEFAULT_USER_QUOTASType30",
    "DISKType",
    "DISKType50",
    "DISK_SIZEType",
    "DISK_SIZEType48",
    "DOCUMENT",
    "DOCUMENT_POOL",
    "DSType",
    "DS_MAD_CONFType",
    "ERROR_VMSType",
    "ERROR_VMSType66",
    "ERROR_VMSType74",
    "EXECUTION_RESULTType",
    "EXTRAType",
    "FEATURES",
    "FEDERATIONType",
    "GRAPHICS",
    "GROUP",
    "GROUPSType",
    "GROUPSType28",
    "GROUPSType33",
    "GROUPType",
    "GROUP_POOL",
    "HISTORY",
    "HISTORYType",
    "HISTORYType55",
    "HISTORY_RECORDS",
    "HISTORY_RECORDSType",
    "HISTORY_RECORDSType54",
    "HM_MADType",
    "HOOK",
    "HOOKLOGType",
    "HOOK_EXECUTION_RECORDType",
    "HOOK_LOG_CONFType",
    "HOOK_MESSAGE",
    "HOOK_POOL",
    "HOST",
    "HOSTSType",
    "HOSTSType35",
    "HOSTType",
    "HOST_POOL",
    "HOST_SHAREType",
    "HUGEPAGEType",
    "HUGEPAGEType12",
    "HYPERV_OPTIONS",
    "IDS",
    "IMAGE",
    "IMAGESType",
    "IMAGEType",
    "IMAGE_POOL",
    "IMAGE_QUOTA",
    "IM_MADType",
    "INCREMENTType",
    "INPUT",
    "IPAM_MADType",
    "LEASESType",
    "LEASEType",
    "LOCK",
    "LOCKType",
    "LOCKType14",
    "LOCKType19",
    "LOCKType40",
    "LOCKType44",
    "LOCKType67",
    "LOCKType78",
    "LOCKType82",
    "LOGIN_TOKENType",
    "LOGIN_TOKENType29",
    "LOGType",
    "MARKETPLACE",
    "MARKETPLACEAPP",
    "MARKETPLACEAPPSType",
    "MARKETPLACEAPP_POOL",
    "MARKETPLACE_POOL",
    "MARKET_MADType",
    "MARKET_MAD_CONFType",
    "MEMORYType",
    "MEMORYType13",
    "MONITORING",
    "MONITORINGType",
    "MONITORINGType22",
    "MONITORINGType43",
    "MONITORINGType47",
    "MONITORING_DATA",
    "NETWORKType",
    "NETWORK_QUOTA",
    "NICType",
    "NICType51",
    "NIC_ALIASType",
    "NIC_DEFAULT",
    "NODEType",
    "NUMA_NODE",
    "NUMA_NODESType",
    "NUMA_NODEType",
    "OPENNEBULA_CONFIGURATION",
    "OS",
    "OUTDATED_VMSType",
    "OUTDATED_VMSType64",
    "OUTDATED_VMSType72",
    "PARAMETERSType",
    "PARAMETERType",
    "PCI",
    "PCIType",
    "PCI_DEVICESType",
    "PERMISSIONS",
    "PERMISSIONSType",
    "PERMISSIONSType15",
    "PERMISSIONSType2",
    "PERMISSIONSType20",
    "PERMISSIONSType21",
    "PERMISSIONSType23",
    "PERMISSIONSType3",
    "PERMISSIONSType39",
    "PERMISSIONSType45",
    "PERMISSIONSType61",
    "PERMISSIONSType68",
    "PERMISSIONSType79",
    "PERMISSIONSType81",
    "PLANType",
    "QUOTASType",
    "QUOTASType25",
    "RAFT",
    "RAFTType",
    "RAW",
    "ROLESType",
    "ROLEType",
    "RULEType",
    "SCHED_ACTION",
    "SCHED_ACTIONType",
    "SCHED_MADType",
    "SECURITY_GROUP",
    "SECURITY_GROUP_POOL",
    "SECURITY_GROUP_RULE",
    "SERVERType",
    "SERVERType87",
    "SERVER_POOLType",
    "SERVER_POOLType86",
    "SHOWBACKType",
    "SHOWBACK_RECORDS",
    "SNAPSHOTSType",
    "SNAPSHOTSType17",
    "SNAPSHOTSType56",
    "SNAPSHOTType",
    "SNAPSHOTType18",
    "SNAPSHOTType52",
    "SNAPSHOTType57",
    "SPICE_OPTIONS",
    "SYSTEMType",
    "TEMPLATE",
    "TEMPLATEType",
    "TEMPLATEType10",
    "TEMPLATEType16",
    "TEMPLATEType24",
    "TEMPLATEType42",
    "TEMPLATEType46",
    "TEMPLATEType49",
    "TEMPLATEType75",
    "TEMPLATEType80",
    "TEMPLATEType84",
    "TEMPLATEType85",
    "TM_MADType",
    "TM_MAD_CONFType",
    "TOPOLOGY",
    "TPMType",
    "UPDATED_VMSType",
    "UPDATED_VMSType63",
    "UPDATED_VMSType71",
    "UPDATING_VMSType",
    "UPDATING_VMSType65",
    "UPDATING_VMSType73",
    "USER",
    "USERSType",
    "USERSType5",
    "USERType",
    "USER_POOL",
    "USER_TEMPLATEType",
    "USER_TEMPLATEType53",
    "VDC",
    "VDC_POOL",
    "VIDEOType",
    "VLAN_IDSType",
    "VM",
    "VMGROUP",
    "VMSType",
    "VMSType83",
    "VMTEMPLATE",
    "VMTEMPLATE_POOL",
    "VMType",
    "VMType1",
    "VMType27",
    "VMType32",
    "VMType4",
    "VMType41",
    "VMType9",
    "VM_GROUP",
    "VM_GROUP_POOL",
    "VM_MADType",
    "VM_POOL",
    "VM_QUOTA",
    "VM_QUOTAType",
    "VM_QUOTAType26",
    "VM_QUOTAType31",
    "VM_QUOTAType8",
    "VNC_PORTSType",
    "VNET",
    "VNETSType",
    "VNETSType38",
    "VNETType",
    "VNETType60",
    "VNET_POOL",
    "VNTEMPLATE",
    "VNTEMPLATE_POOL",
    "VN_MAD_CONFType",
    "VROUTER",
    "VROUTERSType",
    "VROUTERSType70",
    "VROUTER_POOL",
    "VXLAN_IDSType",
    "ZONE",
    "ZONEType",
    "ZONE_POOL"
]
