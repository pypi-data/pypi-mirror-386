"""Text number conversion utilities with patched numerizer to preserve articles like 'a'."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/numerizer.ipynb.

# %% auto 0
__all__ = ['original_numerize_numerals', 'patched_numerize_numerals', 'smart_numerize']

# %% ../nbs/numerizer.ipynb 3
import re
from numerizer import numerize
import numerizer

# %% ../nbs/numerizer.ipynb 4
# Monkey-patch the numerize_numerals function to skip "a" conversion
original_numerize_numerals = numerizer.numerizer.numerize_numerals

def patched_numerize_numerals(
    s: str,  # String to convert written numbers to digits
    ignore: list = None,  # List of words to ignore during conversion
    bias: str = None  # Conversion bias (e.g., 'ordinal')
) -> str:  # String with written numbers converted to digits
    """Patched version that doesn't convert 'a' to '1'"""
    if ignore is None:
        ignore = []
    
    from numerizer import consts
    
    def regexify(
        words: dict,  # Dictionary of words to convert
        ignore: list = None  # List of words to ignore
    ) -> str:  # Regular expression pattern string
        """Create a regex pattern from word dictionary, excluding ignored words."""
        if ignore is None:
            ignore = []
        return '|'.join([c for c in words if c not in ignore])
    
    def _repl_single_digit(
        m: re.Match  # Regular expression match object
    ) -> str:  # Replacement string with converted number
        """Replace single digit word with numeric value."""
        m1 = m.group(1)
        m2 = consts.DIRECT_SINGLE_NUMS[m.group(2).lower()]
        return f'{m1}<num>{m2}'
    
    def _repl_ten_prefixes(
        m: re.Match  # Regular expression match object
    ) -> str:  # Replacement string with converted number
        """Replace ten prefix + single digit combination with numeric value."""
        m1 = m.group(1)
        m2 = consts.TEN_PREFIXES[m.group(2).lower()]
        m3 = consts.SINGLE_NUMS[m.group(3).lower()]
        return f'{m1}<num>{m2 + m3}'
    
    def _repl_ten_prefs_single_ords(
        m: re.Match  # Regular expression match object
    ) -> str:  # Replacement string with converted ordinal number
        """Replace ten prefix + single ordinal combination with numeric ordinal."""
        m2, m4 = m.group(2), m.group(4)
        repl = f'{m.group(1)}<num>' \
            + str(consts.TEN_PREFIXES[m2.lower()] + consts.ORDINAL_SINGLE[m4.lower()]) \
            + m4[-2:]
        return repl
    
    def _repl_ten_prefs(
        m: re.Match  # Regular expression match object
    ) -> str:  # Replacement string with converted number
        """Replace ten prefix word with numeric value."""
        return f'{m.group(1)}<num>' + str(consts.TEN_PREFIXES[m.group(2).lower()])
    
    single_nums = regexify(consts.SINGLE_NUMS.keys(), ignore=ignore)
    dir_single_nums = regexify(consts.DIRECT_SINGLE_NUMS.keys(), ignore=ignore)
    ten_prefs = regexify(consts.TEN_PREFIXES.keys(), ignore=ignore)
    single_ords = regexify(consts.ORDINAL_SINGLE.keys(), ignore=ignore)

    # easy / direct replacements
    pat = re.compile(r'(^|\W)({0})(\s({1}))(?=$|\W)'.format(single_nums, ten_prefs),
                     flags=re.IGNORECASE)
    m = re.search(pat, s)
    if m is not None:
        s = re.sub(pat, lambda m: f'{m.group(1)}{m.group(2)} hundred{m.group(3)}', s)

    pat = re.compile(r'(^|\W)({0})(?=$|\W)'.format(dir_single_nums), flags=re.IGNORECASE)
    m = re.search(pat, s)
    if m is not None:
        s = re.sub(pat, _repl_single_digit, s)

    # SKIP THE "a" to "1" CONVERSION - This is the key change!
    # The original code had this section that we're commenting out:
    """
    if bias == 'ordinal':
        pat = re.compile(r'(^|\W)\ba\b(?=$|\W)(?! (?:{}))'.format(consts.ALL_ORDINALS_REGEX),
                         flags=re.IGNORECASE)
    else:
        pat = re.compile(r'(^|\W)\ba\b(?=$|\W)', flags=re.IGNORECASE)
    m = re.search(pat, s)
    if m is not None:
        s = re.sub(pat, r'\1<num>1', s, count=1)
    """

    # ten, twenty, etc
    pat = re.compile(r'(^|\W)({0})({1})(?=$|\W)'.format(ten_prefs, single_nums),
                     flags=re.IGNORECASE)
    m = re.search(pat, s)
    if m is not None:
        s = re.sub(pat, _repl_ten_prefixes, s)

    #
    pat = re.compile(r'(^|\W)({0})(\s)?({1})(?=$|\W)'.format(ten_prefs, single_ords),
                     flags=re.IGNORECASE)
    m = re.search(pat, s)
    if m is not None:
        try:
            s = re.sub(pat, _repl_ten_prefs_single_ords, s)
        except TypeError:
            pass

    #
    pat = re.compile(r'(^|\W)({})(?=$|\W)'.format(ten_prefs), flags=re.IGNORECASE)
    m = re.search(pat, s)
    if m is not None:
        s = re.sub(pat, _repl_ten_prefs, s)

    return s

# Apply the monkey patch
numerizer.numerizer.numerize_numerals = patched_numerize_numerals

# %% ../nbs/numerizer.ipynb 5
def smart_numerize(
    text: str  # Text containing written numbers to convert
) -> str:  # Text with written numbers converted to digits
    """Convert written numbers to digits with special handling for compound ordinals."""
    # First pass: Handle hyphenated compound ordinals (twenty-fourth, thirty-first)
    compound_pattern = r'\b(\w+-\w+(?:st|nd|rd|th))\b'
    
    def replace_ordinal(
        match: re.Match  # Regular expression match object
    ) -> str:  # Converted ordinal number or original text
        """Convert matched ordinal word to numeric form."""
        word = match.group(1)
        numerized = numerize(word)
        if numerized != word:
            return numerized
        return word
    
    # Replace compound ordinals first
    text = re.sub(compound_pattern, replace_ordinal, text, flags=re.IGNORECASE)
    
    # Second pass: Handle simple ordinals (first, fourth, fifth)
    simple_pattern = r'\b(\w+(?:st|rd|th))\b'
    text = re.sub(simple_pattern, replace_ordinal, text, flags=re.IGNORECASE)
    
    # Final pass: numerize any remaining numbers
    result = numerize(text)
    
    return result
