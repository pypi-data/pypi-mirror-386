"""Arcade Starter Tools for Miro

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API WRAPPER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
from typing import Annotated, Any

import httpx
from arcade_tdk import ToolContext, tool
from arcade_tdk.auth import OAuth2

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    data: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                method=method,
                params=params,
                headers=headers,
                data=data,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_access_token_info(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'token-info'."]:
    """Retrieve details about an access token.

    Use this tool to obtain detailed information regarding an access token, including token type, scopes, associated team, and user information, as well as creation date and time."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v1/oauth-token",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_audit_logs(
    context: ToolContext,
    created_after: Annotated[
        str,
        "Retrieve audit logs created after the specified date and time in UTC format (ISO 8601 with milliseconds and a trailing Z).",  # noqa: E501
    ],
    audit_log_end_date: Annotated[
        str,
        "Retrieve audit logs created before this date and time. Use UTC format, following ISO 8601 with milliseconds and 'Z'.",  # noqa: E501
    ],
    pagination_cursor: Annotated[
        str | None,
        "Cursor for pagination; use to retrieve the next portion of results based on the previously returned cursor value.",  # noqa: E501
    ] = None,
    max_results_limit: Annotated[
        int | None,
        "Specifies the maximum number of audit log results to return. Default is 100 if not specified.",  # noqa: E501
    ] = None,
    sort_order: Annotated[
        str | None,
        "Defines the sort order for the audit logs. Use 'ASC' for ascending and 'DESC' for descending. Defaults to 'ASC'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-get-audit-logs'."]:
    """Retrieve audit logs from the last 90 days.

    Use this tool to access a page of audit events from the past 90 days. If older data is needed, consider using Miro's CSV export feature. Required scope: auditlogs:read."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/audit/logs",
        method="GET",
        params=remove_none_values({
            "createdAfter": created_after,
            "createdBefore": audit_log_end_date,
            "cursor": pagination_cursor,
            "limit": max_results_limit,
            "sorting": sort_order,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_classification_settings(
    context: ToolContext,
    organization_id: Annotated[
        str,
        "The unique identifier of the organization whose board classification settings you want to retrieve.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'enterprise-dataclassification-organization-settings-get'.",
]:
    """Retrieve board classification settings for an organization.

    Use this tool to get the board classification settings for an existing organization in Miro. This is applicable only for organizations under the Enterprise plan and requires Company Admin role and the 'organizations:read' scope."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/data-classification-settings".format(  # noqa: UP032
            org_id=organization_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_team_data_classification_settings(
    context: ToolContext,
    organization_id: Annotated[
        str, "ID of the organization to retrieve board classification settings for."
    ],
    team_identifier: Annotated[
        str,
        "The unique identifier of the team to retrieve classification settings for. Must be a string.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'enterprise-dataclassification-team-settings-get'.",
]:
    """Retrieve board classification settings for an enterprise team.

    Use this tool to get board classification settings for an existing team in an enterprise account. Only available for users with the Company Admin role in the Enterprise plan."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}/data-classification-settings".format(  # noqa: UP032
            org_id=organization_id, team_id=team_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_board_classification(
    context: ToolContext,
    organization_id: Annotated[
        str,
        "The unique identifier for the organization whose board classification you wish to retrieve.",  # noqa: E501
    ],
    team_identifier: Annotated[
        str,
        "The unique identifier of the team for which you want to retrieve the board classification.",  # noqa: E501
    ],
    board_unique_identifier: Annotated[
        str, "Unique identifier of the Miro board to retrieve classification details for."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'enterprise-dataclassification-board-get'."
]:
    """Retrieve board classification status from Miro.

    Retrieves the data classification of a specific board in Miro for Enterprise users. This tool is useful for Company Admins who need to access board classification details, requiring the 'boards:read' scope. It is subject to Level 2 rate limiting."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}/boards/{board_id}/data-classification".format(  # noqa: UP032
            org_id=organization_id, team_id=team_identifier, board_id=board_unique_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_ediscovery_cases(
    context: ToolContext,
    maximum_items_in_result_list: Annotated[
        int,
        "Specify the maximum number of items to include in the result list of eDiscovery cases.",
    ],
    organization_id: Annotated[str, "The ID of the organization to retrieve eDiscovery cases for."],
    pagination_cursor: Annotated[
        str | None,
        "Used to navigate pages of results. Leave empty for the first page; use value from previous response for subsequent pages.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-all-cases'."]:
    """Get the list of eDiscovery cases for an organization.

    Use this tool to retrieve all the eDiscovery cases available in an organization. It is specifically for Enterprise plan users with the Enterprise Guard add-on, requiring Company Admin and eDiscovery Admin roles."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/cases".format(org_id=organization_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "limit": maximum_items_in_result_list,
            "cursor": pagination_cursor,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_case_info(
    context: ToolContext,
    organization_id: Annotated[
        str, "The unique ID of the organization for retrieving case information."
    ],
    case_id: Annotated[str, "The unique identifier of the case to retrieve information for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-case'."]:
    """Retrieve detailed information about a specific case in an organization.

    This tool is used to get detailed information about a case in an organization using Miro's API. It is suitable for Enterprise plan users with the Enterprise Guard add-on who have Company Admin and eDiscovery Admin roles. Useful for administrators managing cases and overseeing organizational operations."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/cases/{case_id}".format(  # noqa: UP032
            org_id=organization_id, case_id=case_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_legal_holds(
    context: ToolContext,
    maximum_items_in_result_list: Annotated[
        int,
        "Specifies the maximum number of items to be included in the retrieved list of legal holds.",  # noqa: E501
    ],
    organization_id: Annotated[
        str,
        "The ID of the organization for which to retrieve the list of legal holds within a case.",
    ],
    case_id: Annotated[
        str, "The unique ID of the case for which to retrieve the list of legal holds."
    ],
    page_cursor: Annotated[
        str | None,
        "An indicator for paginating results. Leave empty for the first page or use the previous request's cursor for subsequent pages.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-all-legal-holds'."]:
    """Retrieve all legal holds for a case in an organization.

    This tool retrieves the list of all legal holds within a specified case for an organization. It is intended for Miro Enterprise plan users with the Enterprise Guard add-on, requiring Company Admin and eDiscovery Admin roles."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/cases/{case_id}/legal-holds".format(  # noqa: UP032
            org_id=organization_id, case_id=case_id
        ),
        method="GET",
        params=remove_none_values({"limit": maximum_items_in_result_list, "cursor": page_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_legal_hold_info(
    context: ToolContext,
    organization_id: Annotated[
        str, "The unique ID of the organization for which to retrieve legal hold data."
    ],
    case_identifier: Annotated[
        str, "The unique identifier for the case to retrieve the legal hold information."
    ],
    legal_hold_id: Annotated[str, "The unique identifier for the legal hold to be retrieved."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-legal-hold'."]:
    """Retrieve information about a legal hold in an organization's case.

    Use this tool to get details about a legal hold in a specific case within an organization, requiring organization:cases:management scope and applicable for Enterprise Guard users with specific admin roles."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/cases/{case_id}/legal-holds/{legal_hold_id}".format(  # noqa: UP032
            org_id=organization_id, case_id=case_identifier, legal_hold_id=legal_hold_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_miro_legal_hold_items(
    context: ToolContext,
    maximum_items_limit: Annotated[
        int, "Specifies the maximum number of content items to return in the list."
    ],
    organization_id: Annotated[
        str,
        "The unique ID of the Miro organization to retrieve its content items under legal hold.",
    ],
    case_id: Annotated[
        str, "The unique identifier for the legal case to retrieve content items under hold."
    ],
    legal_hold_identifier: Annotated[
        str, "The ID of the legal hold to retrieve the list of content items under hold."
    ],
    page_cursor: Annotated[
        str | None,
        "Used to paginate through results. Leave empty for the first page; use the previous request's cursor for the next pages.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-legal-hold-content-items'."]:
    """Retrieve content items under a Miro legal hold.

    This tool retrieves all content items under a specific legal hold in a case for a Miro organization, ensuring the legal hold is active and complete. Only available for Miro Enterprise plan users with appropriate admin roles."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/cases/{case_id}/legal-holds/{legal_hold_id}/content-items".format(  # noqa: UP032
            org_id=organization_id, case_id=case_id, legal_hold_id=legal_hold_identifier
        ),
        method="GET",
        params=remove_none_values({"limit": maximum_items_limit, "cursor": page_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_export_job_status(
    context: ToolContext,
    organization_id: Annotated[
        str,
        "Unique identifier of the organization. Required for accessing the board export job status.",  # noqa: E501
    ],
    board_export_job_id: Annotated[
        str, "Unique identifier of the board export job within Miro to retrieve its status."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'enterprise-board-export-job-status'."
]:
    """Retrieve the status of a Miro board export job for enterprises.

    This tool retrieves the current status of a board export job within an enterprise organization in Miro. It should be called when there's a need to check if a board export job has been completed or to track its progress. This API is restricted to Enterprise plan users with Company Admin roles and requires eDiscovery enabled in the settings."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/boards/export/jobs/{job_id}".format(  # noqa: UP032
            org_id=organization_id, job_id=board_export_job_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_export_job_results(
    context: ToolContext,
    organization_id: Annotated[
        str,
        "Unique identifier of the organization for which the board export job results are retrieved.",  # noqa: E501
    ],
    board_export_job_id: Annotated[
        str, "Unique identifier for the board export job to retrieve results."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'enterprise-board-export-job-results'."
]:
    """Retrieve results of a board export job for Enterprise users.

    This tool retrieves the results of a Miro board export job, providing details such as the S3 link to the exported files. It is available exclusively for Enterprise plan users with company admin roles and eDiscovery enabled. Essential for accessing export details securely."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/boards/export/jobs/{job_id}/results".format(  # noqa: UP032
            org_id=organization_id, job_id=board_export_job_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def fetch_board_content_changes(
    context: ToolContext,
    start_date_time_utc: Annotated[
        str, "Filter logs from this UTC date and time. Must be ISO 8601 with a trailing 'Z'."
    ],
    end_date_time_filter: Annotated[
        str,
        "Specify the end date and time for filtering content logs. Use UTC format, following ISO 8601 with a trailing Z offset.",  # noqa: E501
    ],
    organization_id: Annotated[
        str, "Unique identifier for the organization to fetch content changes."
    ],
    board_ids: Annotated[
        list[str] | None,
        "List of board IDs for fetching content logs. Accepts an array of strings.",
    ] = None,
    user_emails_filter: Annotated[
        list[str] | None,
        "List of user emails to filter content logs for those who created, modified, or deleted the board item.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Pointer to the next portion of results, used for pagination. Use the cursor from the previous response to continue fetching data.",  # noqa: E501
    ] = None,
    maximum_results_per_call: Annotated[
        int | None,
        "Specify the maximum number of content log results to return per call. If exceeded, a cursor is provided for the next request.",  # noqa: E501
    ] = None,
    sort_order: Annotated[
        str | None,
        "Determines the order of board content logs based on their modified date. Use 'asc' for ascending and 'desc' for descending order.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'enterprise-board-content-item-logs-fetch'."
]:
    """Fetch changes to board items in your organization.

    Retrieve content changes for board items, including actions like updates or deletions. Filter by time, board ID, or user email. Available for Enterprise plan admins only."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/content-logs/items".format(  # noqa: UP032
            org_id=organization_id
        ),
        method="GET",
        params=remove_none_values({
            "board_ids": board_ids,
            "emails": user_emails_filter,
            "from": start_date_time_utc,
            "to": end_date_time_filter,
            "cursor": pagination_cursor,
            "limit": maximum_results_per_call,
            "sorting": sort_order,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def reset_user_sessions(
    context: ToolContext,
    user_email_to_reset_sessions: Annotated[
        str,
        "Email ID of the user whose sessions need to be reset. This will sign the user out from all devices.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'enterprise-post-user-sessions-reset'."
]:
    """Reset all active user sessions immediately.

    This tool is used by Enterprise plan Company Admins to reset all active sessions for a user, effectively requiring them to sign in again. It's useful for handling security concerns such as compromised credentials or suspicious account activity."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/sessions/reset_all",
        method="POST",
        params=remove_none_values({"email": user_email_to_reset_sessions}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_organization_info(
    context: ToolContext,
    organization_id: Annotated[
        str,
        "The unique identifier of the organization to retrieve information for. Required for accessing organization details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-get-organization'."]:
    """Retrieve enterprise organization information.

    Fetch details about an organization using the Miro API, available only for users with the Enterprise plan and Company Admin role. This tool should be used to obtain specific organization data."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}".format(org_id=organization_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_organization_members(
    context: ToolContext,
    organization_id: Annotated[
        str, "The unique identifier of the organization to retrieve members from."
    ],
    user_emails: Annotated[
        str | None,
        "A comma-separated list of user emails to retrieve specific organization members.",
    ] = None,
    filter_by_role: Annotated[
        str | None,
        "Specify the role to filter organization members by, such as 'organization_internal_admin' or 'organization_internal_user'.",  # noqa: E501
    ] = None,
    member_license_type: Annotated[
        str | None,
        "Specify the license type of members to filter by. Accepts values: full, occasional, free, free_restricted, full_trial, or unknown.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "A string used for paginating results. Allows fetching the next set of organization members.",  # noqa: E501
    ] = None,
    member_retrieval_limit: Annotated[
        int | None,
        "Specify the maximum number of organization members to retrieve. This is used to limit the size of the results returned by the API.",  # noqa: E501
    ] = None,
    only_active_members: Annotated[
        bool | None,
        "Set to true to retrieve only active members. Filters based on member activity status.",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'enterprise-get-organization-members'."
]:
    """Retrieve members of an organization in Miro.

    This tool fetches members of a Miro organization using the organization ID or user emails. It requires the 'organizations:read' scope and is available only to Enterprise plan users with Company Admin roles. This should be used to obtain detailed information about organization members."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/members".format(org_id=organization_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "emails": user_emails,
            "role": filter_by_role,
            "license": member_license_type,
            "active": only_active_members,
            "cursor": pagination_cursor,
            "limit": member_retrieval_limit,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_organization_member_info(
    context: ToolContext,
    organization_id: Annotated[
        str,
        "The unique identifier of the organization whose member information is being retrieved. This ID is necessary to specify which organization's data to access.",  # noqa: E501
    ],
    organization_member_id: Annotated[
        str, "ID of the organization member to retrieve information for."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'enterprise-get-organization-member'."
]:
    """Retrieve member information of an organization in Miro Enterprise.

    Use this tool to obtain information about a member of an organization within the Miro Enterprise plan. This is exclusive to users with Company Admin roles, requiring the 'organizations:read' scope."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/members/{member_id}".format(  # noqa: UP032
            org_id=organization_id, member_id=organization_member_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_user_accessible_boards(
    context: ToolContext,
    team_id_filter: Annotated[
        str | None,
        "Filter boards by a specific team ID to narrow down results. Useful for fetching boards associated with a specific team.",  # noqa: E501
    ] = None,
    project_id: Annotated[
        str | None,
        "Filter boards by project ID to narrow down the list to those associated with a specific project.",  # noqa: E501
    ] = None,
    filter_query: Annotated[
        str | None, "A search term to filter boards by name or description. Accepts a string value."
    ] = None,
    owner_username: Annotated[
        str | None,
        "Filter boards by the owner's username. Use this to fetch all boards created by a specific user.",  # noqa: E501
    ] = None,
    maximum_results_limit: Annotated[
        str | None,
        "Specifies the maximum number of boards to return in a single response. This allows you to control pagination by limiting the number of results.",  # noqa: E501
    ] = None,
    pagination_offset: Annotated[
        str | None,
        "The number of boards to skip before starting to collect the result set. Used for pagination.",  # noqa: E501
    ] = None,
    sorting_preference: Annotated[
        str | None,
        "Specifies how to sort the list of boards. Options are: 'default', 'last_modified', 'last_opened', 'last_created', 'alphabetically'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-boards'."]:
    """Retrieve boards accessible to the user with filtering options.

    Fetches a list of boards accessible to the user using various filters like `team_id` or `project_id`. Allows Enterprise users with Content Admin permissions to fetch all boards, excluding private contents."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards",
        method="GET",
        params=remove_none_values({
            "team_id": team_id_filter,
            "project_id": project_id,
            "query": filter_query,
            "owner": owner_username,
            "limit": maximum_results_limit,
            "offset": pagination_offset,
            "sort": sorting_preference,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_info(
    context: ToolContext,
    board_identifier: Annotated[
        str,
        "Unique identifier (ID) of the Miro board to retrieve. Needed to fetch specific board details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-specific-board'."]:
    """Retrieve detailed information about a specific Miro board.

    This tool retrieves detailed information about a specific Miro board, using the board's unique ID. It requires the 'boards:read' scope to access the data."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}".format(board_id=board_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_miro_board(
    context: ToolContext,
    board_unique_id: Annotated[str, "Unique identifier of the Miro board to delete."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-board'."]:
    """Delete a Miro board and move it to Trash.

    Use this tool to delete a Miro board. Boards on paid plans are moved to Trash and can be restored via the UI within 90 days. Ensure you have the necessary 'boards:write' scope."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}".format(board_id=board_unique_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_miro_app_card_info(
    context: ToolContext,
    board_id: Annotated[
        str, "Unique identifier of the Miro board for retrieving a specific app card item."
    ],
    item_id: Annotated[
        str, "Unique identifier (ID) of the app card item to retrieve from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-app-card-item'."]:
    """Retrieve information for a specific Miro app card.

    This tool retrieves details about an app card item on a Miro board, requiring 'boards:read' scope. It's useful for getting detailed information about app cards on a board to display or process further."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/app_cards/{item_id}".format(  # noqa: UP032
            board_id=board_id, item_id=item_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_miro_app_card(
    context: ToolContext,
    board_id: Annotated[
        str, "Unique identifier of the board from which you want to delete an item."
    ],
    item_id_to_delete: Annotated[
        str, "The unique identifier (ID) of the specific item to delete from the Miro board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-app-card-item'."]:
    """Delete an app card item from a Miro board.

    Use this tool to delete a specific app card item from a Miro board, requiring 'boards:write' access. Ensure you have the board ID and item ID before calling."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/app_cards/{item_id}".format(  # noqa: UP032
            board_id=board_id, item_id=item_id_to_delete
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_miro_card_info(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier of the board from which to retrieve the specific card item."
    ],
    card_item_id: Annotated[
        str, "Unique identifier (ID) of the card item to retrieve from a Miro board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-card-item'."]:
    """Retrieve details for a specific Miro board card item.

    Use this tool to get detailed information about a specific card item on a Miro board. This tool is useful when you need to access and display information related to individual cards, such as during planning or collaboration tasks."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/cards/{item_id}".format(  # noqa: UP032
            board_id=board_identifier, item_id=card_item_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_card_from_board(
    context: ToolContext,
    board_identifier: Annotated[
        str,
        "Unique ID of the board from which the card item will be deleted. Ensure it is valid and corresponds to the target board.",  # noqa: E501
    ],
    card_item_id: Annotated[
        str, "Unique identifier (ID) of the card item to delete from the Miro board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-card-item'."]:
    """Delete a card item from a Miro board.

    Use this tool to delete a specific card item from a Miro board when you need to manage board content. Ensure you have the necessary authorization with 'boards:write' scope to perform this action."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/cards/{item_id}".format(  # noqa: UP032
            board_id=board_identifier, item_id=card_item_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_board_connectors(
    context: ToolContext,
    board_identifier: Annotated[
        str, "The unique identifier of the Miro board from which to retrieve connectors."
    ],
    max_results_per_page: Annotated[
        str | None,
        "Sets the maximum number of results to return per page. Use for pagination control.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "The cursor value for pagination to retrieve the next set of results. Use the cursor from the previous response.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-connectors'."]:
    """Retrieve connectors from a specific Miro board.

    Use this tool to obtain a list of connectors from a specified Miro board. It supports cursor-based pagination to retrieve large datasets efficiently."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/connectors".format(  # noqa: UP032
            board_id=board_identifier
        ),
        method="GET",
        params=remove_none_values({"limit": max_results_per_page, "cursor": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_connector_info(
    context: ToolContext,
    board_unique_identifier: Annotated[
        str, "Unique identifier (ID) of the board from which to retrieve the specific connector."
    ],
    connector_identifier: Annotated[
        str, "Unique identifier for the connector to retrieve details from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-connector'."]:
    """Retrieve details of a specific connector on a Miro board.

    Use this tool to obtain information about a specific connector on a Miro board. Useful for scenarios where connector details are needed for a given board or project."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/connectors/{connector_id}".format(  # noqa: UP032
            board_id=board_unique_identifier, connector_id=connector_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def remove_connector_from_board(
    context: ToolContext,
    board_id_for_connector_removal: Annotated[
        str, "Unique identifier of the board from which you want to delete the connector."
    ],
    connector_id: Annotated[str, "Unique identifier of the connector to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-connector'."]:
    """Remove a specific connector from the board using Miro API.

    Use this tool to delete a specified connector from a Miro board. It is necessary to have the required 'boards:write' scope to perform this action. Useful when managing or updating board elements."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/connectors/{connector_id}".format(  # noqa: UP032
            board_id=board_id_for_connector_removal, connector_id=connector_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_document_item(
    context: ToolContext,
    board_unique_id: Annotated[
        str, "Unique identifier of the board from which to retrieve a specific item."
    ],
    item_id: Annotated[
        str, "Unique identifier (ID) of the item you want to retrieve from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-document-item'."]:
    """Retrieve information for a specific document item on a board.

    Use this tool to obtain details about a particular document item located on a board in Miro. Requires 'boards:read' scope access."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/documents/{item_id}".format(  # noqa: UP032
            board_id=board_unique_id, item_id=item_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_document_item_from_board(
    context: ToolContext,
    board_id: Annotated[
        str,
        "Unique identifier (ID) of the board from which you want to delete the item. Ensure the ID is valid and you have write permissions.",  # noqa: E501
    ],
    item_id_for_deletion: Annotated[
        str, "The unique identifier (ID) of the item to delete from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-document-item'."]:
    """Removes a document item from a Miro board.

    Use this tool to delete a specific document item from a Miro board. Ensure you have the necessary permissions ('boards:write' scope) to perform this action."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/documents/{item_id}".format(  # noqa: UP032
            board_id=board_id, item_id=item_id_for_deletion
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_embed_item_info(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier (ID) of the Miro board to retrieve a specific embed item."
    ],
    embed_item_id: Annotated[
        str, "Unique identifier of the embed item to retrieve from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-embed-item'."]:
    """Retrieve information for a specific embed item on a board.

    Use this tool to get details about a specific embed item from a Miro board. It requires the board ID and item ID to retrieve the information. Useful for accessing embed details within a Miro board."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/embeds/{item_id}".format(  # noqa: UP032
            board_id=board_identifier, item_id=embed_item_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_embed_item(
    context: ToolContext,
    board_id: Annotated[
        str, "Unique identifier of the board from which the embed item should be deleted."
    ],
    item_id: Annotated[str, "Unique identifier of the item to be deleted from the board."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-embed-item'."]:
    """Delete an embed item from a Miro board.

    Use this tool to delete an embed item from a specific Miro board. It requires the 'boards:write' scope to function."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/embeds/{item_id}".format(  # noqa: UP032
            board_id=board_id, item_id=item_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_board_image_info(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier for the board to retrieve a specific image item from."
    ],
    image_item_id: Annotated[
        str, "The unique identifier of the image item to retrieve from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-image-item'."]:
    """Retrieve information for a specific image item on a board.

    Use this tool to get details about an image item on a Miro board, such as its metadata and properties, using the board and item IDs."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/images/{item_id}".format(  # noqa: UP032
            board_id=board_identifier, item_id=image_item_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_image_from_board(
    context: ToolContext,
    board_id: Annotated[
        str, "Unique identifier (ID) for the board from which the image will be deleted."
    ],
    image_item_id: Annotated[str, "Unique identifier of the image item to delete from the board."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-image-item'."]:
    """Deletes an image from a Miro board.

    Use this tool to delete an image item from a specific Miro board. Ensure you have the 'boards:write' scope permission. This action is rate-limited at Level 3."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/images/{item_id}".format(  # noqa: UP032
            board_id=board_id, item_id=image_item_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_board_items(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier for the Miro board to retrieve items from."
    ],
    limit_number_of_items: Annotated[
        str | None,
        "Sets the maximum number of items to retrieve per API call. Useful for pagination and managing large datasets.",  # noqa: E501
    ] = None,
    item_type_filter: Annotated[
        str | None,
        "Specify the type of items to retrieve from the board, such as text, shape, or image.",
    ] = None,
    pagination_cursor: Annotated[
        str | None, "The cursor value from a previous response to retrieve the next set of items."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-items'."]:
    """Retrieve a list of items from a specific Miro board.

    This tool retrieves a list of items for a specific board in Miro. It supports filtering to get all items, child items within a parent, or specific item types. Results are paginated using a cursor-based approach. Suitable for tasks requiring retrieval of board contents."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/items".format(board_id=board_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "limit": limit_number_of_items,
            "type": item_type_filter,
            "cursor": pagination_cursor,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def fetch_board_item_details(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier (ID) of the board to retrieve a specific item from."
    ],
    item_identifier: Annotated[
        str, "Unique identifier of the item to retrieve from the Miro board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-specific-item'."]:
    """Fetches details of a specific item on a Miro board.

    Use this tool to retrieve detailed information about a particular item on a Miro board. Useful when you need to access or display specific item attributes. Requires 'boards:read' scope."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/items/{item_id}".format(  # noqa: UP032
            board_id=board_identifier, item_id=item_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_miro_item(
    context: ToolContext,
    board_id: Annotated[
        str, "Unique identifier of the board from which you want to delete the item."
    ],
    item_id: Annotated[
        str, "The unique identifier for the item you wish to delete from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-item'."]:
    """Delete an item from a Miro board efficiently.

    Use this tool to delete a specific item from a Miro board when board writing access is granted. Ensure rate limits are considered for optimal performance."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/items/{item_id}".format(  # noqa: UP032
            board_id=board_id, item_id=item_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_members(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier (ID) for the Miro board to retrieve its members."
    ],
    member_limit: Annotated[
        str | None,
        "The maximum number of board members to retrieve in a single request. Specify as an integer string.",  # noqa: E501
    ] = None,
    results_offset: Annotated[
        str | None,
        "The starting point in the list of board members to begin retrieval from, for pagination purposes.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-board-members'."]:
    """Retrieve members of a specified Miro board.

    Use this tool to get a list of members associated with a specific Miro board. Useful when you need to access or display information about board participants. Requires 'boards:read' scope and adheres to Level 1 rate limiting."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/members".format(board_id=board_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({"limit": member_limit, "offset": results_offset}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_member_info(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier of the board to which the board member belongs."
    ],
    board_member_identifier: Annotated[
        str, "The unique ID of the board member whose information you want to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-specific-board-member'."]:
    """Retrieve information about a specific Miro board member.

    Use this tool to obtain details about a particular member of a Miro board. It requires board and member identifiers. Ensure you have the required 'boards:read' scope to access this information."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/members/{board_member_id}".format(  # noqa: UP032
            board_id=board_identifier, board_member_id=board_member_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def remove_board_member(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier of the board from which you want to remove a member."
    ],
    board_member_id: Annotated[str, "Unique identifier of the board member to remove."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'remove-board-member'."]:
    """Remove a member from a Miro board.

    Use this tool to remove a specific member from a Miro board. Requires the board ID and member ID. Ensure you have the 'boards:write' scope."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/members/{board_member_id}".format(  # noqa: UP032
            board_id=board_identifier, board_member_id=board_member_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_shape_item_info(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier of the Miro board to retrieve a specific item from."
    ],
    item_identifier: Annotated[
        str, "Unique identifier of the item to retrieve from the Miro board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-shape-item'."]:
    """Retrieve details of a shape item from a Miro board.

    Use this tool to obtain detailed information about a specific shape item on a Miro board using its board ID and item ID."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/shapes/{item_id}".format(  # noqa: UP032
            board_id=board_identifier, item_id=item_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_shape_item(
    context: ToolContext,
    board_id: Annotated[
        str, "Unique identifier of the Miro board from which the shape item will be deleted."
    ],
    item_unique_id: Annotated[str, "Unique identifier (ID) of the item to delete from the board."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-shape-item'."]:
    """Delete a shape item from the Miro board.

    Use this tool to delete a specific shape item from a Miro board. This is useful when you need to manage or organize board contents by removing unnecessary shapes. Requires 'boards:write' scope."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/shapes/{item_id}".format(  # noqa: UP032
            board_id=board_id, item_id=item_unique_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_sticky_note_info(
    context: ToolContext,
    board_id: Annotated[
        str, "The unique ID of the Miro board containing the sticky note to retrieve."
    ],
    item_identifier: Annotated[
        str, "Unique identifier of the sticky note item to retrieve from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-sticky-note-item'."]:
    """Retrieve details of a specific sticky note on a Miro board.

    Use this tool to get information about a specific sticky note item on a Miro board by providing the board ID and item ID. It requires 'boards:read' permissions and may be subject to rate limits."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/sticky_notes/{item_id}".format(  # noqa: UP032
            board_id=board_id, item_id=item_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_sticky_note(
    context: ToolContext,
    board_id: Annotated[
        str, "Unique identifier of the board from which the sticky note will be deleted."
    ],
    sticky_note_id: Annotated[
        str, "Unique identifier (ID) of the sticky note to delete from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-sticky-note-item'."]:
    """Removes a sticky note item from a Miro board.

    Use this tool to delete a specific sticky note from a board in Miro. Requires appropriate board permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/sticky_notes/{item_id}".format(  # noqa: UP032
            board_id=board_id, item_id=sticky_note_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_text_item(
    context: ToolContext,
    board_unique_id: Annotated[str, "Unique ID of the board to retrieve a specific text item."],
    item_identifier: Annotated[
        str, "Unique identifier of the text item you want to retrieve from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-text-item'."]:
    """Fetches details of a text item from a Miro board.

    This tool retrieves information for a specific text item on a Miro board using the board and item IDs. It requires 'boards:read' access."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/texts/{item_id}".format(  # noqa: UP032
            board_id=board_unique_id, item_id=item_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_board_text_item(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier of the board from which the text item will be deleted."
    ],
    text_item_id: Annotated[
        str, "Unique identifier (ID) of the text item you want to delete from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-text-item'."]:
    """Delete a text item from a Miro board.

    Use this tool to delete a specific text item from a Miro board. This action requires 'boards:write' scope and adheres to level 3 rate limiting. Call this tool when you need to remove unwanted or outdated text entries from your board."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/texts/{item_id}".format(  # noqa: UP032
            board_id=board_identifier, item_id=text_item_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_frame_info(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier of the board containing the frame to retrieve."
    ],
    frame_id: Annotated[str, "Unique identifier of the frame to retrieve from the board."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-frame-item'."]:
    """Retrieve specific frame details from a Miro board.

    This tool retrieves information about a particular frame on a specified Miro board. It is useful when you need details of a frame, such as its size and content, for board organization or analysis."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/frames/{item_id}".format(  # noqa: UP032
            board_id=board_identifier, item_id=frame_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_board_frame(
    context: ToolContext,
    board_unique_id: Annotated[
        str, "The unique ID of the board from which the frame will be deleted."
    ],
    frame_id: Annotated[str, "Unique identifier of the frame to be deleted from the board."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-frame-item'."]:
    """Delete a frame from a specified board.

    Use this tool to delete a frame from a Miro board by specifying the board ID and frame item ID. This action requires the 'boards:write' scope. Ideal for managing board content by removing unnecessary frames."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/frames/{item_id}".format(  # noqa: UP032
            board_id=board_unique_id, item_id=frame_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_items_within_frame(
    context: ToolContext,
    frame_id: Annotated[
        str, "The ID of the frame to retrieve all child items from on the Miro board."
    ],
    board_id: Annotated[
        str, "Unique identifier (ID) of the Miro board containing the frame to retrieve items from."
    ],
    results_limit: Annotated[
        str | None,
        "The maximum number of items to return in the response. Helps control pagination size.",
    ] = None,
    item_type: Annotated[
        str | None,
        "Specify the type of items to retrieve within the frame. Use for filtering by item type.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Cursor for pagination to retrieve the next set of results. Use the value from the previous response to continue fetching items.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-items-within-frame'."]:
    """Retrieve items within a specific frame in a Miro board.

    Use this tool to obtain items located within a particular frame on a Miro board. It supports cursor-based pagination for efficient data retrieval. Ideal for accessing and managing child items of a frame."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id_PlatformContainers}/items".format(  # noqa: UP032
            board_id_PlatformContainers=board_id
        ),
        method="GET",
        params=remove_none_values({
            "parent_item_id": frame_id,
            "limit": results_limit,
            "type": item_type,
            "cursor": pagination_cursor,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_app_usage_metrics(
    context: ToolContext,
    start_date_utc: Annotated[str, "Start date of the period in UTC format (e.g., 2024-12-31)."],
    end_date: Annotated[str, "End date of the period in UTC format (e.g., 2024-12-31)."],
    app_id: Annotated[
        str,
        "The unique identifier of the app to retrieve usage metrics for. This ID specifies which app's data to fetch.",  # noqa: E501
    ],
    group_metrics_by_period: Annotated[
        str | None,
        "The time period to group the data by. Accepted values: 'DAY', 'WEEK', or 'MONTH'.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-metrics'."]:
    """Fetch usage metrics for a specific app over a time range.

    Call this tool to obtain usage metrics for a specific app within a given time period. It's useful for tracking app performance and usage patterns. An app management API token is required to access this information."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2-experimental/apps/{app_id}/metrics".format(app_id=app_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "startDate": start_date_utc,
            "endDate": end_date,
            "period": group_metrics_by_period,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_total_usage_metrics(
    context: ToolContext,
    app_id: Annotated[
        str, "The unique identifier of the Miro app to retrieve total usage metrics for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-metrics-total'."]:
    """Retrieve total usage metrics for a specific app.

    This tool returns the total usage metrics for a Miro app since its creation. It requires an app management API token with 'boards:read' scope. Ideal for monitoring app performance and usage over time."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2-experimental/apps/{app_id}/metrics-total".format(  # noqa: UP032
            app_id=app_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_user_webhook_subscriptions(
    context: ToolContext,
    subscription_limit: Annotated[
        str | None,
        "Specify the maximum number of webhook subscriptions to retrieve. Use integer values.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "A string used to paginate through large sets of webhook subscriptions. Use the cursor returned from a previous call to get the next set of results.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-user-subscriptions'."]:
    """Retrieve webhook subscription details for a specific user.

    Call this tool to get information about all webhook subscriptions associated with a user. This is useful for managing webhook integrations. Requires 'boards:read' scope."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2-experimental/webhooks/subscriptions",
        method="GET",
        params=remove_none_values({"limit": subscription_limit, "cursor": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_subscription_info(
    context: ToolContext,
    subscription_identifier: Annotated[
        str, "Unique identifier of the subscription to retrieve information for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-subscription-by-id'."]:
    """Retrieve information for a specific webhook subscription.

    Use this tool to get detailed information about a particular webhook subscription in Miro. It requires the 'boards:read' scope and is subject to Level 2 rate limiting."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2-experimental/webhooks/subscriptions/{subscription_id}".format(  # noqa: UP032
            subscription_id=subscription_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_webhook_subscription(
    context: ToolContext,
    subscription_id: Annotated[
        str,
        "Unique identifier (ID) of the subscription that you want to delete. This is required to specify which subscription will be deleted.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-subscription-by-id'."]:
    """Delete a specified webhook subscription.

    Use this tool to delete a specific webhook subscription by its ID. Ensure the required 'boards:read' scope is available. Appropriate for managing or cleaning up webhook subscriptions."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2-experimental/webhooks/subscriptions/{subscription_id}".format(  # noqa: UP032
            subscription_id=subscription_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_mindmap_node_info(
    context: ToolContext,
    board_identifier: Annotated[str, "Unique identifier of the board to retrieve a mind map node."],
    mindmap_node_id: Annotated[
        str, "Unique identifier of the mind map node to retrieve from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-mindmap-node-experimental'."]:
    """Retrieve information for a specific mind map node.

    Use this tool to get details about a specific mind map node on a Miro board. Useful for accessing node information when managing or analyzing mind maps."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2-experimental/boards/{board_id}/mindmap_nodes/{item_id}".format(  # noqa: UP032
            board_id=board_identifier, item_id=mindmap_node_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_mindmap_node(
    context: ToolContext,
    board_unique_identifier: Annotated[
        str, "Unique identifier of the board from which the mind map node will be deleted."
    ],
    node_id_to_delete: Annotated[
        str, "Unique identifier of the mind map node to delete, including its children."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete-mindmap-node-experimental'."
]:
    """Delete a mind map node and its children from the board.

    This tool is used to delete a specified mind map node and its child nodes from a Miro board. It requires write access to boards and is subject to Level 3 rate limiting."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2-experimental/boards/{board_id}/mindmap_nodes/{item_id}".format(  # noqa: UP032
            board_id=board_unique_identifier, item_id=node_id_to_delete
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_mindmap_nodes(
    context: ToolContext,
    board_identifier: Annotated[
        str,
        "The unique identifier for the Miro board to retrieve mind map nodes from. Ensure this ID is valid and corresponds to an existing board.",  # noqa: E501
    ],
    max_results_limit: Annotated[
        str | None,
        "Specifies the maximum number of mind map nodes to return in a single call. Use it to control data page size.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "A string indicating the position in the paginated results to fetch the next set of mind map nodes. Use the value provided in the previous API response to continue fetching additional results.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-mindmap-nodes-experimental'."]:
    """Fetches mind map nodes from a specified board.

    Use this tool to retrieve a list of mind map nodes for a specific board in Miro. It supports cursor-based pagination for fetching large sets of nodes incrementally. Requires 'boards:read' scope."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2-experimental/boards/{board_id}/mindmap_nodes".format(  # noqa: UP032
            board_id=board_identifier
        ),
        method="GET",
        params=remove_none_values({"limit": max_results_limit, "cursor": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_items(
    context: ToolContext,
    board_identifier: Annotated[str, "Unique identifier of the Miro board to retrieve items from."],
    item_limit: Annotated[
        str | None,
        "Specifies the maximum number of items to retrieve from the board in one request.",
    ] = None,
    item_type: Annotated[
        str | None, "Specify the type of items to retrieve, such as 'shape'."
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "The cursor value to retrieve the next set of results for board items. Use the value from the previous response's cursor to paginate through results.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-items-experimental'."]:
    """Retrieve items from a Miro board.

    This tool retrieves a list of items from a specific Miro board using a cursor-based pagination method. It can fetch all items, child items within a parent item, or specific types of items based on query parameters. Useful for managing and navigating board content efficiently."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2-experimental/boards/{board_id}/items".format(  # noqa: UP032
            board_id=board_identifier
        ),
        method="GET",
        params=remove_none_values({
            "limit": item_limit,
            "type": item_type,
            "cursor": pagination_cursor,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_item_details(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier (ID) of the board to retrieve a specific item from."
    ],
    item_identifier: Annotated[
        str, "Unique identifier (ID) of the item to retrieve from the Miro board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-specific-item-experimental'."]:
    """Get details of a specific item from a Miro board.

    Use this tool to retrieve information about a specific item on a Miro board. You will need the board and item IDs to access the details. Ensure you have the necessary 'boards:read' scope to perform this action."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2-experimental/boards/{board_id}/items/{item_id}".format(  # noqa: UP032
            board_id=board_identifier, item_id=item_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_board_item(
    context: ToolContext,
    board_id: Annotated[
        str, "Unique identifier (ID) of the board from which the item will be deleted."
    ],
    item_id: Annotated[str, "The unique ID of the item to delete from the board."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-item-experimental'."]:
    """Deletes an item from a Miro board.

    Use this tool to delete a specific item from a board in Miro. This requires 'boards:write' scope and is subject to Level 3 rate limiting."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2-experimental/boards/{board_id}/items/{item_id}".format(  # noqa: UP032
            board_id=board_id, item_id=item_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_shape_details(
    context: ToolContext,
    board_identifier: Annotated[str, "Unique identifier of the board to retrieve a specific item."],
    shape_item_id: Annotated[
        str, "Unique identifier (ID) of the shape item to retrieve from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-shape-item-flowchart'."]:
    """Retrieve information for a specific shape item on a board.

    This tool retrieves detailed information for a specific shape item on a Miro board. It should be called when you need to access data about a particular shape within a flowchart or other diagram. Requires board read access."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2-experimental/boards/{board_id}/shapes/{item_id}".format(  # noqa: UP032
            board_id=board_identifier, item_id=shape_item_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_flowchart_shape(
    context: ToolContext,
    board_unique_identifier: Annotated[
        str, "Unique identifier of the Miro board to delete the flowchart shape from."
    ],
    shape_item_id: Annotated[
        str, "Unique identifier (ID) of the shape item to be deleted from the board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-shape-item-flowchart'."]:
    """Delete a flowchart shape item from a Miro board.

    Use this tool to remove a specific shape item from a flowchart on a Miro board. Useful for managing and updating flowchart designs."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2-experimental/boards/{board_id}/shapes/{item_id}".format(  # noqa: UP032
            board_id=board_unique_identifier, item_id=shape_item_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def list_board_groups(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier of the board to fetch its groups and items."
    ],
    maximum_items_to_return: Annotated[
        int | None,
        "Specify the maximum number of items to return in one call. Default is 10, and maximum is 50.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Cursor for fetching the next set of results in paginated requests. Use the cursor value received from the previous response to continue pagination.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-all-groups'."]:
    """Retrieve all groups and their items from a board.

    Use this tool to get all the groups along with their items within a specified board on Miro. It supports cursor-based pagination for retrieving large sets of data. This tool is useful for those who need to manage or analyze board groups efficiently."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/groups".format(board_id=board_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({"limit": maximum_items_to_return, "cursor": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_items_by_group(
    context: ToolContext,
    group_id: Annotated[str, "The unique ID of the group item to retrieve from the board."],
    board_id: Annotated[
        str, "Unique identifier (ID) of the specific board from which to retrieve group items."
    ],
    max_items_to_return: Annotated[
        int | None,
        "The maximum number of items to return at one time. Defaults to 10, with a maximum of 50.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "A string token to fetch the next set of paginated results. Use the cursor value returned from a previous call to continue retrieving results.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getItemsByGroupId'."]:
    """Retrieve items part of a group within a board.

    Use this tool to get a list of items that belong to any group within a specific board on Miro. It supports cursor-based pagination, allowing retrieval of items in parts using a cursor for managing large collections effectively."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/groups/items".format(board_id=board_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "limit": max_items_to_return,
            "cursor": pagination_cursor,
            "group_item_id": group_id,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_group_items(
    context: ToolContext,
    board_id: Annotated[str, "Unique identifier (ID) of the board to retrieve group items from."],
    group_identifier: Annotated[str, "Unique identifier of the group for retrieving its items."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getGroupById'."]:
    """Retrieve a list of items in a specific group on a board.

    Use this tool to get all items within a specific group on a Miro board by providing the board and group IDs."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/groups/{group_id}".format(  # noqa: UP032
            board_id=board_id, group_id=group_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def ungroup_items_in_miro(
    context: ToolContext,
    board_id: Annotated[str, "Unique identifier (ID) of the Miro board for ungrouping items."],
    group_identifier: Annotated[
        str, "Unique identifier of the group to be ungrouped on the Miro board."
    ],
    delete_items_after_ungrouping: Annotated[
        bool | None, "Indicate whether items should be removed after ungrouping. Defaults to false."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'unGroup'."]:
    """Ungroups items from a group in Miro boards.

    This tool is used to ungroup items within a specified group on a Miro board. It requires the 'boards:write' scope and adheres to level 3 rate limiting. Use this tool when you need to separate items that have been grouped together in a Miro board."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/groups/{group_id}".format(  # noqa: UP032
            board_id=board_id, group_id=group_identifier
        ),
        method="DELETE",
        params=remove_none_values({"delete_items": delete_items_after_ungrouping}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_group_from_board(
    context: ToolContext,
    board_id: Annotated[str, "Unique identifier (ID) of the board to delete the group from."],
    group_id: Annotated[str, "Unique identifier (ID) of the group to be deleted from the board."],
    delete_items_in_group: Annotated[
        bool, "Set to `true` to delete the items in the group along with the group itself."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteGroup'."]:
    """Delete a group and its items from a Miro board.

    Use this tool to delete a specific group from a Miro board along with all its items. It requires the `boards:write` scope and is subject to Level 3 rate limiting."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/groups/{group_id}?".format(  # noqa: UP032
            board_id=board_id, group_id=group_id
        ),
        method="DELETE",
        params=remove_none_values({"delete_items": delete_items_in_group}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_tags_from_item(
    context: ToolContext,
    board_id: Annotated[
        str, "Unique identifier (ID) of the board containing the item whose tags need retrieval."
    ],
    item_identifier: Annotated[
        str,
        "Unique identifier (ID) of the item from which to retrieve tags. Required to specify which item's tags you wish to get from a Miro board.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-tags-from-item'."]:
    """Retrieve all tags from a specified item on a board.

    Use this tool to obtain all tags from a specific item on a Miro board. This is useful for organizing and categorizing items. Requires 'boards:read' scope."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/items/{item_id}/tags".format(  # noqa: UP032
            board_id=board_id, item_id=item_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_tags(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier (ID) of the Miro board from which to retrieve tags."
    ],
    max_tags_limit: Annotated[
        str | None,
        "Specifies the maximum number of tags to retrieve from the board. Leave blank to retrieve all available tags.",  # noqa: E501
    ] = None,
    offset: Annotated[
        str | None,
        "The starting position in the list of tags to begin retrieving from. Useful for pagination.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-tags-from-board'."]:
    """Retrieve all tags from a specified Miro board.

    Use this tool to get a list of all tags from a specific Miro board by providing the board ID. This is useful for organizing or analyzing board elements."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/tags".format(board_id=board_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({"limit": max_tags_limit, "offset": offset}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_tag_info(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier (ID) of the board from which to retrieve a specific tag."
    ],
    tag_id: Annotated[str, "Unique identifier of the tag to retrieve from the Miro board."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-tag'."]:
    """Retrieve information for a specific tag on a Miro board.

    Use this tool to fetch details about a particular tag on a Miro board. Requires 'boards:write' scope. Intended for retrieving tag metadata to enhance user interactions with board contents."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/tags/{tag_id}".format(  # noqa: UP032
            board_id=board_identifier, tag_id=tag_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_tag_from_board(
    context: ToolContext,
    board_identifier: Annotated[
        str, "Unique identifier of the board where the tag will be deleted."
    ],
    tag_id_to_delete: Annotated[
        str, "Unique identifier of the tag you want to delete from the Miro board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete-tag'."]:
    """Delete a tag from a Miro board and all associated items.

    This tool deletes a specified tag from a Miro board, removing it from all associated cards and sticky notes. Note that changes from the API are not reflected in real-time on the board; a refresh is required to see updates."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id}/tags/{tag_id}".format(  # noqa: UP032
            board_id=board_identifier, tag_id=tag_id_to_delete
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_board_items_by_tag(
    context: ToolContext,
    tag_identifier: Annotated[str, "Unique identifier of the tag to be retrieved from the board."],
    board_id: Annotated[
        str, "Unique identifier (ID) of the board to retrieve items with a specific tag."
    ],
    item_limit: Annotated[
        str | None,
        "Specifies the maximum number of items to return. It should be an integer value (e.g., '10', '20').",  # noqa: E501
    ] = None,
    results_starting_position: Annotated[
        str | None, "The position to start retrieving items from. Use for pagination in lists."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-items-by-tag'."]:
    """Retrieve items with a specific tag from a Miro board.

    Use this tool to get all items from a Miro board that have a specified tag. It requires 'boards:read' scope and follows Level 1 rate limiting."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id_PlatformTags}/items".format(  # noqa: UP032
            board_id_PlatformTags=board_id
        ),
        method="GET",
        params=remove_none_values({
            "limit": item_limit,
            "offset": results_starting_position,
            "tag_id": tag_identifier,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def attach_tag_to_item(
    context: ToolContext,
    tag_identifier: Annotated[
        str, "The unique ID of the tag to attach to the specified item on Miro."
    ],
    board_id: Annotated[
        str,
        "Unique identifier (ID) of the board containing the item to which you want to add a tag.",
    ],
    item_id: Annotated[
        str, "Unique identifier of the item to which you want to attach a tag on the Miro board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'attach-tag-to-item'."]:
    """Attach an existing tag to a specified board item in Miro.

    Use this tool to attach an existing tag to a card or sticky note item on a Miro board. Note that updates made via this tool will not be reflected on the board in real-time; you need to refresh the board to see changes. Suitable for up to 8 tags per item."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id_PlatformTags}/items/{item_id}".format(  # noqa: UP032
            board_id_PlatformTags=board_id, item_id=item_id
        ),
        method="POST",
        params=remove_none_values({"tag_id": tag_identifier}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def remove_tag_from_item(
    context: ToolContext,
    tag_identifier: Annotated[
        str, "Unique identifier (ID) of the tag to be removed from the item."
    ],
    board_id: Annotated[
        str,
        "Unique identifier (ID) of the board with the item from which you want to remove a tag.",
    ],
    item_identifier: Annotated[
        str, "Unique identifier of the item from which the tag will be removed on the Miro board."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'remove-tag-from-item'."]:
    """Remove a specified tag from an item on a Miro board.

    Use this tool to remove a specific tag from an item on a Miro board. The tag will still exist on the board, but will no longer be attached to the item. Note that updates via the API will not reflect in real-time on the board; a refresh is required to see changes."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/boards/{board_id_PlatformTags}/items/{item_id}".format(  # noqa: UP032
            board_id_PlatformTags=board_id, item_id=item_identifier
        ),
        method="DELETE",
        params=remove_none_values({"tag_id": tag_identifier}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_miro_team_projects(
    context: ToolContext,
    organization_id: Annotated[
        str, "The ID of the Miro organization for retrieving the list of projects."
    ],
    team_identifier: Annotated[
        str, "The unique ID of the team for which you want to retrieve the list of projects."
    ],
    results_limit: Annotated[
        int | None,
        "The maximum number of project results to return per call. If more projects exist, a cursor for pagination will be provided.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Specify the cursor value to paginate through results. Leave empty for the first page; use the value from the previous response for subsequent pages.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-get-projects'."]:
    """Retrieve a list of projects for a specified team in a Miro organization.

    This tool retrieves all projects in a specified team of an organization using Miro's Enterprise API. Accessible only to Company Admins with the Enterprise plan, it allows fetching both shared and private projects by leveraging Content Admin permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}/projects".format(  # noqa: UP032
            org_id=organization_id, team_id=team_identifier
        ),
        method="GET",
        params=remove_none_values({"limit": results_limit, "cursor": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_enterprise_project_info(
    context: ToolContext,
    organization_id: Annotated[str, "The ID of the organization to retrieve project info from."],
    team_id: Annotated[
        str, "The ID of the team from which you want to retrieve the project information."
    ],
    project_id: Annotated[
        str,
        "The ID of the project from which to retrieve information. Required for fetching project details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-get-project'."]:
    """Get details of a specific enterprise project.

    This tool retrieves information about an existing project within an enterprise plan on Miro. It requires 'projects:read' access and is only available for Company Admins in the Enterprise plan. Use this tool to fetch details like the project's name for a given organization, team, and project ID."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}/projects/{project_id}".format(  # noqa: UP032
            org_id=organization_id, team_id=team_id, project_id=project_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_miro_project(
    context: ToolContext,
    organization_id: Annotated[
        str, "The unique ID of the organization from which the project will be deleted."
    ],
    team_id_for_project_deletion: Annotated[
        str, "The ID of the team from which you want to delete a project in Miro."
    ],
    project_id: Annotated[str, "The ID of the project to delete within the Miro team."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-delete-project'."]:
    """Delete a project from a team in Miro's Enterprise plan.

    This tool deletes a specified project within a team while retaining all boards and users. Available only to Enterprise plan users with Company Admin privileges. Ensure the required scope 'projects:write' is available."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}/projects/{project_id}".format(  # noqa: UP032
            org_id=organization_id, team_id=team_id_for_project_deletion, project_id=project_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_project_settings(
    context: ToolContext,
    organization_id: Annotated[str, "The ID of the organization to which the project belongs."],
    team_id: Annotated[
        str, "The ID of the team to which the project belongs for retrieving its settings."
    ],
    project_identifier: Annotated[
        str,
        "The unique identifier for the project whose settings are to be retrieved. This ID is required to specify the exact project within the organization and team context.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-get-project-settings'."]:
    """Retrieve settings for a specific project in an enterprise environment.

    This tool retrieves the settings of a specified project within an enterprise environment. It is intended for use by users with the Company Admin role on Miro's Enterprise plan. The required API scope is 'projects:read', and it adheres to rate limiting level 1."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}/projects/{project_id}/settings".format(  # noqa: UP032
            org_id=organization_id, team_id=team_id, project_id=project_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_project_members(
    context: ToolContext,
    organization_id: Annotated[
        str, "The unique ID of the organization to which the project belongs."
    ],
    team_id: Annotated[
        str,
        "The ID of the team to which the project belongs. This should be a string representing the unique identifier for the team.",  # noqa: E501
    ],
    project_id: Annotated[
        str, "The unique identifier of the project for which to retrieve member details."
    ],
    maximum_results_per_call: Annotated[
        int | None,
        "The maximum number of project members to return in a single call. If exceeded, a cursor for pagination is provided.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "The cursor for pagination. Leave empty for the first page or use the value returned in the last call for subsequent pages.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-get-project-members'."]:
    """Retrieve members of a specified project for Enterprise users.

    This tool retrieves the list of members for a specific project in Miro, available exclusively for Enterprise plan users with the Company Admin role. It should be called when you need to know who is part of a particular project team."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}/projects/{project_id}/members".format(  # noqa: UP032
            org_id=organization_id, team_id=team_id, project_id=project_id
        ),
        method="GET",
        params=remove_none_values({"limit": maximum_results_per_call, "cursor": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_project_member_info(
    context: ToolContext,
    organization_id: Annotated[str, "The ID of the organization to which the project belongs."],
    team_id: Annotated[str, "The unique identifier of the team to which the project belongs."],
    project_id: Annotated[
        str, "The ID of the project to retrieve specific member information from."
    ],
    member_id: Annotated[str, "ID of the member whose information you want to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-get-project-member'."]:
    """Retrieve information for a specific project member.

    This tool retrieves information about a specific member of a project for users with the Enterprise plan in Miro. It requires 'projects:read' scope and Company Admin rights. Use this tool to gain insights into project member roles and details in an enterprise setting."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}/projects/{project_id}/members/{member_id}".format(  # noqa: UP032
            org_id=organization_id, team_id=team_id, project_id=project_id, member_id=member_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def remove_project_member(
    context: ToolContext,
    organization_id: Annotated[str, "The ID of the organization associated with the project."],
    team_id: Annotated[
        str,
        "The unique identifier for the team associated with the project from which a member is being removed.",  # noqa: E501
    ],
    project_identifier: Annotated[
        str, "The unique identifier of the project from which a member will be removed."
    ],
    member_id: Annotated[
        str,
        "The ID of the member to remove from the Miro project. This ID is necessary to specify which member will be removed.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'enterprise-delete-project-member'."
]:
    """Remove a member from a Miro project.

    This tool removes a specified member from a project within the Miro platform. Note that the member will still remain part of the team even after being removed from the project. This action requires enterprise-level access and can only be performed by a Company Admin."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}/projects/{project_id}/members/{member_id}".format(  # noqa: UP032
            org_id=organization_id,
            team_id=team_id,
            project_id=project_identifier,
            member_id=member_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_organization_teams(
    context: ToolContext,
    organization_id: Annotated[
        str, "The unique identifier for the organization to retrieve teams for."
    ],
    result_limit: Annotated[
        int | None,
        "The maximum number of teams to return in the response. This controls the pagination of the results.",  # noqa: E501
    ] = None,
    page_cursor: Annotated[
        str | None,
        "Indicator for the current page position. Leave empty for first page or use the value from the previous request's cursor for subsequent pages.",  # noqa: E501
    ] = None,
    team_name_filter: Annotated[
        str | None,
        "Filters teams by name using a case insensitive partial match. For example, 'dev' will match both 'Developer's team' and 'Team for developers'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-get-teams'."]:
    """Retrieve a list of teams in an enterprise organization.

    Use this tool to retrieve a list of teams within an existing enterprise organization on Miro. This is available only for Enterprise plan users with Company Admin roles. Ensure appropriate 'organizations:teams:read' scope access is granted."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams".format(org_id=organization_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "limit": result_limit,
            "cursor": page_cursor,
            "name": team_name_filter,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_team_information(
    context: ToolContext,
    organization_id: Annotated[
        str, "The unique identifier for the Organization. Required to retrieve team information."
    ],
    team_identifier: Annotated[
        str, "The unique identifier for the team. Required to fetch specific team details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-get-team'."]:
    """Retrieve team information for an existing team in Enterprise plan.

    This tool retrieves detailed information about a specific team within an organization. It's designed for Enterprise plan users who have Company Admin roles. The tool should be used when there's a need to access or confirm team details, ensuring you have the necessary permissions to execute this request."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}".format(  # noqa: UP032
            org_id=organization_id, team_id=team_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def delete_enterprise_team(
    context: ToolContext,
    organization_id: Annotated[
        str, "The unique identifier of the Organization for which the team is to be deleted."
    ],
    team_id: Annotated[str, "The unique identifier of the team to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-delete-team'."]:
    """Delete a team in an enterprise Miro account.

    Use this tool to delete an existing team in an Enterprise Miro account. This action is only available to Company Admins and requires the 'organizations:teams:write' scope. Ensure you have access to Enterprise APIs before proceeding."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}".format(  # noqa: UP032
            org_id=organization_id, team_id=team_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def retrieve_team_members(
    context: ToolContext,
    organization_id: Annotated[str, "The unique identifier for the Organization."],
    team_id: Annotated[str, "The ID of the team to retrieve members from. Must be a string."],
    results_limit: Annotated[
        int | None,
        "Specifies the maximum number of team members to retrieve per request. Must be a positive integer.",  # noqa: E501
    ] = None,
    page_cursor: Annotated[
        str | None,
        "Indicator for the current page in the result set. Leave empty for first page; use value from previous response for next pages.",  # noqa: E501
    ] = None,
    filter_by_role: Annotated[
        str | None,
        'Filters members by their role in the team. Accepted values: "member", "admin", "non_team", "team_guest". Use full word match.',  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-get-team-members'."]:
    """Retrieve members of a specific Enterprise team.

    Use this tool to obtain a list of team members for a specified team in your organization. It's designed for Enterprise plan users with Company Admin roles. Ensure you have the necessary read permissions for organizations:teams:read."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}/members".format(  # noqa: UP032
            org_id=organization_id, team_id=team_id
        ),
        method="GET",
        params=remove_none_values({
            "limit": results_limit,
            "cursor": page_cursor,
            "role": filter_by_role,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_team_member_info(
    context: ToolContext,
    organization_id: Annotated[str, "The unique identifier for the Organization."],
    team_id: Annotated[
        str,
        "The unique identifier for the team. This is required to retrieve the team member's details.",  # noqa: E501
    ],
    team_member_id: Annotated[
        str, "The unique identifier for the team member whose information is to be retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-get-team-member'."]:
    """Retrieve details of a team member using their ID.

    This tool retrieves information about a team member by their ID. It requires enterprise-level access and the role of a Company Admin. It should be used to access specific member details within an organization."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}/members/{member_id}".format(  # noqa: UP032
            org_id=organization_id, team_id=team_id, member_id=team_member_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def remove_team_member(
    context: ToolContext,
    organization_id: Annotated[
        str, "The ID of the organization from which the team member will be removed."
    ],
    team_identifier: Annotated[
        str, "The unique identifier for the team from which the member will be removed."
    ],
    team_member_id: Annotated[str, "The ID of the team member to be removed from the team."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-delete-team-member'."]:
    """Remove a team member from a Miro Enterprise plan team.

    This tool deletes a specified team member by their ID from a team within the Miro Enterprise plan. It requires the 'organizations:teams:write' scope and is available only for users with the role of Company Admin. Suitable for managing team compositions within organizations."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}/members/{member_id}".format(  # noqa: UP032
            org_id=organization_id, team_id=team_identifier, member_id=team_member_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_organization_default_team_settings(
    context: ToolContext,
    organization_id: Annotated[
        str, "The unique identifier for an organization to retrieve its default team settings."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'enterprise-get-default-team-settings'."
]:
    """Retrieve default team settings for an organization.

    Fetches the default team settings of an existing organization for users with Enterprise plan and Company Admin role. Requires the 'organizations:teams:read' scope and is subject to Level 1 rate limiting."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/default_teams_settings".format(  # noqa: UP032
            org_id=organization_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-miro"))
async def get_team_settings(
    context: ToolContext,
    organization_id: Annotated[str, "The unique identifier for the organization in Miro."],
    team_identifier: Annotated[
        str, "The unique identifier for the team whose settings are to be retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enterprise-get-team-settings'."]:
    """Retrieve team settings in an enterprise Miro account.

    This tool retrieves the settings for a specific team within an enterprise Miro account. It is intended for users with the Company Admin role and requires access to the Enterprise plan. Use this when you need to access or verify the settings of a team in your organization's Miro account."""  # noqa: E501
    response = await make_request(
        url="https://api.miro.com/v2/orgs/{org_id}/teams/{team_id}/settings".format(  # noqa: UP032
            org_id=organization_id, team_id=team_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
