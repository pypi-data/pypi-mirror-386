"""Arcade Starter Tools for Pagerduty

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
from typing import Annotated, Any

import httpx
from arcade_tdk import ToolContext, tool
from arcade_tdk.auth import OAuth2

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    data: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                method=method,
                params=params,
                headers=headers,
                data=data,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_related_tags(
    context: ToolContext,
    entity_type: Annotated[
        str,
        "The type of entity (users, teams, or escalation_policies) related to the tag to be retrieved.",  # noqa: E501
    ],
    resource_id: Annotated[
        str,
        "The unique identifier for the resource you want to retrieve tags for, such as a User, Team, or Escalation Policy.",  # noqa: E501
    ],
    results_per_page_limit: Annotated[
        int | None, "Specify the number of results to return per page."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset to start pagination of search results. Useful for navigating through pages of results.",  # noqa: E501
    ] = None,
    include_total_in_pagination: Annotated[
        bool | None,
        "Set to true to include the total count of results in pagination responses. Defaults to false for faster response times.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getEntityTypeByIdTags'."]:
    """Retrieve related tags for Users, Teams, or Escalation Policies.

    Use this tool to get tags associated with specific Users, Teams, or Escalation Policies in Pagerduty. Tags help in filtering these entities. Requires 'tags.read' OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/{entity_type}/{id}/tags".format(  # noqa: UP032
            entity_type=entity_type, id=resource_id
        ),
        method="GET",
        params=remove_none_values({
            "limit": results_per_page_limit,
            "offset": pagination_offset,
            "total": include_total_in_pagination,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_account_abilities(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAbilities'."]:
    """Retrieve a list of all abilities for your account.

    Call this tool to get a list of your account's abilities, which describe its capabilities based on your pricing plan or account state. Useful for understanding what features are available to your account."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/abilities",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def check_account_ability(
    context: ToolContext,
    resource_id: Annotated[str, "The unique identifier for the specific account ability to check."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAbility'."]:
    """Check if your account has a specific feature ability.

    Use this tool to verify whether your Pagerduty account has a specific feature ability based on various factors like pricing or account state."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/abilities/{id}".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_pagerduty_addons(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "Specify the number of add-ons to display per page."
    ] = None,
    pagination_offset: Annotated[
        int | None, "Offset for starting pagination in search results."
    ] = None,
    include_additional_models: Annotated[
        str | None, "Specify additional models to include in the response. Valid value: 'services'."
    ] = None,
    filter_by_service_ids: Annotated[
        list[str] | None,
        "List of service IDs to filter results, showing only Add-ons associated with these services.",  # noqa: E501
    ] = None,
    addon_type_filter: Annotated[
        str | None,
        "Filter results to show only Add-ons of a specific type, such as 'full_page_addon' or 'incident_show_addon'.",  # noqa: E501
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to include the total number of add-ons in the response. Default is false for faster responses.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAddon'."]:
    """Retrieve all installed add-ons on your PagerDuty account.

    Use this tool to get a list of all add-ons currently installed on your PagerDuty account. Add-ons are extensions that add functionality to the PagerDuty UI. This should be called when you need to view or manage these add-ons. OAuth scope required: `addons.read`."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/addons",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "include[]": include_additional_models,
            "service_ids[]": filter_by_service_ids,
            "filter": addon_type_filter,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_addon_details(
    context: ToolContext,
    addon_id: Annotated[str, "The unique ID of the Pagerduty Add-on to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAddon'."]:
    """Retrieve details of a specific Pagerduty Add-on.

    This tool retrieves information about an existing Add-on integrated into Pagerduty's UI. Use it when you need to view specific details of an Add-on by providing its ID."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/addons/{id}".format(id=addon_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def remove_pagerduty_addon(
    context: ToolContext,
    resource_id: Annotated[str, "The ID of the add-on to be removed from PagerDuty."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteAddon'."]:
    """Remove an existing add-on from PagerDuty.

    Use this tool to remove an existing add-on from PagerDuty. This action deletes a piece of functionality developers have inserted into the PagerDuty UI. Ensure the necessary permissions (`addons.write`) are in place before proceeding."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/addons/{id}".format(id=resource_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_alert_grouping_settings(
    context: ToolContext,
    next_page_cursor: Annotated[
        str | None, "Cursor to retrieve the next page of results; use if more pages are available."
    ] = None,
    cursor_previous_page: Annotated[
        str | None,
        "Cursor to retrieve the previous page of results; only valid if not on the first page.",
    ] = None,
    results_per_page: Annotated[
        int | None, "Specify the number of results to display per page."
    ] = None,
    service_ids: Annotated[
        list[str] | None, "An array of service IDs to filter results by specific services."
    ] = None,
    include_total_count: Annotated[
        bool | None,
        "Set to true to populate the `total` field in pagination responses, or false for faster response times.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAlertGroupingSettings'."]:
    """Retrieve all alert grouping settings.

    Fetches all alert grouping settings, including single service and global content-based configurations, to help manage alert grouping effectively. Requires appropriate OAuth permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/alert_grouping_settings",
        method="GET",
        params=remove_none_values({
            "after": next_page_cursor,
            "before": cursor_previous_page,
            "total": include_total_count,
            "limit": results_per_page,
            "service_ids[]": service_ids,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_alert_grouping_setting(
    context: ToolContext,
    alert_grouping_setting_id: Annotated[
        str, "The unique identifier of the alert grouping setting to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAlertGroupingSetting'."]:
    """Retrieve an existing alert grouping setting by ID.

    Use this tool to obtain details of a specific alert grouping setting in Pagerduty by providing the setting ID. This helps in understanding and managing how alerts are grouped. Requires `services.read` scope for OAuth."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/alert_grouping_settings/{id}".format(  # noqa: UP032
            id=alert_grouping_setting_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_alert_grouping_setting(
    context: ToolContext,
    alert_grouping_setting_id: Annotated[
        str, "The ID of the alert grouping setting to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteAlertGroupingSetting'."]:
    """Delete an existing alert grouping setting.

    Use this tool to delete an alert grouping setting in Pagerduty. This is useful when you need to remove specific alert configurations. Requires appropriate OAuth permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/alert_grouping_settings/{id}".format(  # noqa: UP032
            id=alert_grouping_setting_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_enriched_incident_data(
    context: ToolContext,
    incident_id: Annotated[
        str, "The unique ID of the incident for which to retrieve enriched analytics and metrics."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAnalyticsIncidentsById'."]:
    """Retrieve enriched data and metrics for a specific incident.

    Use this tool to get detailed analytics and metrics for a single incident, including resolution time, engagement time, and other key metrics. Ideal for analyzing incident performance and response."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/analytics/raw/incidents/{id}".format(id=incident_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_audit_records(
    context: ToolContext,
    result_limit: Annotated[
        int | None, "Specify the maximum number of audit records to return in a single request."
    ] = None,
    next_cursor_token: Annotated[
        str | None,
        "Token to request the next set of results in a paginated query. Usually from the `next_cursor` field of the previous request.",  # noqa: E501
    ] = None,
    start_date: Annotated[
        str | None,
        "The start of the date range for searching audit records. Defaults to now() - 24 hours if not specified.",  # noqa: E501
    ] = None,
    date_range_end: Annotated[
        str | None,
        "The end date for the audit record search. Defaults to now if not provided, and must be within 31 days after the `since` date.",  # noqa: E501
    ] = None,
    filter_by_resource_type: Annotated[
        str | None,
        "Filter audit records by the specified types of resources, such as users, teams, or services.",  # noqa: E501
    ] = None,
    actor_type_filter: Annotated[
        str | None,
        "Specifies the type of actor to filter records by. Options are 'user_reference', 'api_key_reference', or 'app_reference'.",  # noqa: E501
    ] = None,
    filter_by_actor_id: Annotated[
        str | None,
        "Filter audit records by a specific Actor ID. Requires 'actor_type' to be specified.",
    ] = None,
    filter_by_method_type: Annotated[
        str | None,
        "Filter records by method type. Options are 'browser', 'oauth', 'api_token', 'identity_provider', or 'other'.",  # noqa: E501
    ] = None,
    method_truncated_token_filter: Annotated[
        str | None,
        "Filter records by a specific method truncated token. Requires 'method_type' to be provided.",  # noqa: E501
    ] = None,
    action_filter: Annotated[
        str | None,
        "Filter audit records by specified action types: 'create', 'update', or 'delete'.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAuditRecords'."]:
    """Retrieve the latest audit trail records from Pagerduty.

    This tool fetches audit trail records from Pagerduty, sorted by execution time from newest to oldest. It requires admin, account owner, or global API token access on accounts with the \"Audit Trail\" feature. Use this tool to monitor recent activities by querying these audit records."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/audit/records",
        method="GET",
        params=remove_none_values({
            "limit": result_limit,
            "cursor": next_cursor_token,
            "since": start_date,
            "until": date_range_end,
            "root_resource_types[]": filter_by_resource_type,
            "actor_type": actor_type_filter,
            "actor_id": filter_by_actor_id,
            "method_type": filter_by_method_type,
            "method_truncated_token": method_truncated_token_filter,
            "actions[]": action_filter,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_automation_actions(
    context: ToolContext,
    max_results_limit: Annotated[
        int | None, "Specifies the maximum number of automation actions to return in one request."
    ] = None,
    next_results_cursor: Annotated[
        str | None,
        "Used to request the next set of results, commonly obtained from the 'next_cursor' field of the previous response. If not provided, retrieval starts from the beginning.",  # noqa: E501
    ] = None,
    filter_by_name: Annotated[
        str | None, "Filters results by matching a case insensitive substring in the action name."
    ] = None,
    filter_by_runner_id: Annotated[
        str | None,
        "Filter results by a specific runner. Use 'any' to include only results linked to runners, excluding unlinked results.",  # noqa: E501
    ] = None,
    filter_by_classification: Annotated[
        str | None,
        "Specify 'diagnostic' or 'remediation' to filter results by classification category.",
    ] = None,
    filter_by_team_id: Annotated[
        str | None, "Filters the results to include actions associated with the given team ID."
    ] = None,
    filter_by_service_id: Annotated[
        str | None, "Filter actions to include only those associated with the specified service ID."
    ] = None,
    filter_by_action_type: Annotated[
        str | None,
        "Filter results to include actions matching specified type: 'script' or 'process_automation'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAllAutomationActions'."]:
    """Retrieve all automation actions in alphabetical order.

    Use this tool to get a list of all automation actions from Pagerduty, sorted by action name. This can be helpful for monitoring or managing automation tasks. Supports query-based filtering and cursor-based pagination."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/actions",
        method="GET",
        params=remove_none_values({
            "limit": max_results_limit,
            "cursor": next_results_cursor,
            "name": filter_by_name,
            "runner_id": filter_by_runner_id,
            "classification": filter_by_classification,
            "team_id": filter_by_team_id,
            "service_id": filter_by_service_id,
            "action_type": filter_by_action_type,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_automation_action(
    context: ToolContext,
    automation_action_id: Annotated[
        str, "The unique ID of the automation action to retrieve from Pagerduty."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAutomationAction'."]:
    """Retrieve details of a specific automation action.

    Use this tool to get information about a specific automation action in Pagerduty by providing the action ID. Ideal for checking action configurations or status."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/actions/{id}".format(  # noqa: UP032
            id=automation_action_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_automation_action(
    context: ToolContext,
    resource_id: Annotated[
        str,
        "The unique ID of the automation action to delete. It identifies which action will be removed.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteAutomationAction'."]:
    """Delete a specified automation action by ID.

    This tool deletes an automation action in PagerDuty by its ID. Use it when you need to remove an existing automation action from your configuration."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/actions/{id}".format(id=resource_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_associated_services(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier for the resource to fetch associated services."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'getAutomationActionsActionServiceAssociations'.",
]:
    """Retrieve services associated with an Automation Action.

    Use this tool to obtain all service references that are linked to a specific Automation Action identified by its ID."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/actions/{id}/services".format(  # noqa: UP032
            id=resource_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_automation_action_service_details(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier for the automation action or service resource."
    ],
    service_id: Annotated[
        str,
        "The unique identifier for the service whose automation action relationship details are needed.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getAutomationActionsActionServiceAssociation'."
]:
    """Retrieve details of a service's automation action relationship.

    This tool retrieves information about the relationship between a specific automation action and a service in Pagerduty. Use it to understand how actions are associated with services, enhancing monitoring and automation configurations."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/actions/{id}/services/{service_id}".format(  # noqa: UP032
            id=resource_id, service_id=service_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def disassociate_automation_action(
    context: ToolContext,
    resource_id: Annotated[str, "The ID of the resource to be disassociated from the service."],
    service_identifier: Annotated[
        str,
        "The unique identifier for the service from which the automation action will be disassociated.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteAutomationActionServiceAssociation'."
]:
    """Disassociate an Automation Action from a service.

    Use this tool to remove the association between an automation action and a specified service when you need to manage or update service configurations."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/actions/{id}/services/{service_id}".format(  # noqa: UP032
            id=resource_id, service_id=service_identifier
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def retrieve_action_team_associations(
    context: ToolContext,
    resource_id: Annotated[
        str, "The ID of the automation action resource to retrieve team associations for."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getAutomationActionsActionTeamAssociations'."
]:
    """Retrieve team references for an automation action.

    Use this tool to get all team references associated with a specific automation action. It helps in identifying which teams are linked to a given action within the Pagerduty system."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/actions/{id}/teams".format(  # noqa: UP032
            id=resource_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def disassociate_automation_action_from_team(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier of the resource to be disassociated. It should be a string."
    ],
    team_identifier: Annotated[
        str, "The unique identifier for the team to disassociate from the automation action."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteAutomationActionTeamAssociation'."
]:
    """Disassociate an Automation Action from a team in Pagerduty.

    Use this tool to remove the association between a specific automation action and a team in Pagerduty when changes in team management or responsibilities occur."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/actions/{id}/teams/{team_id}".format(  # noqa: UP032
            id=resource_id, team_id=team_identifier
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_action_team_association(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier for the Automation Action resource to fetch its details."
    ],
    team_id: Annotated[str, "The unique identifier for the team in Pagerduty."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getAutomationActionsActionTeamAssociation'."
]:
    """Fetch details of an Automation Action and team relationship.

    Use this tool to retrieve information about the relationship between an Automation Action and a specific team in Pagerduty."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/actions/{id}/teams/{team_id}".format(  # noqa: UP032
            id=resource_id, team_id=team_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_automation_action_invocations(
    context: ToolContext,
    invocation_state: Annotated[
        str | None,
        "Specify the current state of the invocation. Expected values: prepared, created, sent, queued, running, aborted, completed, error, unknown.",  # noqa: E501
    ] = None,
    exclude_invocation_state: Annotated[
        str | None,
        "Filter to exclude invocations not in the specified state. Accepts values like 'prepared', 'created', 'sent', etc.",  # noqa: E501
    ] = None,
    incident_identifier: Annotated[
        str | None,
        "The ID of the incident. Use this to filter actions related to a specific incident.",
    ] = None,
    automation_action_id: Annotated[
        str | None,
        "The identifier of the automation action for which invocations are being listed.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAutomationActionInvocations'."]:
    """Retrieve a list of automation action invocations.

    Use this tool to obtain a list of all recently executed automation actions. It provides insight into actions performed through the automation system."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/invocations",
        method="GET",
        params=remove_none_values({
            "invocation_state": invocation_state,
            "not_invocation_state": exclude_invocation_state,
            "incident_id": incident_identifier,
            "action_id": automation_action_id,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_automation_action_invocation(
    context: ToolContext,
    resource_id: Annotated[str, "The unique identifier for the automation action invocation."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAutomationActionsInvocation'."]:
    """Retrieve detailed information about an automation action invocation.

    This tool is used to obtain detailed information about a specific automation action invocation by ID within Pagerduty. Call this tool when you need to understand the status or outcome of a particular action."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/invocations/{id}".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_automation_action_runners(
    context: ToolContext,
    maximum_results_limit: Annotated[
        int | None,
        "Specifies the maximum number of Automation Action runners to retrieve. This is the lesser of the provided value or the API's maximum limit.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Cursor for pagination through results. Use value from `next_cursor` of previous request or omit to start from the beginning.",  # noqa: E501
    ] = None,
    filter_by_runner_name: Annotated[
        str | None,
        "Filters results to include runners with names matching the provided substring (case insensitive).",  # noqa: E501
    ] = None,
    additional_data_inclusion: Annotated[
        list[str] | None,
        "An array of strings specifying additional data elements to include in the response.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAutomationActionsRunners'."]:
    """Retrieve a list of Automation Action runners.

    This tool retrieves a list of Automation Action runners sorted by runner name in alphabetical order. It should be called when you need information about available automation runners from Pagerduty."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/runners",
        method="GET",
        params=remove_none_values({
            "limit": maximum_results_limit,
            "cursor": pagination_cursor,
            "name": filter_by_runner_name,
            "include[]": additional_data_inclusion,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def fetch_automation_action_runner(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier of the automation action runner to fetch details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAutomationActionsRunner'."]:
    """Retrieve details of an Automation Action runner by ID.

    Call this tool to get detailed information about a specific automation action runner using its ID."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/runners/{id}".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_automation_action_runner(
    context: ToolContext,
    automation_action_runner_id: Annotated[
        str, "The unique identifier for the Automation Action runner to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteAutomationActionsRunner'."]:
    """Delete an Automation Action runner by ID.

    Use this tool to delete an Automation Action runner in Pagerduty. It should be called when you need to remove an existing runner by specifying its ID."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/runners/{id}".format(  # noqa: UP032
            id=automation_action_runner_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_runner_team_associations(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier of the runner resource to retrieve associated team references."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getAutomationActionsRunnerTeamAssociations'."
]:
    """Retrieve team associations for a specific runner.

    This tool retrieves all team references associated with a specific automation actions runner in Pagerduty. It should be called when you need to find out which teams are linked to a particular runner."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/runners/{id}/teams".format(  # noqa: UP032
            id=resource_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def disassociate_runner_from_team(
    context: ToolContext,
    runner_resource_id: Annotated[
        str, "The unique ID of the runner resource to be disassociated from the team."
    ],
    team_id: Annotated[str, "The ID of the team to disassociate the runner from."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteAutomationActionsRunnerTeamAssociation'."
]:
    """Disassociates a runner from a team in Pagerduty.

    This tool removes the association between a specified runner and a team in Pagerduty's automation actions. Use it to manage runner and team assignments efficiently."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/runners/{id}/teams/{team_id}".format(  # noqa: UP032
            id=runner_resource_id, team_id=team_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_runner_team_association(
    context: ToolContext,
    resource_id: Annotated[str, "The unique identifier of the resource to get details for."],
    team_id: Annotated[
        str,
        "The unique identifier for the team whose runner association details are being fetched.",
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getAutomationActionsRunnerTeamAssociation'."
]:
    """Fetch details of a runner and team association on Pagerduty.

    Use this tool to obtain information about the relationship between a specific runner and a team on Pagerduty. Ideal for understanding associations and assignments between automation runners and teams."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/automation_actions/runners/{id}/teams/{team_id}".format(  # noqa: UP032
            id=resource_id, team_id=team_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_business_services(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "The maximum number of results to return per page."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset to start pagination for search results, useful for navigating through large sets of data.",  # noqa: E501
    ] = None,
    include_total_in_pagination: Annotated[
        bool | None,
        "Include the total count in pagination responses for detailed data, set to true for inclusion.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listBusinessServices'."]:
    """Retrieve a list of existing business services.

    Use this tool to retrieve information about business services that span multiple technical services and may involve various teams. Useful for gaining insights into cross-functional capabilities. Requires 'services.read' OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/business_services",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_pagination,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_business_service_details(
    context: ToolContext,
    business_service_id: Annotated[
        str, "The unique identifier of the business service to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getBusinessService'."]:
    """Retrieve details of an existing business service.

    Use this tool to get detailed information about a business service, which represents capabilities spanning multiple technical services."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/business_services/{id}".format(id=business_service_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_business_service(
    context: ToolContext,
    business_service_id: Annotated[str, "The unique identifier of the business service to delete."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteBusinessService'."]:
    """Delete an existing business service.

    Use this tool to delete a specific business service from PagerDuty. Once deleted, the service will not be accessible, and no new incidents can be created for it. Appropriate when managing services spanning multiple teams."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/business_services/{id}".format(id=business_service_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def subscribe_to_business_service(
    context: ToolContext,
    resource_id: Annotated[str, "The unique identifier of the business service to subscribe to."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'createBusinessServiceAccountSubscription'."
]:
    """Subscribe an account to a PagerDuty business service.

    Initiates a subscription for your account to a specified PagerDuty business service, requiring the 'subscribers.write' permission scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/business_services/{id}/account_subscription".format(  # noqa: UP032
            id=resource_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def unsubscribe_from_business_service(
    context: ToolContext,
    resource_id: Annotated[
        str,
        "The ID of the resource to unsubscribe from. This identifies the specific business service in Pagerduty.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'removeBusinessServiceAccountSubscription'."
]:
    """Unsubscribe an account from a business service.

    This tool is used to remove an account's subscription from a specified business service in Pagerduty. It should be called when you want to unsubscribe your account. Ensure the necessary OAuth permissions (`subscribers.write`) are in place."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/business_services/{id}/account_subscription".format(  # noqa: UP032
            id=resource_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_business_service_subscribers(
    context: ToolContext,
    business_service_id: Annotated[
        str, "The ID of the business service to retrieve subscribers for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getBusinessServiceSubscribers'."]:
    """Retrieve subscribers of a business service.

    Fetches a list of users subscribed for notifications on a specified business service. Ensure users are added through the appropriate POST method to be available via this endpoint. This requires OAuth scope 'subscribers.read'."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/business_services/{id}/subscribers".format(  # noqa: UP032
            id=business_service_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_supporting_service_impacts(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier of the business service to retrieve supporting impacts for."
    ],
    include_additional_fields: Annotated[
        str | None,
        "Specify additional fields like highest impacting priority or total impacted count to be included in the response.",  # noqa: E501
    ] = None,
    resource_ids: Annotated[
        str | None,
        "A list of resource IDs to get impact information about specific business services.",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getBusinessServiceSupportingServiceImpacts'."
]:
    """Retrieve supporting business services sorted by impact level.

    Use this tool to get the most impacted business services supporting a given business service, up to a limit of 200. The services are sorted by impact, recent impact, and name."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/business_services/{id}/supporting_services/impacts".format(  # noqa: UP032
            id=resource_id
        ),
        method="GET",
        params=remove_none_values({
            "additional_fields[]": include_additional_fields,
            "ids[]": resource_ids,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_top_level_business_service_impactors(
    context: ToolContext,
    business_service_ids: Annotated[
        str | None,
        "A list of IDs for the specific business services to retrieve impactors for. This filters the impactors to those affecting these services.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getBusinessServiceTopLevelImpactors'."
]:
    """Retrieve high-priority impactors for top-level business services.

    This tool retrieves a list of the highest priority impactors, such as incidents, for top-level business services. Impactors are returned in order of priority and creation date, supporting up to 200 entries. Use when needing details on significant impactors affecting business services."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/business_services/impactors",
        method="GET",
        params=remove_none_values({"ids[]": business_service_ids}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_business_service_impacts(
    context: ToolContext,
    include_additional_fields: Annotated[
        str | None,
        "Specify additional fields to include, like highest impacting priority or total impacted count. Options: 'services.highest_impacting_priority', 'total_impacted_count'.",  # noqa: E501
    ] = None,
    specific_business_service_ids: Annotated[
        str | None,
        "List of specific Business Service IDs to retrieve impact information for. Use this to target particular services.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getBusinessServiceImpacts'."]:
    """Retrieve top business services by impact with status included.

    Fetch a list of top-level business services sorted by highest impact, including status. Useful for identifying the most affected services up to a limit of 200. Use the 'ids[]' parameter to get information on specific services. Requires 'services.read' OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/business_services/impacts",
        method="GET",
        params=remove_none_values({
            "additional_fields[]": include_additional_fields,
            "ids[]": specific_business_service_ids,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_priority_thresholds(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getBusinessServicePriorityThresholds'."
]:
    """Retrieve priority threshold information for an account.

    Fetches the global priority threshold to determine which incidents impact business services. Useful for understanding incident impacts based on set priorities."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/business_services/priority_thresholds",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def clear_priority_thresholds(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteBusinessServicePriorityThresholds'."
]:
    """Clears the priority thresholds for business services.

    Use this tool to clear the priority threshold for an account, allowing any incident with a priority to impact business services."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/business_services/priority_thresholds",
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_change_events(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "The number of results to display per page of the response."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset to start pagination in search results. Use this to skip a specified number of records.",  # noqa: E501
    ] = None,
    team_ids: Annotated[
        list[str] | None,
        "An array of team IDs. Only results related to these teams will be returned. Account must have the 'teams' ability.",  # noqa: E501
    ] = None,
    integration_ids: Annotated[
        list[str] | None,
        "An array of integration IDs to filter results. Only events related to these integrations will be returned.",  # noqa: E501
    ] = None,
    start_date_utc_iso: Annotated[
        str | None,
        "The start of the date range for the search in UTC ISO 8601 format. Must be UTC datetime.",
    ] = None,
    end_date_utc: Annotated[
        str | None,
        "The end of the date range for search, in UTC ISO 8601 format. Non-UTC datetimes will return HTTP 400.",  # noqa: E501
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to include the total number of change events in the response. This may increase response time.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listChangeEvents'."]:
    """Retrieve a list of existing change events from Pagerduty.

    This tool retrieves all existing change events from Pagerduty. It should be called when users need to view or manage change events in their system. It requires 'change_events.read' permission."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/change_events",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "team_ids[]": team_ids,
            "integration_ids[]": integration_ids,
            "since": start_date_utc_iso,
            "until": end_date_utc,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def send_change_event(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createChangeEvent'."]:
    """Send change events to Pagerduty's Events API.

    Use this tool to log or send change events to Pagerduty's Events API. It should be called whenever a change event needs to be recorded in Pagerduty's system."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/change_events",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_change_event_details(
    context: ToolContext,
    resource_id: Annotated[str, "The unique ID of the change event to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getChangeEvent'."]:
    """Retrieve details about a specific change event.

    Use this tool to obtain detailed information about an existing change event. Ideal for monitoring changes or audits."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/change_events/{id}".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_escalation_policies(
    context: ToolContext,
    results_per_page: Annotated[
        int | None,
        "Specifies the number of escalation policy results returned per page. Used for pagination.",
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "The starting point for pagination in the search results. Specify an integer to skip past a number of elements.",  # noqa: E501
    ] = None,
    filter_by_name: Annotated[
        str | None, "Filters results to include only records with names matching the query."
    ] = None,
    filter_by_user_ids: Annotated[
        list[str] | None,
        "Array of user IDs to filter escalation policies where these users are targets.",
    ] = None,
    filter_by_team_ids: Annotated[
        list[str] | None,
        "An array of team IDs to filter results. Only returns policies for specified teams. Requires `teams` ability.",  # noqa: E501
    ] = None,
    additional_models_to_include: Annotated[
        str | None,
        "Array specifying additional models ('services', 'teams', 'targets') to include in response.",  # noqa: E501
    ] = None,
    sort_results_by: Annotated[
        str | None,
        "Specify the field to sort the results on, such as 'name', 'name:asc', or 'name:desc'.",
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to include the total field in pagination responses, showing the total number of entries.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listEscalationPolicies'."]:
    """Retrieve all existing escalation policies for alerts.

    This tool retrieves a list of all escalation policies, which define alert notifications for users over time. It requires scope authorization for access."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/escalation_policies",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "query": filter_by_name,
            "user_ids[]": filter_by_user_ids,
            "team_ids[]": filter_by_team_ids,
            "include[]": additional_models_to_include,
            "sort_by": sort_results_by,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_escalation_policy_info(
    context: ToolContext,
    resource_id: Annotated[str, "The unique identifier for the escalation policy resource."],
    additional_models_to_include: Annotated[
        str | None,
        "Array of additional models to include in the escalation policy response. Options are 'services', 'teams', or 'targets'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getEscalationPolicy'."]:
    """Retrieve details of an escalation policy and its rules.

    Use this tool to get information about a specific escalation policy, which defines alerting rules for users. Useful for understanding who is alerted and when in your Pagerduty setup."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/escalation_policies/{id}".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"include[]": additional_models_to_include}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_escalation_policy(
    context: ToolContext,
    resource_id: Annotated[
        str,
        "The ID of the escalation policy to be deleted. Ensure it is not in use before proceeding.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteEscalationPolicy'."]:
    """Delete an existing escalation policy.

    Remove an existing escalation policy and its rules. Ensure the policy is not in use by any services before attempting deletion. Requires appropriate OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/escalation_policies/{id}".format(id=resource_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_escalation_policy_audit_records(
    context: ToolContext,
    resource_id: Annotated[str, "The ID of the escalation policy to retrieve audit records for."],
    result_limit: Annotated[
        int | None,
        "Specify the maximum number of audit records to return, capped by the API's maximum limit.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Optional string to request the next set of results. Use the `next_cursor` from the previous response to continue paging.",  # noqa: E501
    ] = None,
    start_date_range: Annotated[
        str | None,
        "The start date for the search range. Defaults to the past 24 hours if not specified. Format as YYYY-MM-DD.",  # noqa: E501
    ] = None,
    end_date_range_for_search: Annotated[
        str | None,
        "End of the date range for searching audit records. Defaults to current date if unspecified. Max 31 days after start.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listEscalationPolicyAuditRecords'."
]:
    """Retrieve audit records for an escalation policy.

    Call this tool to get audit records related to a specific escalation policy, sorted by execution time from newest to oldest. Useful for tracking changes and actions on escalation policies."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/escalation_policies/{id}/audit/records".format(  # noqa: UP032
            id=resource_id
        ),
        method="GET",
        params=remove_none_values({
            "limit": result_limit,
            "cursor": pagination_cursor,
            "since": start_date_range,
            "until": end_date_range_for_search,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_global_event_orchestrations(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "The number of results to display per page in the response."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "The starting point for pagination in search results. Specify the number of initial records to skip.",  # noqa: E501
    ] = None,
    sort_by_field: Annotated[
        str | None,
        "Specify the field and order to sort results. Options: name, routes, created_at with asc or desc.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listEventOrchestrations'."]:
    """Retrieve all Global Event Orchestrations on an account.

    Use this tool to obtain a list of Global Event Orchestrations from a Pagerduty account. Global Event Orchestrations help manage and route events based on predefined rules. This tool is useful when you need to analyze or modify orchestration configurations."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "sort_by": sort_by_field,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_global_event_orchestration(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str, "The unique ID of the Global Event Orchestration to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOrchestration'."]:
    """Fetch details of a Global Event Orchestration by ID.

    Retrieves information about a Global Event Orchestration, including Global Rules and Router Rules applied to events. Useful for understanding event routing and actions based on orchestration settings."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}".format(id=event_orchestration_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_global_event_orchestration(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str, "The unique identifier of the Event Orchestration to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteOrchestration'."]:
    """Delete a Global Event Orchestration in PagerDuty.

    Use this tool to delete a Global Event Orchestration in PagerDuty. This action ceases the capability to ingest events using the Orchestration's Routing Key. Requires appropriate OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}".format(id=event_orchestration_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_event_orchestration_integrations(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str, "The unique identifier for the specific event orchestration to retrieve integrations."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listOrchestrationIntegrations'."]:
    """Retrieve integrations for an event orchestration.

    Use this tool to list all integrations associated with a specific event orchestration in PagerDuty. It enables you to retrieve routing keys used to send events. OAuth scope `event_orchestrations.read` is required."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/integrations".format(  # noqa: UP032
            id=event_orchestration_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_integration_details(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str, "The ID of an Event Orchestration to retrieve its integration details."
    ],
    integration_id: Annotated[
        str, "The unique identifier for the specific integration to retrieve details from."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOrchestrationIntegration'."]:
    """Retrieve integration details for event orchestrations.

    This tool fetches details of a specific integration associated with event orchestrations in PagerDuty using the routing key. Ideal for obtaining integration information to facilitate event handling. Requires appropriate OAuth scope for access."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/integrations/{integration_id}".format(  # noqa: UP032
            id=event_orchestration_id, integration_id=integration_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_integration_with_routing_key(
    context: ToolContext,
    event_orchestration_id: Annotated[str, "The ID of the Event Orchestration to be deleted."],
    integration_identifier: Annotated[
        str, "The unique identifier for the PagerDuty integration to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteOrchestrationIntegration'."]:
    """Deletes a PagerDuty integration and its routing key.

    Use this tool to delete an integration in PagerDuty along with its associated routing key. This operation ensures that no future events are sent to PagerDuty using the obsolete routing key. Requires appropriate OAuth scope ('event_orchestrations.write')."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/integrations/{integration_id}".format(  # noqa: UP032
            id=event_orchestration_id, integration_id=integration_identifier
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_global_orchestration_rules(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str,
        "The unique identifier for an Event Orchestration, required to fetch its global orchestration rules.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOrchPathGlobal'."]:
    """Fetch the Global Orchestration Rules for Event Processing.

    Use this tool to obtain the global orchestration rules for a specific event orchestration. Useful for understanding how events are processed and modified globally. OAuth with 'event_orchestrations.read' is required."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/global".format(  # noqa: UP032
            id=event_orchestration_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_orchestration_routing_rules(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str, "The unique identifier for the Event Orchestration to retrieve routing rules."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOrchPathRouter'."]:
    """Retrieve routing rules for a Global Orchestration.

    Use this tool to obtain the set of Event Rules in a Global Orchestration Router. It evaluates and routes events to a specific service based on matching rules or defaults to an 'Unrouted' service."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/router".format(  # noqa: UP032
            id=event_orchestration_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_unrouted_event_rules(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str, "The unique identifier for an Event Orchestration to fetch unrouted event rules."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOrchPathUnrouted'."]:
    """Retrieve rules for unrouted events in a global orchestration.

    This tool fetches the rules for handling events that do not match any route in a Global Event Orchestration's Router. It evaluates events against its rules, beginning with the 'start' set, and facilitates further processing."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/unrouted".format(  # noqa: UP032
            id=event_orchestration_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_service_orchestration(
    context: ToolContext,
    service_identifier: Annotated[
        str, "The unique ID of the service for which orchestration details are to be retrieved."
    ],
    include_models: Annotated[
        str | None,
        "An array of additional models like 'migrated_metadata' to include in the response.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOrchPathService'."]:
    """Retrieve orchestration rules for a specific service.

    This tool retrieves the orchestration rules set for a specific service in Pagerduty. It evaluates events against these rules to modify, enhance, or route them. Useful for understanding event processing and service automation configurations."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/services/{service_id}".format(  # noqa: UP032
            service_id=service_identifier
        ),
        method="GET",
        params=remove_none_values({"include[]": include_models}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_service_orchestration_status(
    context: ToolContext,
    service_id: Annotated[str, "The unique identifier for the service you want to query."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOrchActiveStatus'."]:
    """Retrieve a service orchestration's active status.

    Use this tool to determine if a service orchestration is currently active, indicating if an event will be evaluated against a service orchestration path or ruleset. Useful for monitoring and managing service workflows."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/services/{service_id}/active".format(  # noqa: UP032
            service_id=service_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_cache_variables(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str,
        "The unique identifier for an Event Orchestration. Required to list the cache variables.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listCacheVarOnGlobalOrch'."]:
    """Retrieve cache variables for a global event orchestration.

    Use this tool to list cache variables associated with a global event orchestration. Cache variables store event data, which can be used in orchestration rules for conditions or actions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/cache_variables".format(  # noqa: UP032
            id=event_orchestration_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def create_cache_variable_global_event(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str,
        "The unique identifier for the Event Orchestration. This ID is used to specify which orchestration the cache variable will be created for.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createCacheVarOnGlobalOrch'."]:
    """Create a cache variable for global event orchestration.

    This tool creates a cache variable for a Global Event Orchestration in Pagerduty. It is used to store event data which can be utilized in event orchestration rules for conditions or actions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/cache_variables".format(  # noqa: UP032
            id=event_orchestration_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_global_orch_cache_variable(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str,
        "The ID of an Event Orchestration to identify which orchestration to retrieve the cache variable from.",  # noqa: E501
    ],
    cache_variable_identifier: Annotated[
        str, "The unique ID of a Cache Variable to retrieve within a Global Event Orchestration."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCacheVarOnGlobalOrch'."]:
    """Fetch a Cache Variable for a Global Event Orchestration.

    Use this tool to retrieve a specific Cache Variable within a Global Event Orchestration, which is useful for managing event data in orchestration rules for conditions or actions. Scoped OAuth with `event_orchestrations.read` is required."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/cache_variables/{cache_variable_id}".format(  # noqa: UP032
            id=event_orchestration_id, cache_variable_id=cache_variable_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def update_event_cache_variable(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str, "The unique identifier for an Event Orchestration to be updated."
    ],
    cache_variable_id: Annotated[
        str, "The ID of the Cache Variable to update for the event orchestration."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateCacheVarOnGlobalOrch'."]:
    """Update a cache variable for a global event orchestration.

    This tool updates a Cache Variable for a Global Event Orchestration in Pagerduty. Use it to store event data that can be utilized in event orchestration rules. Appropriate for conditions or actions within orchestrations. Requires OAuth permission: `event_orchestrations.write`. Useful when modifying event handling rules."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/cache_variables/{cache_variable_id}".format(  # noqa: UP032
            id=event_orchestration_id, cache_variable_id=cache_variable_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_cache_variable_event_orchestration(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str,
        "The ID of the Event Orchestration to identify which orchestration's cache variable to delete.",  # noqa: E501
    ],
    cache_variable_id: Annotated[
        str,
        "The ID of a specific Cache Variable to be deleted. Required for identifying the variable within the event orchestration.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteCacheVarOnGlobalOrch'."]:
    """Delete a cache variable for a global event orchestration.

    Use this tool to delete a cache variable associated with a global event orchestration on Pagerduty. Cache variables store event data that can be utilized in orchestration rules. Requires appropriate OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/cache_variables/{cache_variable_id}".format(  # noqa: UP032
            id=event_orchestration_id, cache_variable_id=cache_variable_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_external_data_cache_variable(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str, "The unique identifier for an Event Orchestration in Pagerduty."
    ],
    cache_variable_id: Annotated[
        str, "The ID of the cache variable to retrieve data for in the orchestration."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getExternalDataCacheVarDataOnGlobalOrch'."
]:
    """Retrieve cache variable data from a Global Orchestration.

    Use this tool to get the data of an external data type cache variable from a specified Global Orchestration in Pagerduty. This can include string, number, or boolean values stored for use in event orchestration rules. Requires appropriate OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/cache_variables/{cache_variable_id}/data".format(  # noqa: UP032
            id=event_orchestration_id, cache_variable_id=cache_variable_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def update_cache_variable_data(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str, "The unique ID of the Event Orchestration to update the cache variable for."
    ],
    cache_variable_id: Annotated[str, "The unique identifier for the Cache Variable to update."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'updateExternalDataCacheVarDataOnGlobalOrch'."
]:
    """Update cache variable data in Global Event Orchestration.

    Use this tool to update the data for an external cache variable in a Global Event Orchestration. It is useful for storing string, number, or boolean values that can be used in Event Orchestration rules. Requires `event_orchestrations.write` OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/cache_variables/{cache_variable_id}/data".format(  # noqa: UP032
            id=event_orchestration_id, cache_variable_id=cache_variable_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_external_data_cache_variable(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str,
        "The unique identifier for an Event Orchestration. Required for specifying which orchestration's cache variable to delete.",  # noqa: E501
    ],
    cache_variable_id: Annotated[
        str, "The unique identifier for the specific cache variable to be deleted."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteExternalDataCacheVarDataOnGlobalOrch'."
]:
    """Deletes data for a cache variable in Global Event Orchestration.

    Use this tool to delete data stored in an `external_data` type cache variable within a Global Event Orchestration. This is essential for managing values used in orchestration rules, such as conditions or actions. Requires scoped OAuth with `event_orchestrations.write` permission."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/cache_variables/{cache_variable_id}/data".format(  # noqa: UP032
            id=event_orchestration_id, cache_variable_id=cache_variable_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_service_event_cache_variables(
    context: ToolContext,
    service_id: Annotated[
        str, "The unique identifier for the service to retrieve cache variables."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listCacheVarOnServiceOrch'."]:
    """List cache variables for a service event orchestration.

    Use this tool to retrieve cache variables stored in a service event orchestration, which can be utilized in orchestration rules for conditions or actions. Scoped OAuth with `services.read` permission is required."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/services/{service_id}/cache_variables".format(  # noqa: UP032
            service_id=service_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def create_cache_variable_for_event(
    context: ToolContext,
    service_id: Annotated[
        str, "The unique identifier for the service where the cache variable will be created."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createCacheVarOnServiceOrch'."]:
    """Create a cache variable for service event orchestration.

    This tool creates a cache variable for storing event data on a service event orchestration. It is useful for leveraging data in event orchestration rules as part of conditions or actions. Requires 'services.write' OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/services/{service_id}/cache_variables".format(  # noqa: UP032
            service_id=service_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_service_event_cache_variable(
    context: ToolContext,
    service_id: Annotated[
        str,
        "A string representing the unique ID of the service for which the cache variable is to be retrieved.",  # noqa: E501
    ],
    cache_variable_id: Annotated[
        str, "The unique identifier for the cache variable in the service event orchestration."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCacheVarOnServiceOrch'."]:
    """Retrieve a cache variable from a service event orchestration.

    This tool retrieves a specific cache variable associated with a service event orchestration in Pagerduty. Cache variables are used to store event data and can be utilized in orchestration rules for conditions or actions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/services/{service_id}/cache_variables/{cache_variable_id}".format(  # noqa: UP032
            service_id=service_id, cache_variable_id=cache_variable_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def update_service_event_cache_variable(
    context: ToolContext,
    service_identifier: Annotated[
        str, "The unique identifier for the service whose cache variable is to be updated."
    ],
    cache_variable_id: Annotated[
        str, "The unique identifier for the cache variable you want to update."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateCacheVarOnServiceOrch'."]:
    """Update a cache variable for a service event orchestration.

    Use this tool to update cache variables within a service event orchestration on Pagerduty. Ideal for maintaining and manipulating event data to match specific orchestration rules and conditions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/services/{service_id}/cache_variables/{cache_variable_id}".format(  # noqa: UP032
            service_id=service_identifier, cache_variable_id=cache_variable_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_cache_variable(
    context: ToolContext,
    service_id: Annotated[
        str, "The unique identifier for the service related to the event orchestration."
    ],
    cache_variable_id: Annotated[
        str, "The ID of the Cache Variable to be deleted from the service event orchestration."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteCacheVarOnServiceOrch'."]:
    """Delete a cache variable from a service event orchestration.

    Use this tool to delete a Cache Variable associated with a Service Event Orchestration in PagerDuty. Cache Variables store event data and are used in orchestration rules for conditions or actions. This operation requires OAuth with 'services.write' permission."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/services/{service_id}/cache_variables/{cache_variable_id}".format(  # noqa: UP032
            service_id=service_id, cache_variable_id=cache_variable_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def retrieve_service_cache_variable(
    context: ToolContext,
    service_identifier: Annotated[
        str, "The unique identifier for the service. Required to retrieve cache variable data."
    ],
    cache_variable_id: Annotated[
        str,
        "The unique identifier for a Cache Variable. Use this to specify which external data cache variable you want to retrieve for service event orchestration.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getExternalDataCacheVarDataOnServiceOrch'."
]:
    """Retrieve data for an external cache variable in event orchestration.

    Use this tool to get data stored in an external cache variable for service event orchestration. Useful for retrieving string, number, or boolean values used in orchestration rules."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/services/{service_id}/cache_variables/{cache_variable_id}/data".format(  # noqa: UP032
            service_id=service_identifier, cache_variable_id=cache_variable_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def update_external_data_cache_variable(
    context: ToolContext,
    service_id: Annotated[str, "The unique identifier for the service to be updated."],
    cache_variable_id: Annotated[
        str, "The ID of the cache variable to be updated in the service orchestration."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'updateExternalDataCacheVarDataOnServiceOrch'."
]:
    """Update external data cache variable for a service orchestration.

    This tool updates the data for an external_data type Cache Variable on a Service Event Orchestration in Pagerduty. It allows storing string, number, or boolean values, which can be used in event orchestration rules. Use this when you need to change the cache variable data associated with a service."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/services/{service_id}/cache_variables/{cache_variable_id}/data".format(  # noqa: UP032
            service_id=service_id, cache_variable_id=cache_variable_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_service_cache_variable_data(
    context: ToolContext,
    service_id: Annotated[
        str, "The unique identifier for the service whose cache variable data will be deleted."
    ],
    cache_variable_id: Annotated[
        str, "The unique identifier for a Cache Variable in a service's event orchestration."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteExternalDataCacheVarDataOnServiceOrch'."
]:
    """Delete cache variable data for a service event orchestration.

    This tool deletes data for an `external_data` type cache variable in a service event orchestration on Pagerduty. It should be used to clear stored values that are used in conditions or actions within event orchestration rules."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/services/{service_id}/cache_variables/{cache_variable_id}/data".format(  # noqa: UP032
            service_id=service_id, cache_variable_id=cache_variable_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_event_orchestration_features(
    context: ToolContext,
    event_orchestration_id: Annotated[
        str, "The unique identifier for the Event Orchestration to retrieve feature settings for."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listEventOrchestrationFeatureEnablements'."
]:
    """Retrieve feature enablement settings for an Event Orchestration.

    This tool lists all feature enablement settings for an Event Orchestration, focusing on AIOps enablement. It's designed for accounts with the AIOps product addon. A warning will be included if the account isn't entitled to use AIOps features."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/event_orchestrations/{id}/enablements".format(  # noqa: UP032
            id=event_orchestration_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_extension_schemas(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "The number of results to display per page when listing extension schemas."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset to begin paginated search results. Provide an integer to specify the starting point in the data.",  # noqa: E501
    ] = None,
    include_total_in_pagination: Annotated[
        bool | None,
        "Set to true to include the total number of results in the pagination response. Set to false for faster response times.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listExtensionSchemas'."]:
    """Retrieve all PagerDuty extension schemas.

    Use this tool to list all extension schemas available in PagerDuty, representing different types of outbound extensions like Generic Webhook, Slack, and ServiceNow. Useful for integrating with or understanding existing extension capabilities within PagerDuty."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/extension_schemas",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_pagination,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_extension_vendor_details(
    context: ToolContext,
    extension_vendor_id: Annotated[
        str, "The unique identifier for the specific PagerDuty extension vendor."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getExtensionSchema'."]:
    """Retrieve details of a specific PagerDuty extension vendor.

    This tool fetches detailed information about a specific extension vendor in PagerDuty, such as types like Slack or ServiceNow. Use this when you need to understand the capabilities of an extension vendor."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/extension_schemas/{id}".format(id=extension_vendor_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_pagerduty_extensions(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "Specify the number of extensions to retrieve per page."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset to start pagination of search results. Use this to skip a specified number of items.",  # noqa: E501
    ] = None,
    filter_by_name_query: Annotated[
        str | None, "Filters results to show only records whose name matches the given query."
    ] = None,
    filter_by_extension_object_id: Annotated[
        str | None, "Filter results by the specific extension object's ID."
    ] = None,
    filter_by_extension_vendor_id: Annotated[
        str | None, "Filter the extensions by the ID of the extension vendor."
    ] = None,
    include_additional_details: Annotated[
        str | None,
        "Specify additional details to include, such as 'extension_objects' or 'extension_schemas'.",  # noqa: E501
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to include the total count of records in the response; otherwise, it will be null for faster response times.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listExtensions'."]:
    """Retrieve a list of existing Pagerduty extensions.

    This tool retrieves existing extensions in Pagerduty, which are representations of Extension Schema objects attached to Services. It is useful for managing or viewing integrations related to services in your Pagerduty account."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/extensions",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "query": filter_by_name_query,
            "extension_object_id": filter_by_extension_object_id,
            "extension_schema_id": filter_by_extension_vendor_id,
            "include[]": include_additional_details,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_extension_details(
    context: ToolContext,
    extension_id: Annotated[
        str, "The unique ID of the PagerDuty extension to retrieve details for."
    ],
    include_additional_details: Annotated[
        str | None,
        "Specify additional details to include in the response. Options are 'extension_schemas', 'extension_objects', and 'temporarily_disabled'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getExtension'."]:
    """Retrieve details of a PagerDuty extension by ID.

    Call this tool to get detailed information about a specific PagerDuty extension using its ID. Useful for understanding configurations and properties attached to services."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/extensions/{id}".format(id=extension_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"include[]": include_additional_details}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_extension(
    context: ToolContext,
    extension_id: Annotated[
        str,
        "The unique identifier for the extension to be deleted. This is necessary to specify which extension to remove.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteExtension'."]:
    """Delete an existing extension in Pagerduty.

    Use this tool to delete an extension in Pagerduty. Once deleted, the extension becomes inaccessible from the web UI, and new incidents can't be created for it. This is useful for cleaning up or managing extensions attached to services."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/extensions/{id}".format(id=extension_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def enable_extension(
    context: ToolContext,
    resource_id: Annotated[str, "The ID of the extension resource to enable in Pagerduty."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enableExtension'."]:
    """Enable a temporarily disabled extension in Pagerduty.

    Call this tool to enable an extension that has been temporarily disabled on Pagerduty. The extension is linked to a specific service and no request body is required. Suitable for reactivating functionalities swiftly. Requires 'extensions.write' OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/extensions/{id}/enable".format(id=resource_id),  # noqa: UP032
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_incident_workflows(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "Specify the maximum number of incident workflow results to return per page."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "The starting point for pagination of search results. Define how many items to skip before beginning to return results.",  # noqa: E501
    ] = None,
    name_filter_query: Annotated[
        str | None, "Specify a search query to filter results by matching workflow names."
    ] = None,
    include_additional_details: Annotated[
        str | None, "Specify additional details to include, such as steps or team."
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to include the total count field in pagination responses. This may affect response speed.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIncidentWorkflows'."]:
    """Retrieve all existing incident workflows.

    Use this tool to list all incident workflows in your Pagerduty account. Ideal for obtaining a comprehensive view of all workflows, including sequences of steps and triggers configured for incidents."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incident_workflows",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "query": name_filter_query,
            "include[]": include_additional_details,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_incident_workflow(
    context: ToolContext,
    resource_id: Annotated[
        str,
        "The unique identifier for the Incident Workflow you wish to retrieve. This ID is required to specify the exact workflow in Pagerduty.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getIncidentWorkflow'."]:
    """Retrieve details of an existing Incident Workflow.

    Call this tool to obtain information about a specific Incident Workflow in Pagerduty. An Incident Workflow includes a sequence of steps and triggers for automated actions related to an incident."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incident_workflows/{id}".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_incident_workflow(
    context: ToolContext,
    resource_id: Annotated[str, "The unique identifier of the incident workflow to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteIncidentWorkflow'."]:
    """Deletes an existing incident workflow by ID.

    Use this tool to delete an existing incident workflow that consists of configurable steps and triggers for incident automation. Requires the appropriate OAuth scope to perform this action."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incident_workflows/{id}".format(id=resource_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_incident_workflow_actions(
    context: ToolContext,
    limit_results: Annotated[
        int | None, "Specifies the maximum number of workflow actions to return in the response."
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Optional. Use to request the next set of results from the API. Obtained from the `next_cursor` field of the previous request.",  # noqa: E501
    ] = None,
    filter_by_keyword: Annotated[
        str | None,
        "Specify a keyword to filter actions, showing only those tagged with this keyword.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIncidentWorkflowActions'."]:
    """Retrieve a list of incident workflow actions.

    This tool is used to fetch a list of actions available in incident workflows via Pagerduty. It requires OAuth permission `incident_workflows.read` and is useful for understanding available actions within incident workflows."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incident_workflows/actions",
        method="GET",
        params=remove_none_values({
            "limit": limit_results,
            "cursor": pagination_cursor,
            "keyword": filter_by_keyword,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_incident_workflow_action(
    context: ToolContext,
    resource_id: Annotated[str, "The ID of the incident workflow action to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getIncidentWorkflowAction'."]:
    """Retrieve details of a specific incident workflow action.

    Use this tool to obtain information about a specific incident workflow action in Pagerduty. Useful for monitoring and managing incident workflows."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incident_workflows/actions/{id}".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_incident_workflow_triggers(
    context: ToolContext,
    filter_by_workflow_id: Annotated[
        str | None,
        "Filter triggers to those configured to start the specified workflow ID. Useful for listing services associated with it.",  # noqa: E501
    ] = None,
    incident_identifier: Annotated[
        str | None,
        "Filter triggers by the incident's service, if provided. Cannot be used with `service_identifier`.",  # noqa: E501
    ] = None,
    specific_service_id: Annotated[
        str | None,
        "Filter triggers for incidents in a specific service. Cannot be used with `specific_incident_id`.",  # noqa: E501
    ] = None,
    trigger_type: Annotated[
        str | None,
        "Show triggers of a specified type, such as 'manual', 'conditional', or 'incident_type'.",
    ] = None,
    filter_workflow_name_contains: Annotated[
        str | None, "Filter triggers by workflows whose names contain this substring."
    ] = None,
    sort_triggers_by: Annotated[
        str | None,
        "Specify a property to sort the triggers. Options: workflow_id, workflow_id asc, workflow_name desc, etc.",  # noqa: E501
    ] = None,
    result_limit: Annotated[
        int | None,
        "The number of incident workflow triggers to return, up to the API's maximum limit.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Optional string to request the next set of results. Use the `next_cursor` from the previous request; starts at the beginning if not provided.",  # noqa: E501
    ] = None,
    show_disabled_triggers: Annotated[
        bool | None,
        "Set to true to show disabled triggers, false to show enabled. Deprecated and will be removed soon.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIncidentWorkflowTriggers'."]:
    """Retrieve a list of existing incident workflow triggers.

    Use this tool to fetch all existing incident workflow triggers from Pagerduty. It helps in identifying available workflow triggers for automation or integration purposes."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incident_workflows/triggers",
        method="GET",
        params=remove_none_values({
            "workflow_id": filter_by_workflow_id,
            "incident_id": incident_identifier,
            "service_id": specific_service_id,
            "trigger_type": trigger_type,
            "workflow_name_contains": filter_workflow_name_contains,
            "is_disabled": show_disabled_triggers,
            "sort_by": sort_triggers_by,
            "limit": result_limit,
            "cursor": pagination_cursor,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_incident_workflow_trigger(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier for the resource to retrieve the Incident Workflows Trigger."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getIncidentWorkflowTrigger'."]:
    """Retrieve details of an existing Incident Workflows Trigger.

    Call this tool to get information about a specific Incident Workflows Trigger using its ID. Useful for accessing detailed trigger configurations or statuses in Pagerduty."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incident_workflows/triggers/{id}".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_incident_workflow_trigger(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier for the incident workflow trigger to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteIncidentWorkflowTrigger'."]:
    """Deletes an existing incident workflow trigger.

    Use this tool to delete an existing incident workflow trigger in Pagerduty. Requires the 'incident_workflows.write' OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incident_workflows/triggers/{id}".format(id=resource_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def remove_service_from_workflow_trigger(
    context: ToolContext,
    trigger_identifier: Annotated[
        str, "The unique identifier for the trigger from which the service will be removed."
    ],
    service_identifier: Annotated[
        str, "The unique identifier for the service to be removed from the workflow trigger."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteServiceFromIncidentWorkflowTrigger'."
]:
    """Remove a service from an incident workflow trigger.

    Use this tool to delete an existing service from a specified incident workflow trigger in Pagerduty. Typically called when you want to modify incident workflows by removing services that are no longer needed."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incident_workflows/triggers/{trigger_id}/services/{service_id}".format(  # noqa: UP032
            trigger_id=trigger_identifier, service_id=service_identifier
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_incidents(
    context: ToolContext,
    number_of_results_per_page: Annotated[
        int | None, "Specifies the number of incidents to return per page, up to a maximum of 100."
    ] = None,
    pagination_offset: Annotated[
        int | None, "Offset for pagination, indicating the starting point for search results."
    ] = None,
    ignore_date_filters: Annotated[
        str | None,
        "Set to 'all' to ignore 'since' and 'until' date filters, using all available data.",
    ] = None,
    incident_deduplication_key: Annotated[
        str | None,
        "A string representing the de-duplication key of the incident. Incidents with child alerts do not have an incident key. Use it to query incidents by matching alert keys.",  # noqa: E501
    ] = None,
    filter_by_service_ids: Annotated[
        list[str] | None,
        "List of service IDs to filter incidents. Only incidents linked to these service IDs will be returned.",  # noqa: E501
    ] = None,
    team_ids: Annotated[
        list[str] | None,
        "Array of team IDs to filter incidents. Only relevant incidents for these teams will be returned.",  # noqa: E501
    ] = None,
    assigned_user_ids: Annotated[
        list[str] | None,
        "List of user IDs to filter incidents assigned to specific users. Only incidents with statuses of triggered or acknowledged will be returned, as resolved incidents are not assigned to any user.",  # noqa: E501
    ] = None,
    urgency_filters: Annotated[
        str | None,
        "Array of urgencies to filter incidents by. Options: 'high', 'low'. Defaults to all urgencies.",  # noqa: E501
    ] = None,
    time_zone: Annotated[
        str | None,
        "Time zone for rendering results. Defaults to the account time zone if not specified.",
    ] = None,
    incident_statuses: Annotated[
        str | None,
        "Specify statuses to filter incidents: triggered, acknowledged, resolved. Allows multiple selections.",  # noqa: E501
    ] = None,
    sort_incidents_by: Annotated[
        list[str] | None,
        "Specify fields to sort incidents by, with optional direction (e.g., 'incident_number:asc'). Up to two fields allowed.",  # noqa: E501
    ] = None,
    include_additional_details: Annotated[
        str | None,
        "Specify additional details to include, such as acknowledgers, agents, or services, using predefined categories.",  # noqa: E501
    ] = None,
    start_date: Annotated[
        str | None,
        "The start of the date range for searching incidents. Maximum range is 6 months; default is 1 month.",  # noqa: E501
    ] = None,
    end_date_range: Annotated[
        str | None,
        "The end date of the search range. Maximum span is 6 months; defaults to 1 month.",
    ] = None,
    include_total_in_response: Annotated[
        bool | None, "Set to true to populate the `total` field in the pagination response."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIncidents'."]:
    """Retrieve a list of current incidents.

    This tool provides a list of existing incidents, representing problems or issues needing resolution. It should be called when detailed information on current incidents is required. This requires OAuth scope: `incidents.read`."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents",
        method="GET",
        params=remove_none_values({
            "limit": number_of_results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "date_range": ignore_date_filters,
            "incident_key": incident_deduplication_key,
            "service_ids[]": filter_by_service_ids,
            "team_ids[]": team_ids,
            "user_ids[]": assigned_user_ids,
            "urgencies[]": urgency_filters,
            "time_zone": time_zone,
            "statuses[]": incident_statuses,
            "sort_by": sort_incidents_by,
            "include[]": include_additional_details,
            "since": start_date,
            "until": end_date_range,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def retrieve_incident_detail(
    context: ToolContext,
    incident_id: Annotated[
        str, "The unique identifier or number for the incident to retrieve details."
    ],
    additional_details_to_include: Annotated[
        str | None,
        "Array of additional details to include, such as 'acknowledgers', 'agents', etc.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getIncident'."]:
    """Retrieve detailed information about a Pagerduty incident.

    This tool provides detailed information about a specific incident in Pagerduty. It can be called using either an incident ID or number. Use this to get insights into issues that need resolution. Requires 'incidents.read' OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/{id}".format(id=incident_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"include[]": additional_details_to_include}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_incident_alerts(
    context: ToolContext,
    incident_id: Annotated[str, "The unique identifier for the incident to retrieve alerts."],
    results_per_page: Annotated[
        int | None, "Specifies the number of alert results to return per page."
    ] = None,
    pagination_offset: Annotated[
        int | None, "Offset to start pagination for search results."
    ] = None,
    alert_deduplication_key: Annotated[
        str | None, "A unique key used for alert de-duplication in incident management."
    ] = None,
    alert_statuses: Annotated[
        str | None,
        "Return only alerts with the specified statuses. Accepts 'triggered' or 'resolved'.",
    ] = None,
    sort_incident_alerts: Annotated[
        str | None,
        "Specify the field (created_at/resolved_at) and direction (asc/desc) to sort alerts. Use a colon ':' to separate field and direction, and a comma ',' if using two fields.",  # noqa: E501
    ] = None,
    additional_details_to_include: Annotated[
        str | None,
        "List of additional details to include, such as 'services', 'first_trigger_log_entries', and 'incidents'.",  # noqa: E501
    ] = None,
    populate_total_field: Annotated[
        bool | None,
        "Set to true to populate the total field in pagination responses for accurate count, set to false for faster responses.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIncidentAlerts'."]:
    """Retrieve a list of alerts for a specific incident.

    Use this tool to get alerts related to a particular incident, which represents a problem requiring attention and resolution. Useful for monitoring and managing ongoing issues."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/{id}/alerts".format(id=incident_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": populate_total_field,
            "alert_key": alert_deduplication_key,
            "statuses[]": alert_statuses,
            "sort_by": sort_incident_alerts,
            "include[]": additional_details_to_include,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_incident_alert_details(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier of the alert resource to retrieve details for."
    ],
    alert_id: Annotated[str, "The ID of the alert you want to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getIncidentAlert'."]:
    """Retrieve detailed information about a specific alert.

    Use this tool to get detailed information about a specific alert using the alert ID. Useful for understanding and resolving problems associated with incidents."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/{id}/alerts/{alert_id}".format(  # noqa: UP032
            id=resource_id, alert_id=alert_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_impacted_business_services(
    context: ToolContext,
    incident_id: Annotated[
        str, "The unique identifier for the incident affecting business services."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getIncidentImpactedBusinessServices'."
]:
    """Retrieve impacted business services for an incident.

    Retrieve a list of business services that are impacted by a specific incident. This tool should be called when you need to understand the impact of an incident on various business services."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/{id}/business_services/impacts".format(  # noqa: UP032
            id=incident_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_incident_field_values(
    context: ToolContext,
    incident_id: Annotated[
        str,
        "The unique identifier of the incident to retrieve field values for. This is required for the API call.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getIncidentFieldValues'."]:
    """Retrieve custom field values for a specific incident.

    Call this tool to obtain custom field values associated with a specific incident in Pagerduty. Useful for when detailed information about incident fields is required. Requires 'incidents.read' permission."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/{id}/custom_fields/values".format(id=incident_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_incident_log_entries(
    context: ToolContext,
    incident_id: Annotated[str, "The unique ID of the incident to retrieve log entries for."],
    results_per_page: Annotated[
        int | None, "Specifies the number of log entries returned per page."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset to start pagination for search results. Use to specify the starting point for the result set.",  # noqa: E501
    ] = None,
    result_time_zone: Annotated[
        str | None,
        "Specify the time zone for the results. Defaults to the account time zone if not specified.",  # noqa: E501
    ] = None,
    start_date_for_search: Annotated[
        str | None,
        "Start date for the search range. Specify the beginning of the date range over which you want to search.",  # noqa: E501
    ] = None,
    date_range_end: Annotated[
        str | None, "The end date for the range to search log entries. Format: YYYY-MM-DDTHH:MM:SSZ"
    ] = None,
    additional_models_to_include: Annotated[
        str | None,
        "Array of additional models to include in the response, such as incidents, services, channels, or teams.",  # noqa: E501
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to populate the `total` field in pagination responses for log entries.",
    ] = None,
    return_overview_logs_only: Annotated[
        bool | None,
        "Return a subset of log entries showing only the most important changes to the incident when true.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIncidentLogEntries'."]:
    """Retrieve log entries for a specific incident.

    This tool fetches and lists log entries associated with a specific incident. Use it when you need detailed records of all events related to an incident on Pagerduty."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/{id}/log_entries".format(id=incident_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "time_zone": result_time_zone,
            "since": start_date_for_search,
            "until": date_range_end,
            "is_overview": return_overview_logs_only,
            "include[]": additional_models_to_include,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_incident_notes(
    context: ToolContext,
    incident_id: Annotated[str, "The unique ID of the incident for which to list notes."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIncidentNotes'."]:
    """Retrieve existing notes for a specified incident.

    Use this tool to obtain a list of notes related to a particular incident. This is useful for tracking comments or updates on an incident that needs resolution."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/{id}/notes".format(id=incident_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_outlier_incident_info(
    context: ToolContext,
    incident_id: Annotated[str, "The unique ID of the incident to retrieve outlier details for."],
    start_date_for_search: Annotated[
        str | None, "The start date of the range for searching outlier incidents."
    ] = None,
    additional_attributes_for_related_incidents: Annotated[
        str | None,
        "List of additional attributes for the returned related incidents. Options include 'incident'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOutlierIncident'."]:
    """Retrieve outlier incident details for a specific incident.

    Use this tool to obtain detailed information about an outlier incident associated with a specific service incident in Pagerduty. Requires scoped OAuth with `incidents.read` permission."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/{id}/outlier_incident".format(id=incident_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "since": start_date_for_search,
            "additional_details[]": additional_attributes_for_related_incidents,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def retrieve_past_incidents(
    context: ToolContext,
    resource_id: Annotated[
        str,
        "The identifier of the service or incident for which past incidents are to be retrieved.",
    ],
    results_limit: Annotated[
        int | None, "Specify the number of past incidents to be returned."
    ] = None,
    include_total_count: Annotated[
        bool | None,
        "Set to true to include the total number of past incidents in the response. Default is false for faster performance.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPastIncidents'."]:
    """Retrieve past incidents related to a specific incident.

    Use this tool to obtain a list of past incidents from the same service that share metadata with a given incident. Useful for analyzing historical incident data related to a service within the past 6 months. Requires authorization with scoped OAuth using `incidents.read`. Only available with Event Intelligence or Digital Operations plans."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/{id}/past_incidents".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"limit": results_limit, "total": include_total_count}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_related_change_events_for_incident(
    context: ToolContext,
    incident_id: Annotated[
        str, "The unique ID of the incident for which related change events are to be retrieved."
    ],
    results_per_page: Annotated[
        int | None, "Specifies the number of change events to return per page."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIncidentRelatedChangeEvents'."]:
    """List related change events for an incident.

    Provides a list of related change events for a specified incident, along with reasons for their correlation. Useful during incident triage to understand service changes like deploys and configuration updates."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/{id}/related_change_events".format(id=incident_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"limit": results_per_page}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_recent_related_incidents(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier of the resource to fetch related incidents for."
    ],
    include_additional_incident_details: Annotated[
        str | None,
        "Indicate if additional attributes should be included for returned incidents. Valid option is 'incident'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getRelatedIncidents'."]:
    """Fetch recent related incidents impacting responders and services.

    Use this tool to obtain the 20 most recent related incidents impacting other responders and services. This is available with the Event Intelligence package or Digital Operations plan."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/{id}/related_incidents".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"additional_details[]": include_additional_incident_details}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_incident_notification_subscribers(
    context: ToolContext,
    incident_id: Annotated[
        str, "The unique identifier for the incident to retrieve its notification subscribers."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getIncidentNotificationSubscribers'."
]:
    """Retrieve subscribers for an incident's notification.

    Call this tool to get a list of notification subscribers for a specific incident. This is useful for understanding who will receive updates about the incident's status. Users must be added through the corresponding POST endpoint to be included."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/{id}/status_updates/subscribers".format(  # noqa: UP032
            id=incident_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_incident_types(
    context: ToolContext,
    filter_incident_types_by_state: Annotated[
        str | None, "Filter incident types by their enabled state: 'enabled', 'disabled', or 'all'."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIncidentTypes'."]:
    """Retrieve a list of available incident types.

    Retrieves and categorizes incidents like security, major, or fraud incidents. It can filter by enabled or disabled types, requiring 'incident_types.read' OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/types",
        method="GET",
        params=remove_none_values({"filter": filter_incident_types_by_state}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_incident_type_info(
    context: ToolContext,
    incident_type_identifier: Annotated[
        str, "The ID or name of the incident type to get detailed information about it."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getIncidentType'."]:
    """Get detailed information about a specific incident type.

    Use this tool to obtain detailed information about a single incident type by providing either its ID or name. It helps categorize incidents as security, major, or fraud-related. Requires scoped OAuth authorization with 'incident_types.read'."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/types/{type_id_or_name}".format(  # noqa: UP032
            type_id_or_name=incident_type_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_incident_custom_fields(
    context: ToolContext,
    incident_type_identifier: Annotated[
        str, "The ID or name of the incident type to retrieve custom fields for."
    ],
    include_additional_details: Annotated[
        str | None,
        "Specifies additional details to include in the response, such as 'field_options'.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIncidentTypeCustomFields'."]:
    """Retrieve custom fields for a specific incident type.

    Use this tool to list custom fields associated with a particular incident type. These fields provide additional context and support functionalities like customized filtering, search, and analytics. Useful when you need to enhance incident data with customer-specific information."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/types/{type_id_or_name}/custom_fields".format(  # noqa: UP032
            type_id_or_name=incident_type_identifier
        ),
        method="GET",
        params=remove_none_values({"include[]": include_additional_details}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_custom_field_for_incident_type(
    context: ToolContext,
    incident_type_identifier: Annotated[
        str, "The ID or name of the incident type to retrieve the custom field for."
    ],
    field_identifier: Annotated[
        str, "The unique ID of the custom field to retrieve for the incident type."
    ],
    include_field_options: Annotated[
        str | None, "Optional: Specify 'field_options' to include additional details."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getIncidentTypeCustomField'."]:
    """Retrieve a custom field for a specific incident type."""
    response = await make_request(
        url="https://api.pagerduty.com/incidents/types/{type_id_or_name}/custom_fields/{field_id}".format(  # noqa: UP032
            type_id_or_name=incident_type_identifier, field_id=field_identifier
        ),
        method="GET",
        params=remove_none_values({"include[]": include_field_options}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_incident_custom_field(
    context: ToolContext,
    incident_type_identifier: Annotated[
        str, "The ID or name of the incident type for which the custom field should be deleted."
    ],
    field_id: Annotated[
        str, "The unique identifier for the custom field to be deleted from the incident type."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteIncidentTypeCustomField'."]:
    """Delete a custom field from an incident type.

    Use this tool to remove a custom field associated with a specific incident type, allowing for updated configurations and management of incident data."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/types/{type_id_or_name}/custom_fields/{field_id}".format(  # noqa: UP032
            type_id_or_name=incident_type_identifier, field_id=field_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_custom_field_options(
    context: ToolContext,
    incident_type_id_or_name: Annotated[
        str, "The ID or name of the Incident Type to list custom field options for."
    ],
    field_identifier: Annotated[
        str, "The unique identifier for the custom field whose options are being retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIncidentTypeCustomField'."]:
    """List available options for a custom incident field.

    Use this tool to retrieve the options for a custom field associated with a specific incident type in Pagerduty. Useful for contexts requiring customized filtering, search, or analytics based on incident-specific data."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/types/{type_id_or_name}/custom_fields/{field_id}/field_options".format(  # noqa: UP032
            type_id_or_name=incident_type_id_or_name, field_id=field_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_custom_field_option_details(
    context: ToolContext,
    incident_type_identifier: Annotated[
        str,
        "The ID or name of the Incident Type for which you want to retrieve the custom field option details.",  # noqa: E501
    ],
    field_option_id: Annotated[str, "The unique ID of the field option to retrieve details for."],
    field_identifier: Annotated[str, "The unique ID of the custom field for the incident type."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getIncidentTypeCustomFieldFieldOptions'."
]:
    """Retrieve details of a specific custom field option for an incident type.

    Use this tool to get information about a specific field option in a custom field, which provides additional context to incidents in Pagerduty. Useful for customized filtering, search, and analytics. Requires `custom_fields.read` OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/types/{type_id_or_name}/custom_fields/{field_id}/field_options/{field_option_id}".format(  # noqa: UP032
            type_id_or_name=incident_type_identifier,
            field_option_id=field_option_id,
            field_id=field_identifier,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_custom_field_option(
    context: ToolContext,
    incident_type_id_or_name: Annotated[
        str, "The ID or name of the Incident Type to delete the custom field option from."
    ],
    field_option_id: Annotated[
        str, "Specify the ID of the field option to delete from the custom field."
    ],
    field_id: Annotated[
        str, "The unique identifier of the custom field associated with the incident type."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteIncidentTypeCustomFieldFieldOption'."
]:
    """Delete a field option from a custom incident field.

    Use this tool to delete a specific field option for a custom field in Pagerduty incidents. This is useful for managing custom data associated with incidents, especially when you need to update filtering, search, or analytics capabilities. Requires `custom_fields.write` OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/incidents/types/{type_id_or_name}/custom_fields/{field_id}/field_options/{field_option_id}".format(  # noqa: UP032
            type_id_or_name=incident_type_id_or_name,
            field_option_id=field_option_id,
            field_id=field_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_license_allocations(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "Specify the number of results to return per page."
    ] = None,
    pagination_offset: Annotated[
        int | None, "Offset to start pagination of search results."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listLicenseAllocations'."]:
    """Retrieve a list of user license allocations.

    Use this tool to obtain information about licenses allocated to users within your Pagerduty account. Requires appropriate OAuth scope (`licenses.read`)."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/license_allocations",
        method="GET",
        params=remove_none_values({"limit": results_per_page, "offset": pagination_offset}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_account_licenses(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listLicenses'."]:
    """Fetches licenses associated with your account.

    Use this tool to obtain a list of all licenses linked to your Pagerduty account. It requires the 'licenses.read' scope with OAuth."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/licenses",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def fetch_incident_logs(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "Specify the number of log entry results to return per page."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset value to start the pagination of search results. Used for controlling which set of results are displayed.",  # noqa: E501
    ] = None,
    render_results_in_time_zone: Annotated[
        str | None,
        "Specify the time zone for rendering results. Defaults to the account's time zone.",
    ] = None,
    start_date_range: Annotated[
        str | None,
        "The start date for the range to search incident log entries. Format as 'YYYY-MM-DD'.",
    ] = None,
    end_date_range: Annotated[
        str | None,
        "Specify the end date for the search date range. This is used to filter log entries up to a specific date.",  # noqa: E501
    ] = None,
    additional_models_to_include: Annotated[
        str | None,
        "Array of additional models such as 'incidents', 'services', 'channels', 'teams' to include in the response.",  # noqa: E501
    ] = None,
    team_ids: Annotated[
        list[str] | None,
        "An array of team IDs for filtering log entries by team. Requires 'teams' ability.",
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to populate the total field in pagination responses, showing the total number of items.",  # noqa: E501
    ] = None,
    overview_only: Annotated[
        bool | None, "Set to true to return only the most important changes to incidents."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listLogEntries'."]:
    """Retrieve all incident log entries from the account.

    This tool retrieves a comprehensive list of all log entries for incidents across the entire account. Use it to access detailed logs of events related to incidents."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/log_entries",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "time_zone": render_results_in_time_zone,
            "since": start_date_range,
            "until": end_date_range,
            "is_overview": overview_only,
            "include[]": additional_models_to_include,
            "team_ids[]": team_ids,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_incident_log_entry(
    context: ToolContext,
    incident_log_entry_id: Annotated[
        str, "The unique identifier of the incident log entry to retrieve."
    ],
    results_time_zone: Annotated[
        str | None,
        "Specify the time zone for rendering results. Defaults to the account's time zone.",
    ] = None,
    include_models: Annotated[
        str | None,
        "List of additional models to include in the response, such as incidents, services, channels, or teams.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getLogEntry'."]:
    """Retrieve details of a specific incident log entry.

    Fetch additional information about a specific incident log entry to access raw event data. This is useful for understanding all events associated with an incident."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/log_entries/{id}".format(id=incident_log_entry_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"time_zone": results_time_zone, "include[]": include_models}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_maintenance_windows(
    context: ToolContext,
    name_filter_query: Annotated[
        str | None, "Filter results to show only maintenance windows whose name matches this query."
    ] = None,
    results_per_page: Annotated[
        int | None, "The number of maintenance window results returned per page."
    ] = None,
    pagination_offset: Annotated[
        int | None, "Specifies the starting point for pagination in search results."
    ] = None,
    team_ids: Annotated[
        list[str] | None,
        "An array of team IDs to filter maintenance windows. Requires the 'teams' ability.",
    ] = None,
    service_ids: Annotated[
        list[str] | None,
        "An array of service IDs to filter results. Only maintenance windows related to these services will be included.",  # noqa: E501
    ] = None,
    include_additional_models: Annotated[
        str | None,
        "Specify additional models to include in the response. Options are 'teams', 'services', or 'users'.",  # noqa: E501
    ] = None,
    maintenance_window_state_filter: Annotated[
        str | None, "Filter maintenance windows by state: past, future, ongoing, open, or all."
    ] = None,
    include_total_count: Annotated[
        bool | None,
        "Set to true to include the total count of maintenance windows in the response, which may slow down response times.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listMaintenanceWindows'."]:
    """Retrieve existing maintenance windows with optional filters.

    Use this tool to list maintenance windows, which temporarily disable services for specific periods. You can filter the results by service, team, or by time (past, present, future)."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/maintenance_windows",
        method="GET",
        params=remove_none_values({
            "query": name_filter_query,
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_count,
            "team_ids[]": team_ids,
            "service_ids[]": service_ids,
            "include[]": include_additional_models,
            "filter": maintenance_window_state_filter,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_maintenance_window(
    context: ToolContext,
    maintenance_window_id: Annotated[
        str, "The ID of the maintenance window you want to retrieve details for."
    ],
    include_models: Annotated[
        str | None,
        "Specify additional models to include in the response. Options: 'teams', 'services', 'users'. Accepts an array of strings.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getMaintenanceWindow'."]:
    """Retrieve details of a specific maintenance window.

    Use this tool to obtain information about an existing maintenance window, which temporarily disables services for a defined period. Scoped OAuth with 'services.read' is required."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/maintenance_windows/{id}".format(id=maintenance_window_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"include[]": include_models}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_future_or_active_maintenance_window(
    context: ToolContext,
    maintenance_window_id: Annotated[
        str, "The ID of the maintenance window to be deleted or ended."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteMaintenanceWindow'."]:
    """Delete or end a future or active maintenance window.

    Use this tool to delete a maintenance window that is scheduled for the future or actively ongoing. It cannot delete maintenance windows that have already ended. Suitable for managing service disruptions temporarily."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/maintenance_windows/{id}".format(id=maintenance_window_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_notifications(
    context: ToolContext,
    start_date_range: Annotated[
        str,
        'The start date for the search range. Time is optional and format should match the "since" specification.',  # noqa: E501
    ],
    end_date: Annotated[
        str,
        "Specify the end date for the search range. Must be in the same format as the start date ('since') and within 3 months of it.",  # noqa: E501
    ],
    results_per_page: Annotated[
        int | None, "Specify the number of notification results to display per page."
    ] = None,
    pagination_offset: Annotated[
        int | None, "Offset to start pagination search results, specified as an integer."
    ] = None,
    render_results_in_time_zone: Annotated[
        str | None,
        "Time zone in which results will be rendered. Defaults to the account time zone if not specified.",  # noqa: E501
    ] = None,
    notification_type_filter: Annotated[
        str | None,
        "Filter notifications by type, such as SMS, email, phone, or push. Valid values are: sms_notification, email_notification, phone_notification, or push_notification.",  # noqa: E501
    ] = None,
    additional_details_to_include: Annotated[
        str | None, "Array of additional details to include in the response, such as 'users'."
    ] = None,
    include_total_in_response: Annotated[
        bool | None, "Set to true to populate the total field in pagination responses."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listNotifications'."]:
    """Retrieve notifications for a specified time range and type.

    Use this tool to list notifications generated when incidents are triggered or escalated. You can filter notifications by type, such as SMS, email, phone, or push notifications."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/notifications",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "time_zone": render_results_in_time_zone,
            "since": start_date_range,
            "until": end_date,
            "filter": notification_type_filter,
            "include[]": additional_details_to_include,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def revoke_oauth_delegations(
    context: ToolContext,
    user_identifier: Annotated[
        str, "The unique ID of the user whose OAuth delegations are to be revoked."
    ],
    delegation_type: Annotated[
        str,
        "Specifies OAuth delegations to target: 'mobile' or 'web'. Multiple values can be separated by commas.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteOauthDelegations'."]:
    """Revoke all OAuth delegations for specified criteria.

    This tool deletes OAuth delegations, revoking app access for users on PagerDuty. It's used when there's a need to log users out from apps or web sessions, requiring reauthorization for future access."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/oauth_delegations",
        method="DELETE",
        params=remove_none_values({"user_id": user_identifier, "type": delegation_type}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_on_call_entries(
    context: ToolContext,
    results_time_zone: Annotated[
        str | None,
        "Time zone in which results will be rendered. Defaults to the account time zone if not specified.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        int | None, "Specify the number of on-call entries to retrieve per page."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset to start pagination for search results, defining where to begin in the result set.",
    ] = None,
    additional_details_to_include: Annotated[
        str | None,
        "Array specifying additional details to include: 'escalation_policies', 'users', 'schedules'.",  # noqa: E501
    ] = None,
    filter_by_user_ids: Annotated[
        list[str] | None,
        "Filters the on-call entries to include only those for the specified user IDs.",
    ] = None,
    filter_by_escalation_policy_ids: Annotated[
        list[str] | None,
        "Array of escalation policy IDs to filter on-call entries, showing results only for specified IDs.",  # noqa: E501
    ] = None,
    filter_by_schedule_ids: Annotated[
        list[str] | None,
        "An array of schedule IDs to filter results. Include `null` to add permanent on-calls for direct user escalation targets.",  # noqa: E501
    ] = None,
    start_time_range: Annotated[
        str | None,
        "Specify the start time for the search range. Defaults to the current time. Valid entries are up to 90 days in the future.",  # noqa: E501
    ] = None,
    end_time_range: Annotated[
        str | None,
        "The end of the time range for searching on-call entries. Must be within 90 days of current time and cannot be before the start time. Defaults to current time if not specified.",  # noqa: E501
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set this to true to include the total number of on-call entries in pagination responses. This may increase response time.",  # noqa: E501
    ] = None,
    return_earliest_on_call: Annotated[
        bool | None,
        "Set to true to filter and return only the earliest on-call for each escalation policy, level, and user.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listOnCalls'."]:
    """Retrieve on-call entries within a specified time range.

    Use this tool to get on-call entries for users according to specified escalation policies and rules within a given timeframe. Useful for managing on-call schedules and understanding who is responsible during specific periods. Ensure you have the required OAuth permissions (`oncalls.read`) before calling this tool."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/oncalls",
        method="GET",
        params=remove_none_values({
            "time_zone": results_time_zone,
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "include[]": additional_details_to_include,
            "user_ids[]": filter_by_user_ids,
            "escalation_policy_ids[]": filter_by_escalation_policy_ids,
            "schedule_ids[]": filter_by_schedule_ids,
            "since": start_time_range,
            "until": end_time_range,
            "earliest": return_earliest_on_call,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def fetch_recent_paused_incident_alerts(
    context: ToolContext,
    start_date_range: Annotated[
        str | None, "The start date for the search range in ISO 8601 format (YYYY-MM-DD)."
    ] = None,
    end_date: Annotated[
        str | None,
        "Specifies the end date for the search range to look up paused incident alerts. The format should be in ISO 8601 (YYYY-MM-DD).",  # noqa: E501
    ] = None,
    filter_by_service_id: Annotated[
        str | None, "Provide a specific service ID to limit report scope to that service."
    ] = None,
    filter_by_suspension_method: Annotated[
        str | None, "Filter alerts by suspension method: 'Auto Pause' or 'Event Rules'."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPausedIncidentReportAlerts'."]:
    """Fetch recent paused and resolved incident alerts.

    This tool retrieves the five most recent alerts triggered and resolved after being paused within a specified reporting period of up to 6 months. It's available with the Event Intelligence package or Digital Operations plan."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/paused_incident_reports/alerts",
        method="GET",
        params=remove_none_values({
            "since": start_date_range,
            "until": end_date,
            "service_id": filter_by_service_id,
            "suspended_by": filter_by_suspension_method,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_paused_incident_report_counts(
    context: ToolContext,
    start_date: Annotated[
        str | None, "The start date for the search range in YYYY-MM-DD format."
    ] = None,
    end_date: Annotated[
        str | None,
        "The end date of the reporting period to search for paused incidents. Format: YYYY-MM-DD.",
    ] = None,
    filter_by_service_id: Annotated[
        str | None,
        "Specifies a filter to limit the scope of reporting to a particular service by its ID.",
    ] = None,
    filter_by_suspended_source: Annotated[
        str | None, "Filter response to alerts suspended by Auto Pause or Event Rules."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPausedIncidentReportCounts'."]:
    """Retrieve paused incident reporting counts for a specified period.

    This tool fetches reporting counts for paused incident usage within a specific reporting period, with a maximum lookback of 6 months. It is part of the Event Intelligence package or Digital Operations plan. Use this tool to assess incident management efficiency over time."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/paused_incident_reports/counts",
        method="GET",
        params=remove_none_values({
            "since": start_date,
            "until": end_date,
            "service_id": filter_by_service_id,
            "suspended_by": filter_by_suspended_source,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_incident_priorities(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "Number of incident priorities to include per page."
    ] = None,
    pagination_offset: Annotated[
        int | None, "The starting point of the paginated results to list incident priorities."
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to include the total number of items in the response. Set to false for a faster response without the total.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listPriorities'."]:
    """Retrieve a list of incident priorities by severity.

    Use this tool to fetch and organize existing priorities, representing the importance and impact of incidents, from most to least severe. Applicable for Standard and Enterprise plans on Pagerduty."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/priorities",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_pagerduty_rulesets(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "Specifies the number of rulesets to be returned per page in the result set."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "The starting point for pagination in the search results. Use to skip a number of entries.",
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to populate the total count of results in the response for pagination.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listRulesets'."]:
    """Retrieve all PagerDuty rulesets and their details.

    Use this tool to list all available rulesets in PagerDuty. Rulesets are collections of Event Rules that define actions based on event content. Note that rulesets and event rules are reaching end-of-life, and migration to Event Orchestration is recommended. OAuth with 'event_rules.read' scope is required for access."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/rulesets",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_pagerduty_ruleset(
    context: ToolContext,
    ruleset_id: Annotated[str, "The unique identifier for the PagerDuty ruleset to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getRuleset'."]:
    """Retrieve a PagerDuty ruleset for event routing.

    Use this tool to obtain details about a specific ruleset in PagerDuty, which allows you to route events and define actions based on event content. Note that rulesets and event rules are nearing end-of-life, so consider migrating to Event Orchestration for improved features."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/rulesets/{id}".format(id=ruleset_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_ruleset(
    context: ToolContext,
    ruleset_id: Annotated[str, "The unique identifier for the ruleset to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteRuleset'."]:
    """Delete a ruleset from Pagerduty.

    Use this tool to delete a specific ruleset from Pagerduty. This action will remove the ruleset, which is used to route events and apply event rules. It's recommended to migrate to Event Orchestration for enhanced functionality."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/rulesets/{id}".format(id=ruleset_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_event_rules(
    context: ToolContext,
    ruleset_id: Annotated[str, "The unique ID of the ruleset to retrieve event rules for."],
    results_per_page: Annotated[
        int | None,
        "Defines the number of event rules returned per page. Use this to control the volume of data in each response.",  # noqa: E501
    ] = None,
    pagination_offset: Annotated[
        int | None, "Offset for starting pagination of search results."
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to populate the `total` field in pagination responses, providing the total number of results.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listRulesetEventRules'."]:
    """Fetches all event rules under a specified ruleset.

    This tool retrieves all the event rules associated with a given ruleset in Pagerduty. Use it to view the actions defined for handling events. Note that rulesets and event rules will be phased out, so migrating to Event Orchestration is recommended."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/rulesets/{id}/rules".format(id=ruleset_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_event_rule_details(
    context: ToolContext,
    resource_id: Annotated[str, "The unique identifier of the resource within Pagerduty."],
    event_rule_id: Annotated[str, "The ID of the specific Event Rule to retrieve from a ruleset."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getRulesetEventRule'."]:
    """Retrieve details of a specific event rule from a ruleset.

    This tool retrieves information about a specific Event Rule within a ruleset in Pagerduty. Event Rules define actions based on event content. Use this tool to access the rule details before migrating to Event Orchestration."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/rulesets/{id}/rules/{rule_id}".format(  # noqa: UP032
            id=resource_id, rule_id=event_rule_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_event_rule(
    context: ToolContext,
    resource_id: Annotated[str, "The ID of the ruleset resource to delete the event rule from."],
    event_rule_id: Annotated[
        str, "The ID of the event rule to delete from the ruleset in Pagerduty."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteRulesetEventRule'."]:
    """Delete an event rule from a ruleset in Pagerduty.

    Use this tool to delete an existing event rule from a specified ruleset in Pagerduty. This is useful for managing and updating event routing and actions. Note: Migration to Event Orchestration is recommended for enhanced features."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/rulesets/{id}/rules/{rule_id}".format(  # noqa: UP032
            id=resource_id, rule_id=event_rule_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_on_call_schedules(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "Specify the number of results to return per page."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset to start pagination search results. Useful for navigating through a large list of schedules.",  # noqa: E501
    ] = None,
    filter_by_schedule_name: Annotated[
        str | None,
        "Filters the results to show only schedules whose name matches the provided query string.",
    ] = None,
    additional_details_to_include: Annotated[
        str | None,
        "Specify details like 'schedule_layers', 'overrides_subschedule', or 'final_schedule' to include in the response.",  # noqa: E501
    ] = None,
    results_display_time_zone: Annotated[
        str | None,
        "Time zone in which results will be presented. Defaults to the current user's or account's time zone.",  # noqa: E501
    ] = None,
    user_id_for_next_oncall: Annotated[
        str | None, "Specify a user ID to retrieve the user's next on-call information."
    ] = None,
    start_date_range: Annotated[
        str | None,
        "The start date for the schedule entries view. Defaults to two weeks before 'until' if provided.",  # noqa: E501
    ] = None,
    end_date_range: Annotated[
        str | None,
        "The end date for schedule entries display. Defaults to 2 weeks after the start if not specified.",  # noqa: E501
    ] = None,
    populate_total_field: Annotated[
        bool | None,
        "Set to true to populate the total field in pagination responses, providing the total number of entries.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSchedules'."]:
    """Retrieve a list of on-call schedules.

    Use this tool to obtain details about on-call schedules, including which users are on-call and their corresponding time periods. Useful for managing team availability and coverage."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/schedules",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": populate_total_field,
            "query": filter_by_schedule_name,
            "include[]": additional_details_to_include,
            "time_zone": results_display_time_zone,
            "include_next_oncall_for_user": user_id_for_next_oncall,
            "since": start_date_range,
            "until": end_date_range,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_schedule_info(
    context: ToolContext,
    schedule_id: Annotated[str, "The unique identifier for the schedule resource in Pagerduty."],
    time_zone_for_results: Annotated[
        str | None,
        "Specify the time zone for rendering results. Defaults to the schedule's time zone.",
    ] = None,
    start_date: Annotated[
        str | None,
        "The start date for the schedule entries. Defaults to 2 weeks before 'until' if not provided. This is optional and affects the rendered_schedule_entries fields when include[] for schedule types is used.",  # noqa: E501
    ] = None,
    end_date: Annotated[
        str | None,
        "The end of the date range to show schedule entries. Defaults to 2 weeks after the start date if not provided. Optional.",  # noqa: E501
    ] = None,
    user_id_for_next_oncall: Annotated[
        str | None, "Specify a user ID to get information about this user's next on-call schedule."
    ] = None,
    allow_overflow: Annotated[
        bool | None, "Set true to include schedule entries beyond date range bounds."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSchedule'."]:
    """Retrieve detailed schedule information from Pagerduty.

    This tool retrieves comprehensive information regarding a specific schedule from Pagerduty, including details for each schedule layer. Utilize this tool when you need to access and display schedule information. Requires schedule ID to function."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/schedules/{id}".format(id=schedule_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "time_zone": time_zone_for_results,
            "since": start_date,
            "until": end_date,
            "overflow": allow_overflow,
            "include_next_oncall_for_user": user_id_for_next_oncall,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_on_call_schedule(
    context: ToolContext,
    schedule_id: Annotated[str, "The unique identifier of the on-call schedule to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteSchedule'."]:
    """Delete an on-call schedule in PagerDuty.

    Use this tool to delete an existing on-call schedule in PagerDuty. This action is typically required when a schedule is no longer needed. Ensure the right schedule ID is provided for deletion."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/schedules/{id}".format(id=schedule_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_schedule_audit_records(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier for the schedule resource to retrieve audit records for."
    ],
    maximum_records: Annotated[
        int | None,
        "Specifies the maximum number of audit records to retrieve in one request. It is the lesser of this value or the API's maximum limit.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Optional string to request the next set of results. It starts at the beginning if not provided.",  # noqa: E501
    ] = None,
    start_date: Annotated[
        str | None,
        "The start date for the audit record search range. Defaults to 24 hours ago if not specified.",  # noqa: E501
    ] = None,
    end_date: Annotated[
        str | None,
        "The end date for the audit record search range. Defaults to now if not specified. Cannot be more than 31 days after the start date.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSchedulesAuditRecords'."]:
    """Retrieve audit records for a specific schedule.

    This tool retrieves audit records for a specific schedule in PagerDuty, sorted by execution time from newest to oldest. It requires audit_records.read permission and is useful for tracking changes or events associated with a schedule. Refer to the Pagination documentation for navigating large data sets."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/schedules/{id}/audit/records".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "limit": maximum_records,
            "cursor": pagination_cursor,
            "since": start_date,
            "until": end_date,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_schedule_overrides(
    context: ToolContext,
    start_date: Annotated[
        str, "The start date of the range for searching schedule overrides. Format: YYYY-MM-DD."
    ],
    end_date_range: Annotated[
        str,
        "The end date for the search range in 'YYYY-MM-DD' format. Specifies the last day to include in the results.",  # noqa: E501
    ],
    resource_id: Annotated[str, "The ID of the schedule resource to fetch overrides for."],
    return_only_editable_overrides: Annotated[
        bool | None,
        "Set to true to return only future editable overrides, providing only their IDs.",
    ] = None,
    allow_overflow: Annotated[
        bool | None,
        "Set to true to allow schedule entries that extend beyond the date range bounds without truncation.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listScheduleOverrides'."]:
    """Retrieve list of schedule overrides for a time range.

    Use this tool to get a list of schedule overrides for a given time range, which indicates when users are On-Call. OAuth with 'schedules.read' scope is required."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/schedules/{id}/overrides".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "since": start_date,
            "until": end_date_range,
            "editable": return_only_editable_overrides,
            "overflow": allow_overflow,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def remove_schedule_override(
    context: ToolContext,
    resource_id: Annotated[str, "The unique identifier of the schedule resource to modify."],
    schedule_override_id: Annotated[
        str,
        "The ID of the override on the schedule to be removed. This is required for identifying the specific schedule override to delete.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteScheduleOverride'."]:
    """Remove a schedule override in Pagerduty.

    This tool removes an existing schedule override in Pagerduty. It cannot remove past overrides. If the override starts before the current time and ends after, it will be truncated to the current time. Useful for managing on-call schedules."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/schedules/{id}/overrides/{override_id}".format(  # noqa: UP032
            id=resource_id, override_id=schedule_override_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_on_call_schedule_users(
    context: ToolContext,
    schedule_id: Annotated[
        str,
        "The unique identifier of the schedule to retrieve users for within the specified time range.",  # noqa: E501
    ],
    start_date_range: Annotated[
        str | None, "The start of the date range for searching users on call. Format as YYYY-MM-DD."
    ] = None,
    end_date: Annotated[
        str | None,
        "The end of the date range to search for on-call users. Format: YYYY-MM-DDTHH:MM:SSZ.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listScheduleUsers'."]:
    """Retrieve on-call users for a schedule within a time range.

    This tool lists all users on call for a specified schedule during a given time range. It is useful for retrieving information about current on-call personnel. Requires scoped OAuth with `users.read` permission."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/schedules/{id}/users".format(id=schedule_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"since": start_date_range, "until": end_date}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_business_service_dependencies(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier for the Business Service whose dependencies you want to fetch."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getBusinessServiceServiceDependencies'."
]:
    """Fetch immediate dependencies of a specified Business Service.

    This tool retrieves all immediate dependencies of a specified Business Service within Pagerduty. Business Services may involve multiple technical services and can be managed by different teams. Use this tool to understand the dependencies affecting a Business Service."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/service_dependencies/business_services/{id}".format(  # noqa: UP032
            id=resource_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_technical_service_dependencies(
    context: ToolContext,
    service_id: Annotated[
        str, "The unique ID of the technical service whose dependencies are to be retrieved."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getTechnicalServiceServiceDependencies'."
]:
    """Retrieve dependencies of a technical service.

    Use this tool to get all immediate dependencies of a specified technical service, also known as a 'service', from Pagerduty. It requires an OAuth scope of `services.read`."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/service_dependencies/technical_services/{id}".format(  # noqa: UP032
            id=service_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_services(
    context: ToolContext,
    filter_by_name: Annotated[
        str | None, "Filters services by specifying a name query to match."
    ] = None,
    results_per_page: Annotated[
        int | None, "The number of service records to retrieve per page."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset to start pagination in search results, allowing for navigation through pages.",
    ] = None,
    team_ids: Annotated[
        list[str] | None,
        "An array of team IDs. Only services related to these teams will be returned. Requires the `teams` ability.",  # noqa: E501
    ] = None,
    time_zone: Annotated[
        str | None,
        "Specify the time zone for rendering results. Defaults to the account time zone.",
    ] = None,
    sort_services_by: Annotated[
        str | None,
        "Specify the field to sort the results by. Options: 'name', 'name:asc', 'name:desc'.",
    ] = None,
    include_additional_details: Annotated[
        str | None,
        "Specify additional details to include, such as escalation policies or teams. Options are: escalation_policies, teams, integrations, auto_pause_notifications_parameters.",  # noqa: E501
    ] = None,
    filter_by_service_name: Annotated[
        str | None, "Filters results to show only services with the specified name."
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to populate the `total` field in pagination responses, enabling a complete total count.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listServices'."]:
    """Fetch a list of existing Pagerduty services.

    Use this tool to retrieve a list of services, which may represent applications, components, or teams for incident management."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services",
        method="GET",
        params=remove_none_values({
            "query": filter_by_name,
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "team_ids[]": team_ids,
            "time_zone": time_zone,
            "sort_by": sort_services_by,
            "include[]": include_additional_details,
            "name": filter_by_service_name,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_service_details(
    context: ToolContext,
    service_id: Annotated[
        str, "The unique identifier of the Pagerduty service to retrieve details for."
    ],
    include_additional_details: Annotated[
        str | None,
        "Specify which additional details to include, such as escalation policies, teams, integrations, and auto pause notifications parameters.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getService'."]:
    """Retrieve details about a Pagerduty service.

    Use this tool to get information about an existing Pagerduty service, which may represent an application, component, or team. This is useful for understanding the entities you may wish to open incidents against."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/{id}".format(id=service_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"include[]": include_additional_details}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_service(
    context: ToolContext,
    service_id: Annotated[str, "The unique ID of the service to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteService'."]:
    """Delete an existing service in Pagerduty.

    Use this tool to delete an existing service from Pagerduty. Once deleted, the service cannot be accessed through the web UI, and new incidents cannot be created for it. This is typically used for applications, components, or teams that no longer need incident tracking."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/{id}".format(id=service_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_service_audit_records(
    context: ToolContext,
    resource_id: Annotated[str, "The ID of the resource to retrieve audit records for."],
    result_limit: Annotated[
        int | None, "The maximum number of audit records to retrieve in one call."
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "An optional string parameter used to request the next set of results in a paginated API response. It should be obtained from the `next_cursor` field of the previous response, or left empty to start from the beginning.",  # noqa: E501
    ] = None,
    start_date: Annotated[
        str | None, "The start date for the search range. Defaults to 24 hours ago if not provided."
    ] = None,
    end_date_range: Annotated[
        str | None,
        "The end date for the search range. Defaults to now if not specified. Must be within 31 days after the start date.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listServiceAuditRecords'."]:
    """Retrieve a list of service audit records from Pagerduty.

    Call this tool to get audit records for a specific service in Pagerduty, useful for tracking changes or investigating issues. The records are sorted by execution time from newest to oldest, and support cursor-based pagination for large datasets."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/{id}/audit/records".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "limit": result_limit,
            "cursor": pagination_cursor,
            "since": start_date,
            "until": end_date_range,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_service_change_events(
    context: ToolContext,
    service_resource_id: Annotated[
        str,
        "The ID of the service resource to retrieve change events for. This ID is mandatory for identifying the specific service.",  # noqa: E501
    ],
    start_date_utc: Annotated[
        str | None,
        "The start of the date range to search, as a UTC ISO 8601 datetime string. Returns an error for non-UTC datetimes.",  # noqa: E501
    ] = None,
    end_date: Annotated[
        str | None,
        "The end of the date range for the search (UTC ISO 8601 datetime). Must be in UTC; non-UTC format will cause an error.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        int | None, "The number of results to display per page in the response."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset to start pagination for search results. Use this to specify the starting point for results.",  # noqa: E501
    ] = None,
    filter_by_team_ids: Annotated[
        list[str] | None,
        "An array of team IDs to filter results. Only returns data for specified teams. Requires 'teams' ability.",  # noqa: E501
    ] = None,
    integration_ids: Annotated[
        list[str] | None, "An array of integration IDs to filter events by related integrations."
    ] = None,
    include_total_in_pagination: Annotated[
        bool | None,
        "Set to true to populate the total field in pagination responses for complete result counts.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listServiceChangeEvents'."]:
    """Retrieve existing change events for a service.

    Use this tool to list all change events associated with a specified service. Typically used to monitor or audit changes within a service. Requires `services.read` OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/{id}/change_events".format(id=service_resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "since": start_date_utc,
            "until": end_date,
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_pagination,
            "team_ids[]": filter_by_team_ids,
            "integration_ids[]": integration_ids,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_service_integration_details(
    context: ToolContext,
    service_id: Annotated[str, "The ID of the service resource to retrieve integration details."],
    integration_id: Annotated[
        str,
        "The unique ID of the integration associated with a service. Required to retrieve specific integration details.",  # noqa: E501
    ],
    include_additional_details: Annotated[
        str | None, "Specify additional details to include, such as 'services' or 'vendors'."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getServiceIntegration'."]:
    """Retrieve integration details for a given service.

    Use this tool to obtain information about a specific integration associated with a service on Pagerduty. This is useful for understanding the integrations linked to applications, components, or teams for incident management."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/{id}/integrations/{integration_id}".format(  # noqa: UP032
            id=service_id, integration_id=integration_id
        ),
        method="GET",
        params=remove_none_values({"include[]": include_additional_details}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_service_event_rules(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier of the service whose event rules are to be listed."
    ],
    results_per_page: Annotated[
        int | None, "The number of results to return per page. Specify an integer value."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "The starting point for pagination in the search results. Useful for iterating over results in batches.",  # noqa: E501
    ] = None,
    include_additional_models: Annotated[
        str | None,
        "Specify additional models to include in the response, such as 'migrated_metadata'.",
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to populate the 'total' field in pagination responses. This may affect response time.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listServiceEventRules'."]:
    """Retrieve list of event rules for a specific service.

    Use this tool to obtain the event rules associated with a specific service on Pagerduty. Note that this feature will soon be deprecated, and it is recommended to migrate to Event Orchestration for enhanced functionality. This tool requires 'services.read' permission via scoped OAuth."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/{id}/rules".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "include[]": include_additional_models,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def convert_event_rules_to_orchestration(
    context: ToolContext,
    resource_id: Annotated[
        str,
        "The unique identifier of the resource to be converted. This is required for the conversion process.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'convertServiceEventRulesToEventOrchestration'."
]:
    """Convert service event rules to event orchestration rules.

    This tool converts a service's event rules into equivalent event orchestration rules, making the original rules read-only. It should be used to migrate rules before their end-of-life to utilize new orchestration features."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/{id}/rules/convert".format(id=resource_id),  # noqa: UP032
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_service_event_rule(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique ID of the Pagerduty service resource to fetch the event rule from."
    ],
    event_rule_id: Annotated[
        str, "The ID of the event rule to retrieve from the specified service."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getServiceEventRule'."]:
    """Retrieve a specific event rule from a Pagerduty service.

    This tool fetches an event rule associated with a specified service in Pagerduty. It should be called when you need detailed information about a specific rule linked to a Pagerduty service. Note that event rules and rulesets will soon be discontinued, so consider migrating to Event Orchestration for enhanced features."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/{id}/rules/{rule_id}".format(  # noqa: UP032
            id=resource_id, rule_id=event_rule_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_service_event_rule(
    context: ToolContext,
    resource_id: Annotated[
        str, "The ID of the resource from which the event rule will be deleted."
    ],
    event_rule_id: Annotated[
        str, "The unique identifier of the Event Rule to delete from a service."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteServiceEventRule'."]:
    """Delete an event rule from a service in Pagerduty.

    Use this tool to delete an event rule from a specified service within Pagerduty. This is important for managing and updating service event rules as part of migrating to Event Orchestration. Ensure you have the required OAuth access: `services.write`."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/{id}/rules/{rule_id}".format(  # noqa: UP032
            id=resource_id, rule_id=event_rule_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_service_custom_fields(
    context: ToolContext,
    include_additional_details: Annotated[
        str | None, "Specify additional details to include, such as 'field_options'."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listServiceCustomFields'."]:
    """Retrieve custom fields for PagerDuty services.

    This tool retrieves a list of custom fields available for services in PagerDuty, useful for understanding service configurations."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/custom_fields",
        method="GET",
        params=remove_none_values({"include[]": include_additional_details}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def show_service_custom_field(
    context: ToolContext,
    custom_field_id: Annotated[str, "The unique identifier for the custom field to be retrieved."],
    include_additional_details: Annotated[
        str | None, "Specifies additional details to include, such as field options."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getServiceCustomField'."]:
    """Retrieve detailed info about a custom field for a service.

    Call this tool to get detailed information about a specific custom field associated with a service. It requires the custom field ID and is intended for use cases where understanding or managing service configurations is needed."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/custom_fields/{field_id}".format(  # noqa: UP032
            field_id=custom_field_id
        ),
        method="GET",
        params=remove_none_values({"include[]": include_additional_details}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_service_custom_field(
    context: ToolContext,
    field_id: Annotated[str, "The unique identifier of the custom field to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteServiceCustomField'."]:
    """Delete a custom field from a service in PagerDuty.

    Use this tool to delete a custom field from services in PagerDuty. Requires appropriate OAuth permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/custom_fields/{field_id}".format(field_id=field_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def retrieve_field_options(
    context: ToolContext,
    field_id: Annotated[
        str,
        "The unique identifier for the custom field whose options you want to retrieve. This is required to specify which field's options should be listed.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listServiceCustomFieldOptions'."]:
    """Retrieve all options for a specified custom field.

    This tool retrieves all available options for a specified custom field in a Pagerduty service. It is useful for understanding the selectable values associated with a field. OAuth scope `custom_fields.read` is required."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/custom_fields/{field_id}/field_options".format(  # noqa: UP032
            field_id=field_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_service_custom_field_option(
    context: ToolContext,
    field_identifier: Annotated[
        str, "The unique identifier for the field whose option needs to be retrieved."
    ],
    field_option_id: Annotated[
        str, "The identifier for the specific field option to retrieve details from a service."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getServiceCustomFieldOption'."]:
    """Retrieve a specific field option for a service.

    Use this tool to get details of a custom field option for a specific field within a service in Pagerduty. It requires 'custom_fields.read' OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/custom_fields/{field_id}/field_options/{field_option_id}".format(  # noqa: UP032
            field_id=field_identifier, field_option_id=field_option_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def remove_field_option(
    context: ToolContext,
    field_identifier: Annotated[
        str, "The unique identifier of the field whose option you want to delete."
    ],
    field_option_id: Annotated[str, "The unique identifier for the field option to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteServiceCustomFieldOption'."]:
    """Delete a service custom field option in Pagerduty.

    Use this tool to delete a specific custom field option associated with a service in Pagerduty. This is useful when a field option is no longer needed or needs to be permanently removed. Ensure the necessary permissions (`custom_fields.write`) are in place."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/custom_fields/{field_id}/field_options/{field_option_id}".format(  # noqa: UP032
            field_id=field_identifier, field_option_id=field_option_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_service_custom_field_values(
    context: ToolContext,
    resource_id: Annotated[
        str, "The ID of the Pagerduty service to retrieve custom field values for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getServiceCustomFieldValues'."]:
    """Retrieve custom field values for a specified service in Pagerduty.

    Use this tool to obtain custom field values for a specific service in Pagerduty. This requires `services.read` permissions and is ideal when detailed configuration or metadata for a service is needed."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/{id}/custom_fields/values".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_service_feature_enablements(
    context: ToolContext,
    service_id: Annotated[
        str, "The unique identifier of the service to retrieve feature enablement settings for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listServiceFeatureEnablements'."]:
    """Retrieve feature enablement settings for a specific service.

    Use this tool to list all feature enablement settings for a given service in PagerDuty. Ideal for checking AIOps feature status. Returns warnings if the account isn't entitled to use AIOps features."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/services/{id}/enablements".format(id=service_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_account_standards(
    context: ToolContext,
    standard_resource_type: Annotated[
        str | None, "Specify the type of resource for standards, e.g., 'technical_service'."
    ] = None,
    active_standards_only: Annotated[
        bool | None, "Return only active standards if true; otherwise, return all standards."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listStandards'."]:
    """Retrieve all standards for a PagerDuty account.

    This tool retrieves all the standards associated with a PagerDuty account. It requires OAuth permission 'standards.read' to access the data. Call this tool when you need to obtain a list of standards configured in a PagerDuty account."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/standards",
        method="GET",
        params=remove_none_values({
            "active": active_standards_only,
            "resource_type": standard_resource_type,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_resource_standards(
    context: ToolContext,
    resource_ids: Annotated[
        list[str], "A list of resource IDs to apply the standards. Maximum of 100 items allowed."
    ],
    resource_type: Annotated[
        str,
        "Specifies the type of resource to list standards for. Use 'technical_services' to refer to technical service resources.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listResourceStandardsManyServices'."
]:
    """Retrieve standards for multiple services' resources.

    Call this tool to get a list of standards applied to a set of resources in multiple services. This is useful for understanding compliance or operational criteria across different resource types. Requires `standards.read` OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/standards/scores/{resource_type}".format(  # noqa: UP032
            resource_type=resource_type
        ),
        method="GET",
        params=remove_none_values({"ids": resource_ids}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_resource_standards(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier of the resource for which to list the standards."
    ],
    resource_type: Annotated[
        str, "The type of resource to list standards for. Accepted value: 'technical_services'."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listResourceStandards'."]:
    """Retrieve standards for a specific resource in PagerDuty.

    Use this tool to list the standards applied to a specific resource in PagerDuty. Ideal for checking compliance or reviewing standard applications. Requires `standards.read` permission."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/standards/scores/{resource_type}/{id}".format(  # noqa: UP032
            id=resource_id, resource_type=resource_type
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_status_dashboards(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listStatusDashboards'."]:
    """Retrieve all custom status dashboard views.

    Use this tool to get all custom Status Dashboard views associated with your Pagerduty account. It requires appropriate OAuth permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_dashboards",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_status_dashboard_by_id(
    context: ToolContext,
    dashboard_id: Annotated[str, "The unique PagerDuty ID of the status dashboard to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getStatusDashboardById'."]:
    """Retrieve a status dashboard using its PagerDuty ID.

    Use this tool to get detailed information about a specific status dashboard by supplying the PagerDuty ID. Requires the `status_dashboards.read` OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_dashboards/{id}".format(id=dashboard_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_impacted_services_by_dashboard_id(
    context: ToolContext,
    dashboard_id: Annotated[
        str, "The unique identifier for the Status Dashboard to fetch impacted services."
    ],
    include_additional_fields: Annotated[
        str | None,
        "Specify additional fields to include, such as highest impacting priority or total impacted count.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getStatusDashboardServiceImpactsById'."
]:
    """Retrieve impacted Business Services for a specific Dashboard.

    Use this tool to get the most impacted Business Services for a specified Status Dashboard. It returns up to 200 services, sorted by impact, recency, and name. Ideal for identifying major service impacts quickly."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_dashboards/{id}/service_impacts".format(  # noqa: UP032
            id=dashboard_id
        ),
        method="GET",
        params=remove_none_values({"additional_fields[]": include_additional_fields}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_status_dashboard(
    context: ToolContext,
    status_dashboard_url_slug: Annotated[
        str,
        "The human-readable URL slug for the status dashboard, typically a dash-separated string.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getStatusDashboardByUrlSlug'."]:
    """Retrieve a status dashboard using its URL slug.

    Fetch a custom Status Dashboard from PagerDuty using a human-readable URL slug, which is typically a dash-separated string. This tool should be called when you need to access the status of specific dashboards created or modified in the UI."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_dashboards/url_slugs/{url_slug}".format(  # noqa: UP032
            url_slug=status_dashboard_url_slug
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_service_impacts_by_url_slug(
    context: ToolContext,
    status_dashboard_url_slug: Annotated[
        str,
        "The URL slug for the status dashboard to identify and retrieve impacted business services.",  # noqa: E501
    ],
    include_additional_fields: Annotated[
        str | None,
        "Specify additional fields like highest impacting priority or total impacted count for business services.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getStatusDashboardServiceImpactsByUrlSlug'."
]:
    """Retrieve impacted business services by dashboard URL slug.

    Fetches the most impacted business services based on a given status dashboard `url_slug`, providing insights up to a limit of 200."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_dashboards/url_slugs/{url_slug}/service_impacts".format(  # noqa: UP032
            url_slug=status_dashboard_url_slug
        ),
        method="GET",
        params=remove_none_values({"additional_fields[]": include_additional_fields}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_status_pages(
    context: ToolContext,
    status_page_type: Annotated[
        str | None, "Specifies if the status page is 'public' or 'private'."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listStatusPages'."]:
    """Retrieve a list of status pages from PagerDuty.

    Use this tool to obtain a list of available status pages from PagerDuty. This requires `status_pages.read` permission through Scoped OAuth."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages",
        method="GET",
        params=remove_none_values({"status_page_type": status_page_type}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_status_page_impacts(
    context: ToolContext,
    status_page_id: Annotated[
        str, "The unique identifier of the status page to retrieve impacts for."
    ],
    filter_by_post_type: Annotated[
        str | None,
        "Specify the type of post to filter impacts by, such as 'incident' or 'maintenance'.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listStatusPageImpacts'."]:
    """Retrieve impacts for a specific status page by ID.

    Call this tool to obtain a list of impacts for a status page identified by its ID. It requires the 'status_pages.read' scope for OAuth authentication."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/impacts".format(id=status_page_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"post_type": filter_by_post_type}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_status_page_impact(
    context: ToolContext,
    status_page_id: Annotated[str, "The unique identifier for the status page resource."],
    status_page_impact_id: Annotated[
        str,
        "The unique identifier for the impact on the status page. Required to retrieve specific impact details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getStatusPageImpact'."]:
    """Retrieve impact details for a specific status page using IDs.

    This tool retrieves the impact details for a specific status page identified by the status page ID and impact ID. It should be called when detailed information about an impact on a status page is needed."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/impacts/{impact_id}".format(  # noqa: UP032
            id=status_page_id, impact_id=status_page_impact_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_status_page_services(
    context: ToolContext,
    status_page_id: Annotated[
        str, "The unique identifier for the status page whose services you want to list."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listStatusPageServices'."]:
    """Retrieve a list of services for a specific status page.

    Use this tool to get details of all services associated with a status page by providing the status page ID. Requires appropriate OAuth permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/services".format(id=status_page_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_status_page_service(
    context: ToolContext,
    resource_id: Annotated[str, "The ID of the status page resource to retrieve the service from."],
    status_page_service_id: Annotated[str, "The unique ID of the Status Page service to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getStatusPageService'."]:
    """Retrieve service details for a specific status page.

    This tool retrieves the details of a specific service on a status page using the Status Page ID and Service ID. Use it to obtain current service information displayed on a status page."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/services/{service_id}".format(  # noqa: UP032
            id=resource_id, service_id=status_page_service_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_status_page_severities(
    context: ToolContext,
    status_page_id: Annotated[
        str, "The unique identifier for the status page to retrieve severities for."
    ],
    filter_by_post_type: Annotated[
        str | None, "Specify the type of post to filter by: 'incident' or 'maintenance'."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listStatusPageSeverities'."]:
    """Retrieve severities for a specified status page.

    Use this tool to obtain a list of severities associated with a particular status page by providing its ID. This requires appropriate OAuth permissions (`status_pages.read`)."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/severities".format(id=status_page_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"post_type": filter_by_post_type}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_status_page_severity(
    context: ToolContext,
    status_page_id: Annotated[str, "The ID of the status page to retrieve severity details for."],
    severity_id: Annotated[
        str,
        "The ID of the specific severity for the status page. Use this to retrieve severity details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getStatusPageSeverity'."]:
    """Retrieve severity details for a status page by ID.

    Use this tool to get detailed information about a specific severity level for a status page using the status page ID and severity ID. Useful for monitoring and response teams to understand the impact level of issues."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/severities/{severity_id}".format(  # noqa: UP032
            id=status_page_id, severity_id=severity_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_status_page_statuses(
    context: ToolContext,
    status_page_id: Annotated[str, "The ID of the status page to retrieve statuses for."],
    filter_by_post_type: Annotated[
        str | None,
        "Specify the type of post to filter the statuses, such as 'incident' or 'maintenance'.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listStatusPageStatuses'."]:
    """List statuses for a status page by ID.

    Call this tool to retrieve the statuses of a specific status page using its ID. Useful for monitoring and managing page status updates."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/statuses".format(id=status_page_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"post_type": filter_by_post_type}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_status_page_status(
    context: ToolContext,
    status_page_id: Annotated[str, "The ID of the status page resource to retrieve status for."],
    status_page_status_id: Annotated[
        str, "Provide the ID of the Status Page status to retrieve its current status."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getStatusPageStatus'."]:
    """Retrieve the status of a specific status page.

    Use this tool to get the current status of a status page by providing the Status Page ID and Status ID. This is helpful for monitoring the status of services or systems."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/statuses/{status_id}".format(  # noqa: UP032
            id=status_page_id, status_id=status_page_status_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_status_page_posts(
    context: ToolContext,
    resource_id: Annotated[
        str,
        "The ID of the status page to retrieve posts from. This is required to identify the specific page.",  # noqa: E501
    ],
    filter_by_post_type: Annotated[
        str | None,
        "Specifies the post type to filter results, such as 'incident' or 'maintenance'.",
    ] = None,
    filter_reviewed_status: Annotated[
        str | None,
        "Specify the reviewed status of the posts to retrieve, such as 'approved' or 'not_reviewed'.",  # noqa: E501
    ] = None,
    status_identifiers: Annotated[
        list[str] | None,
        "Array of status identifiers to filter posts by. Use to narrow down to specific statuses.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listStatusPagePosts'."]:
    """Retrieve posts for a specific status page.

    Use this tool to list all posts associated with a specific status page by providing its ID. This is useful for monitoring updates or changes communicated through the status page."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/posts".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "post_type": filter_by_post_type,
            "reviewed_status": filter_reviewed_status,
            "status[]": status_identifiers,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_status_page_post(
    context: ToolContext,
    status_page_id: Annotated[
        str, "The unique identifier of the status page to retrieve the post from."
    ],
    status_page_post_id: Annotated[
        str, "The unique identifier for the specific status page post to retrieve."
    ],
    include_models: Annotated[
        list[str] | None,
        "Array of additional models to include in the response. Add model names as needed.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getStatusPagePost'."]:
    """Retrieve a post from a status page using page and post IDs.

    Call this tool to get information about a specific post on a status page using the status page ID and the post ID. Useful for obtaining updates or details about incidents or announcements."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/posts/{post_id}".format(  # noqa: UP032
            id=status_page_id, post_id=status_page_post_id
        ),
        method="GET",
        params=remove_none_values({"include[]": include_models}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_status_page_post(
    context: ToolContext,
    status_page_id: Annotated[
        str, "The ID of the status page from which the post will be deleted."
    ],
    status_page_post_id: Annotated[str, "The unique ID of the Status Page Post to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteStatusPagePost'."]:
    """Delete a post from a status page by ID.

    This tool deletes a specific post from a status page using the Status Page ID and Post ID. It requires appropriate OAuth authentication with `status_pages.write` scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/posts/{post_id}".format(  # noqa: UP032
            id=status_page_id, post_id=status_page_post_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_status_page_post_updates(
    context: ToolContext,
    status_page_id: Annotated[
        str, "The ID of the status page resource to retrieve post updates from."
    ],
    status_page_post_id: Annotated[
        str,
        "The unique identifier for a specific post on the status page. Used to fetch related post updates.",  # noqa: E501
    ],
    filter_by_reviewed_status: Annotated[
        str | None, "Filter post updates by their reviewed status ('approved' or 'not_reviewed')."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listStatusPagePostUpdates'."]:
    """Retrieve updates for a specific status page post.

    This tool fetches post updates for a given status page by specifying the status page ID and post ID. It should be called when you need detailed updates or changes for a specific post on a status page."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/posts/{post_id}/post_updates".format(  # noqa: UP032
            id=status_page_id, post_id=status_page_post_id
        ),
        method="GET",
        params=remove_none_values({"reviewed_status": filter_by_reviewed_status}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_post_update(
    context: ToolContext,
    resource_id: Annotated[str, "The unique ID of the resource to retrieve the post update."],
    status_page_post_id: Annotated[
        str, "The unique ID of the Status Page Post to retrieve the update for."
    ],
    status_page_post_update_id: Annotated[
        str, "The ID of the Status Page Post Update to be retrieved from Pagerduty."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPostUpdate'."]:
    """Retrieve a specific post update by post and update ID.

    Fetch a post update for a post using the post ID and post update ID on Pagerduty."""
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/posts/{post_id}/post_updates/{post_update_id}".format(  # noqa: UP032
            id=resource_id, post_id=status_page_post_id, post_update_id=status_page_post_update_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_status_page_post_update(
    context: ToolContext,
    resource_id: Annotated[str, "The unique identifier for the resource to be deleted."],
    status_page_post_id: Annotated[
        str, "The ID of the Status Page Post to identify which post's update will be deleted."
    ],
    status_page_post_update_id: Annotated[
        str, "The ID of the specific Status Page Post Update to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteStatusPagePostUpdate'."]:
    """Deletes a specific post update from a status page.

    Use this tool to delete a specific post update from a status page by providing the relevant IDs. This action requires appropriate permissions (`status_pages.write`)."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/posts/{post_id}/post_updates/{post_update_id}".format(  # noqa: UP032
            id=resource_id, post_id=status_page_post_id, post_update_id=status_page_post_update_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_postmortem_report(
    context: ToolContext,
    resource_id: Annotated[str, "The unique ID of the resource to retrieve the postmortem report."],
    status_page_post_id: Annotated[
        str, "The unique identifier of the Status Page Post to retrieve the postmortem details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPostmortem'."]:
    """Retrieve postmortem details using a specific post ID.

    This tool fetches the postmortem report for a given post ID from Pagerduty's status pages. It's useful for obtaining detailed insights after incidents. Requires status_pages.read OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/posts/{post_id}/postmortem".format(  # noqa: UP032
            id=resource_id, post_id=status_page_post_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_postmortem(
    context: ToolContext,
    resource_id: Annotated[str, "The unique ID of the resource to delete the postmortem from."],
    status_page_post_id: Annotated[
        str, "The ID of the specific Status Page Post to delete the postmortem from."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteStatusPagePostmortem'."]:
    """Delete a postmortem from a Pagerduty status page post.

    This tool deletes a postmortem associated with a specific post on a Pagerduty status page using the post ID. It requires appropriate OAuth scope permissions to execute."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/posts/{post_id}/postmortem".format(  # noqa: UP032
            id=resource_id, post_id=status_page_post_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_status_page_subscriptions(
    context: ToolContext,
    status_page_id: Annotated[str, "The ID of the status page to retrieve subscriptions for."],
    subscription_status_filter: Annotated[
        str | None, "Filter subscriptions by status: 'active' or 'pending'."
    ] = None,
    subscription_channel_filter: Annotated[
        str | None,
        "Filter subscriptions by channel type. Accepted values: 'webhook', 'email', 'slack'.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listStatusPageSubscriptions'."]:
    """Retrieve subscriptions for a specific status page using its ID."""
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/subscriptions".format(id=status_page_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "status": subscription_status_filter,
            "channel": subscription_channel_filter,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_status_page_subscription(
    context: ToolContext,
    status_page_id: Annotated[str, "The unique identifier for the Status Page resource."],
    status_page_subscription_id: Annotated[
        str, "The ID of the Status Page subscription to be retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getStatusPageSubscription'."]:
    """Retrieve a subscription from a Status Page using IDs.

    Use this tool to retrieve details of a subscription on a specific Status Page by providing the Status Page ID and Subscription ID. Appropriate for monitoring status page subscriptions or checking specific subscription details."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/subscriptions/{subscription_id}".format(  # noqa: UP032
            id=status_page_id, subscription_id=status_page_subscription_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_status_page_subscription(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier for the status page resource that needs subscription deletion."
    ],
    status_page_subscription_id: Annotated[
        str, "The ID of the Status Page subscription to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteStatusPageSubscription'."]:
    """Delete a subscription for a status page by ID.

    Use this tool to delete a subscription from a status page using the status page ID and subscription ID. This should be called when you need to remove user subscriptions from specific status pages."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/status_pages/{id}/subscriptions/{subscription_id}".format(  # noqa: UP032
            id=resource_id, subscription_id=status_page_subscription_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_account_tags(
    context: ToolContext,
    results_per_page: Annotated[int | None, "The number of tag results to return per page."] = None,
    pagination_offset: Annotated[
        int | None, "Offset index from where to start returning paginated search results."
    ] = None,
    label_filter: Annotated[
        str | None, "Filter results to show only tags with labels matching the specified query."
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to include the total count in the pagination response, otherwise it will remain null for faster responses.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listTags'."]:
    """Retrieve all tags for your Pagerduty account.

    This tool fetches all tags from your Pagerduty account, which can be used to filter escalation policies, teams, or users. Use this tool when you need a complete list of tags associated with your account."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/tags",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "query": label_filter,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_existing_tag_details(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier of the tag resource to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTag'."]:
    """Retrieve details of an existing tag in Pagerduty.

    Use this tool to get information about a specific tag that is applied to Escalation Policies, Teams, or Users in Pagerduty."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/tags/{id}".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def remove_pagerduty_tag(
    context: ToolContext,
    resource_id: Annotated[
        str, "The ID of the Pagerduty resource from which the tag will be removed."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteTag'."]:
    """Remove an existing tag from Pagerduty entities.

    This tool removes a specified tag from Escalation Policies, Teams, or Users in Pagerduty. It is useful for managing tags that are used to filter these entities. Requires appropriate OAuth scope (`tags.write`)."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/tags/{id}".format(id=resource_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_related_entities_by_tag(
    context: ToolContext,
    resource_id: Annotated[
        str,
        "The identifier for the resource (user, team, or escalation policy) to retrieve related entities by tag.",  # noqa: E501
    ],
    entity_type: Annotated[
        str,
        "Specifies the type of entity related with the tag, such as users, teams, or escalation policies.",  # noqa: E501
    ],
    results_per_page: Annotated[
        int | None,
        "Specify the number of results to return per page when retrieving entities by tag.",
    ] = None,
    pagination_offset: Annotated[
        int | None, "Offset to start pagination of search results, specifying where to begin."
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to include the total count of results in pagination responses. This may increase response time.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTagsByEntityType'."]:
    """Retrieve related users, teams, or escalation policies by tag.

    Utilize this tool to get users, teams, or escalation policies that are associated with a specific tag. Tags are applied to filter these entities for better organization and management."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/tags/{id}/{entity_type}".format(  # noqa: UP032
            id=resource_id, entity_type=entity_type
        ),
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_pagerduty_teams(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "Specify the number of results to be displayed per page."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset to start pagination of search results. Specify an integer value to skip a number of results.",  # noqa: E501
    ] = None,
    search_query: Annotated[
        str | None, "Filter the teams to list only those whose names match the search query."
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to populate the total field in pagination responses. This toggles total count retrieval for results.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listTeams'."]:
    """Retrieve teams from your PagerDuty account.

    Use this tool to list all teams within your PagerDuty account. Teams consist of users and escalation policies representing groups within an organization. You can also apply a search filter. Requires 'teams.read' OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/teams",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "query": search_query,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_team_details(
    context: ToolContext,
    team_id: Annotated[str, "The ID of the team resource to retrieve details for."],
    include_additional_models: Annotated[
        str | None, "Specifies additional models to include in the response, such as 'privileges'."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTeam'."]:
    """Retrieve details about a specific team.

    This tool retrieves details about an existing team in Pagerduty. Teams are collections of users and escalation policies representing groups within an organization. Use this tool to obtain information about a specific team by providing the team ID."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/teams/{id}".format(id=team_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"include[]": include_additional_models}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_existing_team(
    context: ToolContext,
    team_id: Annotated[str, "The unique identifier for the team to be deleted."],
    reassignment_team_id: Annotated[
        str | None,
        "The ID of the team to which unresolved incidents will be reassigned. If omitted, incidents become account-level.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteTeam'."]:
    """Delete an existing team in Pagerduty.

    Use this tool to delete a team in Pagerduty, provided the team has no associated Escalation Policies, Services, Schedules, or Subteams. Unresolved incidents will be reassigned or become account-level. Note that the incident reassignment process is asynchronous."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/teams/{id}".format(id=team_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({"reassignment_team": reassignment_team_id}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_team_audit_records(
    context: ToolContext,
    team_id: Annotated[str, "The unique identifier for the team to retrieve audit records for."],
    records_limit: Annotated[
        int | None,
        "Specify the maximum number of audit records to return. This should be the lesser of the requested limit or the maximum allowed by the API.",  # noqa: E501
    ] = None,
    next_result_cursor: Annotated[
        str | None,
        "The cursor to retrieve the next set of results, usually obtained from `next_cursor` of the previous request. If not provided, starts from the beginning.",  # noqa: E501
    ] = None,
    start_date: Annotated[
        str | None,
        "The start date for the audit record search. Defaults to 24 hours ago if not specified.",
    ] = None,
    end_date: Annotated[
        str | None,
        "The end of the date range for searching audit records. Defaults to the current date if not specified. Must be within 31 days of the start date.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listTeamsAuditRecords'."]:
    """Retrieve audit records for a specific team.

    Use this tool to get a list of audit records for a specified team, sorted by execution time from newest to oldest. Useful for tracking changes or actions within a team. Requires proper OAuth scope for access."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/teams/{id}/audit/records".format(id=team_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "limit": records_limit,
            "cursor": next_result_cursor,
            "since": start_date,
            "until": end_date,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def remove_team_escalation_policy(
    context: ToolContext,
    resource_id: Annotated[str, "The ID of the team resource to modify."],
    escalation_policy_id: Annotated[
        str,
        "The ID of the escalation policy to be removed from the team. It should be provided as a string.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteTeamEscalationPolicy'."]:
    """Remove an escalation policy from a specified team in PagerDuty.

    Use this tool to delete a specific escalation policy from a given team within PagerDuty. This operation modifies the team's configured escalation policies and requires appropriate OAuth permissions (`teams.write`)."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/teams/{id}/escalation_policies/{escalation_policy_id}".format(  # noqa: UP032
            id=resource_id, escalation_policy_id=escalation_policy_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def add_escalation_policy_to_team(
    context: ToolContext,
    team_id: Annotated[
        str, "The unique identifier for the team to which the escalation policy will be added."
    ],
    escalation_policy_id: Annotated[str, "The ID of the escalation policy to add to the team."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateTeamEscalationPolicy'."]:
    """Add an escalation policy to a team in Pagerduty.

    Use this tool to add an escalation policy to a specified team within an organization using Pagerduty. Requires `teams.write` permission for OAuth."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/teams/{id}/escalation_policies/{escalation_policy_id}".format(  # noqa: UP032
            id=team_id, escalation_policy_id=escalation_policy_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_team_members(
    context: ToolContext,
    team_id: Annotated[str, "The unique identifier of the team whose members are being retrieved."],
    results_per_page: Annotated[
        int | None, "Specify the number of results to return per page."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "The starting point for pagination in search results. Useful for navigating through large sets of data.",  # noqa: E501
    ] = None,
    include_additional_models: Annotated[
        str | None, "Include additional models such as 'users' in the response."
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to populate the total number of results in the response, enhancing pagination metrics.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listTeamUsers'."]:
    """Retrieve details of members in a specific team.

    This tool fetches information about the members of a specific team, which includes users and escalation policies within an organization. It should be used when you need to access the list of users associated with a team. Requires OAuth scope: `teams.read`."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/teams/{id}/members".format(id=team_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "include[]": include_additional_models,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_team_notification_subscriptions(
    context: ToolContext,
    team_id: Annotated[
        str,
        "The unique identifier of the team whose notification subscriptions are to be retrieved.",
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getTeamNotificationSubscriptions'."
]:
    """Retrieve a team's notification subscriptions.

    Call this tool to get the list of notification subscriptions for a specified team in Pagerduty. It requires that teams have been added through the appropriate POST request. OAuth scope needed: `subscribers.read`."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/teams/{id}/notification_subscriptions".format(id=team_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def remove_user_from_team(
    context: ToolContext,
    resource_id: Annotated[str, "The ID of the team from which the user will be removed."],
    user_id_on_team: Annotated[
        str,
        "The ID of the user to be removed from the team. This identifies the specific team member.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteTeamUser'."]:
    """Remove a user from a specific team.

    Call this tool to remove a user from a team. Useful for managing team membership by deleting users who are no longer required in a specific team. Requires appropriate OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/teams/{id}/users/{user_id}".format(  # noqa: UP032
            id=resource_id, user_id=user_id_on_team
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_all_templates(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "The number of results to return per page. Use to control pagination."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset index to start pagination in search results. This is used to navigate through paginated results efficiently.",  # noqa: E501
    ] = None,
    template_search_query: Annotated[
        str | None, "Template name or description to search within the account's templates."
    ] = None,
    filter_by_template_type: Annotated[
        str | None,
        "Filters the templates by their type. Provide the type of template you want to retrieve.",
    ] = None,
    sort_templates_by: Annotated[
        str | None,
        "Specifies the field and direction to sort results, such as 'name' or 'created_at'. Defaults to ascending order if not specified.",  # noqa: E501
    ] = None,
    include_total_in_pagination: Annotated[
        bool | None,
        "Set to true to include the total field in pagination responses for detailed counts.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTemplates'."]:
    """Retrieve all templates from a Pagerduty account.

    This tool retrieves a list of all the templates available in a Pagerduty account. It should be called when you need to access or manage template information in the account. Scoped OAuth with `templates.read` is required."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/templates",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_pagination,
            "query": template_search_query,
            "template_type": filter_by_template_type,
            "sort_by": sort_templates_by,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_template_details(
    context: ToolContext,
    template_id: Annotated[str, "The ID of the Pagerduty template to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTemplate'."]:
    """Retrieve details of a specific Pagerduty template.

    Use this tool to get detailed information about a single template in your Pagerduty account. It requires the 'templates.read' permission."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/templates/{id}".format(id=template_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_template(
    context: ToolContext,
    template_id: Annotated[str, "The unique identifier for the template to delete."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteTemplate'."]:
    """Delete a specific template from the account.

    Call this tool to delete a specific template from a Pagerduty account. Ensure that the necessary permissions (`templates.write`) are in place before attempting this operation."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/templates/{id}".format(id=template_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_template_fields(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTemplateFields'."]:
    """Retrieve fields for account templates in Pagerduty.

    Use this tool to get a list of fields that can be utilized on the account templates. It requires the `templates.read` OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/templates/fields",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_pagerduty_users(
    context: ToolContext,
    user_name_filter: Annotated[
        str | None,
        "Filter results to show only users whose names match this query. Use a string to specify the filter.",  # noqa: E501
    ] = None,
    team_ids: Annotated[
        list[str] | None, "Array of team IDs to filter results. Requires 'teams' ability."
    ] = None,
    results_per_page: Annotated[
        int | None, "The number of user records to return per page of results."
    ] = None,
    pagination_offset_start: Annotated[
        int | None,
        "Offset to start pagination search results. Use this to skip a specified number of results when retrieving the list of users.",  # noqa: E501
    ] = None,
    include_additional_models: Annotated[
        str | None,
        "Array specifying which additional models to include in the response, such as 'contact_methods', 'notification_rules', 'teams', or 'subdomains'.",  # noqa: E501
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to include the total count of records in the response. This may slow down response time.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listUsers'."]:
    """Retrieve a list of users from your PagerDuty account.

    Use this tool to get a list of users in your PagerDuty account. You can optionally filter users by a search query. This is useful for managing account members and their interactions with Incidents and other data."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users",
        method="GET",
        params=remove_none_values({
            "query": user_name_filter,
            "team_ids[]": team_ids,
            "limit": results_per_page,
            "offset": pagination_offset_start,
            "total": include_total_in_response,
            "include[]": include_additional_models,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_user_details(
    context: ToolContext,
    user_id: Annotated[str, "The unique ID of the PagerDuty user to retrieve details for."],
    include_models: Annotated[
        str | None,
        "Specify additional models to include in the response. Options: 'contact_methods', 'notification_rules', 'teams', 'subdomains'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUser'."]:
    """Retrieve detailed information about a PagerDuty user.

    Use this tool to obtain detailed information about a specific user in a PagerDuty account. It provides insights into the user's ability to interact with incidents and other data on the account. This tool requires 'users.read' permission to access the user's information."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}".format(id=user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"include[]": include_models}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def remove_existing_user(
    context: ToolContext,
    user_id: Annotated[str, "The unique ID of the user to be removed from the Pagerduty account."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteUser'."]:
    """Delete a user from the Pagerduty account.

    This tool removes an existing user from a Pagerduty account. It should be called when you want to delete a user. Note that it returns a 400 error if the user has assigned incidents unless your pricing plan supports the 'offboarding' feature and it's configured appropriately. The incidents reassignment process is asynchronous and may not complete before the API call returns."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}".format(id=user_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_user_audit_records(
    context: ToolContext,
    user_id: Annotated[str, "The unique ID of the user whose audit records you want to retrieve."],
    result_limit: Annotated[
        int | None,
        "Defines the maximum number of audit records to retrieve per request. The request will return up to this number of records, or fewer if the result set is smaller.",  # noqa: E501
    ] = None,
    next_results_cursor: Annotated[
        str | None,
        "Cursor for the next set of results. Use the `next_cursor` from the previous request to continue paging.",  # noqa: E501
    ] = None,
    start_date: Annotated[
        str | None,
        "The start of the date range for the audit record search. Defaults to 24 hours ago if not specified.",  # noqa: E501
    ] = None,
    end_date: Annotated[
        str | None,
        "Specify the end date for the search range. Defaults to now; cannot exceed 31 days beyond the 'since' date.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listUsersAuditRecords'."]:
    """Retrieve audit records for a specified user from Pagerduty.

    This tool fetches audit records related to specific changes made to a user in Pagerduty. The records are sorted by execution time and provide insights into user-related changes. Use this tool when you need to review or audit user modifications. It requires appropriate OAuth permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/audit/records".format(id=user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "limit": result_limit,
            "cursor": next_results_cursor,
            "since": start_date,
            "until": end_date,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_user_contact_methods(
    context: ToolContext,
    user_id: Annotated[
        str, "The unique identifier for the PagerDuty user to retrieve contact methods for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserContactMethods'."]:
    """Retrieves contact methods for a specific PagerDuty user.

    Use this tool to obtain the contact methods associated with a PagerDuty user. This is useful for managing or displaying user contact preferences in incident management processes."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/contact_methods".format(id=user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_user_contact_method(
    context: ToolContext,
    user_id: Annotated[
        str, "The unique identifier for the user whose contact method details are being retrieved."
    ],
    contact_method_id: Annotated[
        str, "The unique identifier for a user's contact method in Pagerduty."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserContactMethod'."]:
    """Retrieve details about a user's contact method.

    Call this tool to obtain information on a specific contact method for a user in a PagerDuty account. Useful for managing or verifying user contact details."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/contact_methods/{contact_method_id}".format(  # noqa: UP032
            id=user_id, contact_method_id=contact_method_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def remove_user_contact_method(
    context: ToolContext,
    user_resource_id: Annotated[str, "The unique ID of the user resource in PagerDuty."],
    contact_method_id: Annotated[
        str, "The ID of the contact method to be removed from the user's profile in PagerDuty."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteUserContactMethod'."]:
    """Removes a user's contact method in PagerDuty.

    Use this tool to remove a specific contact method from a user's profile in PagerDuty. Useful when managing users' contact preferences."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/contact_methods/{contact_method_id}".format(  # noqa: UP032
            id=user_resource_id, contact_method_id=contact_method_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_user_license(
    context: ToolContext,
    user_id: Annotated[
        str, "The unique identifier for the user whose license information is being retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserLicense'."]:
    """Retrieve the license allocated to a Pagerduty user.

    Use this tool to get detailed information about the license assigned to a specific user on Pagerduty. Useful for managing user permissions and account settings."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/license".format(id=user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_user_notification_rules(
    context: ToolContext,
    user_id: Annotated[
        str,
        "The unique identifier of the PagerDuty user whose notification rules are being retrieved.",
    ],
    include_additional_details: Annotated[
        str | None, "Specify additional details to include, such as 'contact_methods'."
    ] = None,
    incident_urgency: Annotated[
        str | None,
        "The urgency level for applying notification rules. Options: 'high', 'low', 'all'. Defaults to 'high'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserNotificationRules'."]:
    """Retrieve notification rules for a PagerDuty user.

    This tool retrieves the list of notification rules for a specified PagerDuty user, allowing you to see how notifications are configured. Use it to manage or review user notifications."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/notification_rules".format(id=user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "include[]": include_additional_details,
            "urgency": incident_urgency,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_user_notification_rule(
    context: ToolContext,
    user_id: Annotated[
        str, "The unique identifier for the user whose notification rule is being accessed."
    ],
    notification_rule_id: Annotated[str, "The ID of the notification rule for the specific user."],
    include_additional_details: Annotated[
        str | None, "Specify additional details to include, such as 'contact_methods'."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserNotificationRule'."]:
    """Retrieve details of a user's notification rule from PagerDuty.

    This tool retrieves information about a specific user's notification rule in PagerDuty. It is useful for understanding how a user is notified about incidents. Ensure you have the appropriate OAuth scope: `users:contact_methods.read`."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/notification_rules/{notification_rule_id}".format(  # noqa: UP032
            id=user_id, notification_rule_id=notification_rule_id
        ),
        method="GET",
        params=remove_none_values({"include[]": include_additional_details}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def remove_user_notification_rule(
    context: ToolContext,
    resource_id: Annotated[
        str, "The ID of the PagerDuty user whose notification rule is to be deleted."
    ],
    notification_rule_id: Annotated[
        str,
        "The ID of the notification rule to be removed for the user. This is required to specify which rule to delete.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteUserNotificationRule'."]:
    """Remove a notification rule for a PagerDuty user.

    Call this tool to delete a specific notification rule associated with a user in a PagerDuty account. This is useful when a user's notification preferences need to be updated or maintained. Ensure the required OAuth scope is available: `users:contact_methods.write`."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/notification_rules/{notification_rule_id}".format(  # noqa: UP032
            id=resource_id, notification_rule_id=notification_rule_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_user_notification_subscriptions(
    context: ToolContext,
    user_resource_id: Annotated[
        str,
        "The unique identifier for the user whose notification subscriptions are being retrieved.",
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getUserNotificationSubscriptions'."
]:
    """Retrieve a user's notification subscriptions.

    Get a list of notification subscriptions for a specific user. Use when you need to know which notifications a user is subscribed to. Requires the user to be previously added via `POST /users/{id}/notification_subscriptions`. Scoped OAuth with `subscribers.read` is necessary."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/notification_subscriptions".format(  # noqa: UP032
            id=user_resource_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_user_handoff_notification_rules(
    context: ToolContext,
    user_id: Annotated[
        str, "Specify the ID of the PagerDuty user to retrieve their handoff notification rules."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserHandoffNotificationRules'."]:
    """Retrieve handoff notification rules for a PagerDuty user.

    This tool retrieves the handoff notification rules for a specified user in PagerDuty. It's useful for understanding how a user is notified during on-call handoffs. Requires 'users.read' OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/oncall_handoff_notification_rules".format(  # noqa: UP032
            id=user_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_user_handoff_notification_rule(
    context: ToolContext,
    user_id: Annotated[
        str,
        "The unique identifier of the user resource in Pagerduty whose handoff notification rule details are being retrieved.",  # noqa: E501
    ],
    handoff_notification_rule_id: Annotated[
        str, "The ID of the user's oncall handoff notification rule to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserHandoffNotifiactionRule'."]:
    """Retrieve a user's handoff notification rule details.

    This tool retrieves details about a specific user's handoff notification rule in a PagerDuty account. It should be called when you need to access information about how users are notified during handoffs. Requires appropriate user permissions to read data."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/oncall_handoff_notification_rules/{oncall_handoff_notification_rule_id}".format(  # noqa: UP032
            id=user_id, oncall_handoff_notification_rule_id=handoff_notification_rule_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def remove_user_handoff_notification_rule(
    context: ToolContext,
    user_resource_id: Annotated[
        str,
        "The ID of the user resource to identify which users notification rule is being removed.",
    ],
    oncall_handoff_notification_rule_id: Annotated[
        str, "The ID of the oncall handoff notification rule to be removed for the user."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteUserHandoffNotificationRule'."
]:
    """Remove a user's handoff notification rule on PagerDuty.

    This tool removes a specified user's handoff notification rule in a PagerDuty account. It should be called when you need to delete a user's notification rule for on-call handoffs. OAuth scope 'users.write' is required for this operation."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/oncall_handoff_notification_rules/{oncall_handoff_notification_rule_id}".format(  # noqa: UP032
            id=user_resource_id,
            oncall_handoff_notification_rule_id=oncall_handoff_notification_rule_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_active_user_sessions(
    context: ToolContext,
    user_id: Annotated[
        str, "The unique ID of the PagerDuty user whose active sessions you want to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserSessions'."]:
    """Retrieve active PagerDuty user sessions.

    This tool fetches active sessions for a specific PagerDuty user, excluding newly issued OAuth tokens. It's useful for monitoring user activity and requires OAuth with `users:sessions.read` scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/sessions".format(id=user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_user_session_details(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier for the resource to retrieve session details."
    ],
    session_type: Annotated[
        str,
        "Specifies the session type for the user session ID. Expect a string value indicating the type.",  # noqa: E501
    ],
    user_session_id: Annotated[
        str, "The unique session ID for the PagerDuty user session to retrieve details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserSession'."]:
    """Retrieve details about a specific PagerDuty user session.

    This tool is used to get information about a user's session in PagerDuty. It does not include OAuth tokens issued after November 2021. Users are members of a PagerDuty account who can interact with account data, including incidents. Ensure appropriate OAuth scopes (`users:sessions.read`) are set."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/sessions/{type}/{session_id}".format(  # noqa: UP032
            id=resource_id, type=session_type, session_id=user_session_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_user_status_update_rules(
    context: ToolContext,
    user_id: Annotated[
        str,
        "The ID of the PagerDuty user whose status update notification rules you want to retrieve.",
    ],
    include_additional_details: Annotated[
        str | None, "Specify additional details to include, such as 'contact_methods'."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getUserStatusUpdateNotificationRules'."
]:
    """List a user's status update notification rules on PagerDuty.

    Use this tool to retrieve the status update notification rules for a specific user in PagerDuty. Useful for managing or reviewing how users are notified about incidents. Requires 'users.read' OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/status_update_notification_rules".format(  # noqa: UP032
            id=user_id
        ),
        method="GET",
        params=remove_none_values({"include[]": include_additional_details}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def create_user_status_update_notification_rule(
    context: ToolContext,
    user_resource_id: Annotated[
        str, "The ID of the user resource for which the notification rule should be created."
    ],
    status_update_notification_rule: Annotated[
        dict[str, dict[str, dict[str, str]]] | None,
        "JSON object defining the status update notification rule. Must include contact method details.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'createUserStatusUpdateNotificationRule'."
]:
    """Creates a user's status update notification rule on PagerDuty.

    This tool is used to create a new status update notification rule for a user on PagerDuty. It should be called when there's a need to set up notifications for user status updates. This action requires appropriate OAuth permissions ('users.write')."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/status_update_notification_rules".format(  # noqa: UP032
            id=user_resource_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({"requestBody": status_update_notification_rule}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_user_status_update_notification_rule(
    context: ToolContext,
    resource_id: Annotated[str, "The unique identifier of the user resource in PagerDuty."],
    status_update_notification_rule_id: Annotated[
        str, "The ID of the user's status update notification rule to retrieve details for."
    ],
    include_additional_details: Annotated[
        str | None,
        "Specify details to include, such as contact methods. Use values like 'contact_methods'.",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getUserStatusUpdateNotificationRule'."
]:
    """Retrieve a user's status update notification rule details.

    This tool retrieves specific details about a user's status update notification rule in PagerDuty. It is useful for understanding how a user is notified about status updates. OAuth permission 'users.read' is required."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/status_update_notification_rules/{status_update_notification_rule_id}".format(  # noqa: UP032
            id=resource_id, status_update_notification_rule_id=status_update_notification_rule_id
        ),
        method="GET",
        params=remove_none_values({"include[]": include_additional_details}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_user_notification_rule(
    context: ToolContext,
    user_id: Annotated[
        str, "The unique identifier of the user whose notification rule is to be deleted."
    ],
    status_update_notification_rule_id: Annotated[
        str, "The ID of the status update notification rule to be removed for the user."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteUserStatusUpdateNotificationRule'."
]:
    """Remove a user's status update notification rule.

    This tool removes a specific status update notification rule for a user on PagerDuty. It is used when you want to delete a notification rule to stop receiving updates for incidents. Requires appropriate permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/{id}/status_update_notification_rules/{status_update_notification_rule_id}".format(  # noqa: UP032
            id=user_id, status_update_notification_rule_id=status_update_notification_rule_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_current_user_details(
    context: ToolContext,
    include_additional_models: Annotated[
        str | None,
        "Specify additional models to include in the response, such as contact methods, notification rules, teams, or subdomains.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCurrentUser'."]:
    """Retrieve details of the current Pagerduty user.

    This tool fetches detailed information about the currently authenticated user in Pagerduty. It should be called when user-specific information is needed, such as user profile details and interactions within the Pagerduty system."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/users/me",
        method="GET",
        params=remove_none_values({"include[]": include_additional_models}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_vendors(
    context: ToolContext,
    results_per_page: Annotated[
        int | None, "The number of vendor results to return per page."
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset to start pagination for search results, indicating the number of initial items to skip.",  # noqa: E501
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to `true` to populate the `total` field in pagination responses, otherwise it remains `null` to optimize response time.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listVendors'."]:
    """Retrieve a list of all PagerDuty vendors.

    This tool is used to retrieve a list of all vendors available in PagerDuty, representing specific types of integrations such as AWS Cloudwatch, Splunk, and Datadog. Useful for users needing to know available integration options."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/vendors",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_vendor_details(
    context: ToolContext,
    vendor_id: Annotated[str, "The unique identifier for the vendor integration to be retrieved."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getVendor'."]:
    """Get details about a specific vendor integration.

    Use this tool to retrieve detailed information about a specific PagerDuty vendor integration. A vendor in PagerDuty represents a specific type of integration, such as AWS Cloudwatch, Splunk, or Datadog. This tool is particularly useful for understanding integration capabilities and requirements. Requires 'vendors.read' OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/vendors/{id}".format(id=vendor_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_webhook_subscriptions(
    context: ToolContext,
    results_per_page: Annotated[int | None, "The number of results to display per page."] = None,
    pagination_offset: Annotated[int | None, "Offset to start pagination search results."] = None,
    resource_filter_type: Annotated[
        str | None, "Specify the type of resource to filter: 'account', 'service', or 'team'."
    ] = None,
    resource_filter_id: Annotated[
        str | None, "The ID of the resource to filter by, required if filtering by service or team."
    ] = None,
    include_total_in_response: Annotated[
        bool | None,
        "Set to true to include the total number of results in the response, which might affect response times.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listWebhookSubscriptions'."]:
    """Retrieve existing webhook subscriptions from Pagerduty.

    Use this tool to list all existing webhook subscriptions, optionally filtered by service or team. Useful for managing or reviewing webhook integrations. Requires appropriate OAuth permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/webhook_subscriptions",
        method="GET",
        params=remove_none_values({
            "limit": results_per_page,
            "offset": pagination_offset,
            "total": include_total_in_response,
            "filter_type": resource_filter_type,
            "filter_id": resource_filter_id,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_webhook_subscription_details(
    context: ToolContext,
    webhook_subscription_id: Annotated[
        str, "The unique identifier of the webhook subscription to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getWebhookSubscription'."]:
    """Retrieve details of a specific webhook subscription.

    Use this tool to obtain information about an existing webhook subscription in Pagerduty, using the subscription ID."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/webhook_subscriptions/{id}".format(  # noqa: UP032
            id=webhook_subscription_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_webhook_subscription(
    context: ToolContext,
    resource_id: Annotated[str, "The unique identifier of the webhook subscription to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteWebhookSubscription'."]:
    """Deletes a specified webhook subscription in Pagerduty.

    Use this tool to delete an existing webhook subscription in Pagerduty. It is applicable when a user wants to remove a webhook they no longer need or want to replace. The operation requires appropriate OAuth permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/webhook_subscriptions/{id}".format(id=resource_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def enable_webhook_subscription(
    context: ToolContext,
    resource_id: Annotated[str, "The unique identifier for the webhook to be reactivated."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'enableWebhookSubscription'."]:
    """Enable a temporarily disabled webhook subscription.

    This tool enables a webhook subscription that has been temporarily disabled due to delivery method rejections. It should be called when you need to reactivate such a subscription without providing a request body."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/webhook_subscriptions/{id}/enable".format(id=resource_id),  # noqa: UP032
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def test_webhook_subscription(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier for the webhook subscription resource to be tested."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'testWebhookSubscription'."]:
    """Test a webhook subscription with a ping event.

    This tool fires a test event against a specified webhook subscription by sending a `pagey.ping` event to the target destination. It helps verify the correct configuration of the webhook subscription. Useful for ensuring that webhook endpoints are properly set up and can receive events. Requires `webhook_subscriptions.write` OAuth scope."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/webhook_subscriptions/{id}/ping".format(id=resource_id),  # noqa: UP032
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_oauth_clients(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listOauthClients'."]:
    """Retrieve all OAuth clients for webhook subscriptions.

    Call this tool to list all OAuth clients associated with webhook subscriptions in a Pagerduty account. This requires admin or owner role permissions and can list up to 10 clients per account."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/webhook_subscriptions/oauth_clients",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_oauth_client_details(
    context: ToolContext,
    resource_id: Annotated[
        str,
        "The unique ID of the OAuth client resource to retrieve details for. Requires admin or owner role permissions.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOauthClient'."]:
    """Retrieve details of a specific OAuth client by ID.

    Use this tool to obtain detailed information about a specific OAuth client using its ID. It requires admin or owner role permissions in the Pagerduty service."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/webhook_subscriptions/oauth_clients/{id}".format(  # noqa: UP032
            id=resource_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_oauth_client(
    context: ToolContext,
    resource_id: Annotated[str, "The ID of the OAuth client to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteOauthClient'."]:
    """Delete an OAuth client and disassociate subscriptions.

    Use this tool to delete an OAuth client in Pagerduty. This action will also remove the OAuth client association from any webhook subscriptions using it. Requires admin or owner role permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/webhook_subscriptions/oauth_clients/{id}".format(  # noqa: UP032
            id=resource_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_workflow_integrations(
    context: ToolContext,
    result_limit: Annotated[
        int | None, "Specifies the maximum number of workflow integrations to retrieve in one call."
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "A token to retrieve the next set of results. Obtain from `next_cursor` of the previous response. Defaults to the start if empty.",  # noqa: E501
    ] = None,
    include_deprecated_integrations: Annotated[
        bool | None, "Include deprecated integrations in the response if true."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listWorkflowIntegrations'."]:
    """Retrieve available Workflow Integrations from Pagerduty.

    Use this tool to access a list of available Workflow Integrations via Pagerduty's API. Requires appropriate OAuth permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/workflows/integrations",
        method="GET",
        params=remove_none_values({
            "limit": result_limit,
            "cursor": pagination_cursor,
            "include_deprecated": include_deprecated_integrations,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_workflow_integration_details(
    context: ToolContext,
    resource_id: Annotated[
        str, "The unique identifier for the Workflow Integration resource in Pagerduty."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getWorkflowIntegration'."]:
    """Retrieve details about a Workflow Integration.

    Use this tool to get information about a specific Workflow Integration in Pagerduty. It requires 'workflow_integrations.read' permissions."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/workflows/integrations/{id}".format(id=resource_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def list_workflow_integration_connections(
    context: ToolContext,
    result_limit: Annotated[
        int | None,
        "Specify the maximum number of results to return. Defaults to the smaller of the request's limit or the API's maximum.",  # noqa: E501
    ] = None,
    next_page_cursor: Annotated[
        str | None,
        "Optional parameter for requesting the next set of results. Use the value from `next_cursor` of the previous response. Leave empty to start from the beginning.",  # noqa: E501
    ] = None,
    filter_by_partial_name: Annotated[
        str | None, "Filter integrations based on a partial name match."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listWorkflowIntegrationConnections'."
]:
    """Retrieve all Workflow Integration Connections from Pagerduty.

    Use this tool to access and list all Workflow Integration Connections via Pagerduty. It requires appropriate OAuth scope for access."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/workflows/integrations/connections",
        method="GET",
        params=remove_none_values({
            "limit": result_limit,
            "cursor": next_page_cursor,
            "name": filter_by_partial_name,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_integration_connections(
    context: ToolContext,
    workflow_integration_id: Annotated[
        str, "The unique identifier for the specific Workflow Integration."
    ],
    request_limit: Annotated[
        int | None,
        "Defines the maximum number of integration connections to retrieve in one request.",
    ] = None,
    result_cursor: Annotated[
        str | None,
        "Cursor for fetching the next set of results, obtained from the `next_cursor` of the previous request. If not provided, fetches from the start.",  # noqa: E501
    ] = None,
    filter_integration_by_partial_name: Annotated[
        str | None, "Filter results by a partial name of the integration to narrow down the search."
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'listWorkflowIntegrationConnectionsByIntegration'.",
]:
    """Retrieve connections for a specific workflow integration.

    Use this tool to fetch all workflow integration connections related to a particular integration within Pagerduty. This is useful for managing or auditing connections associated with a specific workflow integration."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/workflows/integrations/{integration_id}/connections".format(  # noqa: UP032
            integration_id=workflow_integration_id
        ),
        method="GET",
        params=remove_none_values({
            "limit": request_limit,
            "cursor": result_cursor,
            "name": filter_integration_by_partial_name,
        }),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def create_workflow_integration_connection(
    context: ToolContext,
    workflow_integration_id: Annotated[
        str, "The unique ID of the workflow integration to create a connection for."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'createWorkflowIntegrationConnection'."
]:
    """Create a new workflow integration connection in Pagerduty.

    This tool creates a new workflow integration connection on Pagerduty. Use it when you need to establish a connection for a workflow integration. Requires OAuth with the 'workflow_integrations:connections.write' permission."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/workflows/integrations/{integration_id}/connections".format(  # noqa: UP032
            integration_id=workflow_integration_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def get_workflow_integration_connection_details(
    context: ToolContext,
    workflow_integration_id: Annotated[
        str, "The unique ID of the Workflow Integration to retrieve connection details for."
    ],
    resource_id: Annotated[str, "The ID of the resource to get details for."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getWorkflowIntegrationConnection'."
]:
    """Retrieve details of a Workflow Integration Connection.

    Use this tool to obtain specific details regarding a Workflow Integration Connection in Pagerduty. This is useful for understanding the setup and configuration of a connection associated with a workflow integration."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/workflows/integrations/{integration_id}/connections/{id}".format(  # noqa: UP032
            integration_id=workflow_integration_id, id=resource_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def update_workflow_integration_connection(
    context: ToolContext,
    workflow_integration_id: Annotated[str, "The ID of the Workflow Integration to be updated."],
    resource_id: Annotated[
        str, "The ID of the resource to update in the workflow integration connection."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'updateWorkflowIntegrationConnection'."
]:
    """Update an existing Workflow Integration Connection.

    This tool updates an existing Workflow Integration Connection in Pagerduty. It requires the `workflow_integrations:connections.write` permission scope and is used when modifications to an integration connection are needed."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/workflows/integrations/{integration_id}/connections/{id}".format(  # noqa: UP032
            integration_id=workflow_integration_id, id=resource_id
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-pagerduty"))
async def delete_workflow_integration_connection(
    context: ToolContext,
    workflow_integration_id: Annotated[
        str, "The unique ID of the Workflow Integration to be deleted."
    ],
    resource_id: Annotated[str, "The unique identifier of the resource to be deleted."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteWorkflowIntegrationConnection'."
]:
    """Delete a workflow integration connection in PagerDuty.

    Use this tool to delete a specific workflow integration connection in PagerDuty. Ensure you have the necessary OAuth scope: `workflow_integrations:connections.write`."""  # noqa: E501
    response = await make_request(
        url="https://api.pagerduty.com/workflows/integrations/{integration_id}/connections/{id}".format(  # noqa: UP032
            integration_id=workflow_integration_id, id=resource_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Accept": "application/vnd.pagerduty+json;version=2",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
