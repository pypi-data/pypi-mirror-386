#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Fri Aug  5 11:45:43 2022 by generateDS.py version 2.40.13.
# Python 3.10.4 (main, Apr  2 2022, 09:04:19) [GCC 11.2.0]
#
# Command line options:
#   ('--no-namespace-defs', '')
#   ('-o', './chronopost_lib/trackingservice.py')
#
# Command line arguments:
#   ./schemas/TrackingServiceWS.xml
#
# Command line:
#   /home/iyed/Github/karrio/.venv/karrio/bin/generateDS --no-namespace-defs -o "./chronopost_lib/trackingservice.py" ./schemas/TrackingServiceWS.xml
#
# Current working directory (os.getcwd()):
#   chronopost
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % float(input_data)).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            input_data = input_data.strip()
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    s1 = s1.replace('\n', '&#10;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class cancelListSkybill(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, accountNumber=None, password=None, language=None, skybillNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accountNumber = accountNumber
        self.accountNumber_nsprefix_ = None
        self.password = password
        self.password_nsprefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.skybillNumber = skybillNumber
        self.skybillNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cancelListSkybill)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cancelListSkybill.subclass:
            return cancelListSkybill.subclass(*args_, **kwargs_)
        else:
            return cancelListSkybill(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accountNumber(self):
        return self.accountNumber
    def set_accountNumber(self, accountNumber):
        self.accountNumber = accountNumber
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_skybillNumber(self):
        return self.skybillNumber
    def set_skybillNumber(self, skybillNumber):
        self.skybillNumber = skybillNumber
    def _hasContent(self):
        if (
            self.accountNumber is not None or
            self.password is not None or
            self.language is not None or
            self.skybillNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cancelListSkybill', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cancelListSkybill')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cancelListSkybill':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cancelListSkybill')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cancelListSkybill', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cancelListSkybill'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cancelListSkybill', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accountNumber is not None:
            namespaceprefix_ = self.accountNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.accountNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccountNumber>%s</%saccountNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.accountNumber), input_name='accountNumber')), namespaceprefix_ , eol_))
        if self.password is not None:
            namespaceprefix_ = self.password_nsprefix_ + ':' if (UseCapturedNS_ and self.password_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespaceprefix_ , eol_))
        if self.skybillNumber is not None:
            namespaceprefix_ = self.skybillNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.skybillNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sskybillNumber>%s</%sskybillNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.skybillNumber), input_name='skybillNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accountNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'accountNumber')
            value_ = self.gds_validate_string(value_, node, 'accountNumber')
            self.accountNumber = value_
            self.accountNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'password':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'password')
            value_ = self.gds_validate_string(value_, node, 'password')
            self.password = value_
            self.password_nsprefix_ = child_.prefix
        elif nodeName_ == 'language':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'language')
            value_ = self.gds_validate_string(value_, node, 'language')
            self.language = value_
            self.language_nsprefix_ = child_.prefix
        elif nodeName_ == 'skybillNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'skybillNumber')
            value_ = self.gds_validate_string(value_, node, 'skybillNumber')
            self.skybillNumber = value_
            self.skybillNumber_nsprefix_ = child_.prefix
# end class cancelListSkybill


class cancelListSkybillResponse(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, return_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.return_ = return_
        self.return__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cancelListSkybillResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cancelListSkybillResponse.subclass:
            return cancelListSkybillResponse.subclass(*args_, **kwargs_)
        else:
            return cancelListSkybillResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_return(self):
        return self.return_
    def set_return(self, return_):
        self.return_ = return_
    def _hasContent(self):
        if (
            self.return_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cancelListSkybillResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cancelListSkybillResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cancelListSkybillResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cancelListSkybillResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cancelListSkybillResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cancelListSkybillResponse'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cancelListSkybillResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.return_ is not None:
            namespaceprefix_ = self.return__nsprefix_ + ':' if (UseCapturedNS_ and self.return__nsprefix_) else ''
            self.return_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='return', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'return':
            obj_ = resultListCancelSkybill.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.return_ = obj_
            obj_.original_tagname_ = 'return'
# end class cancelListSkybillResponse


class resultListCancelSkybill(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, errorCode=None, errorMessage=None, skybills=None, statusCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.errorCode = errorCode
        self.errorCode_nsprefix_ = None
        self.errorMessage = errorMessage
        self.errorMessage_nsprefix_ = None
        if skybills is None:
            self.skybills = []
        else:
            self.skybills = skybills
        self.skybills_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resultListCancelSkybill)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resultListCancelSkybill.subclass:
            return resultListCancelSkybill.subclass(*args_, **kwargs_)
        else:
            return resultListCancelSkybill(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_errorCode(self):
        return self.errorCode
    def set_errorCode(self, errorCode):
        self.errorCode = errorCode
    def get_errorMessage(self):
        return self.errorMessage
    def set_errorMessage(self, errorMessage):
        self.errorMessage = errorMessage
    def get_skybills(self):
        return self.skybills
    def set_skybills(self, skybills):
        self.skybills = skybills
    def add_skybills(self, value):
        self.skybills.append(value)
    def insert_skybills_at(self, index, value):
        self.skybills.insert(index, value)
    def replace_skybills_at(self, index, value):
        self.skybills[index] = value
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def _hasContent(self):
        if (
            self.errorCode is not None or
            self.errorMessage is not None or
            self.skybills or
            self.statusCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultListCancelSkybill', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resultListCancelSkybill')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'resultListCancelSkybill':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='resultListCancelSkybill')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='resultListCancelSkybill', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='resultListCancelSkybill'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultListCancelSkybill', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.errorCode is not None:
            namespaceprefix_ = self.errorCode_nsprefix_ + ':' if (UseCapturedNS_ and self.errorCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorCode>%s</%serrorCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.errorCode, input_name='errorCode'), namespaceprefix_ , eol_))
        if self.errorMessage is not None:
            namespaceprefix_ = self.errorMessage_nsprefix_ + ':' if (UseCapturedNS_ and self.errorMessage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorMessage>%s</%serrorMessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.errorMessage), input_name='errorMessage')), namespaceprefix_ , eol_))
        for skybills_ in self.skybills:
            namespaceprefix_ = self.skybills_nsprefix_ + ':' if (UseCapturedNS_ and self.skybills_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sskybills>%s</%sskybills>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(skybills_), input_name='skybills')), namespaceprefix_ , eol_))
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatusCode>%s</%sstatusCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.statusCode, input_name='statusCode'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'errorCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'errorCode')
            ival_ = self.gds_validate_integer(ival_, node, 'errorCode')
            self.errorCode = ival_
            self.errorCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'errorMessage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'errorMessage')
            value_ = self.gds_validate_string(value_, node, 'errorMessage')
            self.errorMessage = value_
            self.errorMessage_nsprefix_ = child_.prefix
        elif nodeName_ == 'skybills':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'skybills')
            value_ = self.gds_validate_string(value_, node, 'skybills')
            self.skybills.append(value_)
            self.skybills_nsprefix_ = child_.prefix
        elif nodeName_ == 'statusCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'statusCode')
            ival_ = self.gds_validate_integer(ival_, node, 'statusCode')
            self.statusCode = ival_
            self.statusCode_nsprefix_ = child_.prefix
# end class resultListCancelSkybill


class trackESD(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, language=None, esdNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.esdNumber = esdNumber
        self.esdNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackESD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackESD.subclass:
            return trackESD.subclass(*args_, **kwargs_)
        else:
            return trackESD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_esdNumber(self):
        return self.esdNumber
    def set_esdNumber(self, esdNumber):
        self.esdNumber = esdNumber
    def _hasContent(self):
        if (
            self.language is not None or
            self.esdNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackESD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackESD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackESD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackESD')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackESD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackESD'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackESD', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespaceprefix_ , eol_))
        if self.esdNumber is not None:
            namespaceprefix_ = self.esdNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.esdNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sesdNumber>%s</%sesdNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.esdNumber), input_name='esdNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'language':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'language')
            value_ = self.gds_validate_string(value_, node, 'language')
            self.language = value_
            self.language_nsprefix_ = child_.prefix
        elif nodeName_ == 'esdNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'esdNumber')
            value_ = self.gds_validate_string(value_, node, 'esdNumber')
            self.esdNumber = value_
            self.esdNumber_nsprefix_ = child_.prefix
# end class trackESD


class trackESDResponse(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, return_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.return_ = return_
        self.return__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackESDResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackESDResponse.subclass:
            return trackESDResponse.subclass(*args_, **kwargs_)
        else:
            return trackESDResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_return(self):
        return self.return_
    def set_return(self, return_):
        self.return_ = return_
    def _hasContent(self):
        if (
            self.return_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackESDResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackESDResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackESDResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackESDResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackESDResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackESDResponse'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackESDResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.return_ is not None:
            namespaceprefix_ = self.return__nsprefix_ + ':' if (UseCapturedNS_ and self.return__nsprefix_) else ''
            self.return_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='return', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'return':
            obj_ = resultTrackSkybillV2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.return_ = obj_
            obj_.original_tagname_ = 'return'
# end class trackESDResponse


class resultTrackSkybillV2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, errorCode=None, errorMessage=None, listEventInfoComp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.errorCode = errorCode
        self.errorCode_nsprefix_ = None
        self.errorMessage = errorMessage
        self.errorMessage_nsprefix_ = None
        self.listEventInfoComp = listEventInfoComp
        self.listEventInfoComp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resultTrackSkybillV2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resultTrackSkybillV2.subclass:
            return resultTrackSkybillV2.subclass(*args_, **kwargs_)
        else:
            return resultTrackSkybillV2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_errorCode(self):
        return self.errorCode
    def set_errorCode(self, errorCode):
        self.errorCode = errorCode
    def get_errorMessage(self):
        return self.errorMessage
    def set_errorMessage(self, errorMessage):
        self.errorMessage = errorMessage
    def get_listEventInfoComp(self):
        return self.listEventInfoComp
    def set_listEventInfoComp(self, listEventInfoComp):
        self.listEventInfoComp = listEventInfoComp
    def _hasContent(self):
        if (
            self.errorCode is not None or
            self.errorMessage is not None or
            self.listEventInfoComp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultTrackSkybillV2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resultTrackSkybillV2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'resultTrackSkybillV2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='resultTrackSkybillV2')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='resultTrackSkybillV2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='resultTrackSkybillV2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultTrackSkybillV2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.errorCode is not None:
            namespaceprefix_ = self.errorCode_nsprefix_ + ':' if (UseCapturedNS_ and self.errorCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorCode>%s</%serrorCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.errorCode, input_name='errorCode'), namespaceprefix_ , eol_))
        if self.errorMessage is not None:
            namespaceprefix_ = self.errorMessage_nsprefix_ + ':' if (UseCapturedNS_ and self.errorMessage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorMessage>%s</%serrorMessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.errorMessage), input_name='errorMessage')), namespaceprefix_ , eol_))
        if self.listEventInfoComp is not None:
            namespaceprefix_ = self.listEventInfoComp_nsprefix_ + ':' if (UseCapturedNS_ and self.listEventInfoComp_nsprefix_) else ''
            self.listEventInfoComp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='listEventInfoComp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'errorCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'errorCode')
            ival_ = self.gds_validate_integer(ival_, node, 'errorCode')
            self.errorCode = ival_
            self.errorCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'errorMessage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'errorMessage')
            value_ = self.gds_validate_string(value_, node, 'errorMessage')
            self.errorMessage = value_
            self.errorMessage_nsprefix_ = child_.prefix
        elif nodeName_ == 'listEventInfoComp':
            obj_ = listEventInfoComps.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.listEventInfoComp = obj_
            obj_.original_tagname_ = 'listEventInfoComp'
# end class resultTrackSkybillV2


class listEventInfoComps(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, events=None, skybillNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if events is None:
            self.events = []
        else:
            self.events = events
        self.events_nsprefix_ = None
        self.skybillNumber = skybillNumber
        self.skybillNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listEventInfoComps)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listEventInfoComps.subclass:
            return listEventInfoComps.subclass(*args_, **kwargs_)
        else:
            return listEventInfoComps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_events(self):
        return self.events
    def set_events(self, events):
        self.events = events
    def add_events(self, value):
        self.events.append(value)
    def insert_events_at(self, index, value):
        self.events.insert(index, value)
    def replace_events_at(self, index, value):
        self.events[index] = value
    def get_skybillNumber(self):
        return self.skybillNumber
    def set_skybillNumber(self, skybillNumber):
        self.skybillNumber = skybillNumber
    def _hasContent(self):
        if (
            self.events or
            self.skybillNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listEventInfoComps', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listEventInfoComps')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'listEventInfoComps':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listEventInfoComps')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listEventInfoComps', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listEventInfoComps'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listEventInfoComps', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for events_ in self.events:
            namespaceprefix_ = self.events_nsprefix_ + ':' if (UseCapturedNS_ and self.events_nsprefix_) else ''
            events_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='events', pretty_print=pretty_print)
        if self.skybillNumber is not None:
            namespaceprefix_ = self.skybillNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.skybillNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sskybillNumber>%s</%sskybillNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.skybillNumber), input_name='skybillNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'events':
            obj_ = eventInfoComp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.events.append(obj_)
            obj_.original_tagname_ = 'events'
        elif nodeName_ == 'skybillNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'skybillNumber')
            value_ = self.gds_validate_string(value_, node, 'skybillNumber')
            self.skybillNumber = value_
            self.skybillNumber_nsprefix_ = child_.prefix
# end class listEventInfoComps


class event(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, code=None, eventDate=None, eventLabel=None, highPriority=None, NPC=None, officeLabel=None, zipCode=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if isinstance(eventDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(eventDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = eventDate
        self.eventDate = initvalue_
        self.eventDate_nsprefix_ = None
        self.eventLabel = eventLabel
        self.eventLabel_nsprefix_ = None
        self.highPriority = highPriority
        self.highPriority_nsprefix_ = None
        self.NPC = NPC
        self.NPC_nsprefix_ = None
        self.officeLabel = officeLabel
        self.officeLabel_nsprefix_ = None
        self.zipCode = zipCode
        self.zipCode_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if event.subclass:
            return event.subclass(*args_, **kwargs_)
        else:
            return event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_eventDate(self):
        return self.eventDate
    def set_eventDate(self, eventDate):
        self.eventDate = eventDate
    def get_eventLabel(self):
        return self.eventLabel
    def set_eventLabel(self, eventLabel):
        self.eventLabel = eventLabel
    def get_highPriority(self):
        return self.highPriority
    def set_highPriority(self, highPriority):
        self.highPriority = highPriority
    def get_NPC(self):
        return self.NPC
    def set_NPC(self, NPC):
        self.NPC = NPC
    def get_officeLabel(self):
        return self.officeLabel
    def set_officeLabel(self, officeLabel):
        self.officeLabel = officeLabel
    def get_zipCode(self):
        return self.zipCode
    def set_zipCode(self, zipCode):
        self.zipCode = zipCode
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.code is not None or
            self.eventDate is not None or
            self.eventLabel is not None or
            self.highPriority is not None or
            self.NPC is not None or
            self.officeLabel is not None or
            self.zipCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='event', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('event')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'event':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='event')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='event'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='event', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scode>%s</%scode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.code), input_name='code')), namespaceprefix_ , eol_))
        if self.eventDate is not None:
            namespaceprefix_ = self.eventDate_nsprefix_ + ':' if (UseCapturedNS_ and self.eventDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seventDate>%s</%seventDate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.eventDate, input_name='eventDate'), namespaceprefix_ , eol_))
        if self.eventLabel is not None:
            namespaceprefix_ = self.eventLabel_nsprefix_ + ':' if (UseCapturedNS_ and self.eventLabel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seventLabel>%s</%seventLabel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.eventLabel), input_name='eventLabel')), namespaceprefix_ , eol_))
        if self.highPriority is not None:
            namespaceprefix_ = self.highPriority_nsprefix_ + ':' if (UseCapturedNS_ and self.highPriority_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shighPriority>%s</%shighPriority>%s' % (namespaceprefix_ , self.gds_format_boolean(self.highPriority, input_name='highPriority'), namespaceprefix_ , eol_))
        if self.NPC is not None:
            namespaceprefix_ = self.NPC_nsprefix_ + ':' if (UseCapturedNS_ and self.NPC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNPC>%s</%sNPC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NPC), input_name='NPC')), namespaceprefix_ , eol_))
        if self.officeLabel is not None:
            namespaceprefix_ = self.officeLabel_nsprefix_ + ':' if (UseCapturedNS_ and self.officeLabel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sofficeLabel>%s</%sofficeLabel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.officeLabel), input_name='officeLabel')), namespaceprefix_ , eol_))
        if self.zipCode is not None:
            namespaceprefix_ = self.zipCode_nsprefix_ + ':' if (UseCapturedNS_ and self.zipCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%szipCode>%s</%szipCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.zipCode), input_name='zipCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
        elif nodeName_ == 'eventDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.eventDate = dval_
            self.eventDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'eventLabel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'eventLabel')
            value_ = self.gds_validate_string(value_, node, 'eventLabel')
            self.eventLabel = value_
            self.eventLabel_nsprefix_ = child_.prefix
        elif nodeName_ == 'highPriority':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'highPriority')
            ival_ = self.gds_validate_boolean(ival_, node, 'highPriority')
            self.highPriority = ival_
            self.highPriority_nsprefix_ = child_.prefix
        elif nodeName_ == 'NPC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NPC')
            value_ = self.gds_validate_string(value_, node, 'NPC')
            self.NPC = value_
            self.NPC_nsprefix_ = child_.prefix
        elif nodeName_ == 'officeLabel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'officeLabel')
            value_ = self.gds_validate_string(value_, node, 'officeLabel')
            self.officeLabel = value_
            self.officeLabel_nsprefix_ = child_.prefix
        elif nodeName_ == 'zipCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'zipCode')
            value_ = self.gds_validate_string(value_, node, 'zipCode')
            self.zipCode = value_
            self.zipCode_nsprefix_ = child_.prefix
# end class event


class infoComp(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoComp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoComp.subclass:
            return infoComp.subclass(*args_, **kwargs_)
        else:
            return infoComp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def _hasContent(self):
        if (
            self.name is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='infoComp', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoComp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infoComp':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoComp')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infoComp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infoComp'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='infoComp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'value')
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
            self.value_nsprefix_ = child_.prefix
# end class infoComp


class trackSearch(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, accountNumber=None, password=None, language=None, consigneesCountry=None, consigneesRef=None, consigneesZipCode=None, dateDeposit=None, dateEndDeposit=None, parcelState=None, sendersRef=None, serviceCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accountNumber = accountNumber
        self.accountNumber_nsprefix_ = None
        self.password = password
        self.password_nsprefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.consigneesCountry = consigneesCountry
        self.consigneesCountry_nsprefix_ = None
        self.consigneesRef = consigneesRef
        self.consigneesRef_nsprefix_ = None
        self.consigneesZipCode = consigneesZipCode
        self.consigneesZipCode_nsprefix_ = None
        self.dateDeposit = dateDeposit
        self.dateDeposit_nsprefix_ = None
        self.dateEndDeposit = dateEndDeposit
        self.dateEndDeposit_nsprefix_ = None
        self.parcelState = parcelState
        self.parcelState_nsprefix_ = None
        self.sendersRef = sendersRef
        self.sendersRef_nsprefix_ = None
        self.serviceCode = serviceCode
        self.serviceCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackSearch)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackSearch.subclass:
            return trackSearch.subclass(*args_, **kwargs_)
        else:
            return trackSearch(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accountNumber(self):
        return self.accountNumber
    def set_accountNumber(self, accountNumber):
        self.accountNumber = accountNumber
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_consigneesCountry(self):
        return self.consigneesCountry
    def set_consigneesCountry(self, consigneesCountry):
        self.consigneesCountry = consigneesCountry
    def get_consigneesRef(self):
        return self.consigneesRef
    def set_consigneesRef(self, consigneesRef):
        self.consigneesRef = consigneesRef
    def get_consigneesZipCode(self):
        return self.consigneesZipCode
    def set_consigneesZipCode(self, consigneesZipCode):
        self.consigneesZipCode = consigneesZipCode
    def get_dateDeposit(self):
        return self.dateDeposit
    def set_dateDeposit(self, dateDeposit):
        self.dateDeposit = dateDeposit
    def get_dateEndDeposit(self):
        return self.dateEndDeposit
    def set_dateEndDeposit(self, dateEndDeposit):
        self.dateEndDeposit = dateEndDeposit
    def get_parcelState(self):
        return self.parcelState
    def set_parcelState(self, parcelState):
        self.parcelState = parcelState
    def get_sendersRef(self):
        return self.sendersRef
    def set_sendersRef(self, sendersRef):
        self.sendersRef = sendersRef
    def get_serviceCode(self):
        return self.serviceCode
    def set_serviceCode(self, serviceCode):
        self.serviceCode = serviceCode
    def _hasContent(self):
        if (
            self.accountNumber is not None or
            self.password is not None or
            self.language is not None or
            self.consigneesCountry is not None or
            self.consigneesRef is not None or
            self.consigneesZipCode is not None or
            self.dateDeposit is not None or
            self.dateEndDeposit is not None or
            self.parcelState is not None or
            self.sendersRef is not None or
            self.serviceCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackSearch', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackSearch')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackSearch':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackSearch')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackSearch', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackSearch'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackSearch', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accountNumber is not None:
            namespaceprefix_ = self.accountNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.accountNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccountNumber>%s</%saccountNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.accountNumber), input_name='accountNumber')), namespaceprefix_ , eol_))
        if self.password is not None:
            namespaceprefix_ = self.password_nsprefix_ + ':' if (UseCapturedNS_ and self.password_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespaceprefix_ , eol_))
        if self.consigneesCountry is not None:
            namespaceprefix_ = self.consigneesCountry_nsprefix_ + ':' if (UseCapturedNS_ and self.consigneesCountry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconsigneesCountry>%s</%sconsigneesCountry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.consigneesCountry), input_name='consigneesCountry')), namespaceprefix_ , eol_))
        if self.consigneesRef is not None:
            namespaceprefix_ = self.consigneesRef_nsprefix_ + ':' if (UseCapturedNS_ and self.consigneesRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconsigneesRef>%s</%sconsigneesRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.consigneesRef), input_name='consigneesRef')), namespaceprefix_ , eol_))
        if self.consigneesZipCode is not None:
            namespaceprefix_ = self.consigneesZipCode_nsprefix_ + ':' if (UseCapturedNS_ and self.consigneesZipCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconsigneesZipCode>%s</%sconsigneesZipCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.consigneesZipCode), input_name='consigneesZipCode')), namespaceprefix_ , eol_))
        if self.dateDeposit is not None:
            namespaceprefix_ = self.dateDeposit_nsprefix_ + ':' if (UseCapturedNS_ and self.dateDeposit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateDeposit>%s</%sdateDeposit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dateDeposit), input_name='dateDeposit')), namespaceprefix_ , eol_))
        if self.dateEndDeposit is not None:
            namespaceprefix_ = self.dateEndDeposit_nsprefix_ + ':' if (UseCapturedNS_ and self.dateEndDeposit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateEndDeposit>%s</%sdateEndDeposit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dateEndDeposit), input_name='dateEndDeposit')), namespaceprefix_ , eol_))
        if self.parcelState is not None:
            namespaceprefix_ = self.parcelState_nsprefix_ + ':' if (UseCapturedNS_ and self.parcelState_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sparcelState>%s</%sparcelState>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.parcelState), input_name='parcelState')), namespaceprefix_ , eol_))
        if self.sendersRef is not None:
            namespaceprefix_ = self.sendersRef_nsprefix_ + ':' if (UseCapturedNS_ and self.sendersRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssendersRef>%s</%ssendersRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.sendersRef), input_name='sendersRef')), namespaceprefix_ , eol_))
        if self.serviceCode is not None:
            namespaceprefix_ = self.serviceCode_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserviceCode>%s</%sserviceCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serviceCode), input_name='serviceCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accountNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'accountNumber')
            value_ = self.gds_validate_string(value_, node, 'accountNumber')
            self.accountNumber = value_
            self.accountNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'password':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'password')
            value_ = self.gds_validate_string(value_, node, 'password')
            self.password = value_
            self.password_nsprefix_ = child_.prefix
        elif nodeName_ == 'language':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'language')
            value_ = self.gds_validate_string(value_, node, 'language')
            self.language = value_
            self.language_nsprefix_ = child_.prefix
        elif nodeName_ == 'consigneesCountry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'consigneesCountry')
            value_ = self.gds_validate_string(value_, node, 'consigneesCountry')
            self.consigneesCountry = value_
            self.consigneesCountry_nsprefix_ = child_.prefix
        elif nodeName_ == 'consigneesRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'consigneesRef')
            value_ = self.gds_validate_string(value_, node, 'consigneesRef')
            self.consigneesRef = value_
            self.consigneesRef_nsprefix_ = child_.prefix
        elif nodeName_ == 'consigneesZipCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'consigneesZipCode')
            value_ = self.gds_validate_string(value_, node, 'consigneesZipCode')
            self.consigneesZipCode = value_
            self.consigneesZipCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'dateDeposit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dateDeposit')
            value_ = self.gds_validate_string(value_, node, 'dateDeposit')
            self.dateDeposit = value_
            self.dateDeposit_nsprefix_ = child_.prefix
        elif nodeName_ == 'dateEndDeposit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dateEndDeposit')
            value_ = self.gds_validate_string(value_, node, 'dateEndDeposit')
            self.dateEndDeposit = value_
            self.dateEndDeposit_nsprefix_ = child_.prefix
        elif nodeName_ == 'parcelState':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'parcelState')
            value_ = self.gds_validate_string(value_, node, 'parcelState')
            self.parcelState = value_
            self.parcelState_nsprefix_ = child_.prefix
        elif nodeName_ == 'sendersRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sendersRef')
            value_ = self.gds_validate_string(value_, node, 'sendersRef')
            self.sendersRef = value_
            self.sendersRef_nsprefix_ = child_.prefix
        elif nodeName_ == 'serviceCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'serviceCode')
            value_ = self.gds_validate_string(value_, node, 'serviceCode')
            self.serviceCode = value_
            self.serviceCode_nsprefix_ = child_.prefix
# end class trackSearch


class trackSearchResponse(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, return_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.return_ = return_
        self.return__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackSearchResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackSearchResponse.subclass:
            return trackSearchResponse.subclass(*args_, **kwargs_)
        else:
            return trackSearchResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_return(self):
        return self.return_
    def set_return(self, return_):
        self.return_ = return_
    def _hasContent(self):
        if (
            self.return_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackSearchResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackSearchResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackSearchResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackSearchResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackSearchResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackSearchResponse'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackSearchResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.return_ is not None:
            namespaceprefix_ = self.return__nsprefix_ + ':' if (UseCapturedNS_ and self.return__nsprefix_) else ''
            self.return_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='return', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'return':
            obj_ = resultTrackSearch.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.return_ = obj_
            obj_.original_tagname_ = 'return'
# end class trackSearchResponse


class resultTrackSearch(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, errorCode=None, errorMessage=None, listInfosPOD=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.errorCode = errorCode
        self.errorCode_nsprefix_ = None
        self.errorMessage = errorMessage
        self.errorMessage_nsprefix_ = None
        if listInfosPOD is None:
            self.listInfosPOD = []
        else:
            self.listInfosPOD = listInfosPOD
        self.listInfosPOD_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resultTrackSearch)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resultTrackSearch.subclass:
            return resultTrackSearch.subclass(*args_, **kwargs_)
        else:
            return resultTrackSearch(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_errorCode(self):
        return self.errorCode
    def set_errorCode(self, errorCode):
        self.errorCode = errorCode
    def get_errorMessage(self):
        return self.errorMessage
    def set_errorMessage(self, errorMessage):
        self.errorMessage = errorMessage
    def get_listInfosPOD(self):
        return self.listInfosPOD
    def set_listInfosPOD(self, listInfosPOD):
        self.listInfosPOD = listInfosPOD
    def add_listInfosPOD(self, value):
        self.listInfosPOD.append(value)
    def insert_listInfosPOD_at(self, index, value):
        self.listInfosPOD.insert(index, value)
    def replace_listInfosPOD_at(self, index, value):
        self.listInfosPOD[index] = value
    def _hasContent(self):
        if (
            self.errorCode is not None or
            self.errorMessage is not None or
            self.listInfosPOD
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultTrackSearch', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resultTrackSearch')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'resultTrackSearch':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='resultTrackSearch')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='resultTrackSearch', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='resultTrackSearch'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultTrackSearch', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.errorCode is not None:
            namespaceprefix_ = self.errorCode_nsprefix_ + ':' if (UseCapturedNS_ and self.errorCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorCode>%s</%serrorCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.errorCode, input_name='errorCode'), namespaceprefix_ , eol_))
        if self.errorMessage is not None:
            namespaceprefix_ = self.errorMessage_nsprefix_ + ':' if (UseCapturedNS_ and self.errorMessage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorMessage>%s</%serrorMessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.errorMessage), input_name='errorMessage')), namespaceprefix_ , eol_))
        for listInfosPOD_ in self.listInfosPOD:
            namespaceprefix_ = self.listInfosPOD_nsprefix_ + ':' if (UseCapturedNS_ and self.listInfosPOD_nsprefix_) else ''
            listInfosPOD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='listInfosPOD', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'errorCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'errorCode')
            ival_ = self.gds_validate_integer(ival_, node, 'errorCode')
            self.errorCode = ival_
            self.errorCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'errorMessage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'errorMessage')
            value_ = self.gds_validate_string(value_, node, 'errorMessage')
            self.errorMessage = value_
            self.errorMessage_nsprefix_ = child_.prefix
        elif nodeName_ == 'listInfosPOD':
            obj_ = infosPOD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.listInfosPOD.append(obj_)
            obj_.original_tagname_ = 'listInfosPOD'
# end class resultTrackSearch


class infosPOD(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dateDeposit=None, depositCountry=None, depositZipCode=None, objectType=None, recipientCity=None, recipientCountry=None, recipientName=None, recipientRef=None, recipientZipCode=None, shipperCity=None, shipperRef=None, shipperZipCode=None, significantEvent=None, skybillNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(dateDeposit, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateDeposit, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dateDeposit
        self.dateDeposit = initvalue_
        self.dateDeposit_nsprefix_ = None
        self.depositCountry = depositCountry
        self.depositCountry_nsprefix_ = None
        self.depositZipCode = depositZipCode
        self.depositZipCode_nsprefix_ = None
        self.objectType = objectType
        self.objectType_nsprefix_ = None
        self.recipientCity = recipientCity
        self.recipientCity_nsprefix_ = None
        self.recipientCountry = recipientCountry
        self.recipientCountry_nsprefix_ = None
        self.recipientName = recipientName
        self.recipientName_nsprefix_ = None
        self.recipientRef = recipientRef
        self.recipientRef_nsprefix_ = None
        self.recipientZipCode = recipientZipCode
        self.recipientZipCode_nsprefix_ = None
        self.shipperCity = shipperCity
        self.shipperCity_nsprefix_ = None
        self.shipperRef = shipperRef
        self.shipperRef_nsprefix_ = None
        self.shipperZipCode = shipperZipCode
        self.shipperZipCode_nsprefix_ = None
        self.significantEvent = significantEvent
        self.significantEvent_nsprefix_ = None
        self.skybillNumber = skybillNumber
        self.skybillNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infosPOD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infosPOD.subclass:
            return infosPOD.subclass(*args_, **kwargs_)
        else:
            return infosPOD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dateDeposit(self):
        return self.dateDeposit
    def set_dateDeposit(self, dateDeposit):
        self.dateDeposit = dateDeposit
    def get_depositCountry(self):
        return self.depositCountry
    def set_depositCountry(self, depositCountry):
        self.depositCountry = depositCountry
    def get_depositZipCode(self):
        return self.depositZipCode
    def set_depositZipCode(self, depositZipCode):
        self.depositZipCode = depositZipCode
    def get_objectType(self):
        return self.objectType
    def set_objectType(self, objectType):
        self.objectType = objectType
    def get_recipientCity(self):
        return self.recipientCity
    def set_recipientCity(self, recipientCity):
        self.recipientCity = recipientCity
    def get_recipientCountry(self):
        return self.recipientCountry
    def set_recipientCountry(self, recipientCountry):
        self.recipientCountry = recipientCountry
    def get_recipientName(self):
        return self.recipientName
    def set_recipientName(self, recipientName):
        self.recipientName = recipientName
    def get_recipientRef(self):
        return self.recipientRef
    def set_recipientRef(self, recipientRef):
        self.recipientRef = recipientRef
    def get_recipientZipCode(self):
        return self.recipientZipCode
    def set_recipientZipCode(self, recipientZipCode):
        self.recipientZipCode = recipientZipCode
    def get_shipperCity(self):
        return self.shipperCity
    def set_shipperCity(self, shipperCity):
        self.shipperCity = shipperCity
    def get_shipperRef(self):
        return self.shipperRef
    def set_shipperRef(self, shipperRef):
        self.shipperRef = shipperRef
    def get_shipperZipCode(self):
        return self.shipperZipCode
    def set_shipperZipCode(self, shipperZipCode):
        self.shipperZipCode = shipperZipCode
    def get_significantEvent(self):
        return self.significantEvent
    def set_significantEvent(self, significantEvent):
        self.significantEvent = significantEvent
    def get_skybillNumber(self):
        return self.skybillNumber
    def set_skybillNumber(self, skybillNumber):
        self.skybillNumber = skybillNumber
    def _hasContent(self):
        if (
            self.dateDeposit is not None or
            self.depositCountry is not None or
            self.depositZipCode is not None or
            self.objectType is not None or
            self.recipientCity is not None or
            self.recipientCountry is not None or
            self.recipientName is not None or
            self.recipientRef is not None or
            self.recipientZipCode is not None or
            self.shipperCity is not None or
            self.shipperRef is not None or
            self.shipperZipCode is not None or
            self.significantEvent is not None or
            self.skybillNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='infosPOD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infosPOD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infosPOD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infosPOD')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infosPOD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infosPOD'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='infosPOD', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateDeposit is not None:
            namespaceprefix_ = self.dateDeposit_nsprefix_ + ':' if (UseCapturedNS_ and self.dateDeposit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateDeposit>%s</%sdateDeposit>%s' % (namespaceprefix_ , self.gds_format_datetime(self.dateDeposit, input_name='dateDeposit'), namespaceprefix_ , eol_))
        if self.depositCountry is not None:
            namespaceprefix_ = self.depositCountry_nsprefix_ + ':' if (UseCapturedNS_ and self.depositCountry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepositCountry>%s</%sdepositCountry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.depositCountry), input_name='depositCountry')), namespaceprefix_ , eol_))
        if self.depositZipCode is not None:
            namespaceprefix_ = self.depositZipCode_nsprefix_ + ':' if (UseCapturedNS_ and self.depositZipCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepositZipCode>%s</%sdepositZipCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.depositZipCode), input_name='depositZipCode')), namespaceprefix_ , eol_))
        if self.objectType is not None:
            namespaceprefix_ = self.objectType_nsprefix_ + ':' if (UseCapturedNS_ and self.objectType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobjectType>%s</%sobjectType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.objectType), input_name='objectType')), namespaceprefix_ , eol_))
        if self.recipientCity is not None:
            namespaceprefix_ = self.recipientCity_nsprefix_ + ':' if (UseCapturedNS_ and self.recipientCity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecipientCity>%s</%srecipientCity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.recipientCity), input_name='recipientCity')), namespaceprefix_ , eol_))
        if self.recipientCountry is not None:
            namespaceprefix_ = self.recipientCountry_nsprefix_ + ':' if (UseCapturedNS_ and self.recipientCountry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecipientCountry>%s</%srecipientCountry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.recipientCountry), input_name='recipientCountry')), namespaceprefix_ , eol_))
        if self.recipientName is not None:
            namespaceprefix_ = self.recipientName_nsprefix_ + ':' if (UseCapturedNS_ and self.recipientName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecipientName>%s</%srecipientName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.recipientName), input_name='recipientName')), namespaceprefix_ , eol_))
        if self.recipientRef is not None:
            namespaceprefix_ = self.recipientRef_nsprefix_ + ':' if (UseCapturedNS_ and self.recipientRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecipientRef>%s</%srecipientRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.recipientRef), input_name='recipientRef')), namespaceprefix_ , eol_))
        if self.recipientZipCode is not None:
            namespaceprefix_ = self.recipientZipCode_nsprefix_ + ':' if (UseCapturedNS_ and self.recipientZipCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecipientZipCode>%s</%srecipientZipCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.recipientZipCode), input_name='recipientZipCode')), namespaceprefix_ , eol_))
        if self.shipperCity is not None:
            namespaceprefix_ = self.shipperCity_nsprefix_ + ':' if (UseCapturedNS_ and self.shipperCity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshipperCity>%s</%sshipperCity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.shipperCity), input_name='shipperCity')), namespaceprefix_ , eol_))
        if self.shipperRef is not None:
            namespaceprefix_ = self.shipperRef_nsprefix_ + ':' if (UseCapturedNS_ and self.shipperRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshipperRef>%s</%sshipperRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.shipperRef), input_name='shipperRef')), namespaceprefix_ , eol_))
        if self.shipperZipCode is not None:
            namespaceprefix_ = self.shipperZipCode_nsprefix_ + ':' if (UseCapturedNS_ and self.shipperZipCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshipperZipCode>%s</%sshipperZipCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.shipperZipCode), input_name='shipperZipCode')), namespaceprefix_ , eol_))
        if self.significantEvent is not None:
            namespaceprefix_ = self.significantEvent_nsprefix_ + ':' if (UseCapturedNS_ and self.significantEvent_nsprefix_) else ''
            self.significantEvent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='significantEvent', pretty_print=pretty_print)
        if self.skybillNumber is not None:
            namespaceprefix_ = self.skybillNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.skybillNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sskybillNumber>%s</%sskybillNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.skybillNumber), input_name='skybillNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dateDeposit':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dateDeposit = dval_
            self.dateDeposit_nsprefix_ = child_.prefix
        elif nodeName_ == 'depositCountry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'depositCountry')
            value_ = self.gds_validate_string(value_, node, 'depositCountry')
            self.depositCountry = value_
            self.depositCountry_nsprefix_ = child_.prefix
        elif nodeName_ == 'depositZipCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'depositZipCode')
            value_ = self.gds_validate_string(value_, node, 'depositZipCode')
            self.depositZipCode = value_
            self.depositZipCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'objectType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'objectType')
            value_ = self.gds_validate_string(value_, node, 'objectType')
            self.objectType = value_
            self.objectType_nsprefix_ = child_.prefix
        elif nodeName_ == 'recipientCity':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'recipientCity')
            value_ = self.gds_validate_string(value_, node, 'recipientCity')
            self.recipientCity = value_
            self.recipientCity_nsprefix_ = child_.prefix
        elif nodeName_ == 'recipientCountry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'recipientCountry')
            value_ = self.gds_validate_string(value_, node, 'recipientCountry')
            self.recipientCountry = value_
            self.recipientCountry_nsprefix_ = child_.prefix
        elif nodeName_ == 'recipientName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'recipientName')
            value_ = self.gds_validate_string(value_, node, 'recipientName')
            self.recipientName = value_
            self.recipientName_nsprefix_ = child_.prefix
        elif nodeName_ == 'recipientRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'recipientRef')
            value_ = self.gds_validate_string(value_, node, 'recipientRef')
            self.recipientRef = value_
            self.recipientRef_nsprefix_ = child_.prefix
        elif nodeName_ == 'recipientZipCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'recipientZipCode')
            value_ = self.gds_validate_string(value_, node, 'recipientZipCode')
            self.recipientZipCode = value_
            self.recipientZipCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'shipperCity':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shipperCity')
            value_ = self.gds_validate_string(value_, node, 'shipperCity')
            self.shipperCity = value_
            self.shipperCity_nsprefix_ = child_.prefix
        elif nodeName_ == 'shipperRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shipperRef')
            value_ = self.gds_validate_string(value_, node, 'shipperRef')
            self.shipperRef = value_
            self.shipperRef_nsprefix_ = child_.prefix
        elif nodeName_ == 'shipperZipCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shipperZipCode')
            value_ = self.gds_validate_string(value_, node, 'shipperZipCode')
            self.shipperZipCode = value_
            self.shipperZipCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'significantEvent':
            class_obj_ = self.get_class_obj_(child_, event)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.significantEvent = obj_
            obj_.original_tagname_ = 'significantEvent'
        elif nodeName_ == 'skybillNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'skybillNumber')
            value_ = self.gds_validate_string(value_, node, 'skybillNumber')
            self.skybillNumber = value_
            self.skybillNumber_nsprefix_ = child_.prefix
# end class infosPOD


class searchPOD(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, accountNumber=None, password=None, language=None, skybillNumber=None, pdf=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accountNumber = accountNumber
        self.accountNumber_nsprefix_ = None
        self.password = password
        self.password_nsprefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.skybillNumber = skybillNumber
        self.skybillNumber_nsprefix_ = None
        self.pdf = pdf
        self.pdf_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, searchPOD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if searchPOD.subclass:
            return searchPOD.subclass(*args_, **kwargs_)
        else:
            return searchPOD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accountNumber(self):
        return self.accountNumber
    def set_accountNumber(self, accountNumber):
        self.accountNumber = accountNumber
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_skybillNumber(self):
        return self.skybillNumber
    def set_skybillNumber(self, skybillNumber):
        self.skybillNumber = skybillNumber
    def get_pdf(self):
        return self.pdf
    def set_pdf(self, pdf):
        self.pdf = pdf
    def _hasContent(self):
        if (
            self.accountNumber is not None or
            self.password is not None or
            self.language is not None or
            self.skybillNumber is not None or
            self.pdf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='searchPOD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('searchPOD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'searchPOD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='searchPOD')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='searchPOD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='searchPOD'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='searchPOD', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accountNumber is not None:
            namespaceprefix_ = self.accountNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.accountNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccountNumber>%s</%saccountNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.accountNumber), input_name='accountNumber')), namespaceprefix_ , eol_))
        if self.password is not None:
            namespaceprefix_ = self.password_nsprefix_ + ':' if (UseCapturedNS_ and self.password_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespaceprefix_ , eol_))
        if self.skybillNumber is not None:
            namespaceprefix_ = self.skybillNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.skybillNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sskybillNumber>%s</%sskybillNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.skybillNumber), input_name='skybillNumber')), namespaceprefix_ , eol_))
        if self.pdf is not None:
            namespaceprefix_ = self.pdf_nsprefix_ + ':' if (UseCapturedNS_ and self.pdf_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spdf>%s</%spdf>%s' % (namespaceprefix_ , self.gds_format_boolean(self.pdf, input_name='pdf'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accountNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'accountNumber')
            value_ = self.gds_validate_string(value_, node, 'accountNumber')
            self.accountNumber = value_
            self.accountNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'password':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'password')
            value_ = self.gds_validate_string(value_, node, 'password')
            self.password = value_
            self.password_nsprefix_ = child_.prefix
        elif nodeName_ == 'language':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'language')
            value_ = self.gds_validate_string(value_, node, 'language')
            self.language = value_
            self.language_nsprefix_ = child_.prefix
        elif nodeName_ == 'skybillNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'skybillNumber')
            value_ = self.gds_validate_string(value_, node, 'skybillNumber')
            self.skybillNumber = value_
            self.skybillNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'pdf':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'pdf')
            ival_ = self.gds_validate_boolean(ival_, node, 'pdf')
            self.pdf = ival_
            self.pdf_nsprefix_ = child_.prefix
# end class searchPOD


class searchPODResponse(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, return_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.return_ = return_
        self.return__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, searchPODResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if searchPODResponse.subclass:
            return searchPODResponse.subclass(*args_, **kwargs_)
        else:
            return searchPODResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_return(self):
        return self.return_
    def set_return(self, return_):
        self.return_ = return_
    def _hasContent(self):
        if (
            self.return_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='searchPODResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('searchPODResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'searchPODResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='searchPODResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='searchPODResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='searchPODResponse'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='searchPODResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.return_ is not None:
            namespaceprefix_ = self.return__nsprefix_ + ':' if (UseCapturedNS_ and self.return__nsprefix_) else ''
            self.return_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='return', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'return':
            obj_ = resultSearchPOD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.return_ = obj_
            obj_.original_tagname_ = 'return'
# end class searchPODResponse


class resultSearchPOD(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, errorCode=None, errorMessage=None, formatPOD=None, pod=None, podPresente=None, statusCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.errorCode = errorCode
        self.errorCode_nsprefix_ = None
        self.errorMessage = errorMessage
        self.errorMessage_nsprefix_ = None
        self.formatPOD = formatPOD
        self.formatPOD_nsprefix_ = None
        self.pod = pod
        self.pod_nsprefix_ = None
        self.podPresente = podPresente
        self.podPresente_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resultSearchPOD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resultSearchPOD.subclass:
            return resultSearchPOD.subclass(*args_, **kwargs_)
        else:
            return resultSearchPOD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_errorCode(self):
        return self.errorCode
    def set_errorCode(self, errorCode):
        self.errorCode = errorCode
    def get_errorMessage(self):
        return self.errorMessage
    def set_errorMessage(self, errorMessage):
        self.errorMessage = errorMessage
    def get_formatPOD(self):
        return self.formatPOD
    def set_formatPOD(self, formatPOD):
        self.formatPOD = formatPOD
    def get_pod(self):
        return self.pod
    def set_pod(self, pod):
        self.pod = pod
    def get_podPresente(self):
        return self.podPresente
    def set_podPresente(self, podPresente):
        self.podPresente = podPresente
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def _hasContent(self):
        if (
            self.errorCode is not None or
            self.errorMessage is not None or
            self.formatPOD is not None or
            self.pod is not None or
            self.podPresente is not None or
            self.statusCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultSearchPOD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resultSearchPOD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'resultSearchPOD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='resultSearchPOD')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='resultSearchPOD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='resultSearchPOD'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultSearchPOD', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.errorCode is not None:
            namespaceprefix_ = self.errorCode_nsprefix_ + ':' if (UseCapturedNS_ and self.errorCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorCode>%s</%serrorCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.errorCode, input_name='errorCode'), namespaceprefix_ , eol_))
        if self.errorMessage is not None:
            namespaceprefix_ = self.errorMessage_nsprefix_ + ':' if (UseCapturedNS_ and self.errorMessage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorMessage>%s</%serrorMessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.errorMessage), input_name='errorMessage')), namespaceprefix_ , eol_))
        if self.formatPOD is not None:
            namespaceprefix_ = self.formatPOD_nsprefix_ + ':' if (UseCapturedNS_ and self.formatPOD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformatPOD>%s</%sformatPOD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.formatPOD), input_name='formatPOD')), namespaceprefix_ , eol_))
        if self.pod is not None:
            namespaceprefix_ = self.pod_nsprefix_ + ':' if (UseCapturedNS_ and self.pod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spod>%s</%spod>%s' % (namespaceprefix_ , self.gds_format_base64(self.pod, input_name='pod'), namespaceprefix_ , eol_))
        if self.podPresente is not None:
            namespaceprefix_ = self.podPresente_nsprefix_ + ':' if (UseCapturedNS_ and self.podPresente_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spodPresente>%s</%spodPresente>%s' % (namespaceprefix_ , self.gds_format_boolean(self.podPresente, input_name='podPresente'), namespaceprefix_ , eol_))
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatusCode>%s</%sstatusCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.statusCode, input_name='statusCode'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'errorCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'errorCode')
            ival_ = self.gds_validate_integer(ival_, node, 'errorCode')
            self.errorCode = ival_
            self.errorCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'errorMessage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'errorMessage')
            value_ = self.gds_validate_string(value_, node, 'errorMessage')
            self.errorMessage = value_
            self.errorMessage_nsprefix_ = child_.prefix
        elif nodeName_ == 'formatPOD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'formatPOD')
            value_ = self.gds_validate_string(value_, node, 'formatPOD')
            self.formatPOD = value_
            self.formatPOD_nsprefix_ = child_.prefix
        elif nodeName_ == 'pod':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'pod')
            else:
                bval_ = None
            self.pod = bval_
            self.pod_nsprefix_ = child_.prefix
        elif nodeName_ == 'podPresente':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'podPresente')
            ival_ = self.gds_validate_boolean(ival_, node, 'podPresente')
            self.podPresente = ival_
            self.podPresente_nsprefix_ = child_.prefix
        elif nodeName_ == 'statusCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'statusCode')
            ival_ = self.gds_validate_integer(ival_, node, 'statusCode')
            self.statusCode = ival_
            self.statusCode_nsprefix_ = child_.prefix
# end class resultSearchPOD


class cancelSkybill(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, accountNumber=None, password=None, language=None, skybillNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accountNumber = accountNumber
        self.accountNumber_nsprefix_ = None
        self.password = password
        self.password_nsprefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.skybillNumber = skybillNumber
        self.skybillNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cancelSkybill)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cancelSkybill.subclass:
            return cancelSkybill.subclass(*args_, **kwargs_)
        else:
            return cancelSkybill(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accountNumber(self):
        return self.accountNumber
    def set_accountNumber(self, accountNumber):
        self.accountNumber = accountNumber
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_skybillNumber(self):
        return self.skybillNumber
    def set_skybillNumber(self, skybillNumber):
        self.skybillNumber = skybillNumber
    def _hasContent(self):
        if (
            self.accountNumber is not None or
            self.password is not None or
            self.language is not None or
            self.skybillNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cancelSkybill', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cancelSkybill')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cancelSkybill':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cancelSkybill')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cancelSkybill', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cancelSkybill'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cancelSkybill', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accountNumber is not None:
            namespaceprefix_ = self.accountNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.accountNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccountNumber>%s</%saccountNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.accountNumber), input_name='accountNumber')), namespaceprefix_ , eol_))
        if self.password is not None:
            namespaceprefix_ = self.password_nsprefix_ + ':' if (UseCapturedNS_ and self.password_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespaceprefix_ , eol_))
        if self.skybillNumber is not None:
            namespaceprefix_ = self.skybillNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.skybillNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sskybillNumber>%s</%sskybillNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.skybillNumber), input_name='skybillNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accountNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'accountNumber')
            value_ = self.gds_validate_string(value_, node, 'accountNumber')
            self.accountNumber = value_
            self.accountNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'password':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'password')
            value_ = self.gds_validate_string(value_, node, 'password')
            self.password = value_
            self.password_nsprefix_ = child_.prefix
        elif nodeName_ == 'language':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'language')
            value_ = self.gds_validate_string(value_, node, 'language')
            self.language = value_
            self.language_nsprefix_ = child_.prefix
        elif nodeName_ == 'skybillNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'skybillNumber')
            value_ = self.gds_validate_string(value_, node, 'skybillNumber')
            self.skybillNumber = value_
            self.skybillNumber_nsprefix_ = child_.prefix
# end class cancelSkybill


class cancelSkybillResponse(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, return_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.return_ = return_
        self.return__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cancelSkybillResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cancelSkybillResponse.subclass:
            return cancelSkybillResponse.subclass(*args_, **kwargs_)
        else:
            return cancelSkybillResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_return(self):
        return self.return_
    def set_return(self, return_):
        self.return_ = return_
    def _hasContent(self):
        if (
            self.return_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cancelSkybillResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cancelSkybillResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cancelSkybillResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cancelSkybillResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cancelSkybillResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cancelSkybillResponse'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cancelSkybillResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.return_ is not None:
            namespaceprefix_ = self.return__nsprefix_ + ':' if (UseCapturedNS_ and self.return__nsprefix_) else ''
            self.return_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='return', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'return':
            obj_ = resultCancelSkybill.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.return_ = obj_
            obj_.original_tagname_ = 'return'
# end class cancelSkybillResponse


class resultCancelSkybill(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, errorCode=None, errorMessage=None, statusCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.errorCode = errorCode
        self.errorCode_nsprefix_ = None
        self.errorMessage = errorMessage
        self.errorMessage_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resultCancelSkybill)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resultCancelSkybill.subclass:
            return resultCancelSkybill.subclass(*args_, **kwargs_)
        else:
            return resultCancelSkybill(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_errorCode(self):
        return self.errorCode
    def set_errorCode(self, errorCode):
        self.errorCode = errorCode
    def get_errorMessage(self):
        return self.errorMessage
    def set_errorMessage(self, errorMessage):
        self.errorMessage = errorMessage
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def _hasContent(self):
        if (
            self.errorCode is not None or
            self.errorMessage is not None or
            self.statusCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultCancelSkybill', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resultCancelSkybill')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'resultCancelSkybill':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='resultCancelSkybill')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='resultCancelSkybill', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='resultCancelSkybill'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultCancelSkybill', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.errorCode is not None:
            namespaceprefix_ = self.errorCode_nsprefix_ + ':' if (UseCapturedNS_ and self.errorCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorCode>%s</%serrorCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.errorCode, input_name='errorCode'), namespaceprefix_ , eol_))
        if self.errorMessage is not None:
            namespaceprefix_ = self.errorMessage_nsprefix_ + ':' if (UseCapturedNS_ and self.errorMessage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorMessage>%s</%serrorMessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.errorMessage), input_name='errorMessage')), namespaceprefix_ , eol_))
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatusCode>%s</%sstatusCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.statusCode, input_name='statusCode'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'errorCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'errorCode')
            ival_ = self.gds_validate_integer(ival_, node, 'errorCode')
            self.errorCode = ival_
            self.errorCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'errorMessage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'errorMessage')
            value_ = self.gds_validate_string(value_, node, 'errorMessage')
            self.errorMessage = value_
            self.errorMessage_nsprefix_ = child_.prefix
        elif nodeName_ == 'statusCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'statusCode')
            ival_ = self.gds_validate_integer(ival_, node, 'statusCode')
            self.statusCode = ival_
            self.statusCode_nsprefix_ = child_.prefix
# end class resultCancelSkybill


class trackWithSenderRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, accountNumber=None, password=None, language=None, sendersRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accountNumber = accountNumber
        self.accountNumber_nsprefix_ = None
        self.password = password
        self.password_nsprefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.sendersRef = sendersRef
        self.sendersRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackWithSenderRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackWithSenderRef.subclass:
            return trackWithSenderRef.subclass(*args_, **kwargs_)
        else:
            return trackWithSenderRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accountNumber(self):
        return self.accountNumber
    def set_accountNumber(self, accountNumber):
        self.accountNumber = accountNumber
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_sendersRef(self):
        return self.sendersRef
    def set_sendersRef(self, sendersRef):
        self.sendersRef = sendersRef
    def _hasContent(self):
        if (
            self.accountNumber is not None or
            self.password is not None or
            self.language is not None or
            self.sendersRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackWithSenderRef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackWithSenderRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackWithSenderRef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackWithSenderRef')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackWithSenderRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackWithSenderRef'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackWithSenderRef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accountNumber is not None:
            namespaceprefix_ = self.accountNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.accountNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccountNumber>%s</%saccountNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.accountNumber), input_name='accountNumber')), namespaceprefix_ , eol_))
        if self.password is not None:
            namespaceprefix_ = self.password_nsprefix_ + ':' if (UseCapturedNS_ and self.password_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespaceprefix_ , eol_))
        if self.sendersRef is not None:
            namespaceprefix_ = self.sendersRef_nsprefix_ + ':' if (UseCapturedNS_ and self.sendersRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssendersRef>%s</%ssendersRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.sendersRef), input_name='sendersRef')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accountNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'accountNumber')
            value_ = self.gds_validate_string(value_, node, 'accountNumber')
            self.accountNumber = value_
            self.accountNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'password':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'password')
            value_ = self.gds_validate_string(value_, node, 'password')
            self.password = value_
            self.password_nsprefix_ = child_.prefix
        elif nodeName_ == 'language':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'language')
            value_ = self.gds_validate_string(value_, node, 'language')
            self.language = value_
            self.language_nsprefix_ = child_.prefix
        elif nodeName_ == 'sendersRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sendersRef')
            value_ = self.gds_validate_string(value_, node, 'sendersRef')
            self.sendersRef = value_
            self.sendersRef_nsprefix_ = child_.prefix
# end class trackWithSenderRef


class trackWithSenderRefResponse(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, return_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.return_ = return_
        self.return__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackWithSenderRefResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackWithSenderRefResponse.subclass:
            return trackWithSenderRefResponse.subclass(*args_, **kwargs_)
        else:
            return trackWithSenderRefResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_return(self):
        return self.return_
    def set_return(self, return_):
        self.return_ = return_
    def _hasContent(self):
        if (
            self.return_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackWithSenderRefResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackWithSenderRefResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackWithSenderRefResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackWithSenderRefResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackWithSenderRefResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackWithSenderRefResponse'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackWithSenderRefResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.return_ is not None:
            namespaceprefix_ = self.return__nsprefix_ + ':' if (UseCapturedNS_ and self.return__nsprefix_) else ''
            self.return_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='return', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'return':
            obj_ = resultTrackWithSenderRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.return_ = obj_
            obj_.original_tagname_ = 'return'
# end class trackWithSenderRefResponse


class resultTrackWithSenderRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, errorCode=None, errorMessage=None, listParcel=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.errorCode = errorCode
        self.errorCode_nsprefix_ = None
        self.errorMessage = errorMessage
        self.errorMessage_nsprefix_ = None
        if listParcel is None:
            self.listParcel = []
        else:
            self.listParcel = listParcel
        self.listParcel_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resultTrackWithSenderRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resultTrackWithSenderRef.subclass:
            return resultTrackWithSenderRef.subclass(*args_, **kwargs_)
        else:
            return resultTrackWithSenderRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_errorCode(self):
        return self.errorCode
    def set_errorCode(self, errorCode):
        self.errorCode = errorCode
    def get_errorMessage(self):
        return self.errorMessage
    def set_errorMessage(self, errorMessage):
        self.errorMessage = errorMessage
    def get_listParcel(self):
        return self.listParcel
    def set_listParcel(self, listParcel):
        self.listParcel = listParcel
    def add_listParcel(self, value):
        self.listParcel.append(value)
    def insert_listParcel_at(self, index, value):
        self.listParcel.insert(index, value)
    def replace_listParcel_at(self, index, value):
        self.listParcel[index] = value
    def _hasContent(self):
        if (
            self.errorCode is not None or
            self.errorMessage is not None or
            self.listParcel
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultTrackWithSenderRef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resultTrackWithSenderRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'resultTrackWithSenderRef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='resultTrackWithSenderRef')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='resultTrackWithSenderRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='resultTrackWithSenderRef'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultTrackWithSenderRef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.errorCode is not None:
            namespaceprefix_ = self.errorCode_nsprefix_ + ':' if (UseCapturedNS_ and self.errorCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorCode>%s</%serrorCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.errorCode, input_name='errorCode'), namespaceprefix_ , eol_))
        if self.errorMessage is not None:
            namespaceprefix_ = self.errorMessage_nsprefix_ + ':' if (UseCapturedNS_ and self.errorMessage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorMessage>%s</%serrorMessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.errorMessage), input_name='errorMessage')), namespaceprefix_ , eol_))
        for listParcel_ in self.listParcel:
            namespaceprefix_ = self.listParcel_nsprefix_ + ':' if (UseCapturedNS_ and self.listParcel_nsprefix_) else ''
            listParcel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='listParcel', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'errorCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'errorCode')
            ival_ = self.gds_validate_integer(ival_, node, 'errorCode')
            self.errorCode = ival_
            self.errorCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'errorMessage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'errorMessage')
            value_ = self.gds_validate_string(value_, node, 'errorMessage')
            self.errorMessage = value_
            self.errorMessage_nsprefix_ = child_.prefix
        elif nodeName_ == 'listParcel':
            obj_ = listEvents.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.listParcel.append(obj_)
            obj_.original_tagname_ = 'listParcel'
# end class resultTrackWithSenderRef


class listEvents(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, events=None, skybillNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if events is None:
            self.events = []
        else:
            self.events = events
        self.events_nsprefix_ = None
        self.skybillNumber = skybillNumber
        self.skybillNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listEvents)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listEvents.subclass:
            return listEvents.subclass(*args_, **kwargs_)
        else:
            return listEvents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_events(self):
        return self.events
    def set_events(self, events):
        self.events = events
    def add_events(self, value):
        self.events.append(value)
    def insert_events_at(self, index, value):
        self.events.insert(index, value)
    def replace_events_at(self, index, value):
        self.events[index] = value
    def get_skybillNumber(self):
        return self.skybillNumber
    def set_skybillNumber(self, skybillNumber):
        self.skybillNumber = skybillNumber
    def _hasContent(self):
        if (
            self.events or
            self.skybillNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listEvents', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listEvents')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'listEvents':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listEvents')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listEvents', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listEvents'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listEvents', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for events_ in self.events:
            namespaceprefix_ = self.events_nsprefix_ + ':' if (UseCapturedNS_ and self.events_nsprefix_) else ''
            events_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='events', pretty_print=pretty_print)
        if self.skybillNumber is not None:
            namespaceprefix_ = self.skybillNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.skybillNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sskybillNumber>%s</%sskybillNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.skybillNumber), input_name='skybillNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'events':
            class_obj_ = self.get_class_obj_(child_, event)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.events.append(obj_)
            obj_.original_tagname_ = 'events'
        elif nodeName_ == 'skybillNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'skybillNumber')
            value_ = self.gds_validate_string(value_, node, 'skybillNumber')
            self.skybillNumber = value_
            self.skybillNumber_nsprefix_ = child_.prefix
# end class listEvents


class trackSkybillV2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, language=None, skybillNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.skybillNumber = skybillNumber
        self.skybillNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackSkybillV2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackSkybillV2.subclass:
            return trackSkybillV2.subclass(*args_, **kwargs_)
        else:
            return trackSkybillV2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_skybillNumber(self):
        return self.skybillNumber
    def set_skybillNumber(self, skybillNumber):
        self.skybillNumber = skybillNumber
    def _hasContent(self):
        if (
            self.language is not None or
            self.skybillNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackSkybillV2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackSkybillV2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackSkybillV2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackSkybillV2')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackSkybillV2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackSkybillV2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackSkybillV2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespaceprefix_ , eol_))
        if self.skybillNumber is not None:
            namespaceprefix_ = self.skybillNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.skybillNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sskybillNumber>%s</%sskybillNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.skybillNumber), input_name='skybillNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'language':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'language')
            value_ = self.gds_validate_string(value_, node, 'language')
            self.language = value_
            self.language_nsprefix_ = child_.prefix
        elif nodeName_ == 'skybillNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'skybillNumber')
            value_ = self.gds_validate_string(value_, node, 'skybillNumber')
            self.skybillNumber = value_
            self.skybillNumber_nsprefix_ = child_.prefix
# end class trackSkybillV2


class trackSkybillV2Response(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, return_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.return_ = return_
        self.return__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackSkybillV2Response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackSkybillV2Response.subclass:
            return trackSkybillV2Response.subclass(*args_, **kwargs_)
        else:
            return trackSkybillV2Response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_return(self):
        return self.return_
    def set_return(self, return_):
        self.return_ = return_
    def _hasContent(self):
        if (
            self.return_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackSkybillV2Response', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackSkybillV2Response')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackSkybillV2Response':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackSkybillV2Response')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackSkybillV2Response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackSkybillV2Response'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackSkybillV2Response', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.return_ is not None:
            namespaceprefix_ = self.return__nsprefix_ + ':' if (UseCapturedNS_ and self.return__nsprefix_) else ''
            self.return_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='return', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'return':
            obj_ = resultTrackSkybillV2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.return_ = obj_
            obj_.original_tagname_ = 'return'
# end class trackSkybillV2Response


class trackSkybill(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, language=None, skybillNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.skybillNumber = skybillNumber
        self.skybillNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackSkybill)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackSkybill.subclass:
            return trackSkybill.subclass(*args_, **kwargs_)
        else:
            return trackSkybill(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_skybillNumber(self):
        return self.skybillNumber
    def set_skybillNumber(self, skybillNumber):
        self.skybillNumber = skybillNumber
    def _hasContent(self):
        if (
            self.language is not None or
            self.skybillNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackSkybill', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackSkybill')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackSkybill':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackSkybill')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackSkybill', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackSkybill'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackSkybill', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespaceprefix_ , eol_))
        if self.skybillNumber is not None:
            namespaceprefix_ = self.skybillNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.skybillNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sskybillNumber>%s</%sskybillNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.skybillNumber), input_name='skybillNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'language':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'language')
            value_ = self.gds_validate_string(value_, node, 'language')
            self.language = value_
            self.language_nsprefix_ = child_.prefix
        elif nodeName_ == 'skybillNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'skybillNumber')
            value_ = self.gds_validate_string(value_, node, 'skybillNumber')
            self.skybillNumber = value_
            self.skybillNumber_nsprefix_ = child_.prefix
# end class trackSkybill


class trackSkybillResponse(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, return_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.return_ = return_
        self.return__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackSkybillResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackSkybillResponse.subclass:
            return trackSkybillResponse.subclass(*args_, **kwargs_)
        else:
            return trackSkybillResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_return(self):
        return self.return_
    def set_return(self, return_):
        self.return_ = return_
    def _hasContent(self):
        if (
            self.return_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackSkybillResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackSkybillResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackSkybillResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackSkybillResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackSkybillResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackSkybillResponse'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trackSkybillResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.return_ is not None:
            namespaceprefix_ = self.return__nsprefix_ + ':' if (UseCapturedNS_ and self.return__nsprefix_) else ''
            self.return_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='return', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'return':
            obj_ = resultTrackSkybill.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.return_ = obj_
            obj_.original_tagname_ = 'return'
# end class trackSkybillResponse


class resultTrackSkybill(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, errorCode=None, errorMessage=None, listEvents=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.errorCode = errorCode
        self.errorCode_nsprefix_ = None
        self.errorMessage = errorMessage
        self.errorMessage_nsprefix_ = None
        self.listEvents = listEvents
        self.listEvents_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resultTrackSkybill)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resultTrackSkybill.subclass:
            return resultTrackSkybill.subclass(*args_, **kwargs_)
        else:
            return resultTrackSkybill(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_errorCode(self):
        return self.errorCode
    def set_errorCode(self, errorCode):
        self.errorCode = errorCode
    def get_errorMessage(self):
        return self.errorMessage
    def set_errorMessage(self, errorMessage):
        self.errorMessage = errorMessage
    def get_listEvents(self):
        return self.listEvents
    def set_listEvents(self, listEvents):
        self.listEvents = listEvents
    def _hasContent(self):
        if (
            self.errorCode is not None or
            self.errorMessage is not None or
            self.listEvents is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultTrackSkybill', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resultTrackSkybill')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'resultTrackSkybill':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='resultTrackSkybill')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='resultTrackSkybill', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='resultTrackSkybill'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultTrackSkybill', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.errorCode is not None:
            namespaceprefix_ = self.errorCode_nsprefix_ + ':' if (UseCapturedNS_ and self.errorCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorCode>%s</%serrorCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.errorCode, input_name='errorCode'), namespaceprefix_ , eol_))
        if self.errorMessage is not None:
            namespaceprefix_ = self.errorMessage_nsprefix_ + ':' if (UseCapturedNS_ and self.errorMessage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorMessage>%s</%serrorMessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.errorMessage), input_name='errorMessage')), namespaceprefix_ , eol_))
        if self.listEvents is not None:
            namespaceprefix_ = self.listEvents_nsprefix_ + ':' if (UseCapturedNS_ and self.listEvents_nsprefix_) else ''
            self.listEvents.export(outfile, level, namespaceprefix_, namespacedef_='', name_='listEvents', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'errorCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'errorCode')
            ival_ = self.gds_validate_integer(ival_, node, 'errorCode')
            self.errorCode = ival_
            self.errorCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'errorMessage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'errorMessage')
            value_ = self.gds_validate_string(value_, node, 'errorMessage')
            self.errorMessage = value_
            self.errorMessage_nsprefix_ = child_.prefix
        elif nodeName_ == 'listEvents':
            obj_ = listEvents.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.listEvents = obj_
            obj_.original_tagname_ = 'listEvents'
# end class resultTrackSkybill


class searchPODWithSenderRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, accountNumber=None, password=None, language=None, sendersRef=None, pdf=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accountNumber = accountNumber
        self.accountNumber_nsprefix_ = None
        self.password = password
        self.password_nsprefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.sendersRef = sendersRef
        self.sendersRef_nsprefix_ = None
        self.pdf = pdf
        self.pdf_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, searchPODWithSenderRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if searchPODWithSenderRef.subclass:
            return searchPODWithSenderRef.subclass(*args_, **kwargs_)
        else:
            return searchPODWithSenderRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accountNumber(self):
        return self.accountNumber
    def set_accountNumber(self, accountNumber):
        self.accountNumber = accountNumber
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_sendersRef(self):
        return self.sendersRef
    def set_sendersRef(self, sendersRef):
        self.sendersRef = sendersRef
    def get_pdf(self):
        return self.pdf
    def set_pdf(self, pdf):
        self.pdf = pdf
    def _hasContent(self):
        if (
            self.accountNumber is not None or
            self.password is not None or
            self.language is not None or
            self.sendersRef is not None or
            self.pdf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='searchPODWithSenderRef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('searchPODWithSenderRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'searchPODWithSenderRef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='searchPODWithSenderRef')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='searchPODWithSenderRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='searchPODWithSenderRef'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='searchPODWithSenderRef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accountNumber is not None:
            namespaceprefix_ = self.accountNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.accountNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccountNumber>%s</%saccountNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.accountNumber), input_name='accountNumber')), namespaceprefix_ , eol_))
        if self.password is not None:
            namespaceprefix_ = self.password_nsprefix_ + ':' if (UseCapturedNS_ and self.password_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespaceprefix_ , eol_))
        if self.sendersRef is not None:
            namespaceprefix_ = self.sendersRef_nsprefix_ + ':' if (UseCapturedNS_ and self.sendersRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssendersRef>%s</%ssendersRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.sendersRef), input_name='sendersRef')), namespaceprefix_ , eol_))
        if self.pdf is not None:
            namespaceprefix_ = self.pdf_nsprefix_ + ':' if (UseCapturedNS_ and self.pdf_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spdf>%s</%spdf>%s' % (namespaceprefix_ , self.gds_format_boolean(self.pdf, input_name='pdf'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accountNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'accountNumber')
            value_ = self.gds_validate_string(value_, node, 'accountNumber')
            self.accountNumber = value_
            self.accountNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'password':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'password')
            value_ = self.gds_validate_string(value_, node, 'password')
            self.password = value_
            self.password_nsprefix_ = child_.prefix
        elif nodeName_ == 'language':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'language')
            value_ = self.gds_validate_string(value_, node, 'language')
            self.language = value_
            self.language_nsprefix_ = child_.prefix
        elif nodeName_ == 'sendersRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sendersRef')
            value_ = self.gds_validate_string(value_, node, 'sendersRef')
            self.sendersRef = value_
            self.sendersRef_nsprefix_ = child_.prefix
        elif nodeName_ == 'pdf':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'pdf')
            ival_ = self.gds_validate_boolean(ival_, node, 'pdf')
            self.pdf = ival_
            self.pdf_nsprefix_ = child_.prefix
# end class searchPODWithSenderRef


class searchPODWithSenderRefResponse(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, return_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.return_ = return_
        self.return__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, searchPODWithSenderRefResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if searchPODWithSenderRefResponse.subclass:
            return searchPODWithSenderRefResponse.subclass(*args_, **kwargs_)
        else:
            return searchPODWithSenderRefResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_return(self):
        return self.return_
    def set_return(self, return_):
        self.return_ = return_
    def _hasContent(self):
        if (
            self.return_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='searchPODWithSenderRefResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('searchPODWithSenderRefResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'searchPODWithSenderRefResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='searchPODWithSenderRefResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='searchPODWithSenderRefResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='searchPODWithSenderRefResponse'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='searchPODWithSenderRefResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.return_ is not None:
            namespaceprefix_ = self.return__nsprefix_ + ':' if (UseCapturedNS_ and self.return__nsprefix_) else ''
            self.return_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='return', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'return':
            obj_ = resultSearchPODWithSenderRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.return_ = obj_
            obj_.original_tagname_ = 'return'
# end class searchPODWithSenderRefResponse


class resultSearchPODWithSenderRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, errorCode=None, errorMessage=None, listParcelPOD=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.errorCode = errorCode
        self.errorCode_nsprefix_ = None
        self.errorMessage = errorMessage
        self.errorMessage_nsprefix_ = None
        if listParcelPOD is None:
            self.listParcelPOD = []
        else:
            self.listParcelPOD = listParcelPOD
        self.listParcelPOD_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resultSearchPODWithSenderRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resultSearchPODWithSenderRef.subclass:
            return resultSearchPODWithSenderRef.subclass(*args_, **kwargs_)
        else:
            return resultSearchPODWithSenderRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_errorCode(self):
        return self.errorCode
    def set_errorCode(self, errorCode):
        self.errorCode = errorCode
    def get_errorMessage(self):
        return self.errorMessage
    def set_errorMessage(self, errorMessage):
        self.errorMessage = errorMessage
    def get_listParcelPOD(self):
        return self.listParcelPOD
    def set_listParcelPOD(self, listParcelPOD):
        self.listParcelPOD = listParcelPOD
    def add_listParcelPOD(self, value):
        self.listParcelPOD.append(value)
    def insert_listParcelPOD_at(self, index, value):
        self.listParcelPOD.insert(index, value)
    def replace_listParcelPOD_at(self, index, value):
        self.listParcelPOD[index] = value
    def _hasContent(self):
        if (
            self.errorCode is not None or
            self.errorMessage is not None or
            self.listParcelPOD
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultSearchPODWithSenderRef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resultSearchPODWithSenderRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'resultSearchPODWithSenderRef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='resultSearchPODWithSenderRef')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='resultSearchPODWithSenderRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='resultSearchPODWithSenderRef'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='resultSearchPODWithSenderRef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.errorCode is not None:
            namespaceprefix_ = self.errorCode_nsprefix_ + ':' if (UseCapturedNS_ and self.errorCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorCode>%s</%serrorCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.errorCode, input_name='errorCode'), namespaceprefix_ , eol_))
        if self.errorMessage is not None:
            namespaceprefix_ = self.errorMessage_nsprefix_ + ':' if (UseCapturedNS_ and self.errorMessage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorMessage>%s</%serrorMessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.errorMessage), input_name='errorMessage')), namespaceprefix_ , eol_))
        for listParcelPOD_ in self.listParcelPOD:
            namespaceprefix_ = self.listParcelPOD_nsprefix_ + ':' if (UseCapturedNS_ and self.listParcelPOD_nsprefix_) else ''
            listParcelPOD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='listParcelPOD', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'errorCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'errorCode')
            ival_ = self.gds_validate_integer(ival_, node, 'errorCode')
            self.errorCode = ival_
            self.errorCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'errorMessage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'errorMessage')
            value_ = self.gds_validate_string(value_, node, 'errorMessage')
            self.errorMessage = value_
            self.errorMessage_nsprefix_ = child_.prefix
        elif nodeName_ == 'listParcelPOD':
            obj_ = parcelPOD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.listParcelPOD.append(obj_)
            obj_.original_tagname_ = 'listParcelPOD'
# end class resultSearchPODWithSenderRef


class parcelPOD(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, formatPOD=None, pod=None, podPresente=None, skybillNumber=None, statusCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.formatPOD = formatPOD
        self.formatPOD_nsprefix_ = None
        self.pod = pod
        self.pod_nsprefix_ = None
        self.podPresente = podPresente
        self.podPresente_nsprefix_ = None
        self.skybillNumber = skybillNumber
        self.skybillNumber_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parcelPOD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parcelPOD.subclass:
            return parcelPOD.subclass(*args_, **kwargs_)
        else:
            return parcelPOD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_formatPOD(self):
        return self.formatPOD
    def set_formatPOD(self, formatPOD):
        self.formatPOD = formatPOD
    def get_pod(self):
        return self.pod
    def set_pod(self, pod):
        self.pod = pod
    def get_podPresente(self):
        return self.podPresente
    def set_podPresente(self, podPresente):
        self.podPresente = podPresente
    def get_skybillNumber(self):
        return self.skybillNumber
    def set_skybillNumber(self, skybillNumber):
        self.skybillNumber = skybillNumber
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def _hasContent(self):
        if (
            self.formatPOD is not None or
            self.pod is not None or
            self.podPresente is not None or
            self.skybillNumber is not None or
            self.statusCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='parcelPOD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parcelPOD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'parcelPOD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parcelPOD')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='parcelPOD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='parcelPOD'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='parcelPOD', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.formatPOD is not None:
            namespaceprefix_ = self.formatPOD_nsprefix_ + ':' if (UseCapturedNS_ and self.formatPOD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformatPOD>%s</%sformatPOD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.formatPOD), input_name='formatPOD')), namespaceprefix_ , eol_))
        if self.pod is not None:
            namespaceprefix_ = self.pod_nsprefix_ + ':' if (UseCapturedNS_ and self.pod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spod>%s</%spod>%s' % (namespaceprefix_ , self.gds_format_base64(self.pod, input_name='pod'), namespaceprefix_ , eol_))
        if self.podPresente is not None:
            namespaceprefix_ = self.podPresente_nsprefix_ + ':' if (UseCapturedNS_ and self.podPresente_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spodPresente>%s</%spodPresente>%s' % (namespaceprefix_ , self.gds_format_boolean(self.podPresente, input_name='podPresente'), namespaceprefix_ , eol_))
        if self.skybillNumber is not None:
            namespaceprefix_ = self.skybillNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.skybillNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sskybillNumber>%s</%sskybillNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.skybillNumber), input_name='skybillNumber')), namespaceprefix_ , eol_))
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatusCode>%s</%sstatusCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.statusCode, input_name='statusCode'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'formatPOD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'formatPOD')
            value_ = self.gds_validate_string(value_, node, 'formatPOD')
            self.formatPOD = value_
            self.formatPOD_nsprefix_ = child_.prefix
        elif nodeName_ == 'pod':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'pod')
            else:
                bval_ = None
            self.pod = bval_
            self.pod_nsprefix_ = child_.prefix
        elif nodeName_ == 'podPresente':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'podPresente')
            ival_ = self.gds_validate_boolean(ival_, node, 'podPresente')
            self.podPresente = ival_
            self.podPresente_nsprefix_ = child_.prefix
        elif nodeName_ == 'skybillNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'skybillNumber')
            value_ = self.gds_validate_string(value_, node, 'skybillNumber')
            self.skybillNumber = value_
            self.skybillNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'statusCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'statusCode')
            ival_ = self.gds_validate_integer(ival_, node, 'statusCode')
            self.statusCode = ival_
            self.statusCode_nsprefix_ = child_.prefix
# end class parcelPOD


class eventInfoComp(event):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = event
    def __init__(self, code=None, eventDate=None, eventLabel=None, highPriority=None, NPC=None, officeLabel=None, zipCode=None, infoCompList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("eventInfoComp"), self).__init__(code, eventDate, eventLabel, highPriority, NPC, officeLabel, zipCode,  **kwargs_)
        if infoCompList is None:
            self.infoCompList = []
        else:
            self.infoCompList = infoCompList
        self.infoCompList_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eventInfoComp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eventInfoComp.subclass:
            return eventInfoComp.subclass(*args_, **kwargs_)
        else:
            return eventInfoComp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_infoCompList(self):
        return self.infoCompList
    def set_infoCompList(self, infoCompList):
        self.infoCompList = infoCompList
    def add_infoCompList(self, value):
        self.infoCompList.append(value)
    def insert_infoCompList_at(self, index, value):
        self.infoCompList.insert(index, value)
    def replace_infoCompList_at(self, index, value):
        self.infoCompList[index] = value
    def _hasContent(self):
        if (
            self.infoCompList or
            super(eventInfoComp, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='eventInfoComp', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('eventInfoComp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'eventInfoComp':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='eventInfoComp')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='eventInfoComp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='eventInfoComp'):
        super(eventInfoComp, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='eventInfoComp')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='eventInfoComp', fromsubclass_=False, pretty_print=True):
        super(eventInfoComp, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for infoCompList_ in self.infoCompList:
            namespaceprefix_ = self.infoCompList_nsprefix_ + ':' if (UseCapturedNS_ and self.infoCompList_nsprefix_) else ''
            infoCompList_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infoCompList', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(eventInfoComp, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'infoCompList':
            obj_ = infoComp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infoCompList.append(obj_)
            obj_.original_tagname_ = 'infoCompList'
        super(eventInfoComp, self)._buildChildren(child_, node, nodeName_, True)
# end class eventInfoComp


GDSClassesMapping = {
    'cancelListSkybill': cancelListSkybill,
    'cancelListSkybillResponse': cancelListSkybillResponse,
    'cancelSkybill': cancelSkybill,
    'cancelSkybillResponse': cancelSkybillResponse,
    'searchPOD': searchPOD,
    'searchPODResponse': searchPODResponse,
    'searchPODWithSenderRef': searchPODWithSenderRef,
    'searchPODWithSenderRefResponse': searchPODWithSenderRefResponse,
    'trackESD': trackESD,
    'trackESDResponse': trackESDResponse,
    'trackSearch': trackSearch,
    'trackSearchResponse': trackSearchResponse,
    'trackSkybill': trackSkybill,
    'trackSkybillResponse': trackSkybillResponse,
    'trackSkybillV2': trackSkybillV2,
    'trackSkybillV2Response': trackSkybillV2Response,
    'trackWithSenderRef': trackWithSenderRef,
    'trackWithSenderRefResponse': trackWithSenderRefResponse,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cancelListSkybill'
        rootClass = cancelListSkybill
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cancelListSkybill'
        rootClass = cancelListSkybill
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cancelListSkybill'
        rootClass = cancelListSkybill
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:tns="http://cxf.tracking.soap.chronopost.fr/"')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cancelListSkybill'
        rootClass = cancelListSkybill
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from trackingservice import *\n\n')
        sys.stdout.write('import trackingservice as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://cxf.tracking.soap.chronopost.fr/': [('cancelListSkybill',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('cancelListSkybillResponse',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('resultListCancelSkybill',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('trackESD',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('trackESDResponse',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('resultTrackSkybillV2',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('listEventInfoComps',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('eventInfoComp',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('event',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('infoComp',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('trackSearch',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('trackSearchResponse',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('resultTrackSearch',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('infosPOD',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('searchPOD',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('searchPODResponse',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('resultSearchPOD',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('cancelSkybill',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('cancelSkybillResponse',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('resultCancelSkybill',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('trackWithSenderRef',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('trackWithSenderRefResponse',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('resultTrackWithSenderRef',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('listEvents',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('trackSkybillV2',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('trackSkybillV2Response',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('trackSkybill',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('trackSkybillResponse',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('resultTrackSkybill',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('searchPODWithSenderRef',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('searchPODWithSenderRefResponse',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('resultSearchPODWithSenderRef',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT'),
                                             ('parcelPOD',
                                              './schemas/TrackingServiceWS.xml',
                                              'CT')]}

__all__ = [
    "cancelListSkybill",
    "cancelListSkybillResponse",
    "cancelSkybill",
    "cancelSkybillResponse",
    "event",
    "eventInfoComp",
    "infoComp",
    "infosPOD",
    "listEventInfoComps",
    "listEvents",
    "parcelPOD",
    "resultCancelSkybill",
    "resultListCancelSkybill",
    "resultSearchPOD",
    "resultSearchPODWithSenderRef",
    "resultTrackSearch",
    "resultTrackSkybill",
    "resultTrackSkybillV2",
    "resultTrackWithSenderRef",
    "searchPOD",
    "searchPODResponse",
    "searchPODWithSenderRef",
    "searchPODWithSenderRefResponse",
    "trackESD",
    "trackESDResponse",
    "trackSearch",
    "trackSearchResponse",
    "trackSkybill",
    "trackSkybillResponse",
    "trackSkybillV2",
    "trackSkybillV2Response",
    "trackWithSenderRef",
    "trackWithSenderRefResponse"
]
