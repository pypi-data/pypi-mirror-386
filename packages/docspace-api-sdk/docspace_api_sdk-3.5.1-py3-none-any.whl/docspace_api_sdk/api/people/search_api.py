#
# (c) Copyright Ascensio System SIA 2025
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


from __future__ import annotations
import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from docspace_api_sdk.models.account_login_type import AccountLoginType
from docspace_api_sdk.models.area import Area
from docspace_api_sdk.models.employee_activation_status import EmployeeActivationStatus
from docspace_api_sdk.models.employee_array_wrapper import EmployeeArrayWrapper
from docspace_api_sdk.models.employee_full_array_wrapper import EmployeeFullArrayWrapper
from docspace_api_sdk.models.employee_status import EmployeeStatus
from docspace_api_sdk.models.employee_type import EmployeeType
from docspace_api_sdk.models.object_array_wrapper import ObjectArrayWrapper
from docspace_api_sdk.models.payments import Payments
from docspace_api_sdk.models.quota_filter import QuotaFilter
from docspace_api_sdk.models.sort_order import SortOrder

from docspace_api_sdk.api_client import ApiClient, RequestSerialized
from docspace_api_sdk.api_response import ApiResponse
from docspace_api_sdk.rest import RESTResponseType


class SearchApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client
        self._fields = None

    def with_fields(self, fields: str) -> SearchApi:
        self._fields = fields
        return self


    @validate_call
    def get_accounts_entries_with_files_shared(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the account sharing settings from the response.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the account sharing settings in the response.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The area of the account entries.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of the user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of items to retrieve in a request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting index for the query results.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Specifies the separator used in filter expressions.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text filter applied to the accounts search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObjectArrayWrapper:
        """Get account entries with file sharing settings

        Returns the account entries with their sharing settings for a file with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the account sharing settings from the response.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the account sharing settings in the response.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The area of the account entries.
        :type area: Area
        :param employee_types: The list of the user types.
        :type employee_types: List[EmployeeType]
        :param count: The number of items to retrieve in a request.
        :type count: int
        :param start_index: The starting index for the query results.
        :type start_index: int
        :param filter_separator: Specifies the separator used in filter expressions.
        :type filter_separator: str
        :param filter_value: The text filter applied to the accounts search query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_accounts_entries_with_files_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_accounts_entries_with_files_shared_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the account sharing settings from the response.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the account sharing settings in the response.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The area of the account entries.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of the user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of items to retrieve in a request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting index for the query results.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Specifies the separator used in filter expressions.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text filter applied to the accounts search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObjectArrayWrapper]:
        """Get account entries with file sharing settings

        Returns the account entries with their sharing settings for a file with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the account sharing settings from the response.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the account sharing settings in the response.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The area of the account entries.
        :type area: Area
        :param employee_types: The list of the user types.
        :type employee_types: List[EmployeeType]
        :param count: The number of items to retrieve in a request.
        :type count: int
        :param start_index: The starting index for the query results.
        :type start_index: int
        :param filter_separator: Specifies the separator used in filter expressions.
        :type filter_separator: str
        :param filter_value: The text filter applied to the accounts search query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_accounts_entries_with_files_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_accounts_entries_with_files_shared_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the account sharing settings from the response.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the account sharing settings in the response.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The area of the account entries.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of the user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of items to retrieve in a request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting index for the query results.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Specifies the separator used in filter expressions.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text filter applied to the accounts search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get account entries with file sharing settings

        Returns the account entries with their sharing settings for a file with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the account sharing settings from the response.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the account sharing settings in the response.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The area of the account entries.
        :type area: Area
        :param employee_types: The list of the user types.
        :type employee_types: List[EmployeeType]
        :param count: The number of items to retrieve in a request.
        :type count: int
        :param start_index: The starting index for the query results.
        :type start_index: int
        :param filter_separator: Specifies the separator used in filter expressions.
        :type filter_separator: str
        :param filter_value: The text filter applied to the accounts search query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_accounts_entries_with_files_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_accounts_entries_with_files_shared_serialize(
        self,
        id,
        employee_status,
        activation_status,
        exclude_shared,
        include_shared,
        invited_by_me,
        inviter_id,
        area,
        employee_types,
        count,
        start_index,
        filter_separator,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'employeeTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if employee_status is not None:
            
            _query_params.append(('employeeStatus', employee_status.value))
            
        if activation_status is not None:
            
            _query_params.append(('activationStatus', activation_status.value))
            
        if exclude_shared is not None:
            
            _query_params.append(('excludeShared', exclude_shared))
            
        if include_shared is not None:
            
            _query_params.append(('includeShared', include_shared))
            
        if invited_by_me is not None:
            
            _query_params.append(('invitedByMe', invited_by_me))
            
        if inviter_id is not None:
            
            _query_params.append(('inviterId', inviter_id))
            
        if area is not None:
            
            _query_params.append(('area', area.value))
            
        if employee_types is not None:
            
            _query_params.append(('employeeTypes', employee_types))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if filter_separator is not None:
            
            _query_params.append(('filterSeparator', filter_separator))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/accounts/file/{id}/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_accounts_entries_with_folders_shared(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the account sharing settings from the response.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the account sharing settings in the response.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The area of the account entries.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of the user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of items to retrieve in a request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting index for the query results.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Specifies the separator used in filter expressions.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text filter applied to the accounts search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObjectArrayWrapper:
        """Get account entries with folder sharing settings

        Returns the account entries with their sharing settings in a folder with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the account sharing settings from the response.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the account sharing settings in the response.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The area of the account entries.
        :type area: Area
        :param employee_types: The list of the user types.
        :type employee_types: List[EmployeeType]
        :param count: The number of items to retrieve in a request.
        :type count: int
        :param start_index: The starting index for the query results.
        :type start_index: int
        :param filter_separator: Specifies the separator used in filter expressions.
        :type filter_separator: str
        :param filter_value: The text filter applied to the accounts search query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_accounts_entries_with_folders_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_accounts_entries_with_folders_shared_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the account sharing settings from the response.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the account sharing settings in the response.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The area of the account entries.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of the user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of items to retrieve in a request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting index for the query results.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Specifies the separator used in filter expressions.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text filter applied to the accounts search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObjectArrayWrapper]:
        """Get account entries with folder sharing settings

        Returns the account entries with their sharing settings in a folder with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the account sharing settings from the response.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the account sharing settings in the response.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The area of the account entries.
        :type area: Area
        :param employee_types: The list of the user types.
        :type employee_types: List[EmployeeType]
        :param count: The number of items to retrieve in a request.
        :type count: int
        :param start_index: The starting index for the query results.
        :type start_index: int
        :param filter_separator: Specifies the separator used in filter expressions.
        :type filter_separator: str
        :param filter_value: The text filter applied to the accounts search query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_accounts_entries_with_folders_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_accounts_entries_with_folders_shared_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the account sharing settings from the response.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the account sharing settings in the response.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The area of the account entries.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of the user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of items to retrieve in a request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting index for the query results.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Specifies the separator used in filter expressions.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text filter applied to the accounts search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get account entries with folder sharing settings

        Returns the account entries with their sharing settings in a folder with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the account sharing settings from the response.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the account sharing settings in the response.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The area of the account entries.
        :type area: Area
        :param employee_types: The list of the user types.
        :type employee_types: List[EmployeeType]
        :param count: The number of items to retrieve in a request.
        :type count: int
        :param start_index: The starting index for the query results.
        :type start_index: int
        :param filter_separator: Specifies the separator used in filter expressions.
        :type filter_separator: str
        :param filter_value: The text filter applied to the accounts search query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_accounts_entries_with_folders_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_accounts_entries_with_folders_shared_serialize(
        self,
        id,
        employee_status,
        activation_status,
        exclude_shared,
        include_shared,
        invited_by_me,
        inviter_id,
        area,
        employee_types,
        count,
        start_index,
        filter_separator,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'employeeTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if employee_status is not None:
            
            _query_params.append(('employeeStatus', employee_status.value))
            
        if activation_status is not None:
            
            _query_params.append(('activationStatus', activation_status.value))
            
        if exclude_shared is not None:
            
            _query_params.append(('excludeShared', exclude_shared))
            
        if include_shared is not None:
            
            _query_params.append(('includeShared', include_shared))
            
        if invited_by_me is not None:
            
            _query_params.append(('invitedByMe', invited_by_me))
            
        if inviter_id is not None:
            
            _query_params.append(('inviterId', inviter_id))
            
        if area is not None:
            
            _query_params.append(('area', area.value))
            
        if employee_types is not None:
            
            _query_params.append(('employeeTypes', employee_types))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if filter_separator is not None:
            
            _query_params.append(('filterSeparator', filter_separator))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/accounts/folder/{id}/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_accounts_entries_with_rooms_shared(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the account sharing settings from the response.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the account sharing settings in the response.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The area of the account entries.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of the user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of items to retrieve in a request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting index for the query results.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Specifies the separator used in filter expressions.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text filter applied to the accounts search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObjectArrayWrapper:
        """Get account entries

        Returns the account entries with their sharing settings in a room with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the account sharing settings from the response.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the account sharing settings in the response.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The area of the account entries.
        :type area: Area
        :param employee_types: The list of the user types.
        :type employee_types: List[EmployeeType]
        :param count: The number of items to retrieve in a request.
        :type count: int
        :param start_index: The starting index for the query results.
        :type start_index: int
        :param filter_separator: Specifies the separator used in filter expressions.
        :type filter_separator: str
        :param filter_value: The text filter applied to the accounts search query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_accounts_entries_with_rooms_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_accounts_entries_with_rooms_shared_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the account sharing settings from the response.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the account sharing settings in the response.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The area of the account entries.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of the user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of items to retrieve in a request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting index for the query results.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Specifies the separator used in filter expressions.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text filter applied to the accounts search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObjectArrayWrapper]:
        """Get account entries

        Returns the account entries with their sharing settings in a room with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the account sharing settings from the response.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the account sharing settings in the response.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The area of the account entries.
        :type area: Area
        :param employee_types: The list of the user types.
        :type employee_types: List[EmployeeType]
        :param count: The number of items to retrieve in a request.
        :type count: int
        :param start_index: The starting index for the query results.
        :type start_index: int
        :param filter_separator: Specifies the separator used in filter expressions.
        :type filter_separator: str
        :param filter_value: The text filter applied to the accounts search query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_accounts_entries_with_rooms_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_accounts_entries_with_rooms_shared_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the account sharing settings from the response.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the account sharing settings in the response.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The area of the account entries.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of the user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of items to retrieve in a request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting index for the query results.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Specifies the separator used in filter expressions.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text filter applied to the accounts search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get account entries

        Returns the account entries with their sharing settings in a room with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the account sharing settings from the response.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the account sharing settings in the response.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The area of the account entries.
        :type area: Area
        :param employee_types: The list of the user types.
        :type employee_types: List[EmployeeType]
        :param count: The number of items to retrieve in a request.
        :type count: int
        :param start_index: The starting index for the query results.
        :type start_index: int
        :param filter_separator: Specifies the separator used in filter expressions.
        :type filter_separator: str
        :param filter_value: The text filter applied to the accounts search query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_accounts_entries_with_rooms_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_accounts_entries_with_rooms_shared_serialize(
        self,
        id,
        employee_status,
        activation_status,
        exclude_shared,
        include_shared,
        invited_by_me,
        inviter_id,
        area,
        employee_types,
        count,
        start_index,
        filter_separator,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'employeeTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if employee_status is not None:
            
            _query_params.append(('employeeStatus', employee_status.value))
            
        if activation_status is not None:
            
            _query_params.append(('activationStatus', activation_status.value))
            
        if exclude_shared is not None:
            
            _query_params.append(('excludeShared', exclude_shared))
            
        if include_shared is not None:
            
            _query_params.append(('includeShared', include_shared))
            
        if invited_by_me is not None:
            
            _query_params.append(('invitedByMe', invited_by_me))
            
        if inviter_id is not None:
            
            _query_params.append(('inviterId', inviter_id))
            
        if area is not None:
            
            _query_params.append(('area', area.value))
            
        if employee_types is not None:
            
            _query_params.append(('employeeTypes', employee_types))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if filter_separator is not None:
            
            _query_params.append(('filterSeparator', filter_separator))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/accounts/room/{id}/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_search(
        self,
        query: Annotated[StrictStr, Field(description="The search query.")],
        filter_by: Annotated[Optional[StrictStr], Field(description="Specifies a filter criteria for the user search query.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The value used for filtering users, allowing additional constraints for the query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeFullArrayWrapper:
        """Search users

        Returns a list of users matching the search query.

        :param query: The search query. (required)
        :type query: str
        :param filter_by: Specifies a filter criteria for the user search query.
        :type filter_by: str
        :param filter_value: The value used for filtering users, allowing additional constraints for the query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_search_serialize(
            query=query,
            filter_by=filter_by,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_search_with_http_info(
        self,
        query: Annotated[StrictStr, Field(description="The search query.")],
        filter_by: Annotated[Optional[StrictStr], Field(description="Specifies a filter criteria for the user search query.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The value used for filtering users, allowing additional constraints for the query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeFullArrayWrapper]:
        """Search users

        Returns a list of users matching the search query.

        :param query: The search query. (required)
        :type query: str
        :param filter_by: Specifies a filter criteria for the user search query.
        :type filter_by: str
        :param filter_value: The value used for filtering users, allowing additional constraints for the query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_search_serialize(
            query=query,
            filter_by=filter_by,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_search_without_preload_content(
        self,
        query: Annotated[StrictStr, Field(description="The search query.")],
        filter_by: Annotated[Optional[StrictStr], Field(description="Specifies a filter criteria for the user search query.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The value used for filtering users, allowing additional constraints for the query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search users

        Returns a list of users matching the search query.

        :param query: The search query. (required)
        :type query: str
        :param filter_by: Specifies a filter criteria for the user search query.
        :type filter_by: str
        :param filter_value: The value used for filtering users, allowing additional constraints for the query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_search_serialize(
            query=query,
            filter_by=filter_by,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_search_serialize(
        self,
        query,
        filter_by,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if query is not None:
            _path_params['query'] = query
        # process the query parameters
        if filter_by is not None:
            
            _query_params.append(('filterBy', filter_by))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/@search/{query}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_simple_by_filter(
        self,
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="The group ID.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        employee_type: Annotated[Optional[EmployeeType], Field(description="The user type.")] = None,
        employee_types: Annotated[Optional[List[List[StrictInt]]], Field(description="The list of user types.")] = None,
        is_administrator: Annotated[Optional[StrictBool], Field(description="Specifies if the user is an administrator or not.")] = None,
        payments: Annotated[Optional[Payments], Field(description="The user payment status.")] = None,
        account_login_type: Annotated[Optional[AccountLoginType], Field(description="The account login type.")] = None,
        quota_filter: Annotated[Optional[QuotaFilter], Field(description="The quota filter (All - 0, Default - 1, Custom - 2).")] = None,
        without_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of a group or not.")] = None,
        exclude_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of the group with the specified ID.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The filter area.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to be retrieved in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first item to be retrieved in a filtered result set.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the property or field name by which the results should be sorted.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Represents the separator used to split filter criteria in query parameters.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The search text used to filter results based on user input.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeArrayWrapper:
        """Search users by extended filter

        Returns a list of users matching the parameters specified in the request.

        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param group_id: The group ID.
        :type group_id: str
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param employee_type: The user type.
        :type employee_type: EmployeeType
        :param employee_types: The list of user types.
        :type employee_types: List[int]
        :param is_administrator: Specifies if the user is an administrator or not.
        :type is_administrator: bool
        :param payments: The user payment status.
        :type payments: Payments
        :param account_login_type: The account login type.
        :type account_login_type: AccountLoginType
        :param quota_filter: The quota filter (All - 0, Default - 1, Custom - 2).
        :type quota_filter: QuotaFilter
        :param without_group: Specifies whether the user should be a member of a group or not.
        :type without_group: bool
        :param exclude_group: Specifies whether the user should be a member of the group with the specified ID.
        :type exclude_group: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The filter area.
        :type area: Area
        :param count: The maximum number of items to be retrieved in the response.
        :type count: int
        :param start_index: The zero-based index of the first item to be retrieved in a filtered result set.
        :type start_index: int
        :param sort_by: Specifies the property or field name by which the results should be sorted.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_separator: Represents the separator used to split filter criteria in query parameters.
        :type filter_separator: str
        :param filter_value: The search text used to filter results based on user input.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_simple_by_filter_serialize(
            employee_status=employee_status,
            group_id=group_id,
            activation_status=activation_status,
            employee_type=employee_type,
            employee_types=employee_types,
            is_administrator=is_administrator,
            payments=payments,
            account_login_type=account_login_type,
            quota_filter=quota_filter,
            without_group=without_group,
            exclude_group=exclude_group,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_simple_by_filter_with_http_info(
        self,
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="The group ID.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        employee_type: Annotated[Optional[EmployeeType], Field(description="The user type.")] = None,
        employee_types: Annotated[Optional[List[List[StrictInt]]], Field(description="The list of user types.")] = None,
        is_administrator: Annotated[Optional[StrictBool], Field(description="Specifies if the user is an administrator or not.")] = None,
        payments: Annotated[Optional[Payments], Field(description="The user payment status.")] = None,
        account_login_type: Annotated[Optional[AccountLoginType], Field(description="The account login type.")] = None,
        quota_filter: Annotated[Optional[QuotaFilter], Field(description="The quota filter (All - 0, Default - 1, Custom - 2).")] = None,
        without_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of a group or not.")] = None,
        exclude_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of the group with the specified ID.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The filter area.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to be retrieved in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first item to be retrieved in a filtered result set.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the property or field name by which the results should be sorted.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Represents the separator used to split filter criteria in query parameters.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The search text used to filter results based on user input.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeArrayWrapper]:
        """Search users by extended filter

        Returns a list of users matching the parameters specified in the request.

        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param group_id: The group ID.
        :type group_id: str
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param employee_type: The user type.
        :type employee_type: EmployeeType
        :param employee_types: The list of user types.
        :type employee_types: List[int]
        :param is_administrator: Specifies if the user is an administrator or not.
        :type is_administrator: bool
        :param payments: The user payment status.
        :type payments: Payments
        :param account_login_type: The account login type.
        :type account_login_type: AccountLoginType
        :param quota_filter: The quota filter (All - 0, Default - 1, Custom - 2).
        :type quota_filter: QuotaFilter
        :param without_group: Specifies whether the user should be a member of a group or not.
        :type without_group: bool
        :param exclude_group: Specifies whether the user should be a member of the group with the specified ID.
        :type exclude_group: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The filter area.
        :type area: Area
        :param count: The maximum number of items to be retrieved in the response.
        :type count: int
        :param start_index: The zero-based index of the first item to be retrieved in a filtered result set.
        :type start_index: int
        :param sort_by: Specifies the property or field name by which the results should be sorted.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_separator: Represents the separator used to split filter criteria in query parameters.
        :type filter_separator: str
        :param filter_value: The search text used to filter results based on user input.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_simple_by_filter_serialize(
            employee_status=employee_status,
            group_id=group_id,
            activation_status=activation_status,
            employee_type=employee_type,
            employee_types=employee_types,
            is_administrator=is_administrator,
            payments=payments,
            account_login_type=account_login_type,
            quota_filter=quota_filter,
            without_group=without_group,
            exclude_group=exclude_group,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_simple_by_filter_without_preload_content(
        self,
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="The group ID.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        employee_type: Annotated[Optional[EmployeeType], Field(description="The user type.")] = None,
        employee_types: Annotated[Optional[List[List[StrictInt]]], Field(description="The list of user types.")] = None,
        is_administrator: Annotated[Optional[StrictBool], Field(description="Specifies if the user is an administrator or not.")] = None,
        payments: Annotated[Optional[Payments], Field(description="The user payment status.")] = None,
        account_login_type: Annotated[Optional[AccountLoginType], Field(description="The account login type.")] = None,
        quota_filter: Annotated[Optional[QuotaFilter], Field(description="The quota filter (All - 0, Default - 1, Custom - 2).")] = None,
        without_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of a group or not.")] = None,
        exclude_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of the group with the specified ID.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The filter area.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to be retrieved in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first item to be retrieved in a filtered result set.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the property or field name by which the results should be sorted.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Represents the separator used to split filter criteria in query parameters.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The search text used to filter results based on user input.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search users by extended filter

        Returns a list of users matching the parameters specified in the request.

        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param group_id: The group ID.
        :type group_id: str
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param employee_type: The user type.
        :type employee_type: EmployeeType
        :param employee_types: The list of user types.
        :type employee_types: List[int]
        :param is_administrator: Specifies if the user is an administrator or not.
        :type is_administrator: bool
        :param payments: The user payment status.
        :type payments: Payments
        :param account_login_type: The account login type.
        :type account_login_type: AccountLoginType
        :param quota_filter: The quota filter (All - 0, Default - 1, Custom - 2).
        :type quota_filter: QuotaFilter
        :param without_group: Specifies whether the user should be a member of a group or not.
        :type without_group: bool
        :param exclude_group: Specifies whether the user should be a member of the group with the specified ID.
        :type exclude_group: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The filter area.
        :type area: Area
        :param count: The maximum number of items to be retrieved in the response.
        :type count: int
        :param start_index: The zero-based index of the first item to be retrieved in a filtered result set.
        :type start_index: int
        :param sort_by: Specifies the property or field name by which the results should be sorted.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_separator: Represents the separator used to split filter criteria in query parameters.
        :type filter_separator: str
        :param filter_value: The search text used to filter results based on user input.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_simple_by_filter_serialize(
            employee_status=employee_status,
            group_id=group_id,
            activation_status=activation_status,
            employee_type=employee_type,
            employee_types=employee_types,
            is_administrator=is_administrator,
            payments=payments,
            account_login_type=account_login_type,
            quota_filter=quota_filter,
            without_group=without_group,
            exclude_group=exclude_group,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_simple_by_filter_serialize(
        self,
        employee_status,
        group_id,
        activation_status,
        employee_type,
        employee_types,
        is_administrator,
        payments,
        account_login_type,
        quota_filter,
        without_group,
        exclude_group,
        invited_by_me,
        inviter_id,
        area,
        count,
        start_index,
        sort_by,
        sort_order,
        filter_separator,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'employeeTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if employee_status is not None:
            
            _query_params.append(('employeeStatus', employee_status.value))
            
        if group_id is not None:
            
            _query_params.append(('groupId', group_id))
            
        if activation_status is not None:
            
            _query_params.append(('activationStatus', activation_status.value))
            
        if employee_type is not None:
            
            _query_params.append(('employeeType', employee_type.value))
            
        if employee_types is not None:
            
            _query_params.append(('employeeTypes', employee_types))
            
        if is_administrator is not None:
            
            _query_params.append(('isAdministrator', is_administrator))
            
        if payments is not None:
            
            _query_params.append(('payments', payments.value))
            
        if account_login_type is not None:
            
            _query_params.append(('accountLoginType', account_login_type.value))
            
        if quota_filter is not None:
            
            _query_params.append(('quotaFilter', quota_filter.value))
            
        if without_group is not None:
            
            _query_params.append(('withoutGroup', without_group))
            
        if exclude_group is not None:
            
            _query_params.append(('excludeGroup', exclude_group))
            
        if invited_by_me is not None:
            
            _query_params.append(('invitedByMe', invited_by_me))
            
        if inviter_id is not None:
            
            _query_params.append(('inviterId', inviter_id))
            
        if area is not None:
            
            _query_params.append(('area', area.value))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order.value))
            
        if filter_separator is not None:
            
            _query_params.append(('filterSeparator', filter_separator))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        if self._fields is not None:
            _header_params['fields'] = self._fields
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/simple/filter',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_users_with_files_shared(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the user sharing settings or not.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the user sharing settings or not.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user was invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The user area.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of users to be retrieved in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first record to retrieve in a paged query.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="The character or string used to separate multiple filter values in a filtering query.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The filter text value used for searching or filtering user results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeFullArrayWrapper:
        """Get users with file sharing settings

        Returns the users with the sharing settings in a file with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the user sharing settings or not.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the user sharing settings or not.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user was invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The user area.
        :type area: Area
        :param employee_types: The list of user types.
        :type employee_types: List[EmployeeType]
        :param count: The maximum number of users to be retrieved in the request.
        :type count: int
        :param start_index: The zero-based index of the first record to retrieve in a paged query.
        :type start_index: int
        :param filter_separator: The character or string used to separate multiple filter values in a filtering query.
        :type filter_separator: str
        :param filter_value: The filter text value used for searching or filtering user results.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_users_with_files_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_users_with_files_shared_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the user sharing settings or not.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the user sharing settings or not.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user was invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The user area.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of users to be retrieved in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first record to retrieve in a paged query.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="The character or string used to separate multiple filter values in a filtering query.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The filter text value used for searching or filtering user results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeFullArrayWrapper]:
        """Get users with file sharing settings

        Returns the users with the sharing settings in a file with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the user sharing settings or not.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the user sharing settings or not.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user was invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The user area.
        :type area: Area
        :param employee_types: The list of user types.
        :type employee_types: List[EmployeeType]
        :param count: The maximum number of users to be retrieved in the request.
        :type count: int
        :param start_index: The zero-based index of the first record to retrieve in a paged query.
        :type start_index: int
        :param filter_separator: The character or string used to separate multiple filter values in a filtering query.
        :type filter_separator: str
        :param filter_value: The filter text value used for searching or filtering user results.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_users_with_files_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_users_with_files_shared_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the user sharing settings or not.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the user sharing settings or not.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user was invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The user area.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of users to be retrieved in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first record to retrieve in a paged query.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="The character or string used to separate multiple filter values in a filtering query.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The filter text value used for searching or filtering user results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get users with file sharing settings

        Returns the users with the sharing settings in a file with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the user sharing settings or not.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the user sharing settings or not.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user was invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The user area.
        :type area: Area
        :param employee_types: The list of user types.
        :type employee_types: List[EmployeeType]
        :param count: The maximum number of users to be retrieved in the request.
        :type count: int
        :param start_index: The zero-based index of the first record to retrieve in a paged query.
        :type start_index: int
        :param filter_separator: The character or string used to separate multiple filter values in a filtering query.
        :type filter_separator: str
        :param filter_value: The filter text value used for searching or filtering user results.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_users_with_files_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_users_with_files_shared_serialize(
        self,
        id,
        employee_status,
        activation_status,
        exclude_shared,
        include_shared,
        invited_by_me,
        inviter_id,
        area,
        employee_types,
        count,
        start_index,
        filter_separator,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'employeeTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if employee_status is not None:
            
            _query_params.append(('employeeStatus', employee_status.value))
            
        if activation_status is not None:
            
            _query_params.append(('activationStatus', activation_status.value))
            
        if exclude_shared is not None:
            
            _query_params.append(('excludeShared', exclude_shared))
            
        if include_shared is not None:
            
            _query_params.append(('includeShared', include_shared))
            
        if invited_by_me is not None:
            
            _query_params.append(('invitedByMe', invited_by_me))
            
        if inviter_id is not None:
            
            _query_params.append(('inviterId', inviter_id))
            
        if area is not None:
            
            _query_params.append(('area', area.value))
            
        if employee_types is not None:
            
            _query_params.append(('employeeTypes', employee_types))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if filter_separator is not None:
            
            _query_params.append(('filterSeparator', filter_separator))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/file/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_users_with_folders_shared(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the user sharing settings or not.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the user sharing settings or not.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user was invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The user area.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of users to be retrieved in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first record to retrieve in a paged query.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="The character or string used to separate multiple filter values in a filtering query.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The filter text value used for searching or filtering user results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeFullArrayWrapper:
        """Get users with folder sharing settings

        Returns the users with the sharing settings in a folder with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the user sharing settings or not.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the user sharing settings or not.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user was invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The user area.
        :type area: Area
        :param employee_types: The list of user types.
        :type employee_types: List[EmployeeType]
        :param count: The maximum number of users to be retrieved in the request.
        :type count: int
        :param start_index: The zero-based index of the first record to retrieve in a paged query.
        :type start_index: int
        :param filter_separator: The character or string used to separate multiple filter values in a filtering query.
        :type filter_separator: str
        :param filter_value: The filter text value used for searching or filtering user results.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_users_with_folders_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_users_with_folders_shared_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the user sharing settings or not.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the user sharing settings or not.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user was invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The user area.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of users to be retrieved in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first record to retrieve in a paged query.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="The character or string used to separate multiple filter values in a filtering query.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The filter text value used for searching or filtering user results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeFullArrayWrapper]:
        """Get users with folder sharing settings

        Returns the users with the sharing settings in a folder with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the user sharing settings or not.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the user sharing settings or not.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user was invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The user area.
        :type area: Area
        :param employee_types: The list of user types.
        :type employee_types: List[EmployeeType]
        :param count: The maximum number of users to be retrieved in the request.
        :type count: int
        :param start_index: The zero-based index of the first record to retrieve in a paged query.
        :type start_index: int
        :param filter_separator: The character or string used to separate multiple filter values in a filtering query.
        :type filter_separator: str
        :param filter_value: The filter text value used for searching or filtering user results.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_users_with_folders_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_users_with_folders_shared_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the user sharing settings or not.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the user sharing settings or not.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user was invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The user area.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of users to be retrieved in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first record to retrieve in a paged query.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="The character or string used to separate multiple filter values in a filtering query.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The filter text value used for searching or filtering user results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get users with folder sharing settings

        Returns the users with the sharing settings in a folder with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the user sharing settings or not.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the user sharing settings or not.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user was invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The user area.
        :type area: Area
        :param employee_types: The list of user types.
        :type employee_types: List[EmployeeType]
        :param count: The maximum number of users to be retrieved in the request.
        :type count: int
        :param start_index: The zero-based index of the first record to retrieve in a paged query.
        :type start_index: int
        :param filter_separator: The character or string used to separate multiple filter values in a filtering query.
        :type filter_separator: str
        :param filter_value: The filter text value used for searching or filtering user results.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_users_with_folders_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_users_with_folders_shared_serialize(
        self,
        id,
        employee_status,
        activation_status,
        exclude_shared,
        include_shared,
        invited_by_me,
        inviter_id,
        area,
        employee_types,
        count,
        start_index,
        filter_separator,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'employeeTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if employee_status is not None:
            
            _query_params.append(('employeeStatus', employee_status.value))
            
        if activation_status is not None:
            
            _query_params.append(('activationStatus', activation_status.value))
            
        if exclude_shared is not None:
            
            _query_params.append(('excludeShared', exclude_shared))
            
        if include_shared is not None:
            
            _query_params.append(('includeShared', include_shared))
            
        if invited_by_me is not None:
            
            _query_params.append(('invitedByMe', invited_by_me))
            
        if inviter_id is not None:
            
            _query_params.append(('inviterId', inviter_id))
            
        if area is not None:
            
            _query_params.append(('area', area.value))
            
        if employee_types is not None:
            
            _query_params.append(('employeeTypes', employee_types))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if filter_separator is not None:
            
            _query_params.append(('filterSeparator', filter_separator))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/folder/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_users_with_room_shared(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the user sharing settings or not.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the user sharing settings or not.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user was invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The user area.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of users to be retrieved in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first record to retrieve in a paged query.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="The character or string used to separate multiple filter values in a filtering query.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The filter text value used for searching or filtering user results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeFullArrayWrapper:
        """Get users with room sharing settings

        Returns the users with the sharing settings in a room with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the user sharing settings or not.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the user sharing settings or not.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user was invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The user area.
        :type area: Area
        :param employee_types: The list of user types.
        :type employee_types: List[EmployeeType]
        :param count: The maximum number of users to be retrieved in the request.
        :type count: int
        :param start_index: The zero-based index of the first record to retrieve in a paged query.
        :type start_index: int
        :param filter_separator: The character or string used to separate multiple filter values in a filtering query.
        :type filter_separator: str
        :param filter_value: The filter text value used for searching or filtering user results.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_users_with_room_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_users_with_room_shared_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the user sharing settings or not.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the user sharing settings or not.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user was invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The user area.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of users to be retrieved in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first record to retrieve in a paged query.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="The character or string used to separate multiple filter values in a filtering query.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The filter text value used for searching or filtering user results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeFullArrayWrapper]:
        """Get users with room sharing settings

        Returns the users with the sharing settings in a room with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the user sharing settings or not.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the user sharing settings or not.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user was invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The user area.
        :type area: Area
        :param employee_types: The list of user types.
        :type employee_types: List[EmployeeType]
        :param count: The maximum number of users to be retrieved in the request.
        :type count: int
        :param start_index: The zero-based index of the first record to retrieve in a paged query.
        :type start_index: int
        :param filter_separator: The character or string used to separate multiple filter values in a filtering query.
        :type filter_separator: str
        :param filter_value: The filter text value used for searching or filtering user results.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_users_with_room_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_users_with_room_shared_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The user ID.")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude the user sharing settings or not.")] = None,
        include_shared: Annotated[Optional[StrictBool], Field(description="Specifies whether to include the user sharing settings or not.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user was invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The user area.")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="The list of user types.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of users to be retrieved in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first record to retrieve in a paged query.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="The character or string used to separate multiple filter values in a filtering query.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The filter text value used for searching or filtering user results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get users with room sharing settings

        Returns the users with the sharing settings in a room with the ID specified in request.

        :param id: The user ID. (required)
        :type id: int
        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Specifies whether to exclude the user sharing settings or not.
        :type exclude_shared: bool
        :param include_shared: Specifies whether to include the user sharing settings or not.
        :type include_shared: bool
        :param invited_by_me: Specifies whether the user was invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The user area.
        :type area: Area
        :param employee_types: The list of user types.
        :type employee_types: List[EmployeeType]
        :param count: The maximum number of users to be retrieved in the request.
        :type count: int
        :param start_index: The zero-based index of the first record to retrieve in a paged query.
        :type start_index: int
        :param filter_separator: The character or string used to separate multiple filter values in a filtering query.
        :type filter_separator: str
        :param filter_value: The filter text value used for searching or filtering user results.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_users_with_room_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            include_shared=include_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            count=count,
            start_index=start_index,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_users_with_room_shared_serialize(
        self,
        id,
        employee_status,
        activation_status,
        exclude_shared,
        include_shared,
        invited_by_me,
        inviter_id,
        area,
        employee_types,
        count,
        start_index,
        filter_separator,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'employeeTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if employee_status is not None:
            
            _query_params.append(('employeeStatus', employee_status.value))
            
        if activation_status is not None:
            
            _query_params.append(('activationStatus', activation_status.value))
            
        if exclude_shared is not None:
            
            _query_params.append(('excludeShared', exclude_shared))
            
        if include_shared is not None:
            
            _query_params.append(('includeShared', include_shared))
            
        if invited_by_me is not None:
            
            _query_params.append(('invitedByMe', invited_by_me))
            
        if inviter_id is not None:
            
            _query_params.append(('inviterId', inviter_id))
            
        if area is not None:
            
            _query_params.append(('area', area.value))
            
        if employee_types is not None:
            
            _query_params.append(('employeeTypes', employee_types))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if filter_separator is not None:
            
            _query_params.append(('filterSeparator', filter_separator))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/room/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_users_by_extended_filter(
        self,
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="The group ID.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        employee_type: Annotated[Optional[EmployeeType], Field(description="The user type.")] = None,
        employee_types: Annotated[Optional[List[List[StrictInt]]], Field(description="The list of user types.")] = None,
        is_administrator: Annotated[Optional[StrictBool], Field(description="Specifies if the user is an administrator or not.")] = None,
        payments: Annotated[Optional[Payments], Field(description="The user payment status.")] = None,
        account_login_type: Annotated[Optional[AccountLoginType], Field(description="The account login type.")] = None,
        quota_filter: Annotated[Optional[QuotaFilter], Field(description="The quota filter (All - 0, Default - 1, Custom - 2).")] = None,
        without_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of a group or not.")] = None,
        exclude_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of the group with the specified ID.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The filter area.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to be retrieved in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first item to be retrieved in a filtered result set.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the property or field name by which the results should be sorted.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Represents the separator used to split filter criteria in query parameters.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The search text used to filter results based on user input.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeFullArrayWrapper:
        """Search users with detailed information by extended filter

        Returns a list of users with full information about them matching the parameters specified in the request.

        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param group_id: The group ID.
        :type group_id: str
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param employee_type: The user type.
        :type employee_type: EmployeeType
        :param employee_types: The list of user types.
        :type employee_types: List[int]
        :param is_administrator: Specifies if the user is an administrator or not.
        :type is_administrator: bool
        :param payments: The user payment status.
        :type payments: Payments
        :param account_login_type: The account login type.
        :type account_login_type: AccountLoginType
        :param quota_filter: The quota filter (All - 0, Default - 1, Custom - 2).
        :type quota_filter: QuotaFilter
        :param without_group: Specifies whether the user should be a member of a group or not.
        :type without_group: bool
        :param exclude_group: Specifies whether the user should be a member of the group with the specified ID.
        :type exclude_group: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The filter area.
        :type area: Area
        :param count: The maximum number of items to be retrieved in the response.
        :type count: int
        :param start_index: The zero-based index of the first item to be retrieved in a filtered result set.
        :type start_index: int
        :param sort_by: Specifies the property or field name by which the results should be sorted.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_separator: Represents the separator used to split filter criteria in query parameters.
        :type filter_separator: str
        :param filter_value: The search text used to filter results based on user input.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_users_by_extended_filter_serialize(
            employee_status=employee_status,
            group_id=group_id,
            activation_status=activation_status,
            employee_type=employee_type,
            employee_types=employee_types,
            is_administrator=is_administrator,
            payments=payments,
            account_login_type=account_login_type,
            quota_filter=quota_filter,
            without_group=without_group,
            exclude_group=exclude_group,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_users_by_extended_filter_with_http_info(
        self,
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="The group ID.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        employee_type: Annotated[Optional[EmployeeType], Field(description="The user type.")] = None,
        employee_types: Annotated[Optional[List[List[StrictInt]]], Field(description="The list of user types.")] = None,
        is_administrator: Annotated[Optional[StrictBool], Field(description="Specifies if the user is an administrator or not.")] = None,
        payments: Annotated[Optional[Payments], Field(description="The user payment status.")] = None,
        account_login_type: Annotated[Optional[AccountLoginType], Field(description="The account login type.")] = None,
        quota_filter: Annotated[Optional[QuotaFilter], Field(description="The quota filter (All - 0, Default - 1, Custom - 2).")] = None,
        without_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of a group or not.")] = None,
        exclude_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of the group with the specified ID.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The filter area.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to be retrieved in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first item to be retrieved in a filtered result set.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the property or field name by which the results should be sorted.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Represents the separator used to split filter criteria in query parameters.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The search text used to filter results based on user input.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeFullArrayWrapper]:
        """Search users with detailed information by extended filter

        Returns a list of users with full information about them matching the parameters specified in the request.

        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param group_id: The group ID.
        :type group_id: str
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param employee_type: The user type.
        :type employee_type: EmployeeType
        :param employee_types: The list of user types.
        :type employee_types: List[int]
        :param is_administrator: Specifies if the user is an administrator or not.
        :type is_administrator: bool
        :param payments: The user payment status.
        :type payments: Payments
        :param account_login_type: The account login type.
        :type account_login_type: AccountLoginType
        :param quota_filter: The quota filter (All - 0, Default - 1, Custom - 2).
        :type quota_filter: QuotaFilter
        :param without_group: Specifies whether the user should be a member of a group or not.
        :type without_group: bool
        :param exclude_group: Specifies whether the user should be a member of the group with the specified ID.
        :type exclude_group: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The filter area.
        :type area: Area
        :param count: The maximum number of items to be retrieved in the response.
        :type count: int
        :param start_index: The zero-based index of the first item to be retrieved in a filtered result set.
        :type start_index: int
        :param sort_by: Specifies the property or field name by which the results should be sorted.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_separator: Represents the separator used to split filter criteria in query parameters.
        :type filter_separator: str
        :param filter_value: The search text used to filter results based on user input.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_users_by_extended_filter_serialize(
            employee_status=employee_status,
            group_id=group_id,
            activation_status=activation_status,
            employee_type=employee_type,
            employee_types=employee_types,
            is_administrator=is_administrator,
            payments=payments,
            account_login_type=account_login_type,
            quota_filter=quota_filter,
            without_group=without_group,
            exclude_group=exclude_group,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_users_by_extended_filter_without_preload_content(
        self,
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="The user status.")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="The group ID.")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="The user activation status.")] = None,
        employee_type: Annotated[Optional[EmployeeType], Field(description="The user type.")] = None,
        employee_types: Annotated[Optional[List[List[StrictInt]]], Field(description="The list of user types.")] = None,
        is_administrator: Annotated[Optional[StrictBool], Field(description="Specifies if the user is an administrator or not.")] = None,
        payments: Annotated[Optional[Payments], Field(description="The user payment status.")] = None,
        account_login_type: Annotated[Optional[AccountLoginType], Field(description="The account login type.")] = None,
        quota_filter: Annotated[Optional[QuotaFilter], Field(description="The quota filter (All - 0, Default - 1, Custom - 2).")] = None,
        without_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of a group or not.")] = None,
        exclude_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of the group with the specified ID.")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Specifies whether the user is invited by the current user or not.")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="The inviter ID.")] = None,
        area: Annotated[Optional[Area], Field(description="The filter area.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to be retrieved in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first item to be retrieved in a filtered result set.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the property or field name by which the results should be sorted.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_separator: Annotated[Optional[StrictStr], Field(description="Represents the separator used to split filter criteria in query parameters.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The search text used to filter results based on user input.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search users with detailed information by extended filter

        Returns a list of users with full information about them matching the parameters specified in the request.

        :param employee_status: The user status.
        :type employee_status: EmployeeStatus
        :param group_id: The group ID.
        :type group_id: str
        :param activation_status: The user activation status.
        :type activation_status: EmployeeActivationStatus
        :param employee_type: The user type.
        :type employee_type: EmployeeType
        :param employee_types: The list of user types.
        :type employee_types: List[int]
        :param is_administrator: Specifies if the user is an administrator or not.
        :type is_administrator: bool
        :param payments: The user payment status.
        :type payments: Payments
        :param account_login_type: The account login type.
        :type account_login_type: AccountLoginType
        :param quota_filter: The quota filter (All - 0, Default - 1, Custom - 2).
        :type quota_filter: QuotaFilter
        :param without_group: Specifies whether the user should be a member of a group or not.
        :type without_group: bool
        :param exclude_group: Specifies whether the user should be a member of the group with the specified ID.
        :type exclude_group: bool
        :param invited_by_me: Specifies whether the user is invited by the current user or not.
        :type invited_by_me: bool
        :param inviter_id: The inviter ID.
        :type inviter_id: str
        :param area: The filter area.
        :type area: Area
        :param count: The maximum number of items to be retrieved in the response.
        :type count: int
        :param start_index: The zero-based index of the first item to be retrieved in a filtered result set.
        :type start_index: int
        :param sort_by: Specifies the property or field name by which the results should be sorted.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_separator: Represents the separator used to split filter criteria in query parameters.
        :type filter_separator: str
        :param filter_value: The search text used to filter results based on user input.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_users_by_extended_filter_serialize(
            employee_status=employee_status,
            group_id=group_id,
            activation_status=activation_status,
            employee_type=employee_type,
            employee_types=employee_types,
            is_administrator=is_administrator,
            payments=payments,
            account_login_type=account_login_type,
            quota_filter=quota_filter,
            without_group=without_group,
            exclude_group=exclude_group,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_separator=filter_separator,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_users_by_extended_filter_serialize(
        self,
        employee_status,
        group_id,
        activation_status,
        employee_type,
        employee_types,
        is_administrator,
        payments,
        account_login_type,
        quota_filter,
        without_group,
        exclude_group,
        invited_by_me,
        inviter_id,
        area,
        count,
        start_index,
        sort_by,
        sort_order,
        filter_separator,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'employeeTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if employee_status is not None:
            
            _query_params.append(('employeeStatus', employee_status.value))
            
        if group_id is not None:
            
            _query_params.append(('groupId', group_id))
            
        if activation_status is not None:
            
            _query_params.append(('activationStatus', activation_status.value))
            
        if employee_type is not None:
            
            _query_params.append(('employeeType', employee_type.value))
            
        if employee_types is not None:
            
            _query_params.append(('employeeTypes', employee_types))
            
        if is_administrator is not None:
            
            _query_params.append(('isAdministrator', is_administrator))
            
        if payments is not None:
            
            _query_params.append(('payments', payments.value))
            
        if account_login_type is not None:
            
            _query_params.append(('accountLoginType', account_login_type.value))
            
        if quota_filter is not None:
            
            _query_params.append(('quotaFilter', quota_filter.value))
            
        if without_group is not None:
            
            _query_params.append(('withoutGroup', without_group))
            
        if exclude_group is not None:
            
            _query_params.append(('excludeGroup', exclude_group))
            
        if invited_by_me is not None:
            
            _query_params.append(('invitedByMe', invited_by_me))
            
        if inviter_id is not None:
            
            _query_params.append(('inviterId', inviter_id))
            
        if area is not None:
            
            _query_params.append(('area', area.value))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order.value))
            
        if filter_separator is not None:
            
            _query_params.append(('filterSeparator', filter_separator))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        if self._fields is not None:
            _header_params['fields'] = self._fields
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/filter',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_users_by_query(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeArrayWrapper:
        """Search users (using query parameters)

        Returns a list of users matching the search query. This method uses the query parameters.

        :param query: The search query.
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_users_by_query_serialize(
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeArrayWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_users_by_query_with_http_info(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeArrayWrapper]:
        """Search users (using query parameters)

        Returns a list of users matching the search query. This method uses the query parameters.

        :param query: The search query.
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_users_by_query_serialize(
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeArrayWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_users_by_query_without_preload_content(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search users (using query parameters)

        Returns a list of users matching the search query. This method uses the query parameters.

        :param query: The search query.
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_users_by_query_serialize(
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeArrayWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_users_by_query_serialize(
        self,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_users_by_status(
        self,
        status: Annotated[EmployeeStatus, Field(description="The user status.")],
        query: Annotated[Optional[StrictStr], Field(description="The advanced search query.")] = None,
        filter_by: Annotated[Optional[StrictStr], Field(description="Specifies the criteria used to filter search results in advanced queries.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The value used to filter the search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeFullArrayWrapper:
        """Search users by status filter

        Returns a list of users matching the status filter and search query.

        :param status: The user status. (required)
        :type status: EmployeeStatus
        :param query: The advanced search query.
        :type query: str
        :param filter_by: Specifies the criteria used to filter search results in advanced queries.
        :type filter_by: str
        :param filter_value: The value used to filter the search query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_users_by_status_serialize(
            status=status,
            query=query,
            filter_by=filter_by,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_users_by_status_with_http_info(
        self,
        status: Annotated[EmployeeStatus, Field(description="The user status.")],
        query: Annotated[Optional[StrictStr], Field(description="The advanced search query.")] = None,
        filter_by: Annotated[Optional[StrictStr], Field(description="Specifies the criteria used to filter search results in advanced queries.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The value used to filter the search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeFullArrayWrapper]:
        """Search users by status filter

        Returns a list of users matching the status filter and search query.

        :param status: The user status. (required)
        :type status: EmployeeStatus
        :param query: The advanced search query.
        :type query: str
        :param filter_by: Specifies the criteria used to filter search results in advanced queries.
        :type filter_by: str
        :param filter_value: The value used to filter the search query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_users_by_status_serialize(
            status=status,
            query=query,
            filter_by=filter_by,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_users_by_status_without_preload_content(
        self,
        status: Annotated[EmployeeStatus, Field(description="The user status.")],
        query: Annotated[Optional[StrictStr], Field(description="The advanced search query.")] = None,
        filter_by: Annotated[Optional[StrictStr], Field(description="Specifies the criteria used to filter search results in advanced queries.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The value used to filter the search query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search users by status filter

        Returns a list of users matching the status filter and search query.

        :param status: The user status. (required)
        :type status: EmployeeStatus
        :param query: The advanced search query.
        :type query: str
        :param filter_by: Specifies the criteria used to filter search results in advanced queries.
        :type filter_by: str
        :param filter_value: The value used to filter the search query.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_users_by_status_serialize(
            status=status,
            query=query,
            filter_by=filter_by,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_users_by_status_serialize(
        self,
        status,
        query,
        filter_by,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if status is not None:
            _path_params['status'] = status.value
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if filter_by is not None:
            
            _query_params.append(('filterBy', filter_by))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/status/{status}/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


