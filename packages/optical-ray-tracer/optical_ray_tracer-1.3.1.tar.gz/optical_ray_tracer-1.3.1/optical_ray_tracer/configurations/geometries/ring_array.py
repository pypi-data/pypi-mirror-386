from optical_ray_tracer.configurations.main import Geometry
from optical_ray_tracer.configurations.geometries.Parabolic import ParabolicReflector
from scipy.optimize import minimize
import numpy as np
import sympy as spy
from decimal import Decimal, getcontext
getcontext().prec = 80

class RingarrayReflector(Geometry):
    
    def __init__(self, Rin_0: float, N_rings: int, A_target, material_w: float, h_max: float, surf_pos=[0.0, 0.0, 0.0], rotation_angle=0.0, edge_tol=1e-3):
        super().__init__(surf_pos, rotation_angle, edge_tol)
        self.r_in_0 = Rin_0
        self.n_rings = N_rings
        self.area_target = A_target
        self.material_with = material_w
        self.h_max = h_max
        self.ring = optimizeRingArray(Rin_0, A_target, N_rings, material_w, h_max)

        # Make optimization
        self.sol = self.ring.optimize()
        # create instances of the basic geometries that compose the ring array
        G = self.sol['G']
        f0 = self.sol['f0']
        focs = self.sol['focal']
        N = int(self.sol['N'])
        R_2D = self.sol['Rays']
        h_2D = self.sol['Heights']
        rms = self.sol['RMS']
        self.parabola_rings=[]
        if rms<10:
            for i in np.arange(N):
                self.parabola_rings.append(ParabolicReflector(focs[i], focs[i], h_2D[i, 1], 
                                                              surf_pos=[self.geometry_position[0], self.geometry_position[1], 
                                                                        self.geometry_position[2] + focs[0]-focs[i]]))

    def symbolic_equation(self):
        return None  

    def boundaries(self):
        return None      

    def volume(self):
        """
        Calculate the volume values for a set of parabola rings.
        This method computes the volume values for each parabola ring in the `parabola_rings` list.
        It evaluates the symbolic equation of each parabola over a 3D grid defined by the ray bounds
        (`rx`, `ry`) and height bounds (`z_min`, `z_max`) for the corresponding ring.
        Returns:
            list: A list of 3D numpy arrays, where each array represents the computed volume values
                  for a parabola ring. Values outside the height bounds (`z_min`, `z_max`) are set to 1.0.
        """
        values = []
        
        for i, parabola in enumerate(self.parabola_rings):
            z_min = self.sol['Heights'][i, 0]
            z_max = self.sol['Heights'][i, 1]
            rx = self.sol['Rays'][i, 1]
            ry = self.sol['Rays'][i, 1]
            # Compute parabola surface equation
            x, y, z = spy.symbols('x y z')
            parabola_equ = spy.lambdify((x, y, z), parabola.symbolic_equation(), 'numpy')
            xx, yy, zz = np.meshgrid(np.linspace(-rx, rx), np.linspace(-ry, ry), np.linspace(z_min, z_max), indexing='ij')
            value = parabola_equ(xx, yy, zz)
            value[zz<z_min] = 1.0
            value[zz>z_max] = 1.0

            values.append(value)
        
        return values

    def collection_area(self):
        """
        Calculate the collection area of the last ring (biggest) in the parabola rings.

        This method retrieves the last ring from the `parabola_rings` attribute
        and calculates its collection area by invoking the `collection_area` 
        method of the ring.

        Returns:
            float: The collection area of the last ring.
        """
        last_ring = self.parabola_rings[-1]
        return last_ring.collection_area()

    def generate_rays_from_source(self, n_rays: int, source: object):
        """
        Generate rays from a specified source using the last ring (biggest) in the parabola rings.

        Args:
            n_rays (int): The number of rays to generate.
            source (object): The source object from which rays are generated.

        Returns:
            list: A list of rays generated by the last ring.
        """
        last_ring = self.parabola_rings[-1]
        return last_ring.generate_rays_from_source(n_rays, source)

    def compute_material_surface(self):
        """
        Computes the total material surface area for the ring array.
        This method calculates the cumulative material surface area by iterating
        through each parabola in the `parabola_rings` list. For each parabola, it
        computes the difference in surface area between the outer and inner radii
        and heights, and adds the absolute value of this difference to the total
        surface area.
        Returns:
            float: The total material surface area of the ring array.
        """
        surface = 0.0
        for i, parabola in enumerate(self.parabola_rings):
            r_in = self.sol['Rays'][i, 0]
            r_ext = self.sol['Rays'][i, 1] 
            h_in = self.sol['Heights'][i, 0]
            h_ext = self.sol['Heights'][i, 1]
            surface = surface + abs(parabola.compute_material_surface(r_ext, h_ext) - parabola.compute_material_surface(r_in, h_in))

        return surface


class optimizeRingArray:
    """optimizeRingArray
    =================
    This class is designed to optimize the parameters for designing a ring array solar reflector with a Fresnel lens 
    in the internal ray of the first ring. The optimization process involves calculating the geometry of the ring array 
    to minimize the root mean square (RMS) error between the total area of the rings and a target area.
    Attributes:
    -----------
    - Rin_0 (float): Internal radius of the first ring (m), equal to the Fresnel lens diameter.
    - A_target (float): Targeted reflector area (m²).
    - N (int): Number of rings in the array.
    - w (float): Reflector material width (m).
    - h_max (float): Maximum height of the array, corresponding to the external height of the first ring (m).
    - f0 (float): Initial focal distance (default: 1e-2).
    - G (float): Gradient of the linear height function (default: -0.5).
    - b_lim (tuple): Limit conditions on `b_in`.
    - heights (numpy.ndarray): Array of internal and external heights for each ring.
    - b_in (float): Internal height offset.
    - b_ex (float): External height offset.
    - R (numpy.ndarray): Array of internal and external radii for each ring.
    - f_2D (numpy.ndarray): Array of focal distances for each ring.
    Methods:
    --------
    - __init__(Rin_0, A_target, N, w, h_max):
        Initializes the object with the given parameters.
    - update_init(Rin_0, A_target, N, w, h_max):
    - evaluate_rms(X):
        Evaluates the root mean square (RMS) error for a ring array configuration based on the geometry 
        and its deviation from the target area.
    - optimize():
        Optimizes the parameters of the ring array geometry to minimize the RMS error using the 
        Sequential Least Squares Programming (SLSQP) algorithm.
    ------
    - The optimization process ensures that the geometric relationships between the parameters are respected.
    - Invalid configurations (e.g., negative heights or complex roots) are penalized with a large RMS value.
    - The optimization results include the minimized RMS error, optimized parameters, and the computed geometry 
      of the ring array.
    """

    def __init__(self, Rin_0: float, A_target: float, N: int, w: float, h_max: float):
        # Inputs parameters
        self.Rin_0 = Rin_0  # first top ring internal ray, equal to the fresnel lens diameter (m)
        self.A_target = A_target  # targeted reflector area (m²)
        self.N = N  # number of rings
        self.w = w  # reflector materiel width (m)
        self.h_max = h_max  # max height of the array, corresponding to the external height of the 1st ring (m)

        # Some other initial parameters needed
        self.f0 = 1e-2
        self.G = -0.5
        self.b_lim = (-self.G * Rin_0 + 1e-3, h_max - self.G * Rin_0)  # limit conditions on b_in
        self.heights = np.ones((N, 2))
        self.b_in = 0
        self.b_ex = 0
        self.R = np.ones((N, 2))
        self.f_2D = np.ones((N, 2))

    def update_init(self, Rin_0: float, A_target: float, N: int, w: float, h_max: float):
        """
        Updates the initialization parameters of the object and reinitializes it with the updated values.
        Parameters:
            Rin_0 (float): The initial inner radius. If None, the current value of `self.Rin_0` is used.
            A_target (float): The target area. If None, the current value of `self.A_target` is used.
            N (int): The number of elements. If None, the current value of `self.N` is used.
            w (float): The width of the elements. If None, the current value of `self.w` is used.
            h_max (float): The maximum height. If None, the current value of `self.h_max` is used.
        Notes:
            - If any parameter is passed as None, the method will use the corresponding current value of the object.
            - The method reinitializes the object by calling its `__init__` method with the updated parameters.
        """
        inputdatas = {'Rin_0': Rin_0, 'A_target': A_target, 'N': N, 'w': w, 'h_max': h_max}
        default_inputdatas = {'Rin_0': self.Rin_0, 'A_target': self.A_target, 'N': self.N, 'w': self.w,
                              'h_max': self.h_max}
        for name, val in inputdatas.items():
            # print('name is', name, 'and value is', val)
            if val is None:
                inputdatas[name] = default_inputdatas[name]

        self.__init__(**inputdatas)

    def evaluate_rms(self, X):
        """
        Evaluate the root mean square (RMS) error for a ring array configuration.
        This method calculates the RMS error based on the geometry of a ring array 
        and its deviation from a target area. The method uses the input parameters 
        to compute the radii, focal distances, heights, and angles for each ring 
        in the array. If the configuration is invalid (e.g., negative heights or 
        complex roots), a large penalty value is returned.
        Parameters:
            X (list or array-like): A list of input parameters where:
                X[0] (float): Gradient (G) of the linear height function.
                X[1] (float): Initial focal distance (f0).
                X[2] (float): Number of rings (N), rounded to the nearest integer.
        Returns:
            float: The RMS error value. A large penalty value (1e3) is returned 
            if the configuration is invalid.
        Notes:
            - The method assumes that the instance variables `Rin_0`, `h_max`, 
              `w`, and `A_target` are defined and initialized prior to calling 
              this method.
            - The method computes the geometry iteratively for each ring, starting 
              from the innermost ring and moving outward.
            - The angles between incident and reflected rays are used to ensure 
              the configuration is valid.
            - The total area of the rings is compared to the target area to 
              compute the RMS error.
        """

        self.G = X[0]
        self.f0 = X[1]
        self.N = round(X[2])

        self.R = np.ones((self.N, 2))
        self.f_2D = np.ones((self.N, 2))
        self.heights = np.ones((self.N, 2))
        n_inc = np.array([0, -1, 0])
        theta = np.zeros(2 * self.N)

        for i in np.arange(0, self.N):

            if i == 0:
                # R[0, :] = [Rin_0, Rin_0 + dR]
                self.R[0, 0] = self.Rin_0  # R_in of ring 0
                self.R[0, 1] = np.sqrt(4 * self.f0 * self.h_max)  # R_ex of ring 0

                self.f_2D[0, :] = self.f0

                self.heights[i, 0] = self.Rin_0 ** 2 / (4 * self.f_2D[0, 0])
                self.heights[i, 1] = self.h_max

                self.b_ex = self.h_max - self.G * self.R[0, 1]
                self.b_in = self.Rin_0 ** 2 / (4 * self.f0) - self.G * self.Rin_0

            else:
                self.R[i, 0] = self.R[i - 1, 1] + self.w
                self.heights[i, 0] = self.G * self.R[i, 0] + self.b_in
                # Computation of focal distance of ring i
                a = 4
                b = 4 * (self.G * self.R[i, 0] + self.b_in - self.f_2D[0, 0])
                c = -self.R[i, 0] ** 2
                coeff = [a, b, c]
                roots = np.roots(coeff)
                if np.iscomplex(roots).any():
                    return 1e3
                else:
                    self.f_2D[i, :] = np.max(roots)
                # Computation of external ray of ring i
                coeff = [1 / (4 * self.f_2D[i, 0]), -self.G, -(self.f_2D[i, 0] - self.f_2D[0, 0] + self.b_ex)]
                roots = np.roots(coeff)
                if np.iscomplex(roots).any():
                    return 1e3
                else:
                    self.R[i, 1] = np.max(roots)

                self.heights[i, 1] = self.G * self.R[i, 1] + self.b_ex

                if self.heights[i, 1] < 0:
                    return 1e3

                n_in = np.array([self.R[i, 0] / (2 * self.f_2D[i, 0]), 1, 0])
                n_ex = np.array([self.R[i, 1] / (2 * self.f_2D[i, 1]), 1, 0])
                ur_in = n_inc - 2 * np.dot(n_inc, n_in) * n_in
                ur_ex = n_inc - 2 * np.dot(n_inc, n_ex) * n_ex
                ur_in = ur_in / np.linalg.norm(ur_in)
                ur_ex = ur_ex / np.linalg.norm(ur_ex)

                theta[2 * i: 2 * i + 2] = np.array([np.arccos(np.dot(ur_in, -n_inc)),
                                                    np.arccos(np.dot(ur_ex, -n_inc))])
        dtheta = 1
        for i in np.arange(0, self.N - 1):
            dtheta = dtheta * (theta[2 * i + 3] - theta[2 * i])
        if dtheta < 0:
            return 1e3

        # A = np.pi * self.R / (6 * self.heights ** 2) * ((self.R ** 2 + 4 * self.heights ** 2) ** (3 / 2) - self.R ** 3)
        area = np.pi * (self.R[:, 1]**2 - self.R[:, 0]**2)
        # dA = A[:, 1] - A[:, 0]
        total_area = np.sum(area)
        rms = (total_area - self.A_target) ** 2  # + int(angles > 0)* 100

        return rms

    def optimize(self):
        """
        Optimize the parameters of the ring array geometry to minimize the root mean square (RMS) error.
        This method uses the Sequential Least Squares Programming (SLSQP) algorithm to optimize the 
        parameters `G`, `f0`, and `N` of the ring array geometry. The optimization is subject to 
        specified bounds and constraints.
        Returns:
            dict: A dictionary containing the optimization results with the following keys:
                - 'RMS': The minimized RMS error (float).
                - 'G': The optimized value of parameter G (float).
                - 'f0': The optimized value of parameter f0 (float).
                - 'N': The optimized value of parameter N (float).
                - 'focal': The focal values from the 2D array (numpy array).
                - 'Rays': The ray data (numpy array).
                - 'Heights': The heights data (numpy array).
        Notes:
            - The optimization bounds are defined as:
                * G: No upper bound, lower bound is 0.
                * f0: Between 0 and 5e-2.
                * N: No lower bound, must be greater than or equal to 1.
            - The constraint ensures that the optimization respects the geometric relationship 
              between `Rin_0`, `G`, and `b_in`.
            - If the optimization fails, an exception message is printed, and the output dictionary 
              will contain `None` values for the optimization results.
        """
        bnds = ((None, 0), (0, 5e-2), (1, None))
        X0 = np.array([self.G, self.f0, self.N])  # X=[G, b_in]

        cons = ({'type': 'ineq', 'fun': lambda x: self.Rin_0 ** 2 / (4 * x[1]) - x[0] * self.Rin_0})
        res = {'fun': None, 'x': [None, None, None]}

        try:
            res = minimize(self.evaluate_rms, X0, method='SLSQP', options={'disp': False}, bounds=bnds, constraints=cons)
        except ValueError as e:
            print(f"Optimization failed due to invalid input: {e}")
        except RuntimeError as e:
            print(f"Optimization failed due to runtime error: {e}")
        finally:
            outputdatas = {'RMS': res["fun"], 'G': res["x"][0], 'f0': res["x"][1], 'N': res["x"][2],
                        'focal': self.f_2D[:, 0], 'Rays': self.R, 'Heights': self.heights}

        return outputdatas

