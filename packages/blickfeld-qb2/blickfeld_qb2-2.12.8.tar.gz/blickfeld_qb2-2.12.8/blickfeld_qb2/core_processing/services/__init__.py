

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: blickfeld/core_processing/services/acceleration.proto, blickfeld/core_processing/services/distortion_correction.proto, blickfeld/core_processing/services/health.proto, blickfeld/core_processing/services/point_cloud.proto
# plugin: python-betterproto
import asyncio
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    Iterator,
    Optional,
)

import blickfeld_qb2.betterproto as betterproto
import blickfeld_qb2.betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from blickfeld_qb2.betterproto.grpc.grpclib_server import ServiceBase

from .. import (
    config as _config__,
    data as _data__,
)


if TYPE_CHECKING:
    import grpclib.server
    from blickfeld_qb2.betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class AccelerationStreamResponse(betterproto.Message):
    """Stream response to acceleration stream request"""

    buffer: "_data__.AccelerationBuffer" = betterproto.message_field(1)
    """Buffer with acceleration"""


@dataclass(eq=False, repr=False)
class AccelerationGetFilteredResponse(betterproto.Message):
    """Response to acceleration get filtered request"""

    acceleration: "_data__.Acceleration" = betterproto.message_field(1)
    """Single filtered acceleration"""


@dataclass(eq=False, repr=False)
class HealthGetResponse(betterproto.Message):
    """Response to health get request"""

    health: "_data__.Health" = betterproto.message_field(1)
    """Health state"""


@dataclass(eq=False, repr=False)
class HealthWatchResponse(betterproto.Message):
    """Stream response to health watch request"""

    health: "_data__.Health" = betterproto.message_field(1)
    """Health state"""


@dataclass(eq=False, repr=False)
class HealthSetConfigRequest(betterproto.Message):
    """Health set config request"""

    config: "_config__.Health" = betterproto.message_field(1)
    """Health parameters"""


@dataclass(eq=False, repr=False)
class HealthGetConfigResponse(betterproto.Message):
    """Health get config response"""

    config: "_config__.Health" = betterproto.message_field(1)
    """Health parameters"""


@dataclass(eq=False, repr=False)
class PointCloudStreamRequest(betterproto.Message):
    """Request for point cloud stream request"""

    pass


@dataclass(eq=False, repr=False)
class PointCloudGetRequest(betterproto.Message):
    """Request for point cloud get request"""

    pass


@dataclass(eq=False, repr=False)
class PointCloudStreamResponse(betterproto.Message):
    """Stream response to point cloud stream request"""

    frame: "_data__.Frame" = betterproto.message_field(1)
    """Point cloud frame"""


@dataclass(eq=False, repr=False)
class PointCloudGetResponse(betterproto.Message):
    """Response to point cloud get request"""

    frame: "_data__.Frame" = betterproto.message_field(1)
    """Point cloud frame"""


@dataclass(eq=False, repr=False)
class PointCloudSetFilterRequest(betterproto.Message):
    """Request for setting the filter configuration"""

    filter: "_config__.PointCloudFilter" = betterproto.message_field(1)
    """
    Filter configuration which should be applied on the point cloud frames.
    """


@dataclass(eq=False, repr=False)
class PointCloudGetFilterResponse(betterproto.Message):
    """Response for retrieving the current filter configuration"""

    filter: "_config__.PointCloudFilter" = betterproto.message_field(1)
    """
    Filter configuration which is currently applied on the point cloud frames.
    """


class Acceleration(betterproto.ServiceStub):
    """
    The Acceleration Service provides access to the accelerometer of the
    device.
    """

    async def async_stream(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["AccelerationStreamResponse"]:
        """
        Streams raw data from accelerometer   [WARNING] Raw data is acquired
        with a high sampling frequency and sent out in larger chunks. To
        estimate the static state of the device the GetFiltered method should
        be used.
        """

        request = betterproto_lib_google_protobuf.Empty()

        async for response in self._unary_stream(
            "/blickfeld.core_processing.services.Acceleration/Stream",
            request,
            AccelerationStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def stream(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> Iterator["AccelerationStreamResponse"]:
        """
        Streams raw data from accelerometer   [WARNING] Raw data is acquired
        with a high sampling frequency and sent out in larger chunks. To
        estimate the static state of the device the GetFiltered method should
        be used.
        """

        loop = asyncio.get_event_loop()
        ait = self.async_stream(
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj

    async def async_get_filtered(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AccelerationGetFilteredResponse":
        """Get filtered sample from accelerometer"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.core_processing.services.Acceleration/GetFiltered",
            request,
            AccelerationGetFilteredResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get_filtered(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AccelerationGetFilteredResponse":
        """Get filtered sample from accelerometer"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get_filtered(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class DistortionCorrection(betterproto.ServiceStub):
    """
    Service interface for managing the point cloud distortion correction.
    """

    async def async_enable(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Enable the distortion correction. If available, the user configuration
        will be taken, otherwise the factory configuration will be used.
        NOTE: Enabling the distortion correction is persistent, meaning it will
        still be enabled after reboot.
        """

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.core_processing.services.DistortionCorrection/Enable",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def enable(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Enable the distortion correction. If available, the user configuration
        will be taken, otherwise the factory configuration will be used.
        NOTE: Enabling the distortion correction is persistent, meaning it will
        still be enabled after reboot.
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_enable(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_disable(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Disable the distortion correction.   NOTE: Disabling the distortion
        correction is persistent, meaning it will still be disabled after
        reboot.
        """

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.core_processing.services.DistortionCorrection/Disable",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def disable(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Disable the distortion correction.   NOTE: Disabling the distortion
        correction is persistent, meaning it will still be disabled after
        reboot.
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_disable(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class Health(betterproto.ServiceStub):
    """
    The health service provides methods to monitor operational status of the
    core_processing module
    """

    async def async_get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "HealthGetResponse":
        """Returns the current health status of the core_processing module"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.core_processing.services.Health/Get",
            request,
            HealthGetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "HealthGetResponse":
        """Returns the current health status of the core_processing module"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["HealthWatchResponse"]:
        """
        Can be used to attach to the health monitoring status information of
        the core_processing module
        """

        request = betterproto_lib_google_protobuf.Empty()

        async for response in self._unary_stream(
            "/blickfeld.core_processing.services.Health/Watch",
            request,
            HealthWatchResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> Iterator["HealthWatchResponse"]:
        """
        Can be used to attach to the health monitoring status information of
        the core_processing module
        """

        loop = asyncio.get_event_loop()
        ait = self.async_watch(
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj

    async def async_set_config(
        self,
        *,
        config: "_config__.Health" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Set the necessary parameters to generate the health message. It could
        be calibration flag, limits, etc.
        """

        request = HealthSetConfigRequest()
        if config is not None:
            request.config = config

        return await self._unary_unary(
            "/blickfeld.core_processing.services.Health/SetConfig",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def set_config(
        self,
        *,
        config: "_config__.Health" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Set the necessary parameters to generate the health message. It could
        be calibration flag, limits, etc.
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_set_config(
                config=config,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_get_config(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "HealthGetConfigResponse":
        """Get the health config"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.core_processing.services.Health/GetConfig",
            request,
            HealthGetConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get_config(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "HealthGetConfigResponse":
        """Get the health config"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get_config(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class PointCloud(betterproto.ServiceStub):
    """
    Point Cloud service for core point cloud stream. It is the direct result of
    the internal processing pipeline. The output is not post-processed further.
    The post-processed output can be retrieved from the percept-processing
    PointCloud service.
    """

    async def async_stream(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["PointCloudStreamResponse"]:
        """
        Stream a point cloud stream   NOTE: This activates the sensor if it is
        currently idle.
        """

        request = PointCloudStreamRequest()

        async for response in self._unary_stream(
            "/blickfeld.core_processing.services.PointCloud/Stream",
            request,
            PointCloudStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def stream(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> Iterator["PointCloudStreamResponse"]:
        """
        Stream a point cloud stream   NOTE: This activates the sensor if it is
        currently idle.
        """

        loop = asyncio.get_event_loop()
        ait = self.async_stream(
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj

    async def async_get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "PointCloudGetResponse":
        """
        Get a single point cloud   NOTE: This activates the sensor if it is
        currently idle.
        """

        request = PointCloudGetRequest()

        return await self._unary_unary(
            "/blickfeld.core_processing.services.PointCloud/Get",
            request,
            PointCloudGetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "PointCloudGetResponse":
        """
        Get a single point cloud   NOTE: This activates the sensor if it is
        currently idle.
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_set_filter(
        self,
        *,
        filter: "_config__.PointCloudFilter" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Set the filter configuration which is to be applied on the point cloud
        data
        """

        request = PointCloudSetFilterRequest()
        if filter is not None:
            request.filter = filter

        return await self._unary_unary(
            "/blickfeld.core_processing.services.PointCloud/SetFilter",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def set_filter(
        self,
        *,
        filter: "_config__.PointCloudFilter" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Set the filter configuration which is to be applied on the point cloud
        data
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_set_filter(
                filter=filter,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_get_filter(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "PointCloudGetFilterResponse":
        """
        Get the filter configuration which is currently applied on the point
        cloud data
        """

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.core_processing.services.PointCloud/GetFilter",
            request,
            PointCloudGetFilterResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get_filter(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "PointCloudGetFilterResponse":
        """
        Get the filter configuration which is currently applied on the point
        cloud data
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get_filter(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )
