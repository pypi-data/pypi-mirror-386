from . import config
from . import data
from . import geometry

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: blickfeld/base/options/access_control.proto, blickfeld/base/options/misc.proto, blickfeld/base/options/product_variant.proto, blickfeld/base/options/protocol_maturity.proto, blickfeld/base/options/validate.proto
# plugin: python-betterproto
from dataclasses import dataclass

import blickfeld_qb2.betterproto as betterproto
import blickfeld_qb2.betterproto.lib.google.protobuf as betterproto_lib_google_protobuf


class AccessControlLevel(betterproto.Enum):
    """
    Available access levels   The levels are ordered in ascending order, which
    means that each level also inherits the permissions of the levels above it.
    """

    LEVEL_UNSPECIFIED = 0
    """Access level is not specified"""

    LEVEL_PUBLIC = 1
    """
    Everyone can access   The corresponding entities can be accessed by anyone
    who has access to the interface of the device. The access can not be
    disabled by the user.
    """

    LEVEL_AUTHORIZED = 2
    """
    Only authorized clients can access   The corresponding entities can only be
    used by authorized clients. The access can be managed by clients with the
    ADMIN access level. If desired, the AUTHORIZED access level can be
    configured to act equally to the PUBLIC access level.
    """

    LEVEL_ADMIN = 3
    """
    Only administrative clients can access   The corresponding entities are
    mainly used to configure the accounts with AUTHORIZED & ADMIN access
    levels.
    """

    LEVEL_SUPPORT = 4
    """
    Only clients of the Blickfeld support can access   The corresponding
    entities can only be accessed by Blickfeld Support Tools & clients. The
    access tokens are bound to devices.
    """

    LEVEL_PRODUCTION = 5
    """
    Only clients in production can access   The corresponding entities are used
    for end-of-line & re-work processes.
    """

    LEVEL_DEVELOPER = 6
    """Only Blickfeld developers can access"""


class LifeTimeDiagnosticsType(betterproto.Enum):
    """
    Type of diagnostics.   Is used to aggregate multiple long term statistics.
    """

    TYPE_UNSPECIFIED = 0
    """Unspecified type."""

    TYPE_TEMPERATURE = 1
    """Temperature sensor or estimate."""

    TYPE_UTILIZATION = 2
    """Indicates how much of the available resource is used."""

    TYPE_RATE = 3
    """Frequency measurement or estimate."""

    TYPE_VOLTAGE = 4
    """Electrical voltage sensor or estimate."""


class ProtocolMaturityLevel(betterproto.Enum):
    """
    This enumeration describes the maturity of a protocol. Please refer to the
    individual values.   [IMPORTANT] APIs marked with the EXPERIMENTAL and
    DEPRECATED flags have to be handled with care. Please read through the
    definition.   Please report if the protocol maturity of a service, method,
    and field does not fit e.g. if an EXPERIMENTAL field is required in an
    application and production use case.
    """

    LEVEL_UNSPECIFIED = 0
    """
    Level is not set. Default level for services is EXPERIMENTAL. Default level
    for methods and fields is INHERITED.
    """

    LEVEL_EXPERIMENTAL = 1
    """
    APIs marked with this flag should be handled with care. They might not
    function as expected. Additionally it is not ensured that the APIs will
    ever be moved to the MAINTAINED level. They might be altered or removed in
    any upcoming release without further notice.
    """

    LEVEL_MAINTAINED = 2
    """
    APIs marked with this flag are actively maintained and released. They will
    not change their behavior without notices in the changelog. Breaking
    changes in a maintained APIs have to result in a major update of the
    module.
    """

    LEVEL_DEPRECATED = 3
    """
    APIs marked with this flag are no longer actively maintained. They will be
    removed in upcoming releases.
    """

    LEVEL_INHERITED = 4
    """The protocol maturity is inherited from the parent"""


class ProductVariant(betterproto.Enum):
    """The product variant specifies a Blickfeld Qb2 product variant."""

    PRODUCT_VARIANT_UNSPECIFIED = 0
    """
    Unspecified (default value) - placeholder for all other product variants.
    """

    PRODUCT_VARIANT_QBBASIC = 1
    """QbBasic - Basic & Core product variant."""

    PRODUCT_VARIANT_QBPROTECT = 2
    """
    QbProtect - Tailored product variant for security & protection
    applications.
    """

    PRODUCT_VARIANT_QBVOLUME = 3
    """
    QbVolume - Tailored product variant for stockpile management applications.
    """

    PRODUCT_VARIANT_QB2 = 4
    """
    Qb2 - Generic product variant allowing the exploration & discovery of new
    applicaton areas for smart lidar.
    """


@dataclass(eq=False, repr=False)
class AccessControl(betterproto.Message):
    """
    The Access Control message specifies the required access level and licenses
    for protocol entities. Protocol entities are usually gRPC services but can
    also be more fine grained on gRPC method and Protobuf field level.
    """

    level: "AccessControlLevel" = betterproto.enum_field(1)
    """Minimum access level required for entity"""

    read_only: bool = betterproto.bool_field(2)
    """True if the entity can be accessed with read-only permissions"""


@dataclass(eq=False, repr=False)
class LifeTimeDiagnostics(betterproto.Message):
    """
    This annotation is used by diagnostic modules to collect long term
    statistics for the annotated field.
    """

    type: "LifeTimeDiagnosticsType" = betterproto.enum_field(1)
    """Type"""


@dataclass(eq=False, repr=False)
class LinkData(betterproto.Message):
    """Message defining LinkData"""

    type: str = betterproto.string_field(1)
    directory: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ProtocolMaturity(betterproto.Message):
    """
    This message specifies the maturity of a protocol for customer- and
    production-facing APIs.
    """

    level: "ProtocolMaturityLevel" = betterproto.enum_field(1)
    """Simple level which describes maturity"""


@dataclass(eq=False, repr=False)
class Validate(betterproto.Message):
    """Input validation"""

    number: "ValidateNumberRules" = betterproto.message_field(1)
    """See description at the messages above!"""

    string: "ValidateStringRules" = betterproto.message_field(2)
    bytes: "ValidateBytesRules" = betterproto.message_field(3)
    repeated: "ValidateRepeatedRules" = betterproto.message_field(4)
    map: "ValidateMapRules" = betterproto.message_field(5)
    path: str = betterproto.string_field(100)
    """
    path to the (sub message) child field the validation shall be enforced (cf.
    path of a protobuf FieldMask: https://protobuf.dev/reference/java/api-
    docs/com/google/protobuf/FieldMask.html)
    """

    optional: bool = betterproto.bool_field(101)
    """This field is optional if set to True"""


@dataclass(eq=False, repr=False)
class ValidateNumberRules(betterproto.Message):
    """
    Number validation. Can be applied for all numbers (float, double, int32,
    int64, uint32, etc.) for values between -16777216 and +16777216
    """

    greater: float = betterproto.double_field(1)
    """target value has to be "Greater Than"""

    greater_or_equal: float = betterproto.double_field(2)
    """target value has to be "Greater Than or Equal"""

    less: float = betterproto.double_field(3)
    """target value has to be "Less Than"""

    less_or_equal: float = betterproto.double_field(4)
    """target value has to be "Less Than or Equal"""


@dataclass(eq=False, repr=False)
class ValidateStringRules(betterproto.Message):
    """String validation"""

    minimum: int = betterproto.uint32_field(1)
    """minimal number of required characters"""

    maximum: int = betterproto.uint32_field(2)
    """maximal number of allowed characters"""

    startswith: str = betterproto.string_field(3)
    """string has to start with this string (case sensitive)"""

    endswith: str = betterproto.string_field(4)
    """string has to start with this string (case sensitive)"""

    contains: str = betterproto.string_field(5)
    """string has to start with this string (case sensitive)"""

    pattern: str = betterproto.string_field(6)
    """
    string has to match this regex pattern. The following regex match method is
    used: https://developer.mozilla.org/en-
    US/docs/Web/JavaScript/Reference/Global_Objects/String/match
    """


@dataclass(eq=False, repr=False)
class ValidateBytesRules(betterproto.Message):
    """Byte validation"""

    minimum: int = betterproto.uint32_field(1)
    """minimal number of required bytes"""

    maximum: int = betterproto.uint32_field(2)
    """maximal number of allowed bytes"""


@dataclass(eq=False, repr=False)
class ValidateRepeatedRules(betterproto.Message):
    """Repeated validation: Apply only to repeated fields"""

    minimum: int = betterproto.uint64_field(1)
    """minimal number of repeated list elements"""

    maximum: int = betterproto.uint64_field(2)
    """maximal number of repeated list elements"""


@dataclass(eq=False, repr=False)
class ValidateMapRules(betterproto.Message):
    """Map validation: Apply only to map fields"""

    minimum: int = betterproto.uint64_field(1)
    """minimal number of key-value pairs"""

    maximum: int = betterproto.uint64_field(2)
    """maximal number of key-value pairs"""

    keys: "Validate" = betterproto.message_field(3)
    """(recursive) Validate definition for keys"""

    values: "Validate" = betterproto.message_field(4)
    """(recursive) Validate definition for values"""
