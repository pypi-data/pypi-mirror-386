

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: blickfeld/push/config/authentication.proto, blickfeld/push/config/destination.proto, blickfeld/push/config/payload.proto, blickfeld/push/config/push.proto
# plugin: python-betterproto
from dataclasses import dataclass

import blickfeld_qb2.betterproto as betterproto
import blickfeld_qb2.betterproto.lib.google.protobuf as betterproto_lib_google_protobuf


class PayloadEncoding(betterproto.Enum):
    """define how the messages are serialized"""

    ENCODING_UNSPECIFIED = 0
    """unspecified"""

    ENCODING_PROTOBUF = 1
    """protobuf serialized as binary"""

    ENCODING_JSON = 2
    """json representation of protobuf messages"""

    ENCODING_JSON_FLATTENED = 3
    """flattened json representation of protobuf messages"""


class PayloadDataType(betterproto.Enum):
    """The type of data that the stream contains"""

    DATA_TYPE_UNSPECIFIED = 0
    """The zero value should not be used"""

    DATA_TYPE_HEALTH = 1
    """
    Health data type: this contains information about the health of the
    pipeline and of the module
    """

    DATA_TYPE_POINT_CLOUD = 2
    """Point cloud data type: a complete point cloud message is streamed"""

    DATA_TYPE_STATES = 5
    """
    States data type: a map of states generated by the system as configured in
    the pipeline
    """

    DATA_TYPE_VOLUME_MAP = 6
    """
    Volume map data type: a volume map generated by one volume zone configured
    in the pipeline
    """

    DATA_TYPE_OBJECTS = 7
    """Objects data type: a map of objects detected by the system"""

    DATA_TYPE_EVENT = 8
    """Event data type: a message is emitted for each event"""


@dataclass(eq=False, repr=False)
class Authentication(betterproto.Message):
    """Authentication definition"""

    user: str = betterproto.string_field(1)
    """the user name used for authentication"""

    password: str = betterproto.string_field(2)
    """the password used for authentication"""

    server_certificate: bytes = betterproto.bytes_field(3)
    """the server certificate (will implicitly use SSL)"""

    client_certificate: bytes = betterproto.bytes_field(4)
    """client certificate"""

    client_key: bytes = betterproto.bytes_field(5)
    """client key"""


@dataclass(eq=False, repr=False)
class Destination(betterproto.Message):
    """Push destination definition"""

    mqtt: "DestinationMqtt" = betterproto.message_field(1, group="destination_type")
    """mqtt server destination"""


@dataclass(eq=False, repr=False)
class DestinationMqtt(betterproto.Message):
    """Mqtt Endpoint definition"""

    server_fqdn: str = betterproto.string_field(1)
    """mqtt server location"""

    server_port: int = betterproto.uint32_field(2)
    """
    mqtt server port will be set to 1883 if it is not set (server_port==0)
    """

    authentication: "Authentication" = betterproto.message_field(3)
    """mqtt server authentication settings"""

    client_identifier: str = betterproto.string_field(4)
    """mqtt client identifier"""

    topic: str = betterproto.string_field(5)
    """
    mqtt topic - if empty the
    'blickfeld/{data_type}/{encoding_type}/{config_name}' pattern is used as a
    default
    """


@dataclass(eq=False, repr=False)
class Payload(betterproto.Message):
    """defines what type of data stream to use as payload"""

    encoding: "PayloadEncoding" = betterproto.enum_field(1)
    """payload encoding"""

    data_type: "PayloadDataType" = betterproto.enum_field(3)
    """payload data type to stream"""


@dataclass(eq=False, repr=False)
class Push(betterproto.Message):
    """defines a combination of stream and destination"""

    name: str = betterproto.string_field(1)
    """name of push"""

    payload: "Payload" = betterproto.message_field(2)
    """stream payload"""

    destination: "Destination" = betterproto.message_field(3)
    """push destination"""

    enabled: bool = betterproto.bool_field(4)
    """push enabled"""
