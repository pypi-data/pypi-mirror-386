

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: blickfeld/percept_pipeline/services/data_source.proto, blickfeld/percept_pipeline/services/health.proto, blickfeld/percept_pipeline/services/perception.proto, blickfeld/percept_pipeline/services/zone.proto
# plugin: python-betterproto
import asyncio
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    Iterator,
    List,
    Optional,
)

import blickfeld_qb2.betterproto as betterproto
import blickfeld_qb2.betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
import numpy as np
from blickfeld_qb2.betterproto.grpc.grpclib_server import ServiceBase

from ...core_processing import data as __core_processing_data__
from .. import (
    config as _config__,
    data as _data__,
)


if TYPE_CHECKING:
    import grpclib.server
    from blickfeld_qb2.betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class HealthWatchResponse(betterproto.Message):
    """Stream response containing health of the module"""

    health: "_data__.Health" = betterproto.message_field(1)
    """The module health"""


@dataclass(eq=False, repr=False)
class HealthGetResponse(betterproto.Message):
    """Get response containing health of the module"""

    health: "_data__.Health" = betterproto.message_field(1)
    """The module health"""


@dataclass(eq=False, repr=False)
class DataSourceGetResponse(betterproto.Message):
    """Response containing the current data source"""

    data_source: "_config__.DataSource" = betterproto.message_field(1)
    """The currently set data source"""


@dataclass(eq=False, repr=False)
class DataSourceSetRequest(betterproto.Message):
    """Request for setting the data source"""

    data_source: "_config__.DataSource" = betterproto.message_field(1)
    """The data source to be set"""


@dataclass(eq=False, repr=False)
class DataSourceWatchResponse(betterproto.Message):
    """Continuous response on data source changes"""

    data_source: "_config__.DataSource" = betterproto.message_field(1)
    """The currently set data source"""


@dataclass(eq=False, repr=False)
class PerceptionGetResponse(betterproto.Message):
    """Response containing the current perception configuration"""

    perception: "_config__.Perception" = betterproto.message_field(1)
    """The current perception configuration"""


@dataclass(eq=False, repr=False)
class PerceptionSetRequest(betterproto.Message):
    """Request for setting the perception configuration"""

    perception: "_config__.Perception" = betterproto.message_field(2)
    """Use the specified configuration"""


@dataclass(eq=False, repr=False)
class PerceptionWatchResponse(betterproto.Message):
    """Continuous response on perception configuration changes"""

    perception: "_config__.Perception" = betterproto.message_field(1)
    """The current set perception configuration"""


@dataclass(eq=False, repr=False)
class PerceptionResetBackgroundRequest(betterproto.Message):
    """Request to reset the background model"""

    binary_direction_id: np.ndarray = betterproto.bytes_field(2, numpy_dtype="<u4")
    """
    If set, the background is only reset for the given direction ids. The
    direction ids might be extracted from the point cloud of an object.   NOTE:
    This is only supported for the mixture of gaussian background subtraction.
    Type: UInt32
    """


@dataclass(eq=False, repr=False)
class PerceptionGetBackgroundResponse(betterproto.Message):
    """Response containing the active background frame"""

    background: "__core_processing_data__.Frame" = betterproto.message_field(1)
    """The frame currently active as background"""


@dataclass(eq=False, repr=False)
class PerceptionSetBackgroundRequest(betterproto.Message):
    """Request to set the active background frame"""

    background: "__core_processing_data__.Frame" = betterproto.message_field(
        1, group="background_oneof"
    )
    """The frame to be set as background"""


@dataclass(eq=False, repr=False)
class ZoneListResponse(betterproto.Message):
    """Response containing the configured list of zones"""

    zones: List["_config__.ZoneAlgorithm"] = betterproto.message_field(1)
    """The currently configured zones"""


@dataclass(eq=False, repr=False)
class ZoneStoreRequest(betterproto.Message):
    """Request to store or update existing zones"""

    zone: "_config__.ZoneAlgorithm" = betterproto.message_field(1)
    """
    The new zone to be added. If there is a zone with the same uuid, that zone
    will get updated with this configuration.
    """

    zones: List["_config__.ZoneAlgorithm"] = betterproto.message_field(2)
    """
    For a batch update: the new zones to be added. If any of them has a uuid
    matching an existing zone, it will get updated.
    """

    delete_others: bool = betterproto.bool_field(3)
    """
    If this is set to true, all existing zones that are not specified in this
    request will be deleted.
    """


@dataclass(eq=False, repr=False)
class ZoneDeleteRequest(betterproto.Message):
    """Request to delete zones"""

    uuid: str = betterproto.string_field(1)
    """The uuid of the zone to be deleted"""

    uuids: List[str] = betterproto.string_field(2)
    """For a batch delete: the uuids of the zones to be deleted"""


@dataclass(eq=False, repr=False)
class ZoneWatchResponse(betterproto.Message):
    """Continuous response on zone list changes"""

    zones: List["_config__.ZoneAlgorithm"] = betterproto.message_field(1)
    """The current/updated list of zones"""


@dataclass(eq=False, repr=False)
class ZoneGetTareVolumeRequest(betterproto.Message):
    """Request for the raw volume to be used for taring a volume zone"""

    zone_uuid: str = betterproto.string_field(1)
    """The uuid of the volume zone"""


@dataclass(eq=False, repr=False)
class ZoneGetTareVolumeResponse(betterproto.Message):
    """Response containing the raw volume of the requested zone"""

    tare_volume: float = betterproto.float_field(1)
    """
    The raw volume of the volume zone without any offsets/modifications. The
    value is supposed to be configured as 'empty_volume' value of a volume
    zone. As a result the current volume of the zone will be '0' until more
    volume is added.
    """


class Health(betterproto.ServiceStub):
    """Reports the health of the pipeline module."""

    async def async_watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["HealthWatchResponse"]:
        """
        Streams health information on a regular cadence or if certain incidents
        happen
        """

        request = betterproto_lib_google_protobuf.Empty()

        async for response in self._unary_stream(
            "/blickfeld.percept_pipeline.services.Health/Watch",
            request,
            HealthWatchResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> Iterator["HealthWatchResponse"]:
        """
        Streams health information on a regular cadence or if certain incidents
        happen
        """

        loop = asyncio.get_event_loop()
        ait = self.async_watch(
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj

    async def async_get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "HealthGetResponse":
        """Returns the current health information"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.Health/Get",
            request,
            HealthGetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "HealthGetResponse":
        """Returns the current health information"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class DataSource(betterproto.ServiceStub):
    """
    The data source service allows getting, configuring and receiving updates
    of the data source used for processing pipelines. The data source
    configuration specifies where to retrieve the point cloud data for further
    processing.
    """

    async def async_get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DataSourceGetResponse":
        """Get current data_source Configuration"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.DataSource/Get",
            request,
            DataSourceGetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DataSourceGetResponse":
        """Get current data_source Configuration"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_set(
        self,
        *,
        data_source: "_config__.DataSource" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Set configuration for data_source"""

        request = DataSourceSetRequest()
        if data_source is not None:
            request.data_source = data_source

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.DataSource/Set",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def set(
        self,
        *,
        data_source: "_config__.DataSource" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Set configuration for data_source"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_set(
                data_source=data_source,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_reset(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Resets the data_source configuration to factory values"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.DataSource/Reset",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def reset(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Resets the data_source configuration to factory values"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_reset(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["DataSourceWatchResponse"]:
        """Watch configuration for data_source"""

        request = betterproto_lib_google_protobuf.Empty()

        async for response in self._unary_stream(
            "/blickfeld.percept_pipeline.services.DataSource/Watch",
            request,
            DataSourceWatchResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> Iterator["DataSourceWatchResponse"]:
        """Watch configuration for data_source"""

        loop = asyncio.get_event_loop()
        ait = self.async_watch(
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj


class Perception(betterproto.ServiceStub):
    """
    The perception service allows getting, configuring and receiving updates of
    the perception configurations. Perception configurations specify the
    algorithms used for e.g. for background subtraction etc.
    """

    async def async_get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "PerceptionGetResponse":
        """Get current perception configuration"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.Perception/Get",
            request,
            PerceptionGetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "PerceptionGetResponse":
        """Get current perception configuration"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_set(
        self,
        *,
        perception: "_config__.Perception" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Set the perception configuration"""

        request = PerceptionSetRequest()
        if perception is not None:
            request.perception = perception

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.Perception/Set",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def set(
        self,
        *,
        perception: "_config__.Perception" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Set the perception configuration"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_set(
                perception=perception,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["PerceptionWatchResponse"]:
        """Watch changes of perception configuration"""

        request = betterproto_lib_google_protobuf.Empty()

        async for response in self._unary_stream(
            "/blickfeld.percept_pipeline.services.Perception/Watch",
            request,
            PerceptionWatchResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> Iterator["PerceptionWatchResponse"]:
        """Watch changes of perception configuration"""

        loop = asyncio.get_event_loop()
        ait = self.async_watch(
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj

    async def async_reset_background(
        self,
        *,
        binary_direction_id: np.ndarray = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Resets the background of one, multiple or all devices"""

        request = PerceptionResetBackgroundRequest()
        request.binary_direction_id = binary_direction_id

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.Perception/ResetBackground",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def reset_background(
        self,
        *,
        binary_direction_id: np.ndarray = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Resets the background of one, multiple or all devices"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_reset_background(
                binary_direction_id=binary_direction_id,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_get_background(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "PerceptionGetBackgroundResponse":
        """Get the background frame of a single device"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.Perception/GetBackground",
            request,
            PerceptionGetBackgroundResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get_background(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "PerceptionGetBackgroundResponse":
        """Get the background frame of a single device"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get_background(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_set_background(
        self,
        *,
        background: "__core_processing_data__.Frame" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Set the background frame of a single device"""

        request = PerceptionSetBackgroundRequest()
        if background is not None:
            request.background = background

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.Perception/SetBackground",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def set_background(
        self,
        *,
        background: "__core_processing_data__.Frame" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Set the background frame of a single device"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_set_background(
                background=background,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class Zone(betterproto.ServiceStub):
    """
    The zone service allows getting, configuring, deleting and receiving
    updates of the configured zones.
    """

    async def async_list(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "ZoneListResponse":
        """Returns the configured zones"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.Zone/List",
            request,
            ZoneListResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def list(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "ZoneListResponse":
        """Returns the configured zones"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_list(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_store(
        self,
        *,
        zone: "_config__.ZoneAlgorithm" = None,
        zones: Optional[List["_config__.ZoneAlgorithm"]] = None,
        delete_others: bool = False,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Store / Update a zone"""

        zones = zones or []

        request = ZoneStoreRequest()
        if zone is not None:
            request.zone = zone
        if zones is not None:
            request.zones = zones
        request.delete_others = delete_others

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.Zone/Store",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def store(
        self,
        *,
        zone: "_config__.ZoneAlgorithm" = None,
        zones: Optional[List["_config__.ZoneAlgorithm"]] = None,
        delete_others: bool = False,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Store / Update a zone"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_store(
                zone=zone,
                zones=zones,
                delete_others=delete_others,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_delete(
        self,
        *,
        uuid: str = "",
        uuids: Optional[List[str]] = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Delete a zone"""

        uuids = uuids or []

        request = ZoneDeleteRequest()
        request.uuid = uuid
        request.uuids = uuids

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.Zone/Delete",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def delete(
        self,
        *,
        uuid: str = "",
        uuids: Optional[List[str]] = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Delete a zone"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_delete(
                uuid=uuid,
                uuids=uuids,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_delete_all(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Delete all zones"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.Zone/DeleteAll",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def delete_all(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Delete all zones"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_delete_all(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["ZoneWatchResponse"]:
        """Watch configuration for zone list"""

        request = betterproto_lib_google_protobuf.Empty()

        async for response in self._unary_stream(
            "/blickfeld.percept_pipeline.services.Zone/Watch",
            request,
            ZoneWatchResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> Iterator["ZoneWatchResponse"]:
        """Watch configuration for zone list"""

        loop = asyncio.get_event_loop()
        ait = self.async_watch(
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj

    async def async_get_tare_volume(
        self,
        *,
        zone_uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ZoneGetTareVolumeResponse":
        """Computes raw volume within a volume zone without any offsets."""

        request = ZoneGetTareVolumeRequest()
        request.zone_uuid = zone_uuid

        return await self._unary_unary(
            "/blickfeld.percept_pipeline.services.Zone/GetTareVolume",
            request,
            ZoneGetTareVolumeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get_tare_volume(
        self,
        *,
        zone_uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ZoneGetTareVolumeResponse":
        """Computes raw volume within a volume zone without any offsets."""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get_tare_volume(
                zone_uuid=zone_uuid,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )
