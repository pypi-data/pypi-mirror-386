"""Analyze cross-notebook imports and generate Mermaid.js dependency diagrams"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/dependencies.ipynb.

# %% ../nbs/dependencies.ipynb 3
from __future__ import annotations
from pathlib import Path
from typing import List, Dict, Set, Tuple, Optional
from dataclasses import dataclass, field
from nbdev.config import get_config
from .core import *
from .parsers import *
import re
from collections import defaultdict

# %% auto 0
__all__ = ['ModuleDependency', 'DependencyGraph', 'extract_project_imports', 'analyze_module_dependencies',
           'build_dependency_graph', 'generate_mermaid_diagram', 'generate_dependency_matrix']

# %% ../nbs/dependencies.ipynb 5
@dataclass
class ModuleDependency:
    "Represents a dependency between modules"
    source: str                                 # Source module name
    target: str                                 # Target module name
    import_type: str                            # Type of import (from/import)
    imported_names: List[str] = field(default_factory=list)  # Specific names imported

# %% ../nbs/dependencies.ipynb 6
@dataclass
class DependencyGraph:
    """Dependency graph for a project"""
    modules: Dict[str, ModuleInfo] = field(default_factory=dict)  # Module name -> ModuleInfo
    dependencies: List[ModuleDependency] = field(default_factory=list)  # All dependencies
    
    def add_module(self,
                   module:ModuleInfo  # Module to add to the graph
                   ):                  # None
        """Add a module to the dependency graph"""
        self.modules[module.name] = module
    
    def add_dependency(self,
                       dep:ModuleDependency  # Dependency to add
                       ):                     # None
        """Add a dependency to the graph"""
        self.dependencies.append(dep)
    
    def get_module_dependencies(self, module_name: str  # Module to query
                               ) -> List[ModuleDependency]:  # Dependencies
        """Get all dependencies for a specific module"""
        return [d for d in self.dependencies if d.source == module_name]
    
    def get_module_dependents(self, module_name: str    # Module to query
                             ) -> List[ModuleDependency]:  # Dependents
        """Get all modules that depend on a specific module"""
        return [d for d in self.dependencies if d.target == module_name]

# %% ../nbs/dependencies.ipynb 8
def extract_project_imports(import_str: str,            # Import statement
                           project_name: str            # Project package name
                           ) -> Optional[ModuleDependency]:  # Dependency if internal
    "Extract project-internal imports from an import statement"
    # Check for 'from X import Y' pattern
    from_match = re.match(r'from\s+(\S+)\s+import\s+(.+)', import_str)
    if from_match:
        module = from_match.group(1)
        imports = from_match.group(2)
        
        # Check if it's a project import
        if module.startswith(project_name):
            # Extract the module name after project name
            module_parts = module.split('.')
            if len(module_parts) > 1:
                # Join all parts after the project name to get full module path
                target_module = '.'.join(module_parts[1:])
                
                # Parse imported names
                imported_names = [name.strip() for name in imports.split(',')]
                # Handle 'import *'
                if imported_names == ['*']:
                    imported_names = ['*']
                
                return ModuleDependency(
                    source="",  # Will be filled by caller
                    target=target_module,
                    import_type="from",
                    imported_names=imported_names
                )
    
    # Check for 'import X' pattern
    import_match = re.match(r'import\s+(\S+)', import_str)
    if import_match:
        module = import_match.group(1)
        
        # Check if it's a project import
        if module.startswith(project_name):
            module_parts = module.split('.')
            if len(module_parts) > 1:
                # Join all parts after the project name to get full module path
                target_module = '.'.join(module_parts[1:])
                
                return ModuleDependency(
                    source="",  # Will be filled by caller
                    target=target_module,
                    import_type="import",
                    imported_names=[target_module]
                )
    
    return None

# %% ../nbs/dependencies.ipynb 9
def analyze_module_dependencies(module: ModuleInfo,     # Module to analyze
                               project_name: str        # Project package name
                               ) -> List[ModuleDependency]:  # Dependencies found
    "Analyze a module's imports to find project-internal dependencies"
    dependencies = []
    
    for import_str in module.imports:
        dep = extract_project_imports(import_str, project_name)
        if dep:
            dep.source = module.name
            dependencies.append(dep)
    
    return dependencies

# %% ../nbs/dependencies.ipynb 11
def build_dependency_graph(path: Path = None,           # Project path
                          project_name: Optional[str] = None  # Override project name
                          ) -> DependencyGraph:         # Dependency graph
    "Build a dependency graph for all modules in a project"
    if path is None:
        cfg = get_config()
        path = cfg.nbs_path
    
    # Get project name from config if not provided
    if project_name is None:
        cfg = get_config()
        project_name = cfg.lib_name.replace('-', '_')
    
    graph = DependencyGraph()
    
    # Get all notebooks
    notebooks = get_notebook_files(path, recursive=True)
    
    # Parse each notebook and analyze dependencies
    for nb_path in notebooks:
        # Skip index notebooks
        if nb_path.stem in ['index', '00_index']:
            continue
        
        try:
            # Parse the notebook
            module_info = parse_notebook(nb_path)
            graph.add_module(module_info)
            
            # Analyze dependencies
            dependencies = analyze_module_dependencies(module_info, project_name)
            for dep in dependencies:
                graph.add_dependency(dep)
        
        except Exception as e:
            print(f"Error processing {nb_path}: {e}")
            continue
    
    return graph

# %% ../nbs/dependencies.ipynb 13
def generate_mermaid_diagram(graph: DependencyGraph,    # Dependency graph
                           direction: str = "TD",       # Diagram direction (TD/LR)
                           show_imports: bool = False   # Show imported names
                           ) -> str:                    # Mermaid diagram code
    """Generate a Mermaid.js dependency diagram from a dependency graph"""
    
    # Define known Mermaid reserved keywords that need escaping
    RESERVED_KEYWORDS = {
        'style', 'end', 'default', 'class', 'classDef', 'click', 'graph', 
        'subgraph', 'direction', 'TD', 'LR', 'TB', 'RL', 'BT'
    }
    
    def escape_node_name(name:str  # Node name to check for conflicts
                        ) -> str:  # Escaped name if needed
        """Escape node names that conflict with Mermaid reserved keywords"""
        if name.lower() in RESERVED_KEYWORDS:
            # Add suffix to avoid keyword conflicts
            return name + "_mod"
        return name
    
    def sanitize_node_id(name:str  # Module name with possible dots
                        ) -> str:  # Sanitized node ID
        """Convert module name to valid Mermaid node ID"""
        # Replace dots with underscores for valid Mermaid IDs
        return name.replace('.', '_')
    
    lines = []
    lines.append(f"```mermaid")
    lines.append(f"graph {direction}")
    
    # Add nodes with descriptions
    for module_name, module_info in graph.modules.items():
        # Create a sanitized ID for Mermaid
        node_id = sanitize_node_id(module_name)
        escaped_id = escape_node_name(node_id)
        
        # Create node label with original module name for display
        if module_info.title:
            label = f"{escaped_id}[{module_name}<br/>{module_info.title}]"
        else:
            label = f"{escaped_id}[{module_name}]"
        lines.append(f"    {label}")
    
    lines.append("")  # Empty line for readability
    
    # Consolidate dependencies between same source and target
    dep_map = defaultdict(list)
    for dep in graph.dependencies:
        key = (dep.source, dep.target)
        dep_map[key].extend(dep.imported_names)
    
    # Add edges
    for (source, target), imported_names in dep_map.items():
        # Sanitize module names for Mermaid IDs
        source_id = sanitize_node_id(source)
        target_id = sanitize_node_id(target)
        escaped_source = escape_node_name(source_id)
        escaped_target = escape_node_name(target_id)
        
        if show_imports and imported_names:
            # Remove duplicates and show what's imported
            unique_imports = list(dict.fromkeys(imported_names))  # Preserve order while removing duplicates
            imports = ', '.join(unique_imports[:3])  # Limit to 3
            if len(unique_imports) > 3:
                imports += '...'
            lines.append(f'    {escaped_source} -->|"{imports}"| {escaped_target}')
        else:
            lines.append(f"    {escaped_source} --> {escaped_target}")
    
    lines.append("```")
    
    return '\n'.join(lines)

# %% ../nbs/dependencies.ipynb 14
def generate_dependency_matrix(graph: DependencyGraph   # Dependency graph
                              ) -> str:                 # Markdown table
    "Generate a dependency matrix showing which modules depend on which"
    # Get all module names sorted
    modules = sorted(graph.modules.keys())
    
    if not modules:
        return "No modules found"
    
    # Build dependency map
    dep_map = defaultdict(set)
    for dep in graph.dependencies:
        dep_map[dep.source].add(dep.target)
    
    # Create table header
    lines = []
    header = "| Module | " + " | ".join(modules) + " |"
    separator = "|--------|" + "".join(["----|" for _ in modules])
    
    lines.append(header)
    lines.append(separator)
    
    # Create rows
    for source in modules:
        row = f"| {source} |"
        for target in modules:
            if target in dep_map[source]:
                row += " âœ“ |"
            else:
                row += "   |"
        lines.append(row)
    
    return '\n'.join(lines)
