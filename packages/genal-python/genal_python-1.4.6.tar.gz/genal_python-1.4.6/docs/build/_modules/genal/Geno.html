<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>genal.Geno &mdash; genal v0.8 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/documentation_options.js?v=b326c068"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            genal
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html#tutorial">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">The Geno class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html#main-functions">Main functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">genal</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">genal.Geno</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for genal.Geno</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">psutil</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>
<span class="kn">from</span> <span class="nn">plotnine</span> <span class="kn">import</span> <span class="n">ggplot</span><span class="p">,</span> <span class="n">aes</span><span class="p">,</span> <span class="n">geom_point</span><span class="p">,</span> <span class="n">geom_errorbarh</span><span class="p">,</span> <span class="n">geom_errorbar</span><span class="p">,</span> <span class="n">theme</span><span class="p">,</span> <span class="n">element_text</span><span class="p">,</span> <span class="n">geom_abline</span><span class="p">,</span> <span class="n">labs</span><span class="p">,</span> <span class="n">expand_limits</span>


<span class="kn">from</span> <span class="nn">.proxy</span> <span class="kn">import</span> <span class="n">find_proxies</span><span class="p">,</span> <span class="n">apply_proxies</span><span class="p">,</span> <span class="n">query_outcome_proxy</span>
<span class="kn">from</span> <span class="nn">.MR_tools</span> <span class="kn">import</span> <span class="n">query_outcome_func</span><span class="p">,</span> <span class="n">harmonize_MR</span><span class="p">,</span> <span class="n">MR_func</span><span class="p">,</span> <span class="n">mrpresso_func</span>
<span class="kn">from</span> <span class="nn">.clump</span> <span class="kn">import</span> <span class="n">clump_data</span>
<span class="kn">from</span> <span class="nn">.lift</span> <span class="kn">import</span> <span class="n">lift_data</span>
<span class="kn">from</span> <span class="nn">.tools</span> <span class="kn">import</span> <span class="n">create_tmp</span><span class="p">,</span> <span class="n">get_plink19_path</span><span class="p">,</span> <span class="n">load_reference_panel</span><span class="p">,</span> <span class="n">setup_genetic_path</span>
<span class="kn">from</span> <span class="nn">.geno_tools</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">save_data</span><span class="p">,</span>
    <span class="n">check_arguments</span><span class="p">,</span>
    <span class="n">adjust_column_names</span><span class="p">,</span>
    <span class="n">check_int_column</span><span class="p">,</span>
    <span class="n">fill_snpids_func</span><span class="p">,</span>
    <span class="n">fill_coordinates_func</span><span class="p">,</span>
    <span class="n">fill_nea</span><span class="p">,</span>
    <span class="n">fill_ea_nea</span><span class="p">,</span>
    <span class="n">check_beta_column</span><span class="p">,</span>
    <span class="n">check_p_column</span><span class="p">,</span>
    <span class="n">fill_se_p</span><span class="p">,</span>
    <span class="n">check_allele_column</span><span class="p">,</span>
    <span class="n">check_snp_column</span><span class="p">,</span>
    <span class="n">remove_na</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.association</span> <span class="kn">import</span> <span class="n">set_phenotype_func</span><span class="p">,</span> <span class="n">association_test_func</span>
<span class="kn">from</span> <span class="nn">.extract_prs</span> <span class="kn">import</span> <span class="n">extract_snps_func</span><span class="p">,</span> <span class="n">prs_func</span>
<span class="kn">from</span> <span class="nn">.snp_query</span> <span class="kn">import</span> <span class="n">async_query_gwas_catalog</span>
<span class="kn">from</span> <span class="nn">.constants</span> <span class="kn">import</span> <span class="n">STANDARD_COLUMNS</span><span class="p">,</span> <span class="n">REF_PANEL_COLUMNS</span><span class="p">,</span> <span class="n">CHECKS_DICT</span><span class="p">,</span> <span class="n">MR_METHODS_NAMES</span>

<span class="c1"># Do all the MR steps (query_outcome, harmonize etc) based on CHR/POS and not SNPs</span>
<span class="c1"># Consider reference panels in build 38</span>
<span class="c1"># Add proxying function (input is df + searchspace (list of SNP or path to .bim, can be separated by chromosomes) and returns proxied df)</span>
<span class="c1"># Get proxies (simply return a list of proxies)</span>
<span class="c1"># Multi-MR with python MR</span>
<span class="c1"># Switch to plink2.0 (but check that all functions exist)</span>
<span class="c1"># Handle genetic files in pgen (requires plink2.0)</span>
<span class="c1"># Helper function to read bim or pvar (or other variant files) from a genetic path and handle the cases where the chr column is not only a number</span>


<div class="viewcode-block" id="Geno">
<a class="viewcode-back" href="../../modules.html#genal.Geno">[docs]</a>
<span class="k">class</span> <span class="nc">Geno</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to handle GWAS-derived data, including SNP rsID, genome position,</span>
<span class="sd">    SNP-trait effects, and effect allele frequencies.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        data (pd.DataFrame): Main DataFrame containing SNP data.</span>
<span class="sd">        phenotype (pd.DataFrame, str): Tuple with a DataFrame of individual-level phenotype</span>
<span class="sd">            data and a string representing the phenotype trait column. Initialized after</span>
<span class="sd">            running the &#39;set_phenotype&#39; method.</span>
<span class="sd">        MR_data (pd.DataFrame, pd.DataFrame, str): Tuple containing DataFrames for associations</span>
<span class="sd">            with exposure and outcome, and a string for the outcome name. Initialized after</span>
<span class="sd">            running the &#39;query_outcome&#39; method.</span>
<span class="sd">        MR_results (pd.DataFrame, pd.DataFrame, str, str): Contains an MR results dataframe, a dataframe of harmonized SNPs, an exposure name, an outcome name. Assigned after calling the MR method and used for plotting with the MR_plot method.</span>
<span class="sd">        ram (int): Available memory.</span>
<span class="sd">        cpus (int): Number of available CPUs.</span>
<span class="sd">        checks (dict): Dictionary of checks performed on the main DataFrame.</span>
<span class="sd">        name (str): ID of the object (for internal reference and debugging purposes).</span>
<span class="sd">        reference_panel (pd.DataFrame): Reference population SNP data used for SNP info</span>
<span class="sd">            adjustments. Initialized when first needed.</span>
<span class="sd">        reference_panel_name (str): string to identify the reference_panel (path or population string)</span>

<span class="sd">    Methods:</span>
<span class="sd">        preprocess_data: Clean and preprocess the &#39;data&#39; attribute (the main dataframe of SNP-level data).</span>
<span class="sd">        clump: Clump the main data based on reference panels and return a new Geno object with the clumped data.</span>
<span class="sd">        prs: Computes Polygenic Risk Score on genomic data.</span>
<span class="sd">        set_phenotype: Assigns a DataFrame with individual-level data and a phenotype trait to the &#39;phenotype&#39; attribute.</span>
<span class="sd">        association_test: Computes SNP-trait effect estimates, standard errors, and p-values.</span>
<span class="sd">        query_outcome: Extracts SNPs from SNP-outcome association data and stores it in the &#39;MR_data&#39; attribute.</span>
<span class="sd">        MR: Performs Mendelian Randomization between the SNP-exposure and SNP-outcome data stored in the &#39;MR_data&#39; attribute. Stores the results in the &#39;MR_results&#39; attribute.</span>
<span class="sd">        MR_plot: Plot the results of the MR analysis stored in the &#39;MR_results&#39; attribute.</span>
<span class="sd">        MRpresso: Executes the MR-PRESSO algorithm for horizontal pleiotropy correction between the SNP-exposure and SNP-outcome data stored in the &#39;MR_data&#39; attribute.</span>
<span class="sd">        lift: Lifts SNP data from one genomic build to another.</span>
<span class="sd">        query_gwas_catalog: Query the GWAS Catalog for SNP-trait associations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">CHR</span><span class="o">=</span><span class="s2">&quot;CHR&quot;</span><span class="p">,</span>
        <span class="n">POS</span><span class="o">=</span><span class="s2">&quot;POS&quot;</span><span class="p">,</span>
        <span class="n">SNP</span><span class="o">=</span><span class="s2">&quot;SNP&quot;</span><span class="p">,</span>
        <span class="n">EA</span><span class="o">=</span><span class="s2">&quot;EA&quot;</span><span class="p">,</span>
        <span class="n">NEA</span><span class="o">=</span><span class="s2">&quot;NEA&quot;</span><span class="p">,</span>
        <span class="n">BETA</span><span class="o">=</span><span class="s2">&quot;BETA&quot;</span><span class="p">,</span>
        <span class="n">SE</span><span class="o">=</span><span class="s2">&quot;SE&quot;</span><span class="p">,</span>
        <span class="n">P</span><span class="o">=</span><span class="s2">&quot;P&quot;</span><span class="p">,</span>
        <span class="n">EAF</span><span class="o">=</span><span class="s2">&quot;EAF&quot;</span><span class="p">,</span>
        <span class="n">keep_columns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the Geno object used to store and transform Single Nucleotide Polymorphisms (SNP) data.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame): DataFrame where each row represents a SNP.</span>
<span class="sd">            CHR (str, optional): Column name for chromosome. Defaults to &quot;CHR&quot;.</span>
<span class="sd">            POS (str, optional): Column name for genomic position. Defaults to &quot;POS&quot;.</span>
<span class="sd">            SNP (str, optional): Column name for SNP identifier. Defaults to &quot;SNP&quot;.</span>
<span class="sd">            EA (str, optional): Column name for effect allele. Defaults to &quot;EA&quot;.</span>
<span class="sd">            NEA (str, optional): Column name for non-effect allele. Defaults to &quot;NEA&quot;.</span>
<span class="sd">            BETA (str, optional): Column name for effect estimate. Defaults to &quot;BETA&quot;.</span>
<span class="sd">            SE (str, optional): Column name for effect standard error. Defaults to &quot;SE&quot;.</span>
<span class="sd">            P (str, optional): Column name for p-value. Defaults to &quot;P&quot;.</span>
<span class="sd">            EAF (str, optional): Column name for effect allele frequency. Defaults to &quot;EAF&quot;.</span>
<span class="sd">            keep_columns (bool, optional): Determines if non-main columns should be kept. Defaults to True.</span>

<span class="sd">        Attributes:</span>
<span class="sd">            name (str): Randomly generated ID for the Geno object.</span>
<span class="sd">            outcome (list): List of outcomes (initialized as empty).</span>
<span class="sd">            cpus (int): Number of CPUs to be used.</span>
<span class="sd">            ram (int): Amount of RAM to be used in MBs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Validate df type</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;df needs to be a pandas dataframe.&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Standardize column names based on provided parameters +/- delete other columns</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">adjust_column_names</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">CHR</span><span class="p">,</span> <span class="n">POS</span><span class="p">,</span> <span class="n">SNP</span><span class="p">,</span> <span class="n">EA</span><span class="p">,</span> <span class="n">NEA</span><span class="p">,</span> <span class="n">BETA</span><span class="p">,</span> <span class="n">SE</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">EAF</span><span class="p">,</span> <span class="n">keep_columns</span>
        <span class="p">)</span>

        <span class="c1"># Set object attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())[:</span><span class="mi">8</span><span class="p">]</span>

        <span class="c1"># List to keep track of checks performed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checks</span> <span class="o">=</span> <span class="n">CHECKS_DICT</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Set the maximal amount of ram/cpu to be used by the methods and dask chunksize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cpus</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SLURM_CPUS_PER_TASK&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()))</span>
        <span class="n">non_hpc_ram_per_cpu</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">virtual_memory</span><span class="p">()</span><span class="o">.</span><span class="n">available</span> <span class="o">/</span> <span class="p">(</span>
            <span class="mi">1024</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpus</span>
        <span class="p">)</span>
        <span class="n">ram_per_cpu</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SLURM_MEM_PER_CPU&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">non_hpc_ram_per_cpu</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ram</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ram_per_cpu</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpus</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">)</span>

        <span class="n">create_tmp</span><span class="p">()</span>

        <span class="k">return</span>

<div class="viewcode-block" id="Geno.preprocess_data">
<a class="viewcode-back" href="../../modules.html#genal.Geno.preprocess_data">[docs]</a>
    <span class="k">def</span> <span class="nf">preprocess_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">preprocessing</span><span class="o">=</span><span class="s1">&#39;Fill&#39;</span><span class="p">,</span>
        <span class="n">reference_panel</span><span class="o">=</span><span class="s2">&quot;eur&quot;</span><span class="p">,</span>
        <span class="n">effect_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_multi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_dups</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_snpids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_coordinates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clean and preprocess the main dataframe of Single Nucleotide Polymorphisms (SNP) data.</span>

<span class="sd">        Args:</span>
<span class="sd">            preprocessing (str, optional): Level of preprocessing to apply. Options include:</span>
<span class="sd">                - &quot;None&quot;: The dataframe is not modified.</span>
<span class="sd">                - &quot;Fill&quot;: Missing columns are added based on reference data and invalid values set to NaN, but no rows are deleted.</span>
<span class="sd">                - &quot;Fill_delete&quot;: Missing columns are added, and rows with missing, duplicated, or invalid values are deleted.</span>
<span class="sd">                Defaults to &#39;Fill&#39;.</span>
<span class="sd">            reference_panel (str or pd.DataFrame, optional): Reference panel for SNP adjustments. Can be a string representing ancestry classification (&quot;eur&quot;, &quot;afr&quot;, &quot;eas&quot;, &quot;sas&quot;, &quot;amr&quot;) or a DataFrame with [&quot;CHR&quot;,&quot;SNP&quot;,&quot;POS&quot;,&quot;A1&quot;,&quot;A2&quot;] columns or a path to a .bim file. Defaults to &quot;eur&quot;.</span>
<span class="sd">            effect_column (str, optional): Specifies the type of effect column (&quot;BETA&quot; or &quot;OR&quot;). If None, the method tries to determine it. Odds Ratios will be log-transformed and the standard error adjusted. Defaults to None.</span>
<span class="sd">            keep_multi (bool, optional): Determines if multiallelic SNPs should be kept. If None, defers to preprocessing value. Defaults to None.</span>
<span class="sd">            keep_dups (bool, optional): Determines if rows with duplicate SNP IDs should be kept. If None, defers to preprocessing value. Defaults to None.</span>
<span class="sd">            fill_snpids (bool, optional): Decides if the SNP (rsID) column should be created or replaced based on CHR/POS columns and a reference genome. If None, defers to preprocessing value. Defaults to None.</span>
<span class="sd">            fill_coordinates (bool, optional): Decides if CHR and/or POS should be created or replaced based on SNP column and a reference genome. If None, defers to preprocessing value. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Check arguments and solve arguments logic.</span>
        <span class="n">keep_multi</span><span class="p">,</span> <span class="n">keep_dups</span><span class="p">,</span> <span class="n">fill_snpids</span><span class="p">,</span> <span class="n">fill_coordinates</span> <span class="o">=</span> <span class="n">check_arguments</span><span class="p">(</span>
            <span class="n">preprocessing</span><span class="p">,</span>
            <span class="n">reference_panel</span><span class="p">,</span>
            <span class="n">effect_column</span><span class="p">,</span>
            <span class="n">fill_snpids</span><span class="p">,</span>
            <span class="n">fill_coordinates</span><span class="p">,</span>
            <span class="n">keep_multi</span><span class="p">,</span>
            <span class="n">keep_dups</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Ensure CHR and POS columns are integers if preprocessing is enabled</span>
        <span class="k">for</span> <span class="n">int_col</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">int_col</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="n">preprocessing</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Fill&#39;</span><span class="p">,</span> <span class="s1">&#39;Fill_delete&#39;</span><span class="p">]:</span>
                <span class="n">check_int_column</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">int_col</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">[</span><span class="n">int_col</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Fill missing SNP column from reference data if necessary</span>
        <span class="n">should_fill_snpids</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;CHR&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;POS&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;SNP&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="n">fill_snpids</span>
        <span class="k">if</span> <span class="n">should_fill_snpids</span> <span class="ow">and</span> <span class="n">fill_snpids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">fill_snpids_func</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reference_panel</span><span class="p">(</span><span class="n">reference_panel</span><span class="p">))</span>

        <span class="c1"># Fill missing CHR/POS columns from reference data if necessary</span>
        <span class="n">should_fill_coordinates</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="s2">&quot;CHR&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="s2">&quot;POS&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
            <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;SNP&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="n">fill_coordinates</span>
        <span class="k">if</span> <span class="n">should_fill_coordinates</span> <span class="ow">and</span> <span class="n">fill_coordinates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">fill_coordinates_func</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reference_panel</span><span class="p">(</span><span class="n">reference_panel</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Fill missing NEA column from reference data if necessary and preprocessing is enabled</span>
        <span class="n">missing_nea_condition</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;CHR&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
            <span class="ow">and</span> <span class="s2">&quot;POS&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
            <span class="ow">and</span> <span class="s2">&quot;NEA&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
            <span class="ow">and</span> <span class="s2">&quot;EA&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">missing_nea_condition</span> <span class="ow">and</span> <span class="n">preprocessing</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Fill&#39;</span><span class="p">,</span> <span class="s1">&#39;Fill_delete&#39;</span><span class="p">]:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">fill_nea</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reference_panel</span><span class="p">(</span><span class="n">reference_panel</span><span class="p">))</span>

        <span class="c1"># Fill missing EA and NEA columns from reference data if necessary and preprocessing is enabled</span>
        <span class="n">missing_ea_nea_condition</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;CHR&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
            <span class="ow">and</span> <span class="s2">&quot;POS&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
            <span class="ow">and</span> <span class="s2">&quot;NEA&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
            <span class="ow">and</span> <span class="s2">&quot;EA&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">missing_ea_nea_condition</span> <span class="ow">and</span> <span class="n">preprocessing</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Fill&#39;</span><span class="p">,</span> <span class="s1">&#39;Fill_delete&#39;</span><span class="p">]:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">fill_ea_nea</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reference_panel</span><span class="p">(</span><span class="n">reference_panel</span><span class="p">))</span>

        <span class="c1"># Convert effect column to Beta estimates if present</span>
        <span class="k">if</span> <span class="s2">&quot;BETA&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">check_beta_column</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">effect_column</span><span class="p">,</span> <span class="n">preprocessing</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">[</span><span class="s2">&quot;BETA&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Ensure P column contains valid values</span>
        <span class="k">if</span> <span class="s2">&quot;P&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="n">preprocessing</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Fill&#39;</span><span class="p">,</span> <span class="s1">&#39;Fill_delete&#39;</span><span class="p">]:</span>
            <span class="n">check_p_column</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">[</span><span class="s2">&quot;P&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Fill missing SE or P columns if necessary</span>
        <span class="k">if</span> <span class="n">preprocessing</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Fill&#39;</span><span class="p">,</span> <span class="s1">&#39;Fill_delete&#39;</span><span class="p">]:</span>
            <span class="n">fill_se_p</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Process allele columns</span>
        <span class="k">for</span> <span class="n">allele_col</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;EA&quot;</span><span class="p">,</span> <span class="s2">&quot;NEA&quot;</span><span class="p">]:</span>
            <span class="n">check_allele_condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">allele_col</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">preprocessing</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Fill&#39;</span><span class="p">,</span> <span class="s1">&#39;Fill_delete&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">keep_multi</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">check_allele_condition</span><span class="p">:</span>
                <span class="n">check_allele_column</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">allele_col</span><span class="p">,</span> <span class="n">keep_multi</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">[</span><span class="n">allele_col</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Check for and handle duplicate SNPs if necessary</span>
        <span class="k">if</span> <span class="s2">&quot;SNP&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">keep_dups</span><span class="p">:</span>
            <span class="n">check_snp_column</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">[</span><span class="s2">&quot;SNP&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Warn if essential columns are missing</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">STANDARD_COLUMNS</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">column</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Warning: the data doesn&#39;t include a </span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2"> column. This may become an issue later on.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Remove missing values if preprocessing level is set to &#39;Fill_delete&#39;</span>
        <span class="k">if</span> <span class="n">preprocessing</span> <span class="o">==</span> <span class="s1">&#39;Fill_delete&#39;</span><span class="p">:</span>
            <span class="n">remove_na</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">[</span><span class="s2">&quot;NA_removal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1">## Reset index</span>
        <span class="c1"># self.data.reset_index(drop=True, inplace=True)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span></div>


<div class="viewcode-block" id="Geno.get_reference_panel">
<a class="viewcode-back" href="../../api.html#genal.Geno.get_reference_panel">[docs]</a>
    <span class="k">def</span> <span class="nf">get_reference_panel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_panel</span><span class="o">=</span><span class="s2">&quot;eur&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve or set the reference panel for the Geno object.</span>

<span class="sd">        If the Geno object does not have a reference panel attribute set,</span>
<span class="sd">        this method will try to set it based on the provided `reference_panel`</span>
<span class="sd">        argument. This can be either a string indicating a predefined reference panel</span>
<span class="sd">        or a DataFrame with specific columns or a path to a .bim file.</span>

<span class="sd">        Args:</span>
<span class="sd">            reference_panel (str or pd.DataFrame, optional): Either a string indicating a predefined</span>
<span class="sd">                reference panel (default is &quot;eur&quot;, options are &quot;afr&quot;, &quot;amr&quot;, &quot;eas&quot;, &quot;sas&quot;) or a DataFrame with necessary columns or a valid path to a .bim file</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: The reference panel DataFrame for the Geno object.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the provided DataFrame doesn&#39;t have the necessary columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if the user provided a dataframe</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference_panel</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="c1"># If the provided reference_panel is a DataFrame, verify its structure and dtypes</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">REF_PANEL_COLUMNS</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reference_panel</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> column is not present in the reference_panel provided and is necessary.&quot;</span>
                    <span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Using the provided reference_panel dataframe as the reference panel.&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_panel</span> <span class="o">=</span> <span class="n">reference_panel</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_panel_name</span> <span class="o">=</span> <span class="s2">&quot;USER_PROVIDED&quot;</span>
            
        <span class="c1"># Else, check if there is already a reference_panel with the same ID. If not, load it based on provided string</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;reference_panel&quot;</span><span class="p">)</span> <span class="ow">and</span> 
                  <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;reference_panel_name&quot;</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">reference_panel_name</span><span class="o">==</span><span class="n">reference_panel</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_panel</span> <span class="o">=</span> <span class="n">load_reference_panel</span><span class="p">(</span><span class="n">reference_panel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_panel_name</span> <span class="o">=</span> <span class="n">reference_panel</span>   

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_panel</span></div>


<div class="viewcode-block" id="Geno.clump">
<a class="viewcode-back" href="../../modules.html#genal.Geno.clump">[docs]</a>
    <span class="k">def</span> <span class="nf">clump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kb</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">r2</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="mf">5e-8</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">reference_panel</span><span class="o">=</span><span class="s2">&quot;eur&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clump the data based on linkage disequilibrium and return another Geno object with the clumped data.</span>
<span class="sd">        The clumping process is executed using plink.</span>

<span class="sd">        Args:</span>
<span class="sd">            kb (int, optional): Clumping window in thousands of SNPs. Default is 250.</span>
<span class="sd">            r2 (float, optional): Linkage disequilibrium threshold, values between 0 and 1. Default is 0.1.</span>
<span class="sd">            p1 (float, optional): P-value threshold during clumping. SNPs with a P-value higher than this value are excluded. Default is 5e-8.</span>
<span class="sd">            p2 (float, optional): P-value threshold post-clumping to further filter the clumped SNPs. If p2 &lt; p1, it won&#39;t be considered. Default is 0.01.</span>
<span class="sd">            reference_panel (str, optional): The reference population for linkage disequilibrium values. Accepts values &quot;eur&quot;, &quot;sas&quot;, &quot;afr&quot;, &quot;eas&quot;, &quot;amr&quot;. Alternatively, a path leading to a specific bed/bim/fam reference panel can be provided. Default is &quot;eur&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            genal.Geno: A new Geno object based on the clumped data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Ensure required columns exist in the data</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SNP&quot;</span><span class="p">,</span> <span class="s2">&quot;P&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The column </span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2"> is not found in the data&quot;</span><span class="p">)</span>
                
        <span class="n">create_tmp</span><span class="p">()</span> <span class="c1">#Make sure temporary folder exists</span>

        <span class="c1"># Validate and process SNP and P columns, if not already done</span>
        <span class="k">if</span> <span class="s2">&quot;SNP&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">:</span>
            <span class="n">check_snp_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">[</span><span class="s2">&quot;SNP&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="s2">&quot;P&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">:</span>
            <span class="n">check_p_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">[</span><span class="s2">&quot;P&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">initial_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;SNP&quot;</span><span class="p">,</span> <span class="s2">&quot;P&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">deleted_rows</span> <span class="o">=</span> <span class="n">initial_rows</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">deleted_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">deleted_rows</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">deleted_rows</span><span class="o">/</span><span class="n">initial_rows</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">%) rows with NA values in columns SNP or P have been deleted.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create tmp directory if it doesn&#39;t exist</span>
        <span class="n">create_tmp</span><span class="p">()</span>

        <span class="c1"># Clump the data using the specified parameters</span>
        <span class="n">clumped_data</span> <span class="o">=</span> <span class="n">clump_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">reference_panel</span><span class="p">,</span>
            <span class="n">kb</span><span class="p">,</span>
            <span class="n">r2</span><span class="p">,</span>
            <span class="n">p1</span><span class="p">,</span>
            <span class="n">p2</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ram</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># If clumped data is successfully generated, assign it to the object&#39;s attribute</span>
        <span class="k">if</span> <span class="n">clumped_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Clumped</span> <span class="o">=</span> <span class="n">Geno</span><span class="p">(</span><span class="n">clumped_data</span><span class="p">,</span> <span class="n">keep_columns</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">Clumped</span><span class="o">.</span><span class="n">checks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;phenotype&quot;</span><span class="p">):</span>
                <span class="n">Clumped</span><span class="o">.</span><span class="n">phenotype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phenotype</span>
            <span class="k">return</span> <span class="n">Clumped</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Geno.update_snpids">
<a class="viewcode-back" href="../../api.html#genal.Geno.update_snpids">[docs]</a>
    <span class="k">def</span> <span class="nf">update_snpids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update or create the column of SNP name based on genetic data and genomic position.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            path (str, optional): Path to a bed/bim/fam set of genetic files.</span>
<span class="sd">                If files are split by chromosomes, replace the chromosome number with &#39;$&#39;.</span>
<span class="sd">                For instance: path = &quot;ukb_chr$_file&quot;. Defaults to the path from the configuration.</span>
<span class="sd">            replace (bool, optional): To update the .data attribute with the updated SNP column or not.</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">            None: It updates the dataframe in the .data attribute.</span>
<span class="sd">            </span>
<span class="sd">        Note:</span>
<span class="sd">            This can be used before extracting SNPs from the genetic data if there is possibility of a mismatch between the SNP name contained in the Geno dataframe (SNP-level data) and the SNP name used in the genetic data (individual-level data). </span>
<span class="sd">            Notably, this can avoid losing SNPs due to ID mismatch during polygenic risk scoring or single-SNP association testing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check mandatory columns</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The column </span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2"> is not found in the data and is mandatory to update snpIDs!&quot;</span>
                <span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># We don&#39;t want to modify the data attribute</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">setup_genetic_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="c1">#Verify the path</span>
        <span class="n">filetype</span> <span class="o">=</span> <span class="s2">&quot;split&quot;</span> <span class="k">if</span> <span class="s2">&quot;$&quot;</span> <span class="ow">in</span> <span class="n">path</span> <span class="k">else</span> <span class="s2">&quot;combined&quot;</span> <span class="c1">#If data is split by chromosomes or not</span>
        <span class="c1"># Merge data with the bim dataframe</span>
        <span class="k">if</span> <span class="n">filetype</span> <span class="o">==</span> <span class="s2">&quot;combined&quot;</span><span class="p">:</span>
            <span class="n">bim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
                <span class="n">path</span> <span class="o">+</span> <span class="s2">&quot;.bim&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">,</span> <span class="s2">&quot;SNP&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">,</span> <span class="s2">&quot;A1&quot;</span><span class="p">,</span> <span class="s2">&quot;A2&quot;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Convert CHR to string and remove &#39;chr&#39; prefix if present, then convert to int</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">bim</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;chr&quot;</span><span class="p">):</span>
                <span class="n">bim</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bim</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;^chr&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">bim</span><span class="p">[[</span><span class="s2">&quot;CHR&quot;</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">,</span> <span class="s2">&quot;SNP&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;_new&#39;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chr_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;CHR&#39;</span><span class="p">)}</span> <span class="c1">#Split the dataframe by chromosome</span>
            <span class="n">partial_merge_command_parallel</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">merge_command_parallel</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span>
            <span class="p">)</span>  <span class="c1"># Wrapper function</span>
            <span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span> <span class="c1">#Merge each dataframe subset</span>
                <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">partial_merge_command_parallel</span><span class="p">,</span> <span class="n">chr_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#And combine them again</span>
        <span class="c1"># Update the SNP column</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;SNP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;SNP_new&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SNP&#39;</span><span class="p">])</span>
        <span class="n">n_absent</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;SNP_new&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SNP_new&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">#if n_absent &gt; 0:</span>
        <span class="c1">#    print(f&quot;{n_absent}({n_absent/data.shape[0]*100:.3f}%) are not present in the genetic data.&quot;)</span>
        <span class="c1">#else:</span>
        <span class="c1">#    print(&quot;All SNPs are present in the genetic data.&quot;)</span>
        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="c1">#Update attribute if replace argument</span>
        <span class="k">return</span> <span class="n">data</span></div>

    
<div class="viewcode-block" id="Geno.extract_snps">
<a class="viewcode-back" href="../../api.html#genal.Geno.extract_snps">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_snps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the list of SNPs of this Geno object from the genetic data provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, optional): Path to a bed/bim/fam set of genetic files.</span>
<span class="sd">                If files are split by chromosomes, replace the chromosome number with &#39;$&#39;.</span>
<span class="sd">                For instance: path = &quot;ukb_chr$_file&quot;. Default is None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: The output is a bed/bim/fam triple in the tmp_GENAL folder</span>
<span class="sd">            with the format &quot;{name}_extract_allchr&quot; which includes the SNPs from the UKB.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The provided path is saved to the config file. If this function is called again,</span>
<span class="sd">            you don&#39;t need to specify the path if you want to use the same genomic files.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">create_tmp</span><span class="p">()</span> <span class="c1">#Make sure temporary folder exists</span>
        
        <span class="c1"># Extract the SNP list</span>
        <span class="n">snp_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;SNP&quot;</span><span class="p">]</span>

        <span class="c1"># Extract SNPs using the provided path and SNP list</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">extract_snps_func</span><span class="p">(</span><span class="n">snp_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

        <span class="k">return</span></div>


<div class="viewcode-block" id="Geno.prs">
<a class="viewcode-back" href="../../modules.html#genal.Geno.prs">[docs]</a>
    <span class="k">def</span> <span class="nf">prs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">proxy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">reference_panel</span><span class="o">=</span><span class="s2">&quot;eur&quot;</span><span class="p">,</span>
            <span class="n">kb</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
            <span class="n">r2</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
            <span class="n">window_snps</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
            
           <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a Polygenic Risk Score (PRS) and save it as a CSV file in the current directory.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str, optional): Name or path of the saved PRS file.</span>
<span class="sd">            weighted (bool, optional): If True, performs a PRS weighted by the BETA column estimates.</span>
<span class="sd">                                       If False, performs an unweighted PRS. Default is True.</span>
<span class="sd">            path (str, optional): Path to a bed/bim/fam set of genetic files for PRS calculation.</span>
<span class="sd">                                  If files are split by chromosomes, replace the chromosome number</span>
<span class="sd">                                  with &#39;$&#39;. For instance: path = &quot;ukb_chr$_file&quot;.</span>
<span class="sd">                                  If not provided, it will use the genetic path most recently used </span>
<span class="sd">                                  (if any). Default is None.</span>
<span class="sd">            position (bool, optional): Use the genomic positions instead of the SNP names to find the</span>
<span class="sd">                                  SNPs in the genetic data (recommended).</span>
<span class="sd">            proxy (bool, optional): If true, proxies are searched. Default is True.</span>
<span class="sd">            reference_panel (str, optional): The reference population used to derive linkage</span>
<span class="sd">                disequilibrium values and find proxies (only if proxy=True). Acceptable values</span>
<span class="sd">                include &quot;EUR&quot;, &quot;SAS&quot;, &quot;AFR&quot;, &quot;EAS&quot;, &quot;AMR&quot; or a path to a specific bed/bim/fam panel.</span>
<span class="sd">                Default is &quot;EUR&quot;.</span>
<span class="sd">            kb (int, optional): Width of the genomic window to look for proxies. Default is 5000.</span>
<span class="sd">            r2 (float, optional): Minimum linkage disequilibrium value with the main SNP</span>
<span class="sd">                for a proxy to be included. Default is 0.6.</span>
<span class="sd">            window_snps (int, optional): Compute the LD value for SNPs that are not</span>
<span class="sd">                more than x SNPs away from the main SNP. Default is 5000.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: The computed PRS data.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the data hasn&#39;t been clumped and &#39;clumped&#39; parameter is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">path</span> <span class="o">=</span> <span class="n">setup_genetic_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="c1"># Check path</span>
        <span class="n">create_tmp</span><span class="p">()</span> <span class="c1">#Make sure temporary folder exists</span>
        
        <span class="c1"># Check for mandatory columns in data</span>
        <span class="n">mandatory_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;EA&quot;</span><span class="p">,</span> <span class="s2">&quot;BETA&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">mandatory_cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The column </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> is not found in the data!&quot;</span><span class="p">)</span>
                
        <span class="c1"># Based on column presents, run the PRS with SNP names or genomic positions (with preference for positions)</span>
        <span class="k">if</span> <span class="s2">&quot;CHR&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s2">&quot;POS&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CHR/POS columns present: SNPs searched based on genomic positions.&quot;</span><span class="p">)</span>
            <span class="n">data_prs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_snpids</span><span class="p">(</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;SNP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CHR/POS columns absent: SNPs searched based on SNP name.&quot;</span><span class="p">)</span>
            <span class="n">data_prs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either the SNP or the CHR/POS columns need to be present to run a PRS.&quot;</span><span class="p">)</span>

        <span class="c1"># Check SNP and EA columns</span>
        <span class="k">if</span> <span class="s2">&quot;SNP&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">:</span>
            <span class="n">check_snp_column</span><span class="p">(</span><span class="n">data_prs</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;EA&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">:</span>
            <span class="n">check_allele_column</span><span class="p">(</span><span class="n">data_prs</span><span class="p">,</span> <span class="s2">&quot;EA&quot;</span><span class="p">,</span> <span class="n">keep_multi</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;BETA&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">:</span>
            <span class="n">check_beta_column</span><span class="p">(</span><span class="n">data_prs</span><span class="p">,</span> <span class="n">effect_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">preprocessing</span><span class="o">=</span><span class="s1">&#39;Fill_delete&#39;</span><span class="p">)</span>

        <span class="n">initial_rows</span> <span class="o">=</span> <span class="n">data_prs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data_prs</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;SNP&quot;</span><span class="p">,</span> <span class="s2">&quot;EA&quot;</span><span class="p">,</span> <span class="s2">&quot;BETA&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">deleted_rows</span> <span class="o">=</span> <span class="n">initial_rows</span> <span class="o">-</span> <span class="n">data_prs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">deleted_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">deleted_rows</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">deleted_rows</span><span class="o">/</span><span class="n">initial_rows</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">%) rows with NA values in columns SNP, EA, or BETA have been deleted.&quot;</span>
            <span class="p">)</span>
            
        <span class="c1"># If proxy option</span>
        <span class="k">if</span> <span class="n">proxy</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Identifying the SNPs present in the genetic data...&quot;</span><span class="p">)</span>
            <span class="c1"># Obtain the list of SNPs present in the genetic data</span>
            <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;$&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">#If split: merge all SNP columns of the .bim files</span>
                <span class="n">genetic_snp_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">23</span><span class="p">):</span>
                    <span class="n">path_i</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;$&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">+</span> <span class="s2">&quot;.bim&quot;</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_i</span><span class="p">):</span>
                        <span class="n">bim_i</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
                            <span class="n">path_i</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">,</span> <span class="s2">&quot;SNP&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">,</span> <span class="s2">&quot;A1&quot;</span><span class="p">,</span> <span class="s2">&quot;A2&quot;</span><span class="p">],</span> <span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;SNP&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="n">genetic_snp_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bim_i</span><span class="o">.</span><span class="n">SNP</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#If not split</span>
                <span class="n">bim_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;.bim&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">bim_path</span><span class="p">):</span>
                    <span class="n">bim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
                            <span class="n">bim_path</span><span class="p">,</span> 
                            <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">,</span> <span class="s2">&quot;SNP&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">,</span> <span class="s2">&quot;A1&quot;</span><span class="p">,</span> <span class="s2">&quot;A2&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The file </span><span class="si">{</span><span class="n">bim_path</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
                <span class="n">genetic_snp_list</span> <span class="o">=</span> <span class="n">bim</span><span class="o">.</span><span class="n">SNP</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="c1"># Identify the SNPs already present in the genetic data</span>
            <span class="n">genetic_snps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">genetic_snp_list</span><span class="p">)</span>
            <span class="n">exposure_snps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">data_prs</span><span class="o">.</span><span class="n">SNP</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">snps_present</span> <span class="o">=</span> <span class="n">exposure_snps</span> <span class="o">&amp;</span> <span class="n">genetic_snps</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">snps_present</span><span class="p">)</span><span class="si">}</span><span class="s2"> SNPs out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">exposure_snps</span><span class="p">)</span><span class="si">}</span><span class="s2"> are present in the genetic data.&quot;</span>
            <span class="p">)</span>
            <span class="c1"># Search proxies for absent SNPs</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exposure_snps</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">snps_present</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">snps_absent</span> <span class="o">=</span> <span class="n">exposure_snps</span> <span class="o">-</span> <span class="n">snps_present</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Searching proxies for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">snps_absent</span><span class="p">)</span><span class="si">}</span><span class="s2"> SNPs...&quot;</span><span class="p">)</span>
                <span class="n">ld</span> <span class="o">=</span> <span class="n">find_proxies</span><span class="p">(</span>
                    <span class="n">snps_absent</span><span class="p">,</span>
                    <span class="n">reference_panel</span><span class="o">=</span><span class="n">reference_panel</span><span class="p">,</span>
                    <span class="n">kb</span><span class="o">=</span><span class="n">kb</span><span class="p">,</span>
                    <span class="n">r2</span><span class="o">=</span><span class="n">r2</span><span class="p">,</span>
                    <span class="n">window_snps</span><span class="o">=</span><span class="n">window_snps</span><span class="p">,</span>
                    <span class="n">threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cpus</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">data_prs</span> <span class="o">=</span> <span class="n">apply_proxies</span><span class="p">(</span><span class="n">data_prs</span><span class="p">,</span> <span class="n">ld</span><span class="p">,</span> <span class="n">searchspace</span> <span class="o">=</span> <span class="n">genetic_snps</span><span class="p">)</span>
                <span class="n">check_snp_column</span><span class="p">(</span><span class="n">data_prs</span><span class="p">)</span>

        <span class="c1"># Compute PRS</span>
        <span class="n">prs_data</span> <span class="o">=</span> <span class="n">prs_func</span><span class="p">(</span><span class="n">data_prs</span><span class="p">,</span> <span class="n">weighted</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ram</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ram</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Save the computed PRS data as a CSV file</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="k">else</span> <span class="n">name</span>
        <span class="n">prs_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.csv&quot;</span>
        <span class="n">prs_data</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">prs_filename</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PRS data saved to </span><span class="si">{</span><span class="n">prs_filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span></div>


<div class="viewcode-block" id="Geno.set_phenotype">
<a class="viewcode-back" href="../../modules.html#genal.Geno.set_phenotype">[docs]</a>
    <span class="k">def</span> <span class="nf">set_phenotype</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">IID</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PHENO</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PHENO_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alternate_control</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign a phenotype dataframe to the .phenotype attribute.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (pd.DataFrame): DataFrame containing individual-level row data with at least an individual IDs column</span>
<span class="sd">                                 and one phenotype column.</span>
<span class="sd">            IID (str, optional): Name of the individual IDs column in &#39;data&#39;. These IDs should</span>
<span class="sd">                                 correspond to the genetic IDs in the FAM file that will be used for association testing.</span>
<span class="sd">            PHENO (str, optional): Name of the phenotype column in &#39;data&#39; which will be used</span>
<span class="sd">                                   as the dependent variable for association tests.</span>
<span class="sd">            PHENO_type (str, optional): If not specified, the function will try to infer if</span>
<span class="sd">                                        the phenotype is binary or quantitative. To bypass this,</span>
<span class="sd">                                        use &quot;quant&quot; for quantitative or &quot;binary&quot; for binary phenotypes.</span>
<span class="sd">                                        Default is None.</span>
<span class="sd">            alternate_control (bool, optional): By default, the function assumes that for a binary</span>
<span class="sd">                                                trait, the controls have the most frequent value.</span>
<span class="sd">                                                Set to True if this is not the case. Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: Sets the .phenotype attribute for the instance.</span>

<span class="sd">        Note:</span>
<span class="sd">            This method sets the .phenotype attribute which is essential to perform single-SNP association tests using the association_test method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">processed_data</span><span class="p">,</span> <span class="n">inferred_pheno_type</span> <span class="o">=</span> <span class="n">set_phenotype_func</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">PHENO</span><span class="p">,</span> <span class="n">PHENO_type</span><span class="p">,</span> <span class="n">IID</span><span class="p">,</span> <span class="n">alternate_control</span>
        <span class="p">)</span>

        <span class="c1"># Assign the processed data and inferred phenotype type to the .phenotype attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phenotype</span> <span class="o">=</span> <span class="p">(</span><span class="n">processed_data</span><span class="p">,</span> <span class="n">inferred_pheno_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geno.association_test">
<a class="viewcode-back" href="../../modules.html#genal.Geno.association_test">[docs]</a>
    <span class="k">def</span> <span class="nf">association_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">covar</span><span class="o">=</span><span class="p">[],</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conduct single-SNP association tests against a phenotype.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, optional): Path to a bed/bim/fam set of genetic files.</span>
<span class="sd">                If files are split by chromosomes, replace the chromosome number with &#39;$&#39;.</span>
<span class="sd">                For instance: path = &quot;ukb_chr$_file&quot;. Default is None.</span>
<span class="sd">            covar (list, optional): List of columns in the phenotype dataframe to be used</span>
<span class="sd">                                    as covariates in the association tests. Default is an empty list.</span>
<span class="sd">            standardize (bool, optional): If True, it will standardize a quantitative phenotype</span>
<span class="sd">                                          before performing association tests. This is typically done</span>
<span class="sd">                                          to make results more interpretable. Default is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: Updates the BETA, SE, and P columns of the data attribute based on the results</span>
<span class="sd">                  of the association tests.</span>

<span class="sd">        Note:</span>
<span class="sd">            This method requires the phenotype to be set using the set_phenotype() function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure that the phenotype has been set using set_phenotype</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;phenotype&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;You first need to set a phenotype using .set_phenotype(data, PHENO, PHENO_type, IID)!&quot;</span>
            <span class="p">)</span>

        <span class="n">create_tmp</span><span class="p">()</span> <span class="c1">#Make sure temporary folder exists</span>
        
        <span class="c1"># Based on column presents, extract the SNP based names or genomic positions (with preference for positions)</span>
        <span class="k">if</span> <span class="s2">&quot;CHR&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s2">&quot;POS&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CHR/POS columns present: SNPs searched based on genomic positions.&quot;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_snpids</span><span class="p">(</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;SNP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CHR/POS columns absent: SNPs searched based on SNP name.&quot;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either the SNP or the CHR/POS columns need to be present to identify SNPs in genetic data.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Extract the SNP list</span>
        <span class="n">snp_list</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;SNP&quot;</span><span class="p">]</span>

        <span class="c1"># Extract SNPs using the provided path and SNP list</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">extract_snps_func</span><span class="p">(</span><span class="n">snp_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        
        <span class="c1"># Perform the association test</span>
        <span class="n">updated_data</span> <span class="o">=</span> <span class="n">association_test_func</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">covar</span><span class="p">,</span>
            <span class="n">standardize</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phenotype</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phenotype</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># Update the instance data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">updated_data</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The BETA, SE, P columns of the .data attribute have been updated.&quot;</span><span class="p">)</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="Geno.query_outcome">
<a class="viewcode-back" href="../../modules.html#genal.Geno.query_outcome">[docs]</a>
    <span class="k">def</span> <span class="nf">query_outcome</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">outcome</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">proxy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">reference_panel</span><span class="o">=</span><span class="s2">&quot;eur&quot;</span><span class="p">,</span>
        <span class="n">kb</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
        <span class="n">r2</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
        <span class="n">window_snps</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepares dataframes required for Mendelian Randomization (MR) with the SNP information in `data` as exposure.</span>

<span class="sd">        Queries the outcome data, with or without proxying, and assigns a tuple to</span>
<span class="sd">        the outcome attribute: (exposure_data, outcome_data, name) ready for MR methods.</span>

<span class="sd">        Args:</span>
<span class="sd">            outcome: Can be a Geno object (from a GWAS) or a filepath of types: .h5 or .hdf5 (created with the :meth:`Geno.save` method.</span>
<span class="sd">            name (str, optional): Name for the outcome data. Defaults to None.</span>
<span class="sd">            proxy (bool, optional): If true, proxies are searched. Default is True.</span>
<span class="sd">            reference_panel (str, optional): The reference population to get linkage</span>
<span class="sd">                disequilibrium values and find proxies (only if proxy=True). Acceptable values</span>
<span class="sd">                include &quot;EUR&quot;, &quot;SAS&quot;, &quot;AFR&quot;, &quot;EAS&quot;, &quot;AMR&quot; or a path to a specific bed/bim/fam panel.</span>
<span class="sd">                Default is &quot;EUR&quot;.</span>
<span class="sd">            kb (int, optional): Width of the genomic window to look for proxies. Default is 5000.</span>
<span class="sd">            r2 (float, optional): Minimum linkage disequilibrium value with the main SNP</span>
<span class="sd">                for a proxy to be included. Default is 0.6.</span>
<span class="sd">            window_snps (int, optional): Compute the LD value for SNPs that are not</span>
<span class="sd">                more than x SNPs away from the main SNP. Default is 5000.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: Sets the `MR_data` attribute for the instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">exposure</span><span class="p">,</span> <span class="n">outcome_data</span><span class="p">,</span> <span class="n">outcome_name</span> <span class="o">=</span> <span class="n">query_outcome_func</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">outcome</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">proxy</span><span class="p">,</span>
            <span class="n">reference_panel</span><span class="p">,</span>
            <span class="n">kb</span><span class="p">,</span>
            <span class="n">r2</span><span class="p">,</span>
            <span class="n">window_snps</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cpus</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Assign the processed data to the MR_data attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MR_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">exposure</span><span class="p">,</span> <span class="n">outcome_data</span><span class="p">,</span> <span class="n">outcome_name</span><span class="p">]</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="Geno.MR">
<a class="viewcode-back" href="../../modules.html#genal.Geno.MR">[docs]</a>
    <span class="k">def</span> <span class="nf">MR</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;IVW&quot;</span><span class="p">,</span><span class="s2">&quot;IVW-FE&quot;</span><span class="p">,</span><span class="s2">&quot;WM&quot;</span><span class="p">,</span><span class="s2">&quot;Simple-mode&quot;</span><span class="p">,</span><span class="s2">&quot;Egger&quot;</span><span class="p">],</span>
        <span class="n">action</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">eaf_threshold</span><span class="o">=</span><span class="mf">0.42</span><span class="p">,</span>
        <span class="n">heterogeneity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">nboot</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">penk</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">phi</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">exposure_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">outcome_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cpus</span><span class="o">=-</span><span class="mi">1</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes Mendelian Randomization (MR) using the `data_clumped` attribute as exposure data and `MR_data` attribute as outcome data queried using the `query_outcome` method.</span>

<span class="sd">        Args:</span>
<span class="sd">            methods (list, optional): List of MR methods to run. Possible options include:</span>
<span class="sd">                &quot;IVW&quot;: inverse variance-weighted with random effects and under-dispersion correction</span>
<span class="sd">                &quot;IVW-FE&quot;: inverse variance-weighted with fixed effects</span>
<span class="sd">                &quot;IVW-RE&quot;: inverse variance-weighted with random effects and without under-dispersion correction</span>
<span class="sd">                &quot;UWR&quot;: unweighted regression</span>
<span class="sd">                &quot;WM&quot;: weighted median (bootstrapped standard errors)</span>
<span class="sd">                &quot;WM-pen&quot;: penalised weighted median (bootstrapped standard errors)</span>
<span class="sd">                &quot;Simple-median&quot;: simple median (bootstrapped standard errors)</span>
<span class="sd">                &quot;Sign&quot;: sign concordance test</span>
<span class="sd">                &quot;Egger&quot;: egger regression</span>
<span class="sd">                &quot;Egger-boot&quot;: egger regression with bootstrapped standard errors</span>
<span class="sd">                &quot;Simple-mode&quot;: simple mode method</span>
<span class="sd">                &quot;Weighted-mode&quot;: weighted mode method</span>
<span class="sd">                Default is [&quot;IVW&quot;,&quot;IVW-FE&quot;,&quot;WM&quot;,&quot;Simple-mode&quot;,&quot;Weighted-mode&quot;,&quot;Egger&quot;].</span>
<span class="sd">            action (int, optional): How to treat palindromes during harmonizing between</span>
<span class="sd">                exposure and outcome data. Accepts:</span>
<span class="sd">                1: Doesn&#39;t flip them (Assumes all alleles are on the forward strand)</span>
<span class="sd">                2: Uses allele frequencies to attempt to flip (conservative, default)</span>
<span class="sd">                3: Removes all palindromic SNPs (very conservative)</span>
<span class="sd">            eaf_threshold (float, optional): Max effect allele frequency accepted when</span>
<span class="sd">                flipping palindromic SNPs (relevant if action=2). Default is 0.42.</span>
<span class="sd">            heterogeneity (bool, optional): If True, includes heterogeneity tests in the results (Cochran&#39;s Q test).Default is False.</span>
<span class="sd">            nboot (int, optional): Number of bootstrap replications for methods with bootstrapping. Default is 1000.</span>
<span class="sd">            penk (int, optional): Penalty value for the WM-pen method. Default is 20.</span>
<span class="sd">            phi (int, optional): Factor for the bandwidth parameter used in the kernel density estimation of the mode methods</span>
<span class="sd">            exposure_name (str, optional): Name of the exposure data (only for display purposes).</span>
<span class="sd">            outcome_name (str, optional): Name of the outcome data (only for display purposes).</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: A table with MR results.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure that query_outcome has been previously called</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;MR_data&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You must first call query_outcome() before running MR.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outcome_name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MR_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">outcome_name</span>
        <span class="n">exp_name</span> <span class="o">=</span> <span class="n">exposure_name</span> <span class="k">if</span> <span class="n">exposure_name</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">cpus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpus</span> <span class="k">if</span> <span class="n">cpus</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">cpus</span>
        <span class="n">res</span><span class="p">,</span> <span class="n">df_mr</span> <span class="o">=</span> <span class="n">MR_func</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MR_data</span><span class="p">,</span>
            <span class="n">methods</span><span class="p">,</span>
            <span class="n">action</span><span class="p">,</span>
            <span class="n">heterogeneity</span><span class="p">,</span>
            <span class="n">eaf_threshold</span><span class="p">,</span>
            <span class="n">nboot</span><span class="p">,</span>
            <span class="n">penk</span><span class="p">,</span>
            <span class="n">phi</span><span class="p">,</span>
            <span class="n">exp_name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cpus</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">MR_results</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">df_mr</span><span class="p">,</span> <span class="n">exposure_name</span><span class="p">,</span> <span class="n">outcome_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

    
<div class="viewcode-block" id="Geno.MR_plot">
<a class="viewcode-back" href="../../modules.html#genal.Geno.MR_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">MR_plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">methods</span><span class="o">=</span><span class="p">[</span>
            <span class="s2">&quot;IVW&quot;</span><span class="p">,</span>
            <span class="s2">&quot;WM&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Simple-mode&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Egger&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">exposure_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">outcome_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates and returns a scatter plot of individual SNP effects with lines representing different Mendelian Randomization (MR) methods. Each MR method specified in the &#39;methods&#39; argument is represented as a line in the plot.</span>

<span class="sd">        Args:</span>
<span class="sd">            methods (list of str, optional): A list of MR methods to be included in the plot. Default methods are &quot;IVW&quot;, &quot;WM&quot;, &quot;Simple-median&quot;, and &quot;Egger&quot;.</span>
<span class="sd">            exposure_name (str, optional): A custom label for the exposure effect axis. If None, uses the label provided in the MR function call or a default label.</span>
<span class="sd">            outcome_name (str, optional): A custom label for the outcome effect axis. If None, uses the label provided in the MR function call or a default label.</span>
<span class="sd">            filename (str, optional): The filename where the plot will be saved. If None, the plot is not saved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            plotnine.ggplot.ggplot: A plotnine ggplot object representing the scatter plot of individual SNP effects with MR method lines.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If MR analysis has not been performed prior to calling this function.</span>

<span class="sd">        Note:</span>
<span class="sd">            This function requires prior execution of the `MR` method to compute MR results. Make sure the MR analysis is performed on the data before calling `MR_plot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;MR_results&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to run an MR analysis with the MR method before calling the MR_plot function.&quot;</span><span class="p">)</span>
        
        <span class="c1">## Extract the previously computed MR results</span>
        <span class="n">df_mr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MR_results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MR_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">exposure_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MR_results</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">exposure_name</span> <span class="k">else</span> <span class="n">exposure_name</span>
        <span class="n">exposure_name</span> <span class="o">=</span> <span class="s2">&quot;Effect on the exposure&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">exposure_name</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;Effect on </span><span class="si">{</span><span class="n">exposure_name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">outcome_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MR_results</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">outcome_name</span> <span class="k">else</span> <span class="n">outcome_name</span>
        <span class="n">outcome_name</span> <span class="o">=</span> <span class="s2">&quot;Effect on the outcome&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">outcome_name</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;Effect on </span><span class="si">{</span><span class="n">outcome_name</span><span class="si">}</span><span class="s2">&quot;</span>
        
        <span class="c1">## Switch all exposure betas to &gt;= 0</span>
        <span class="n">df_mr</span><span class="p">[</span><span class="s1">&#39;BETA_e&#39;</span><span class="p">],</span> <span class="n">df_mr</span><span class="p">[</span><span class="s1">&#39;BETA_o&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df_mr</span><span class="p">[</span><span class="s1">&#39;BETA_e&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">df_mr</span><span class="p">[</span><span class="s1">&#39;BETA_e&#39;</span><span class="p">],</span> <span class="o">-</span><span class="n">df_mr</span><span class="p">[</span><span class="s1">&#39;BETA_o&#39;</span><span class="p">]),</span> <span class="p">(</span><span class="n">df_mr</span><span class="p">[</span><span class="s1">&#39;BETA_e&#39;</span><span class="p">],</span> <span class="n">df_mr</span><span class="p">[</span><span class="s1">&#39;BETA_o&#39;</span><span class="p">]))</span>

        <span class="c1">## Create the scatter plot with error bars</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ggplot</span><span class="p">(</span><span class="n">df_mr</span><span class="p">,</span> <span class="n">aes</span><span class="p">(</span><span class="s1">&#39;BETA_e&#39;</span><span class="p">,</span> <span class="s1">&#39;BETA_o&#39;</span><span class="p">))</span>

            <span class="o">+</span> <span class="n">geom_errorbarh</span><span class="p">(</span><span class="n">aes</span><span class="p">(</span><span class="n">xmin</span><span class="o">=</span><span class="s1">&#39;BETA_e-SE_e&#39;</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="s1">&#39;BETA_e+SE_e&#39;</span><span class="p">),</span> <span class="n">height</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span> 
            <span class="o">+</span> <span class="n">geom_errorbar</span><span class="p">(</span><span class="n">aes</span><span class="p">(</span><span class="n">ymin</span><span class="o">=</span><span class="s1">&#39;BETA_o-SE_o&#39;</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="s1">&#39;BETA_o+SE_o&#39;</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">geom_point</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span> 
            <span class="o">+</span> <span class="n">geom_abline</span><span class="p">(</span><span class="n">slope</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">labs</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">exposure_name</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">outcome_name</span><span class="p">)</span> 
            <span class="o">+</span> <span class="n">theme</span><span class="p">(</span>
                <span class="n">axis_title</span><span class="o">=</span><span class="n">element_text</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">),</span>
                <span class="n">axis_text</span><span class="o">=</span><span class="n">element_text</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span>
                <span class="n">figure_size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="o">+</span> <span class="n">expand_limits</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1">## Add the lines corresponding to the specified MR methods (if present in the computation)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">MR_METHODS_NAMES</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> is not an appropriate MR method. MR methods can be IVW, WM, Egger... Please refer to the documentation for more.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1">## If not an Egger method: simply need to get the slope</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Egger&quot;</span><span class="p">):</span>
                <span class="n">method_name</span> <span class="o">=</span> <span class="n">MR_METHODS_NAMES</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
                <span class="n">res_row</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="n">method_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">res_row</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">method_name</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">) method was not included in the MR method call and will be excluded from the plot.&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">res_row</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;slope&#39;</span><span class="p">:</span> <span class="n">res_row</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                        <span class="s1">&#39;intercept&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> 
                        <span class="s1">&#39;MR Methods&#39;</span><span class="p">:</span> <span class="n">method_name</span>  <span class="c1"># Use method_name as the color label</span>
                    <span class="p">})</span>
            <span class="c1">## For Egger methods: need to get the slope and the intercept</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">method_name</span> <span class="o">=</span> <span class="n">MR_METHODS_NAMES</span><span class="p">[</span><span class="n">method</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">method_name_intercept</span> <span class="o">=</span> <span class="n">MR_METHODS_NAMES</span><span class="p">[</span><span class="n">method</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">res_row</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="n">method_name</span><span class="p">]</span>
                <span class="n">res_row_intercept</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="n">method_name_intercept</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">res_row</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">method_name</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">) method was not included in the MR method call and will be excluded from the plot.&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">res_row</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">res_row_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;slope&#39;</span><span class="p">:</span> <span class="n">res_row</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                        <span class="s1">&#39;intercept&#39;</span><span class="p">:</span> <span class="n">res_row_intercept</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                        <span class="s1">&#39;MR Methods&#39;</span><span class="p">:</span> <span class="n">method_name</span>  <span class="c1"># Use method_name as the color label</span>
                    <span class="p">})</span>
        <span class="n">line_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="n">plot</span> <span class="o">+=</span> <span class="n">geom_abline</span><span class="p">(</span><span class="n">aes</span><span class="p">(</span><span class="n">slope</span><span class="o">=</span><span class="s1">&#39;slope&#39;</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="s1">&#39;intercept&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;MR Methods&#39;</span><span class="p">),</span> <span class="n">data</span><span class="o">=</span><span class="n">line_data</span><span class="p">)</span>
        
        <span class="c1">## Save plot if filename is specified</span>
        <span class="k">if</span> <span class="n">filename</span><span class="p">:</span>
            <span class="n">plot</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">plot</span></div>

  
<span class="c1">#    def MR_forest(</span>
<span class="c1">#        self,</span>
<span class="c1">#        methods=[</span>
<span class="c1">#            &quot;IVW&quot;,</span>
<span class="c1">#            &quot;WM&quot;,</span>
<span class="c1">#            &quot;Simple-median&quot;,</span>
<span class="c1">#            &quot;Egger&quot;,</span>
<span class="c1">#        ],</span>
<span class="c1">#        exposure_name=None,</span>
<span class="c1">#        outcome_name=None,</span>
<span class="c1">#        filename=None</span>
<span class="c1">#    ):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Creates and returns a scatter plot of individual SNP effects with lines representing different Mendelian Randomization (MR) methods. Each MR method specified in the &#39;methods&#39; argument is represented as a line in the plot.</span>
<span class="c1">#</span>
<span class="c1">#        Args:</span>
<span class="c1">#            methods (list of str, optional): A list of MR methods to be included in the plot. Default methods are &quot;IVW&quot;, &quot;WM&quot;, &quot;Simple-median&quot;, and &quot;Egger&quot;.</span>
<span class="c1">#            exposure_name (str, optional): A custom label for the exposure effect axis. If None, uses the label provided in the MR function call or a default label.</span>
<span class="c1">#            outcome_name (str, optional): A custom label for the outcome effect axis. If None, uses the label provided in the MR function call or a default label.</span>
<span class="c1">#            filename (str, optional): The filename where the plot will be saved. If None, the plot is not saved.</span>
<span class="c1">#</span>
<span class="c1">#        Returns:</span>
<span class="c1">#            plotnine.ggplot.ggplot: A plotnine ggplot object representing the scatter plot of individual SNP effects with MR method lines.</span>
<span class="c1">#</span>
<span class="c1">#        Raises:</span>
<span class="c1">#            ValueError: If MR analysis has not been performed prior to calling this function.</span>
<span class="c1">#</span>
<span class="c1">#        Note:</span>
<span class="c1">#            This function requires prior execution of the `MR` method to compute MR results. Make sure the MR analysis is performed on the data before calling `MR_plot`.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if not hasattr(self, &quot;MR_results&quot;):</span>
<span class="c1">#            raise ValueError(&quot;You need to run an MR analysis with the MR method before calling the MR_plot function.&quot;)</span>
<span class="c1">#        </span>
<span class="c1">#        ## Extract the previously computed MR results</span>
<span class="c1">#        df_mr = self.MR_results[1]</span>
<span class="c1">#        res = self.MR_results[0]</span>
<span class="c1">#        exposure_name = self.MR_results[2] if not exposure_name else exposure_name</span>
<span class="c1">#        exposure_name = &quot;Effect on the exposure&quot; if not exposure_name else f&quot;Effect on {exposure_name}&quot;</span>
<span class="c1">#        outcome_name = self.MR_results[3] if not outcome_name else outcome_name</span>
<span class="c1">#        outcome_name = &quot;Effect on the outcome&quot; if not outcome_name else f&quot;Effect on {outcome_name}&quot;</span>
<span class="c1">#        </span>
<span class="c1">#        ## Switch all exposure betas to &gt;= 0</span>
<span class="c1">#        df_mr[&#39;BETA_e&#39;], df_mr[&#39;BETA_o&#39;] = np.where(df_mr[&#39;BETA_e&#39;] &lt; 0, (-df_mr[&#39;BETA_e&#39;], -df_mr[&#39;BETA_o&#39;]), (df_mr[&#39;BETA_e&#39;], df_mr[&#39;BETA_o&#39;]))</span>
<span class="c1">#</span>
<span class="c1">#        ## Create the scatter plot with error bars</span>
<span class="c1">#        plot = (</span>
<span class="c1">#            ggplot(df_mr, aes(&#39;BETA_e&#39;, &#39;BETA_o&#39;))</span>
<span class="c1">#</span>
<span class="c1">#            + geom_errorbarh(aes(xmin=&#39;BETA_e-SE_e&#39;, xmax=&#39;BETA_e+SE_e&#39;), height=0, color=&quot;gray&quot;, size=0.1) </span>
<span class="c1">#            + geom_errorbar(aes(ymin=&#39;BETA_o-SE_o&#39;, ymax=&#39;BETA_o+SE_o&#39;), width=0, color=&quot;gray&quot;, size=0.1)</span>
<span class="c1">#            + geom_point(color=&#39;black&#39;, size=0.2) </span>
<span class="c1">#            + geom_abline(slope=0, intercept=0, color=&#39;black&#39;)</span>
<span class="c1">#            + labs(x=exposure_name, y=outcome_name) </span>
<span class="c1">#            + theme(</span>
<span class="c1">#                axis_title=element_text(size=12),</span>
<span class="c1">#                axis_text=element_text(size=10),</span>
<span class="c1">#                figure_size=(10,6)</span>
<span class="c1">#            )</span>
<span class="c1">#            + expand_limits(x=0)</span>
<span class="c1">#        )</span>
<span class="c1">#        </span>
<span class="c1">#        ## Add the lines corresponding to the specified MR methods (if present in the computation)</span>
<span class="c1">#        lines = []</span>
<span class="c1">#        for method in methods:</span>
<span class="c1">#            if method not in MR_METHODS_NAMES.keys():</span>
<span class="c1">#                warnings.warn(f&quot;{method} is not an appropriate MR method. MR methods can be IVW, WM, Egger... Please refer to the documentation for more.&quot;)</span>
<span class="c1">#                continue</span>
<span class="c1">#            ## If not an Egger method: simply need to get the slope</span>
<span class="c1">#            if not method.startswith(&quot;Egger&quot;):</span>
<span class="c1">#                method_name = MR_METHODS_NAMES[method]</span>
<span class="c1">#                res_row = res[res.method == method_name]</span>
<span class="c1">#                if res_row.shape[0] == 0:</span>
<span class="c1">#                    warnings.warn(f&quot;The {method_name} ({method}) method was not included in the MR method call and will be excluded from the plot.&quot;)</span>
<span class="c1">#                elif res_row.shape[0] == 1:</span>
<span class="c1">#                    lines.append({</span>
<span class="c1">#                        &#39;slope&#39;: res_row[&quot;b&quot;].values[0], </span>
<span class="c1">#                        &#39;intercept&#39;: 0, </span>
<span class="c1">#                        &#39;MR Methods&#39;: method_name  # Use method_name as the color label</span>
<span class="c1">#                    })</span>
<span class="c1">#            ## For Egger methods: need to get the slope and the intercept</span>
<span class="c1">#            else:</span>
<span class="c1">#                method_name = MR_METHODS_NAMES[method][0]</span>
<span class="c1">#                method_name_intercept = MR_METHODS_NAMES[method][1]</span>
<span class="c1">#                res_row = res[res.method == method_name]</span>
<span class="c1">#                res_row_intercept = res[res.method == method_name_intercept]</span>
<span class="c1">#                if res_row.shape[0] == 0:</span>
<span class="c1">#                    warnings.warn(f&quot;The {method_name} ({method}) method was not included in the MR method call and will be excluded from the plot.&quot;)</span>
<span class="c1">#                elif res_row.shape[0] == 1 and res_row_intercept.shape[0] == 1:</span>
<span class="c1">#                    lines.append({</span>
<span class="c1">#                        &#39;slope&#39;: res_row[&quot;b&quot;].values[0], </span>
<span class="c1">#                        &#39;intercept&#39;: res_row_intercept[&quot;b&quot;].values[0], </span>
<span class="c1">#                        &#39;MR Methods&#39;: method_name  # Use method_name as the color label</span>
<span class="c1">#                    })</span>
<span class="c1">#        line_data = pd.DataFrame(lines)</span>
<span class="c1">#        plot += geom_abline(aes(slope=&#39;slope&#39;, intercept=&#39;intercept&#39;, color=&#39;MR Methods&#39;), data=line_data)</span>
<span class="c1">#        </span>
<span class="c1">#        ## Save plot if filename is specified</span>
<span class="c1">#        if filename:</span>
<span class="c1">#            plot.save(f&quot;{filename}.png&quot;, dpi=500, width=10, height=6, verbose=False)</span>
<span class="c1">#        </span>
<span class="c1">#        return plot</span>
    
    

<div class="viewcode-block" id="Geno.MRpresso">
<a class="viewcode-back" href="../../modules.html#genal.Geno.MRpresso">[docs]</a>
    <span class="k">def</span> <span class="nf">MRpresso</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">eaf_threshold</span><span class="o">=</span><span class="mf">0.42</span><span class="p">,</span>
        <span class="n">n_iterations</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
        <span class="n">outlier_test</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">distortion_test</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">significance_p</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="n">cpus</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the MR-PRESSO Mendelian Randomization algorithm for detection and correction of horizontal pleiotropy.</span>

<span class="sd">        Args:</span>
<span class="sd">            action (int, optional): Treatment for palindromes during harmonizing between</span>
<span class="sd">                exposure and outcome data. Options:</span>
<span class="sd">                - 1: Don&#39;t flip (assume all alleles are on the forward strand)</span>
<span class="sd">                - 2: Use allele frequencies to flip (default)</span>
<span class="sd">                - 3: Remove all palindromic SNPs</span>
<span class="sd">            eaf_threshold (float, optional): Max effect allele frequency when flipping</span>
<span class="sd">                palindromic SNPs (relevant if action=2). Default is 0.42.</span>
<span class="sd">            n_iterations (int, optional): Number of random data generation steps for</span>
<span class="sd">                improved result stability. Default is 10000.</span>
<span class="sd">            outlier_test (bool, optional): Identify outlier SNPs responsible for horizontal</span>
<span class="sd">                pleiotropy if global test p_value &lt; significance_p. Default is True.</span>
<span class="sd">            distortion_test (bool, optional): Test significant distortion in causal estimates</span>
<span class="sd">                before and after outlier removal if global test p_value &lt; significance_p.</span>
<span class="sd">                Default is True.</span>
<span class="sd">            significance_p (float, optional): Statistical significance threshold for</span>
<span class="sd">                horizontal pleiotropy detection (both global test and outlier identification).</span>
<span class="sd">                Default is 0.05.</span>
<span class="sd">            cpus (int, optional): number of cpu cores to be used for the parallel random data generation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: Contains the following elements:</span>
<span class="sd">                - mod_table: DataFrame containing the original (before outlier removal)</span>
<span class="sd">                             and outlier-corrected (after outlier removal) inverse variance-weighted MR results.</span>
<span class="sd">                - GlobalTest: p-value of the global MR-PRESSO test indicating the presence of horizontal pleiotropy.</span>
<span class="sd">                - OutlierTest: DataFrame assigning a p-value to each SNP representing the likelihood of this</span>
<span class="sd">                               SNP being responsible for the global pleiotropy. Set to NaN if global test p_value &gt; significance_p.</span>
<span class="sd">                - DistortionTest: p-value for the distortion test.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;MR_data&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You must first call query_outcome() before running MR.&quot;</span><span class="p">)</span>
        <span class="n">cpus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpus</span> <span class="k">if</span> <span class="n">cpus</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">cpus</span>

        <span class="k">return</span> <span class="n">mrpresso_func</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MR_data</span><span class="p">,</span>
            <span class="n">action</span><span class="p">,</span>
            <span class="n">eaf_threshold</span><span class="p">,</span>
            <span class="n">n_iterations</span><span class="p">,</span>
            <span class="n">outlier_test</span><span class="p">,</span>
            <span class="n">distortion_test</span><span class="p">,</span>
            <span class="n">significance_p</span><span class="p">,</span>
            <span class="n">cpus</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Geno.lift">
<a class="viewcode-back" href="../../modules.html#genal.Geno.lift">[docs]</a>
    <span class="k">def</span> <span class="nf">lift</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start</span><span class="o">=</span><span class="s2">&quot;hg19&quot;</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="s2">&quot;hg38&quot;</span><span class="p">,</span>
        <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">extraction_file</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">chain_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">liftover_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a liftover from one genetic build to another.</span>

<span class="sd">        Args:</span>
<span class="sd">            start (str, optional): Current build of the data. Default is &quot;hg19&quot;.</span>
<span class="sd">            end (str, optional): Target build for the liftover. Default is &quot;hg38&quot;.</span>
<span class="sd">            replace (bool, optional): If True, updates the data attribute in place. Default is False.</span>
<span class="sd">            extraction_file (bool, optional): If True, prints a CHR POS SNP space-delimited</span>
<span class="sd">                file. Default is False.</span>
<span class="sd">            chain_file (str, optional): Path to a local chain file for the lift.</span>
<span class="sd">                If provided, `start` and `end` arguments are not considered. Default is None.</span>
<span class="sd">            name (str, optional): Filename or filepath (without extension) to save the lifted dataframe.</span>
<span class="sd">                If not provided, the data is not saved.</span>
<span class="sd">            liftover_path (str, optional): Specify the path to the USCS liftover executable. If not provided, the lift will be done in python (slower for large amount of SNPs).</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Data after being lifted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure mandatory columns are present in the input data</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The column </span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2"> is not found in the data!&quot;</span><span class="p">)</span>

        <span class="n">create_tmp</span><span class="p">()</span>  <span class="c1"># Create tmp folder if does not exist</span>

        <span class="c1"># Select appropriate data or copy of data depending on replace argument</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">replace</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Do the appropriate preprocessing on CHR and POS columns if not already done</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">]:</span>
            <span class="n">check_int_column</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;CHR&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">[</span><span class="s2">&quot;POS&quot;</span><span class="p">]:</span>
            <span class="n">check_int_column</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">)</span>

        <span class="c1"># Update the checks if replace = True</span>
        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="p">[</span><span class="s2">&quot;POS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Lifting the data</span><span class="si">{</span><span class="s1">&#39; inplace&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">replace</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;The .data attribute will </span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">replace</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;not &#39;</span><span class="si">}</span><span class="s2">be modified. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Use replace=</span><span class="si">{</span><span class="s1">&#39;False&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">replace</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;True&#39;</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="s1">&#39;leave it as is&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">replace</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;lift inplace&#39;</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">lift_data</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
                <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
                <span class="n">extraction_file</span><span class="o">=</span><span class="n">extraction_file</span><span class="p">,</span>
                <span class="n">chain_file</span><span class="o">=</span><span class="n">chain_file</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">liftover_path</span><span class="o">=</span><span class="n">liftover_path</span><span class="p">,</span>
                <span class="n">object_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>

    
<div class="viewcode-block" id="Geno.query_gwas_catalog">
<a class="viewcode-back" href="../../modules.html#genal.Geno.query_gwas_catalog">[docs]</a>
    <span class="k">def</span> <span class="nf">query_gwas_catalog</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">p_threshold</span><span class="o">=</span><span class="mf">5e-8</span><span class="p">,</span>
        <span class="n">return_p</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_study</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">max_associations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">timeout</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the GWAS Catalog Rest API and add an &quot;ASSOC&quot; column containing associated traits for each SNP.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            p_threshold (float, optional): Only associations that are at least as significant are reported. Default is 5e-8.</span>
<span class="sd">            return_p (bool, optional): If True, include the p-value in the results. Default is False.</span>
<span class="sd">            return_study (bool, optional): If True, include the ID of the study from which the association is derived in the results. Default is False.</span>
<span class="sd">            replace (bool, optional): If True, updates the data attribute in place. Default is True.</span>
<span class="sd">            max_associations (int, optional): If not None, only the first `max_associations` associations are reported for each SNP. Default is None.</span>
<span class="sd">            timeout (int, optional): Timeout for each query in seconds. Default is -1 (custom timeout based on number of SNPs to query). Choose None for no timeout.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Data attribute with an additional column &quot;ASSOC&quot;.</span>
<span class="sd">                The elements of this column are lists of strings or tuples depending on the `return_p` and `return_study` flags. If the SNP could not be queried, the value is set to &quot;FAILED_QUERY&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure mandatory column is present in the input data</span>
        <span class="k">if</span> <span class="s2">&quot;SNP&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The SNP column is necessary for the GWAS query!&quot;</span><span class="p">)</span>
            
        <span class="c1"># Select appropriate data or copy of data depending on replace argument</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">replace</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Querying the GWAS Catalog and creating the ASSOC column. </span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Only associations with a p-value &lt;= </span><span class="si">{</span><span class="n">p_threshold</span><span class="si">}</span><span class="s2"> are reported. Use the p_threshold argument to change the threshold.&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">max_associations</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reporting the first </span><span class="si">{</span><span class="n">max_associations</span><span class="si">}</span><span class="s2"> associations for each SNP.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_p</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;To report the p-value for each association, use return_p=True.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_study</span> <span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;To report the study ID for each association, use return_study=True.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The .data attribute will </span><span class="si">{</span><span class="s1">&#39;be&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">replace</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;not be&#39;</span><span class="si">}</span><span class="s2"> modified. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;Use replace=False to leave it as is.&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">replace</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        
        <span class="c1"># Estimate a reasonable timeout given the number of SNPs to query (45 SNPs per second)</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span> <span class="k">if</span> <span class="n">timeout</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">timeout</span>

        <span class="c1"># Call the async function to query all SNPs</span>
        <span class="n">results_snps</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">timeouts</span> <span class="o">=</span> <span class="n">async_query_gwas_catalog</span><span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">SNP</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span> 
            <span class="n">p_threshold</span><span class="o">=</span><span class="n">p_threshold</span><span class="p">,</span> 
            <span class="n">return_p</span><span class="o">=</span><span class="n">return_p</span><span class="p">,</span> 
            <span class="n">return_study</span><span class="o">=</span><span class="n">return_study</span><span class="p">,</span>
            <span class="n">max_associations</span><span class="o">=</span><span class="n">max_associations</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="c1"># Create the column</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ASSOC&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;SNP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">results_snps</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">&quot;FAILED_QUERY&quot;</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;SNP&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">timeouts</span><span class="p">),</span> <span class="s2">&quot;ASSOC&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;TIMEOUT&quot;</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The ASSOC column has been successfully created.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%) SNPs failed to query (not found in GWAS Catalog) and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">timeouts</span><span class="p">)</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">timeouts</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%) SNPs timed out after </span><span class="si">{</span><span class="n">timeout</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds.&quot;</span> 
              <span class="sa">f</span><span class="s2">&quot; You can increase the timeout value with the timeout argument.&quot;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">data</span></div>

        

<div class="viewcode-block" id="Geno.standardize">
<a class="viewcode-back" href="../../api.html#genal.Geno.standardize">[docs]</a>
    <span class="k">def</span> <span class="nf">standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standardize the Betas and adjust the SE column accordingly.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the required columns are not found in the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">required_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;BETA&quot;</span><span class="p">,</span> <span class="s2">&quot;SE&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">required_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The column </span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2"> is not found in the data!&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;BETA&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">BETA</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">BETA</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">BETA</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;SE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">BETA</span> <span class="o">/</span> <span class="n">st</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">P</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;The Beta column has been standardized and the SE column has been adjusted.&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Geno.sort_group">
<a class="viewcode-back" href="../../api.html#genal.Geno.sort_group">[docs]</a>
    <span class="k">def</span> <span class="nf">sort_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;lowest_p&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handle duplicate SNPs. Useful if the instance combines different Genos.</span>

<span class="sd">        Args:</span>
<span class="sd">            method (str, optional): How to handle duplicates. Default is &quot;lowest_p&quot;,</span>
<span class="sd">                                    which retains the lowest P-value for each SNP.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;lowest_p&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;P&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;SNP&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="Geno.copy">
<a class="viewcode-back" href="../../api.html#genal.Geno.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a deep copy of the Geno instance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Geno: A deep copy of the instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geno.save">
<a class="viewcode-back" href="../../api.html#genal.Geno.save">[docs]</a>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;h5&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the Geno data to a file.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, optional): Folder path to save the file. Defaults to the current directory.</span>
<span class="sd">            fmt (str, optional): File format. Options: .h5 (default), .csv, .txt. Future: .vcf, .vcf.gz.</span>
<span class="sd">            sep (str, optional): Delimiter for .csv and .txt formats. Default is tab.</span>
<span class="sd">            header (bool, optional): Save column names for .csv and .txt formats. Default is True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If clumped data is requested but data is not clumped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">save_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
        <span class="k">return</span></div>
</div>


<span class="k">def</span> <span class="nf">merge_command_parallel</span><span class="p">(</span><span class="n">df_subset</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function of the update_snpids method to update SNP in parallel when genetic data is split by chromosome.&quot;&quot;&quot;</span>
    <span class="n">chr_number</span> <span class="o">=</span> <span class="n">df_subset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;CHR&#39;</span><span class="p">]</span>
    <span class="n">bim_path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;$&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">chr_number</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;.bim&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">bim_path</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="n">bim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
        <span class="n">bim_path</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">,</span> <span class="s2">&quot;SNP&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">,</span> <span class="s2">&quot;A1&quot;</span><span class="p">,</span> <span class="s2">&quot;A2&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Convert CHR to string and remove &#39;chr&#39; prefix if present, then convert to int</span>
    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">bim</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;chr&quot;</span><span class="p">):</span>
        <span class="n">bim</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bim</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;^chr&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="n">bim</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df_subset</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">bim</span><span class="p">[[</span><span class="s2">&quot;CHR&quot;</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">,</span> <span class="s2">&quot;SNP&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CHR&quot;</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;_new&#39;</span><span class="p">)</span>
    <span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Cyprien A. Rivier.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>