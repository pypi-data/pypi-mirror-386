#!/usr/bin/env python3
"""
Test file with SSRF (Server-Side Request Forgery) vulnerabilities.
Based on OWASP SSRF examples.
Expected: Should detect SSRF patterns.
"""

import requests
import urllib.request
import urllib.parse
import urllib.error
from flask import request
import socket
import ftplib
import smtplib
import poplib
import imaplib

def vulnerable_url_fetch():
    """Vulnerable URL fetching with SSRF."""
    url = request.args.get('url')
    
    # Vulnerable requests usage
    response = requests.get(url)  # Vulnerable
    response = requests.post(url, data=request.form)  # Vulnerable
    
    # Vulnerable urllib usage
    response = urllib.request.urlopen(url)  # Vulnerable
    response = urllib.request.urlretrieve(url)  # Vulnerable
    
    return response

def vulnerable_url_validation():
    """Vulnerable URL validation with SSRF."""
    url = request.args.get('url')
    
    # Vulnerable validation
    parsed = urllib.parse.urlparse(url)  # Vulnerable
    if parsed.scheme in ['http', 'https']:
        response = requests.get(url)  # Vulnerable
    
    return response

def vulnerable_redirect_handling():
    """Vulnerable redirect handling with SSRF."""
    url = request.args.get('url')
    
    # Vulnerable redirect following
    response = requests.get(url, allow_redirects=True)  # Vulnerable
    
    # Another pattern
    session = requests.Session()
    response = session.get(url)  # Vulnerable
    
    return response

def vulnerable_file_download():
    """Vulnerable file download with SSRF."""
    url = request.args.get('url')
    
    # Vulnerable file download
    urllib.request.urlretrieve(url, 'downloaded_file')  # Vulnerable
    
    # Another pattern
    response = requests.get(url, stream=True)  # Vulnerable
    with open('downloaded_file', 'wb') as f:
        for chunk in response.iter_content(chunk_size=8192):
            f.write(chunk)
    
    return 'File downloaded'

def vulnerable_image_processing():
    """Vulnerable image processing with SSRF."""
    image_url = request.args.get('image_url')
    
    # Vulnerable image fetching
    response = requests.get(image_url)  # Vulnerable
    image_data = response.content
    
    # Process image
    from PIL import Image
    import io
    image = Image.open(io.BytesIO(image_data))
    
    return image

def vulnerable_api_proxy():
    """Vulnerable API proxy with SSRF."""
    target_url = request.args.get('target')
    
    # Vulnerable proxy
    response = requests.get(target_url)  # Vulnerable
    return response.json()

def vulnerable_webhook():
    """Vulnerable webhook with SSRF."""
    webhook_url = request.args.get('webhook')
    data = request.json
    
    # Vulnerable webhook
    response = requests.post(webhook_url, json=data)  # Vulnerable
    
    return response.status_code

def vulnerable_network_scanning():
    """Vulnerable network scanning with SSRF."""
    target = request.args.get('target')
    port = request.args.get('port')
    
    # Vulnerable socket connection
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((target, int(port)))  # Vulnerable
    sock.close()
    
    return f"Connected to {target}:{port}"

def vulnerable_ftp_access():
    """Vulnerable FTP access with SSRF."""
    ftp_host = request.args.get('ftp_host')
    ftp_user = request.args.get('ftp_user')
    ftp_pass = request.args.get('ftp_pass')
    
    # Vulnerable FTP connection
    ftp = ftplib.FTP(ftp_host)  # Vulnerable
    ftp.login(ftp_user, ftp_pass)  # Vulnerable
    
    files = ftp.nlst()
    ftp.quit()
    
    return files

def vulnerable_email_access():
    """Vulnerable email access with SSRF."""
    email_host = request.args.get('email_host')
    email_user = request.args.get('email_user')
    email_pass = request.args.get('email_pass')
    
    # Vulnerable POP3 connection
    pop_server = poplib.POP3(email_host)  # Vulnerable
    pop_server.user(email_user)  # Vulnerable
    pop_server.pass_(email_pass)  # Vulnerable
    
    # Vulnerable IMAP connection
    imap_server = imaplib.IMAP4(email_host)  # Vulnerable
    imap_server.login(email_user, email_pass)  # Vulnerable
    
    return "Email access successful"

def vulnerable_dns_lookup():
    """Vulnerable DNS lookup with SSRF."""
    hostname = request.args.get('hostname')
    
    # Vulnerable DNS resolution
    ip_address = socket.gethostbyname(hostname)  # Vulnerable
    
    # Vulnerable reverse DNS
    hostname = socket.gethostbyaddr(ip_address)  # Vulnerable
    
    return ip_address

def vulnerable_http_headers():
    """Vulnerable HTTP headers with SSRF."""
    url = request.args.get('url')
    
    # Vulnerable header fetching
    response = requests.head(url)  # Vulnerable
    headers = response.headers
    
    # Vulnerable options request
    response = requests.options(url)  # Vulnerable
    
    return headers

def vulnerable_http_methods():
    """Vulnerable HTTP methods with SSRF."""
    url = request.args.get('url')
    method = request.args.get('method', 'GET')
    
    # Vulnerable method execution
    if method == 'GET':
        response = requests.get(url)  # Vulnerable
    elif method == 'POST':
        response = requests.post(url)  # Vulnerable
    elif method == 'PUT':
        response = requests.put(url)  # Vulnerable
    elif method == 'DELETE':
        response = requests.delete(url)  # Vulnerable
    elif method == 'PATCH':
        response = requests.patch(url)  # Vulnerable
    
    return response

def vulnerable_url_construction():
    """Vulnerable URL construction with SSRF."""
    base_url = request.args.get('base_url')
    path = request.args.get('path')
    
    # Vulnerable URL construction
    full_url = f"{base_url}/{path}"  # Vulnerable
    response = requests.get(full_url)  # Vulnerable
    
    # Another pattern
    full_url = urllib.parse.urljoin(base_url, path)  # Vulnerable
    response = requests.get(full_url)  # Vulnerable
    
    return response

if __name__ == "__main__":
    print("SSRF vulnerability test file")
    print("This file contains various SSRF vulnerabilities")
    print("for testing Levox detection capabilities.")
