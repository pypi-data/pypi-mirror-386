// XPath 2.0 Pest Grammar
// Based on the W3C XPath 2.0 Specification
// https://www.w3.org/TR/xpath20/
//
// Notes
// - Pest (v2.8.5) is a PEG parser: avoid left recursion
// - This file reorganizes rules for readability only; rule names and semantics are unchanged
// - Sections: Lexical, Names, Symbols, Keywords, Expressions, Paths/Steps, Node tests, Types, Literals

// =========================
// Lexical: whitespace/comment
// =========================
WHITESPACE = _{ (" " | "\t" | "\r" | "\n" | COMMENT)+ }
COMMENT    = _{ "(:" ~ (COMMENT | (!":)" ~ ANY))* ~ ":)" }

// =========================
// Character classes and names
// =========================
digits = { ASCII_DIGIT+ }

// QNames and NCNames with XML 1.1 support
// Note: qname is intentionally non-atomic so the evaluator can access prefix/local parts by rule name.
qname        = { (qname_prefix ~ ":" ~ qname_local) | qname_local }
qname_prefix = { ncname }
qname_local  = { ncname }

// NCName (no colon) per XML 1.1
ncname = @{ ncname_start_char ~ ncname_char* }
ncname_start_char = {
    "_"
  | ASCII_ALPHA
  | '\u{00C0}'..'\u{00D6}'
  | '\u{00D8}'..'\u{00F6}'
  | '\u{00F8}'..'\u{02FF}'
  | '\u{0370}'..'\u{037D}'
  | '\u{037F}'..'\u{1FFF}'
  | '\u{200C}'..'\u{200D}'
  | '\u{2070}'..'\u{218F}'
  | '\u{2C00}'..'\u{2FEF}'
  | '\u{3001}'..'\u{D7FF}'
  | '\u{F900}'..'\u{FDCF}'
  | '\u{FDF0}'..'\u{FFFD}'
  | '\u{10000}'..'\u{EFFFF}'
}
ncname_char = {
    ncname_start_char
  | ASCII_DIGIT
  | "-"
  | "."
  | "\u{00B7}"
  | '\u{0300}'..'\u{036F}'
  | '\u{203F}'..'\u{2040}'
}

// =========================
// Symbols and operators
// =========================
// Punctuation
COMMA          = @{ "," }
LPAR           = @{ "(" }
RPAR           = @{ ")" }
LBRACK         = @{ "[" }
RBRACK         = @{ "]" }
QMARK          = @{ "?" }
OP_AT          = @{ "@" }
OP_DOT         = @{ "." }
OP_DOTDOT      = @{ ".." }
OP_COLONCOLON  = @{ "::" }
OP_ASSIGN      = @{ ":=" }
OP_SLASH       = @{ "/" }
OP_DSLASH      = @{ "//" }
OP_PIPE        = @{ "|" }

// Arithmetic and set operators
OP_PLUS   = @{ "+" }
OP_MINUS  = @{ "-" }
OP_STAR   = @{ "*" }
OP_LTE    = @{ "<=" }
OP_GTE    = @{ ">=" }
OP_NE     = @{ "!=" }
OP_EQ     = @{ "=" }
OP_LT     = @{ "<" }
OP_GT     = @{ ">" }
OP_PRECEDES = @{ "<<" }
OP_FOLLOWS  = @{ ">>" }

// =========================
// Keywords (word-boundary guarded)
// =========================
// Logical
K_OR  = @{ "or"  ~ !ncname_char }
K_AND = @{ "and" ~ !ncname_char }

// Comparison (value)
K_EQ = @{ "eq" ~ !ncname_char }
K_NE = @{ "ne" ~ !ncname_char }
K_LT = @{ "lt" ~ !ncname_char }
K_LE = @{ "le" ~ !ncname_char }
K_GT = @{ "gt" ~ !ncname_char }
K_GE = @{ "ge" ~ !ncname_char }
K_IS = @{ "is" ~ !ncname_char }

// Arithmetic (word-based)
K_DIV  = @{ "div"  ~ !ncname_char }
K_IDIV = @{ "idiv" ~ !ncname_char }
K_MOD  = @{ "mod"  ~ !ncname_char }

// Set
K_UNION     = @{ "union"     ~ !ncname_char }
K_INTERSECT = @{ "intersect" ~ !ncname_char }
K_EXCEPT    = @{ "except"    ~ !ncname_char }

// Structural
K_FOR       = @{ "for"       ~ !ncname_char }
K_LET       = @{ "let"       ~ !ncname_char }
K_IN        = @{ "in"        ~ !ncname_char }
K_RETURN    = @{ "return"    ~ !ncname_char }
K_SOME      = @{ "some"      ~ !ncname_char }
K_EVERY     = @{ "every"     ~ !ncname_char }
K_SATISFIES = @{ "satisfies" ~ !ncname_char }
K_IF        = @{ "if"        ~ !ncname_char }
K_THEN      = @{ "then"      ~ !ncname_char }
K_ELSE      = @{ "else"      ~ !ncname_char }
K_TO        = @{ "to"        ~ !ncname_char }

// Type ops
K_INSTANCE = @{ "instance" ~ !ncname_char }
K_OF       = @{ "of"       ~ !ncname_char }
K_TREAT    = @{ "treat"    ~ !ncname_char }
K_AS       = @{ "as"       ~ !ncname_char }
K_CASTABLE = @{ "castable" ~ !ncname_char }
K_CAST     = @{ "cast"     ~ !ncname_char }

// Kind/sequence-type
K_NODE                   = @{ "node"                   ~ !ncname_char }
K_TEXT                   = @{ "text"                   ~ !ncname_char }
K_COMMENT                = @{ "comment"                ~ !ncname_char }
K_PROCESSING_INSTRUCTION = @{ "processing-instruction" ~ !ncname_char }
K_ELEMENT                = @{ "element"                ~ !ncname_char }
K_ATTRIBUTE              = @{ "attribute"              ~ !ncname_char }
K_SCHEMA_ELEMENT         = @{ "schema-element"         ~ !ncname_char }
K_SCHEMA_ATTRIBUTE       = @{ "schema-attribute"       ~ !ncname_char }
K_DOCUMENT_NODE          = @{ "document-node"          ~ !ncname_char }
K_EMPTY_SEQUENCE         = @{ "empty-sequence"         ~ !ncname_char }
K_ITEM                   = @{ "item"                   ~ !ncname_char }

// Axes
K_CHILD              = @{ "child"              ~ !ncname_char }
K_DESCENDANT         = @{ "descendant"         ~ !ncname_char }
K_SELF               = @{ "self"               ~ !ncname_char }
K_DESCENDANT_OR_SELF = @{ "descendant-or-self" ~ !ncname_char }
K_FOLLOWING_SIBLING  = @{ "following-sibling"  ~ !ncname_char }
K_FOLLOWING          = @{ "following"          ~ !ncname_char }
K_NAMESPACE          = @{ "namespace"          ~ !ncname_char }
K_PARENT             = @{ "parent"             ~ !ncname_char }
K_ANCESTOR           = @{ "ancestor"           ~ !ncname_char }
K_PRECEDING_SIBLING  = @{ "preceding-sibling"  ~ !ncname_char }
K_PRECEDING          = @{ "preceding"          ~ !ncname_char }
K_ANCESTOR_OR_SELF   = @{ "ancestor-or-self"   ~ !ncname_char }

// =========================
// Entry + expression hierarchy
// =========================
xpath       = { SOI ~ expr ~ EOI }
expr        = { expr_single ~ (COMMA ~ expr_single)* }
expr_single = { for_expr | let_expr | quantified_expr | if_expr | or_expr }

// For/quantified/if
for_expr = { K_FOR ~ "$" ~ var_name ~ K_IN ~ expr_single ~ (COMMA ~ "$" ~ var_name ~ K_IN ~ expr_single)* ~ K_RETURN ~ expr_single }
let_expr = { K_LET ~ "$" ~ var_name ~ OP_ASSIGN ~ expr_single ~ (COMMA ~ "$" ~ var_name ~ OP_ASSIGN ~ expr_single)* ~ K_RETURN ~ expr_single }
quantified_expr = { (K_SOME | K_EVERY) ~ "$" ~ var_name ~ K_IN ~ expr_single ~ (COMMA ~ "$" ~ var_name ~ K_IN ~ expr_single)* ~ K_SATISFIES ~ expr_single }
if_expr = { K_IF ~ LPAR ~ expr ~ RPAR ~ K_THEN ~ expr_single ~ K_ELSE ~ expr_single }

// Logical
or_expr  = { and_expr ~ (or_op ~ and_expr)* }
and_expr = { comparison_expr ~ (and_op ~ comparison_expr)* }
or_op    = _{ K_OR }
and_op   = _{ K_AND }

// Comparison
comparison_expr = { (range_expr ~ comparison_op ~ range_expr) | range_expr }
comparison_op   = { node_comp | value_comp | general_comp }
general_comp    = _{ OP_LTE | OP_GTE | OP_NE | OP_EQ | OP_LT | OP_GT }
value_comp      = _{ K_EQ | K_NE | K_LT | K_LE | K_GT | K_GE }
node_comp       = _{ OP_PRECEDES | OP_FOLLOWS | K_IS }

// Arithmetic precedence
range_expr            = { additive_expr ~ (K_TO ~ additive_expr)? }
additive_expr         = { multiplicative_expr ~ (add_op ~ multiplicative_expr)* }
multiplicative_expr   = { union_expr ~ (mult_op ~ union_expr)* }
add_op                = _{ OP_PLUS | OP_MINUS }
mult_op               = _{ OP_STAR | K_DIV | K_IDIV | K_MOD }

// Set operations
union_expr            = { intersect_except_expr ~ (union_op ~ intersect_except_expr)* }
intersect_except_expr = { instanceof_expr ~ (intersect_except_op ~ instanceof_expr)* }
union_op              = _{ K_UNION | OP_PIPE }
intersect_except_op   = _{ K_INTERSECT | K_EXCEPT }

// Type expressions
instanceof_expr = { treat_expr ~ (instanceof_op ~ sequence_type)? }
treat_expr      = { castable_expr ~ (treat_op ~ sequence_type)? }
castable_expr   = { cast_expr ~ (castable_op ~ single_type)? }
cast_expr       = { unary_expr ~ (cast_op ~ single_type)? }
instanceof_op   = { K_INSTANCE ~ K_OF }
treat_op        = { K_TREAT ~ K_AS }
castable_op     = { K_CASTABLE ~ K_AS }
cast_op         = { K_CAST ~ K_AS }

// Unary/value
unary_expr = { (OP_MINUS | OP_PLUS)* ~ value_expr }
value_expr = { path_expr }

// =========================
// Paths and steps
// =========================
path_expr = { absolute_path | relative_path_expr }
absolute_path = { (OP_DSLASH ~ relative_path_expr) | (OP_SLASH ~ relative_path_expr?) }
relative_path_expr = { step_expr ~ (path_operator ~ step_expr)* }
path_operator = _{ OP_DSLASH | OP_SLASH }

// Step expressions
step_expr = { filter_expr | axis_step }
filter_expr = { primary_expr ~ predicate_list }
axis_step = { (reverse_step | forward_step) ~ predicate_list }

forward_step = { (forward_axis ~ node_test) | abbrev_forward_step }
forward_axis = {
    (K_CHILD ~ OP_COLONCOLON)
  | (K_DESCENDANT ~ OP_COLONCOLON)
  | (K_ATTRIBUTE ~ OP_COLONCOLON)
  | (K_SELF ~ OP_COLONCOLON)
  | (K_DESCENDANT_OR_SELF ~ OP_COLONCOLON)
  | (K_FOLLOWING_SIBLING ~ OP_COLONCOLON)
  | (K_FOLLOWING ~ OP_COLONCOLON)
  | (K_NAMESPACE ~ OP_COLONCOLON)
}

reverse_step = { reverse_axis ~ node_test }
reverse_axis = {
    (K_PARENT ~ OP_COLONCOLON)
  | (K_ANCESTOR ~ OP_COLONCOLON)
  | (K_PRECEDING_SIBLING ~ OP_COLONCOLON)
  | (K_PRECEDING ~ OP_COLONCOLON)
  | (K_ANCESTOR_OR_SELF ~ OP_COLONCOLON)
}

abbrev_forward_step = { (OP_AT ~ name_test) | node_test }
abbrev_reverse_step = { OP_DOTDOT }

// =========================
// Node/name tests and predicates
// =========================
node_test     = { kind_test | name_test }
name_test     = { wildcard_name | qname }
wildcard_name = @{ ("*" ~ ":" ~ ncname) | (ncname ~ ":" ~ "*") | "*" }

predicate_list = { predicate* }
predicate      = { LBRACK ~ expr ~ RBRACK }

// =========================
// Primary expressions and function calls
// =========================
primary_expr = { var_ref | function_call | literal | parenthesized_expr | abbrev_reverse_step | context_item_expr }
var_ref            = { "$" ~ var_name }
var_name           = { qname }
parenthesized_expr = { LPAR ~ expr? ~ RPAR }
context_item_expr  = { OP_DOT }
literal            = { numeric_literal | string_literal }

// Reserved function names cannot be used unprefixed (A.3)
reserved_function_name = @{ ("attribute"|"comment"|"document-node"|"element"|"empty-sequence"|"if"|"item"|"node"|"processing-instruction"|"schema-attribute"|"schema-element"|"text"|"typeswitch") ~ !ncname_char }
function_qname = @{ (ncname ~ ":" ~ ncname) | (!(reserved_function_name) ~ ncname) }
function_call  = { function_qname ~ LPAR ~ (expr_single ~ (COMMA ~ expr_single)*)? ~ RPAR }

// =========================
// Sequence types and kind tests
// =========================
single_type   = { atomic_type ~ QMARK? }
sequence_type = { (K_EMPTY_SEQUENCE ~ LPAR ~ RPAR) | (item_type ~ occurrence_indicator?) }
occurrence_indicator = { QMARK | OP_STAR | OP_PLUS }
item_type            = { kind_test | (K_ITEM ~ LPAR ~ RPAR) | atomic_type }
atomic_type          = { qname }

kind_test = { document_test | element_test | attribute_test | schema_element_test | schema_attribute_test | pi_test | comment_test | text_test | any_kind_test }
any_kind_test = { K_NODE ~ LPAR ~ RPAR }
document_test = { K_DOCUMENT_NODE ~ LPAR ~ (element_test | schema_element_test)? ~ RPAR }
text_test     = { K_TEXT ~ LPAR ~ RPAR }
comment_test  = { K_COMMENT ~ LPAR ~ RPAR }
pi_test       = { K_PROCESSING_INSTRUCTION ~ LPAR ~ (ncname | string_literal)? ~ RPAR }

attribute_test          = { K_ATTRIBUTE ~ LPAR ~ (attrib_name_or_wildcard ~ (COMMA ~ type_name)?)? ~ RPAR }
attrib_name_or_wildcard = { attribute_name | "*" }
schema_attribute_test   = { K_SCHEMA_ATTRIBUTE ~ LPAR ~ attribute_declaration ~ RPAR }
attribute_declaration   = { attribute_name }

element_test             = { K_ELEMENT ~ LPAR ~ (element_name_or_wildcard ~ (COMMA ~ type_name ~ QMARK?)?)? ~ RPAR }
element_name_or_wildcard = { element_name | "*" }
schema_element_test      = { K_SCHEMA_ELEMENT ~ LPAR ~ element_declaration ~ RPAR }
element_declaration      = { element_name }

attribute_name = { qname }
element_name   = { qname }
type_name      = { qname }

// =========================
// Literals
// =========================
numeric_literal = { double_literal | decimal_literal | integer_literal }
integer_literal = @{ digits ~ !("." | ^"e" | "div" | "mod" | "and" | "or" | ncname_start_char) }
decimal_literal = @{ (digits ~ "." ~ digits ~ !("div" | "mod" | "and" | "or" | ncname_start_char))
                  | ("." ~ digits ~ !("div" | "mod" | "and" | "or" | ncname_start_char))
                  | (digits ~ "." ~ !(ASCII_DIGIT | ^"e" | "div" | "mod" | "and" | "or" | ncname_start_char)) }
double_literal  = @{ ((digits ~ "." ~ digits) | ("." ~ digits) | digits) ~ ^"e" ~ ("+" | "-")? ~ digits }

// String literal with accessible inner content (quotes excluded in inner rules)
string_literal    = { dbl_string | sgl_string }
// Make string rules atomic so default WHITESPACE skipping does not remove
// leading whitespace just after the opening quote.
dbl_string        = @{ "\"" ~ dbl_string_inner ~ "\"" }
sgl_string        = @{ "'"  ~ sgl_string_inner ~ "'" }
dbl_string_inner  = @{ (escape_quot | (!"\"" ~ ANY))* }
sgl_string_inner  = @{ (escape_apos | (!"'"  ~ ANY))* }
escape_quot       = { "\"\"" }
escape_apos       = { "''" }
