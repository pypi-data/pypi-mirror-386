import { Palette, ScrollView } from "std-widgets.slint";

export struct TreeNodeVM {
	id: string,
	label: string,
	has_children: bool,
    icon_name: string,
    depth: int,
    is_expanded: bool,
    is_valid: bool,
}

// (Tooltip removed for now)

// Einzelne Zeile (vorab definieren, damit nutzbar)
component TreeRow inherits Rectangle {
    in property <TreeNodeVM> node;
    in property <bool> show-icons;
    in property <int> indent-size;
    in property <bool> is-selected;
    in property <bool> is-focused;
    in property <bool> is-expanded;
    in property <int> index;
    // callbacks to bubble actions
	callback activate();
    callback toggle();
    callback refresh();
    callback refresh-subtree();
    height: 22px;
    // Base visuals
    background: Palette.background;
    border-width: 0px;
    border-color: Palette.border;
    // Smooth transition between backgrounds
    animate background { duration: 120ms; }
    // (Optional fade-in removed for compatibility)

    states [
        hover when ta.has-hover && !is-selected: {
            root.background: Palette.background.darker(5%);
        }
        pressed when ta.pressed && !is-selected: {
            root.background: Palette.background.darker(10%);
        }
        selected when is-selected: {
            root.background: Palette.selection-background;
            label_text.color: Palette.selection-foreground;
            root.border-width: 0px;
        }
        focused when is-focused && !is-selected: {
            root.border-width: 1px;
            root.border-color: Palette.selection-foreground;
        }
    ]

	// Left selection indicator for better contrast
	Rectangle {
        x: 0px;
        y: 0px;
        width: 3px;
        height: parent.height;
        background: Palette.selection-foreground;
        visible: is-selected;
        opacity: 0.6;
    }

	// Row click handling base layer (behind specific controls)
    // No-op property; hover detection uses ta.has-hover directly
    ta := TouchArea {
        width: parent.width;
        height: parent.height;
        clicked => {
            root.activate();
        }
    }
    // (Tooltip hover timers removed)

    HorizontalLayout {
        spacing: 6px;

		// Einrückung je Ebene
        Rectangle {
            width: (node.depth * indent-size) * 1px;
            height: 1px;
            opacity: 0;
        }

		// Disclosure
        Rectangle {
            width: 16px;
            height: parent.height;

            // Right-facing chevron (collapsed)
            path_right := Path {
                visible: root.node.has_children;
                x: (parent.width - 12px) / 2;
                y: (parent.height - 12px) / 2;
                width: 12px;
                height: 12px;
                commands: "M 5 4 L 9 8 L 5 12";
                stroke: is-selected ? Palette.selection-foreground : Palette.foreground;
                stroke-width: 2px;
                opacity: is-expanded ? 0.0 : 1.0;
                animate opacity { duration: 120ms; }
                fill: transparent;
            }

            // Down-facing chevron (expanded)
            path_down := Path {
                visible: root.node.has_children;
                x: (parent.width - 12px) / 2;
                y: (parent.height - 12px) / 2;
                width: 12px;
                height: 12px;
                commands: "M 4 7 L 8 11 L 12 7";
                stroke: is-selected ? Palette.selection-foreground : Palette.foreground;
                stroke-width: 2px;
                opacity: is-expanded ? 1.0 : 0.0;
                animate opacity { duration: 120ms; }
                fill: transparent;
            }

            TouchArea {
                clicked => {
                    if (root.node.has_children) {
                        root.toggle();
                    }
                }
            }
        }

		// Optionales Icon (16x16) – leerer Platzhalter wenn kein Icon
        Rectangle {
            visible: show-icons;
            width: 16px;
            height: 16px;

			// TODO: In späterer Phase: image: @image-url("icons/" + node.icon_name + ".svg");
		}

		// Label
        label_text := Text {
            text: node.label;
            color: is-selected ? Palette.selection-foreground : Palette.foreground;
            vertical-alignment: center;
            horizontal-stretch: 1;
        }
    }

    // Strike-through overlay when node is invalid (placed outside layout to overlay the text)
    Rectangle {
        // Only show when invalid; positioned over the label_text
        visible: !root.node.is_valid;
        height: 1px;
        y: (parent.height - self.height) / 2;
        x: label_text.x;
        width: label_text.width;
        background: is-selected ? Palette.selection-foreground : Palette.foreground.with-alpha(150);
    }

    // Simple tooltip shown on hover, using standard Palette
    // Appears above the row near the mouse cursor; kept lightweight (no Material import)

    // Proper Slint context menu for this row
    ContextMenuArea {
        width: parent.width;
        height: parent.height;
        Menu {
            MenuItem {
                title: @tr("Refresh");
                activated => { root.refresh(); }
            }
            MenuItem {
                title: @tr("Refresh subtree");
                activated => { root.refresh-subtree(); }
            }
        }
    }
}

export component TreeView inherits ScrollView {
    in property <bool> show-icons: true;
    in property <int> indent-size: 14;
    in property <[TreeNodeVM]> root-model: [];
    in-out property <int> selected-index: -1;

	// Internal state
	in-out property <int> focused-index: -1; // -1 = none
	private property <length> row-height: 22px;

	// ScrollView configuration - scrollbars as needed
	vertical-scrollbar-policy: as-needed;
    horizontal-scrollbar-policy: as-needed;

    // Viewport dimensions - essential for ScrollView to work correctly
    viewport-height: root-model.length * row-height + 4px; // +4px for padding
    // Smooth scrolling adjustments
    animate viewport-y { duration: 140ms; }
    // Calculate minimum width needed for content - this enables horizontal scrolling
    // viewport-width: max(self.visible-width, 500px); // at least 500px or visible width

    // Index-based signals
    callback node-selected-index(index: int);
    callback node-toggled-index(index: int, is_expanded: bool);
    callback request-children-index(index: int);
    // New: request refresh for a specific row index
    callback refresh-index(index: int);
    callback refresh-subtree-index(index: int);

	// Public API: programmatic selection by index; focuses + scrolls consistently
	public function select_index(i: int) {
        if (i < 0 || i >= root-model.length) {
            return;
        }
        self.apply_focus_and_select(i);
    }
    public function request_focus() {
        fs.focus();
        if (root-model.length == 0) {
            return;
        }
		if (focused-index >= 0) {
            self.scroll_into_view(focused-index);
        } else if (selected-index < 0) {
            // No selection and no focus: move to first row once
            selected-index = 0;
            focused-index = 0;
            root.node-selected-index(0);
            self.scroll_into_view(0);
        }
    }

	// Helpers
	function scroll_into_view(index: int) {
        let item_y = row-height * index;
        let view_top = -self.viewport-y;  // viewport-y is negative, so negate it
        let view_bottom = view_top + self.visible-height;
        let item_bottom = item_y + row-height;
        if (item_y < view_top) {
            // Item is above visible area, scroll up
            self.viewport-y = -item_y;
        } else if (item_bottom > view_bottom) {
            // Item is below visible area, scroll down
            let desired = item_bottom - self.visible-height;
            self.viewport-y = -desired;
        }
    }
    function has_rows() -> bool {
        return root-model.length > 0;
    }
    function max_index() -> int {
        if (root-model.length == 0) {
            return -1;
        }
        return root-model.length - 1;
    }
    function prev_index() -> int {
        let mi = self.max_index();
        if (mi < 0) {
            return -1;
        }
        let i = focused-index;
        if (i < 0) {
            return 0;
        }
        if (i > 0) {
            return i - 1;
        }
        return 0;
    }
    function next_index() -> int {
        let mi = self.max_index();
        if (mi < 0) {
            return -1;
        }
        let i = focused-index;
        if (i < 0) {
            return 0;
        }
        if (i < mi) {
            return i + 1;
        }
        return mi;
    }

    function home_index() -> int {
        if (root-model.length > 0) {
            return 0;
        }
        return -1;
    }
    function end_index() -> int {
        return self.max_index();
    }

	// (Parent navigation - simplified version)
	function find_parent_index(child_index: int) -> int {
        if (child_index <= 0 || child_index >= root-model.length) {
            return -1;
        }
        let child_depth = root-model[child_index].depth;
        if (child_depth <= 0) {
            return -1; // No parent for root level items
        }

        // For now, just go to previous item with less depth
        // This is a simplified approach - in a real tree we'd need proper parent tracking
        let target_depth = child_depth - 1;
        if (child_index > 0) {
            let prev = child_index - 1;
            if (prev >= 0 && root-model[prev].depth == target_depth) {
                return prev;
            }
            if (child_index > 1) {
                let prev2 = child_index - 2;
                if (prev2 >= 0 && root-model[prev2].depth == target_depth) {
                    return prev2;
                }
            }
            if (child_index > 2) {
                let prev3 = child_index - 3;
                if (prev3 >= 0 && root-model[prev3].depth == target_depth) {
                    return prev3;
                }
            }
        }
        return -1;
    }

	// Return index of first child (i+1) if it exists and has greater depth
	function first_child_index(i: int) -> int {
        let mi = self.max_index();
        if (i < 0 || i >= mi) {
            return -1;
        }
        let my_depth = root-model[i].depth;
        let next_i = i + 1;
        if (next_i <= mi && root-model[next_i].depth > my_depth) {
            return next_i;
        }
        return -1;
    }

    // Content container
	fs := FocusScope {
        width: 100%;
        height: 100%;
        focus-on-click: true;

            // Tastatur-Navigation wie im Windows Explorer (Safer Version)
            key-pressed(event) => {
            if (!root.has_rows()) {
                reject
            }

            // Validiere focused-index EINMAL zu Beginn
            if (root.focused-index < 0 || root.focused-index >= root.root-model.length) {
                root.focused-index = 0;
                // No apply_focus_and_select here - avoid loops
                if (root.root-model.length > 0) {
                    selected-index = 0;
                    root.node-selected-index(0);
                    root.scroll_into_view(0);
                }
                accept
            }

                // Pfeil HOCH: vorherige sichtbare Node
                if (event.text == Key.UpArrow) {
                let current = root.focused-index;
                if (current > 0) {
                    root.apply_focus_and_select(current - 1);
                }
                accept
            }

            // Pfeil RUNTER: nächste sichtbare Node
            if (event.text == Key.DownArrow) {
                let current = root.focused-index;
                let max_idx = root.max_index();
                if (current < max_idx) {
                    root.apply_focus_and_select(current + 1);
                }
                accept
            }            // Pfeil LINKS: Kollabieren oder zu Parent
            if (event.text == Key.LeftArrow) {
                let current = root.focused-index;
                if (current >= 0 && current < root.root-model.length) {
                    let node = root.root-model[current];
                    if (node.has_children && node.is_expanded) {
                        // collapse
                        root.node-toggled-index(current, false);
                    } else if (node.depth > 0) {
                        // Gehe zum Parent (vorherige Node mit geringerer Tiefe)
                        let parent_idx = root.find_parent_index(current);
                        if (parent_idx >= 0) {
                            root.apply_focus_and_select(parent_idx);
                        }
                    }
                }
                accept
            }

            // Pfeil RECHTS: Expandieren oder zu erstem Child
            if (event.text == Key.RightArrow) {
                let current = root.focused-index;
                if (current >= 0 && current < root.root-model.length) {
                    let node = root.root-model[current];
                    if (node.has_children) {
                        if (!node.is_expanded) {
                            // expand
                            root.node-toggled-index(current, true);
                            root.request-children-index(current);
                        } else {
                            // Node ist bereits expanded -> gehe zum ersten Kind
                            if (current + 1 < root.root-model.length) {
                                let next_node = root.root-model[current + 1];
                                if (next_node.depth > node.depth) {
                                    root.apply_focus_and_select(current + 1);
                                }
                            }
                        }
                    }
                    // Wenn Node keine Kinder hat: Ignorieren und accept trotzdem
                }
                accept
            }

                // Home: Springe zum ersten Element
                if (event.text == Key.Home) {
                root.apply_focus_and_select(0);
                accept
            }

            // End: Springe zum letzten Element
            if (event.text == Key.End) {
                let max_idx = root.max_index();
                if (max_idx >= 0) {
                    root.apply_focus_and_select(max_idx);
                }
                accept
            }

                // PageUp: Springe eine Bildschirmseite nach oben
                if (event.text == Key.PageUp) {
                let page_size = max(1, floor(root.visible-height / root.row-height));
                let current = root.focused-index;
                let new_idx = max(0, current - page_size);
                root.apply_focus_and_select(new_idx);
                accept
            }

            // PageDown: Springe eine Bildschirmseite nach unten
            if (event.text == Key.PageDown) {
                let page_size = max(1, floor(root.visible-height / root.row-height));
                let current = root.focused-index;
                let max_idx = root.max_index();
                let new_idx = min(max_idx, current + page_size);
                root.apply_focus_and_select(new_idx);
                accept
            }

            // F5: Refresh currently focused row
            if (event.text == Key.F5) {
                if (root.focused-index >= 0 && root.focused-index < root.root-model.length) {
                    root.refresh-index(root.focused-index);
                }
                accept
            }

            // Für alle anderen Keys: accept statt reject um "Hängen" zu vermeiden
            accept
        }
        VerticalLayout {
            padding: 2px;
            for item[i] in root-model: TreeRow {
                node: item;
                show-icons: root.show-icons;
                indent-size: root.indent-size;
                is-selected: i == root.selected-index;
                is-focused: i == root.focused-index;
                is-expanded: item.is_expanded;
                index: i;
                activate => { root.on_row_activated(i); }
                toggle => { root.on_row_toggled(i); }
                refresh => { root.on_row_refresh(i); }
                refresh-subtree => { root.on_row_refresh_subtree(i); }
                // (Tooltip wiring removed)
            }
        }
    }

    // (index-based callbacks declared above)

    // internal handlers
	function on_row_activated(i: int) {
        // Ensure the FocusScope has keyboard focus when a row is clicked
        // (safe here because it's pointer-initiated, avoiding key event loops)
        fs.focus();
        focused-index = i;
        if (i != selected-index) {
            selected-index = i;
            root.node-selected-index(i);
        }
        self.scroll_into_view(i);
    }
    function on_row_toggled(i: int) {
        // Mouse-initiated toggle: it's safe to focus the scope to keep keyboard navigation active
        fs.focus();
        let nd = root-model[i];
        if (!nd.has_children) {
            return;
        }
        // Emit toggle intent with inverse of current expanded state
        root.node-toggled-index(i, !nd.is_expanded);
        if (!nd.is_expanded) {
            root.request-children-index(i);
        }
    }
    function on_row_refresh(i: int) {
        if (i < 0 || i >= root-model.length) { return; }
        root.refresh-index(i);
    }
    function on_row_refresh_subtree(i: int) {
        if (i < 0 || i >= root-model.length) { return; }
        root.refresh-subtree-index(i);
    }
    function apply_focus_and_select(i: int) {
        // Robuste Bounds-Checking
        if (i < 0 || i >= root-model.length) {
            return;
        }
        focused-index = i;

        if (i != selected-index) {
            selected-index = i;
            root.node-selected-index(i);
        }
        self.scroll_into_view(i);
    }
}
