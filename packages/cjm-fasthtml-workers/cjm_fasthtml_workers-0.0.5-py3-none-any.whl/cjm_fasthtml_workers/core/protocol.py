"""Protocol definitions for worker communication and plugin manager integration."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/protocol.ipynb.

# %% auto 0
__all__ = ['WorkerRequestType', 'WorkerResponseType', 'WorkerRequest', 'WorkerResponse', 'WorkerStreamChunk', 'WorkerResult',
           'PluginManagerAdapter']

# %% ../../nbs/core/protocol.ipynb 3
from typing import Dict, Any, Optional, Iterator, Protocol
from enum import Enum
from dataclasses import dataclass

# %% ../../nbs/core/protocol.ipynb 6
class WorkerRequestType(Enum):
    """Types of requests sent to worker process."""
    INIT = "init"  # Initialize worker with plugin configurations
    EXECUTE = "execute"  # Execute a job with specified plugin and parameters
    RELOAD = "reload"  # Reload a plugin with new configuration
    UNLOAD = "unload"  # Unload a plugin to free resources
    GET_STATE = "get_state"  # Query current worker state
    STOP = "stop"  # Gracefully shutdown the worker

# %% ../../nbs/core/protocol.ipynb 7
class WorkerResponseType(Enum):
    """Types of responses from worker process."""
    READY = "ready"  # Worker initialized successfully
    RESULT = "result"  # Job execution completed (success or error)
    STREAM_CHUNK = "stream_chunk"  # Streaming output chunk
    RESPONSE = "response"  # Synchronous response to commands
    STATE = "state"  # Worker state information
    ERROR = "error"  # Fatal worker error

# %% ../../nbs/core/protocol.ipynb 10
@dataclass
class WorkerRequest:
    """Base structure for worker requests."""
    type: WorkerRequestType
    data: Dict[str, Any]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for queue serialization."""
        return {
            'type': self.type.value,
            **self.data
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WorkerRequest':
        """Create from dictionary received from queue."""
        req_type = WorkerRequestType(data['type'])
        request_data = {k: v for k, v in data.items() if k != 'type'}
        return cls(type=req_type, data=request_data)

# %% ../../nbs/core/protocol.ipynb 14
@dataclass
class WorkerResponse:
    """Base structure for worker responses."""
    type: WorkerResponseType
    data: Dict[str, Any]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for queue serialization."""
        return {
            'type': self.type.value,
            **self.data
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WorkerResponse':
        """Create from dictionary received from queue."""
        resp_type = WorkerResponseType(data['type'])
        response_data = {k: v for k, v in data.items() if k != 'type'}
        return cls(type=resp_type, data=response_data)

# %% ../../nbs/core/protocol.ipynb 16
@dataclass
class WorkerStreamChunk:
    """Structure for streaming job results."""
    job_id: str  # Unique identifier for the job
    chunk: str  # Text chunk from streaming output
    is_final: bool = False  # Whether this is the final chunk
    metadata: Optional[Dict[str, Any]] = None  # Optional metadata

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for queue serialization."""
        return {
            'type': WorkerResponseType.STREAM_CHUNK.value,
            'job_id': self.job_id,
            'chunk': self.chunk,
            'is_final': self.is_final,
            'metadata': self.metadata or {}
        }

# %% ../../nbs/core/protocol.ipynb 18
@dataclass
class WorkerResult:
    """Structure for job execution results."""
    job_id: str  # Unique identifier for the job
    status: str  # 'success' or 'error'
    data: Optional[Dict[str, Any]] = None  # Result data on success
    error: Optional[str] = None  # Error message on failure

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for queue serialization."""
        result = {
            'type': WorkerResponseType.RESULT.value,
            'job_id': self.job_id,
            'status': self.status,
        }
        if self.data is not None:
            result['data'] = self.data
        if self.error is not None:
            result['error'] = self.error
        return result

# %% ../../nbs/core/protocol.ipynb 23
class PluginManagerAdapter(Protocol):
    """
    Protocol that plugin managers must satisfy for worker integration.

    Uses structural subtyping (duck typing) - plugin managers don't need to
    explicitly inherit from this, they just need to implement these methods.
    """

    def discover_plugins(self) -> list:  # List of plugin metadata/data objects
        """Discover available plugins."""
        ...

    def load_plugin(
        self, 
        plugin_data:Any,  # Plugin metadata/data from discovery
        config:Dict[str, Any]  # Plugin configuration dictionary
    ) -> None:
        """Load a plugin with configuration."""
        ...

    def execute_plugin(
        self, 
        plugin_name:str,  # Name of the plugin to execute
        **params  # Plugin-specific parameters
    ) -> Any:  # Plugin execution result
        """Execute a plugin with given parameters."""
        ...

    def execute_plugin_stream(
        self, 
        plugin_name:str,  # Name of the plugin to execute
        **params  # Plugin-specific parameters
    ) -> Iterator[str]:  # String chunks from plugin execution
        """Execute a plugin with streaming output."""
        ...

    def reload_plugin(
        self, 
        plugin_name:str,  # Name of the plugin to reload
        config:Optional[Dict[str, Any]]=None  # New configuration (None to unload)
    ) -> None:
        """Reload a plugin with new configuration."""
        ...

    def unload_plugin(
        self, 
        plugin_name:str  # Name of the plugin to unload
    ) -> None:
        """Unload a plugin to free resources."""
        ...

    def check_streaming_support(
        self, 
        plugin_name:str  # Name of the plugin to check
    ) -> bool:  # True if plugin supports streaming
        """Check if a plugin supports streaming execution."""
        ...
