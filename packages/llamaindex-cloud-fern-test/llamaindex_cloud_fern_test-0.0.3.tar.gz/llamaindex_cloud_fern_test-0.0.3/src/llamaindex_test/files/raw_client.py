# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from .. import core
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.file import File
from ..types.file_create_permission_info_value import FileCreatePermissionInfoValue
from ..types.file_create_resource_info_value import FileCreateResourceInfoValue
from ..types.file_id_presigned_url import FileIdPresignedUrl
from ..types.http_validation_error import HttpValidationError
from ..types.page_figure_metadata import PageFigureMetadata
from ..types.page_screenshot_metadata import PageScreenshotMetadata
from ..types.presigned_url import PresignedUrl
from .types.file_create_from_url_resource_info_value import FileCreateFromUrlResourceInfoValue

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawFilesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get(
        self,
        id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[File]:
        """
        Read File metadata objects.

        Parameters
        ----------
        id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[File]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    File,
                    construct_type(
                        type_=File,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self,
        id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Delete the file from S3.

        Parameters
        ----------
        id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}",
            method="DELETE",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list(
        self,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[File]]:
        """
        Read File metadata objects.

        Parameters
        ----------
        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[File]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/files",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[File],
                    construct_type(
                        type_=typing.List[File],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upload(
        self,
        *,
        upload_file: core.File,
        external_file_id: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[File]:
        """
        Upload a file to S3.

        Parameters
        ----------
        upload_file : core.File
            See core.File for more documentation

        external_file_id : typing.Optional[str]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[File]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/files",
            method="POST",
            params={
                "external_file_id": external_file_id,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            data={},
            files={
                "upload_file": upload_file,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    File,
                    construct_type(
                        type_=File,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def generate_presigned_url(
        self,
        *,
        name: str,
        expires_at_seconds: typing.Optional[int] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        external_file_id: typing.Optional[str] = OMIT,
        file_size: typing.Optional[int] = OMIT,
        last_modified_at: typing.Optional[dt.datetime] = OMIT,
        resource_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]]] = OMIT,
        permission_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]]] = OMIT,
        data_source_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[FileIdPresignedUrl]:
        """
        Create a presigned url for uploading a file.

        The presigned url is valid for a limited time period, after which it will expire.
        Be careful on accidental exposure of the presigned url, as it may allow unauthorized access to the file before the expiration.

        Parameters
        ----------
        name : str
            Name that will be used for created file. If possible, always include the file extension in the name.

        expires_at_seconds : typing.Optional[int]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        external_file_id : typing.Optional[str]
            The ID of the file in the external system

        file_size : typing.Optional[int]
            Size of the file in bytes

        last_modified_at : typing.Optional[dt.datetime]
            The last modified time of the file

        resource_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]]]
            Resource information for the file

        permission_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]]]
            Permission information for the file

        data_source_id : typing.Optional[str]
            The ID of the data source that the file belongs to

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FileIdPresignedUrl]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/files",
            method="PUT",
            params={
                "expires_at_seconds": expires_at_seconds,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "name": name,
                "external_file_id": external_file_id,
                "file_size": file_size,
                "last_modified_at": last_modified_at,
                "resource_info": convert_and_respect_annotation_metadata(
                    object_=resource_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]],
                    direction="write",
                ),
                "permission_info": convert_and_respect_annotation_metadata(
                    object_=permission_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]],
                    direction="write",
                ),
                "data_source_id": data_source_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileIdPresignedUrl,
                    construct_type(
                        type_=FileIdPresignedUrl,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def sync(
        self,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[File]]:
        """
        Sync Files API against file contents uploaded via S3 presigned urls.

        Parameters
        ----------
        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[File]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/files/sync",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[File],
                    construct_type(
                        type_=typing.List[File],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upload_from_url(
        self,
        *,
        url: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        name: typing.Optional[str] = OMIT,
        proxy_url: typing.Optional[str] = OMIT,
        request_headers: typing.Optional[typing.Dict[str, typing.Optional[str]]] = OMIT,
        verify_ssl: typing.Optional[bool] = OMIT,
        follow_redirects: typing.Optional[bool] = OMIT,
        resource_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreateFromUrlResourceInfoValue]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[File]:
        """
        Upload a file to the project from a URL.

        If name is ommitted in the request payload, the file name will be
        extracted from the response Content-Disposition header if available
        or otherwise it will be derived from the URL path.

        If providing the name in the request payload, always suffix the
        file extension in the name if available.

        Parameters
        ----------
        url : str
            URL of the file to download

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        name : typing.Optional[str]
            Name that will be used for created file. If possible, always include the file extension in the name.

        proxy_url : typing.Optional[str]
            URL of the proxy server to use for downloading the file

        request_headers : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Headers to include in the request when downloading the file

        verify_ssl : typing.Optional[bool]
            Whether to verify the SSL certificate when downloading the file

        follow_redirects : typing.Optional[bool]
            Whether to follow redirects when downloading the file

        resource_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreateFromUrlResourceInfoValue]]]
            Resource information for the file

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[File]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/files/upload_from_url",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "name": name,
                "url": url,
                "proxy_url": proxy_url,
                "request_headers": request_headers,
                "verify_ssl": verify_ssl,
                "follow_redirects": follow_redirects,
                "resource_info": convert_and_respect_annotation_metadata(
                    object_=resource_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreateFromUrlResourceInfoValue]],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    File,
                    construct_type(
                        type_=File,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_content(
        self,
        id: str,
        *,
        expires_at_seconds: typing.Optional[int] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PresignedUrl]:
        """
        Returns a presigned url to read the file content.

        Parameters
        ----------
        id : str

        expires_at_seconds : typing.Optional[int]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PresignedUrl]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/content",
            method="GET",
            params={
                "expires_at_seconds": expires_at_seconds,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PresignedUrl,
                    construct_type(
                        type_=PresignedUrl,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_page_screenshots(
        self,
        id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[PageScreenshotMetadata]]:
        """
        List metadata for all screenshots of pages from a file.

        Parameters
        ----------
        id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[PageScreenshotMetadata]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page_screenshots",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PageScreenshotMetadata],
                    construct_type(
                        type_=typing.List[PageScreenshotMetadata],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_page_screenshot(
        self,
        id: str,
        page_index: int,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get screenshot of a page from a file.

        Parameters
        ----------
        id : str

        page_index : int

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page_screenshots/{jsonable_encoder(page_index)}",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_pages_figures(
        self,
        id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[PageFigureMetadata]]:
        """
        Parameters
        ----------
        id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[PageFigureMetadata]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page-figures",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PageFigureMetadata],
                    construct_type(
                        type_=typing.List[PageFigureMetadata],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_page_figures(
        self,
        id: str,
        page_index: int,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[PageFigureMetadata]]:
        """
        Parameters
        ----------
        id : str

        page_index : int

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[PageFigureMetadata]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page-figures/{jsonable_encoder(page_index)}",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PageFigureMetadata],
                    construct_type(
                        type_=typing.List[PageFigureMetadata],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_page_figure(
        self,
        id: str,
        page_index: int,
        figure_name: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        id : str

        page_index : int

        figure_name : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page-figures/{jsonable_encoder(page_index)}/{jsonable_encoder(figure_name)}",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def generate_page_screenshot_presigned_url(
        self,
        id: str,
        page_index: int,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PresignedUrl]:
        """
        Returns a presigned url to read a page screenshot.

        The presigned url is valid for a limited time period, after which it will expire.
        Be careful on accidental exposure of the presigned url, as it may allow unauthorized access to the file before the expiration.

        Parameters
        ----------
        id : str

        page_index : int

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PresignedUrl]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page_screenshots/{jsonable_encoder(page_index)}/presigned_url",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PresignedUrl,
                    construct_type(
                        type_=PresignedUrl,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def generate_page_figure_presigned_url(
        self,
        id: str,
        page_index: int,
        figure_name: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PresignedUrl]:
        """
        Returns a presigned url to read a page figure.

        The presigned url is valid for a limited time period, after which it will expire.
        Be careful on accidental exposure of the presigned url, as it may allow unauthorized access to the file before the expiration.

        Parameters
        ----------
        id : str

        page_index : int

        figure_name : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PresignedUrl]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page-figures/{jsonable_encoder(page_index)}/{jsonable_encoder(figure_name)}/presigned_url",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PresignedUrl,
                    construct_type(
                        type_=PresignedUrl,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawFilesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get(
        self,
        id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[File]:
        """
        Read File metadata objects.

        Parameters
        ----------
        id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[File]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    File,
                    construct_type(
                        type_=File,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self,
        id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Delete the file from S3.

        Parameters
        ----------
        id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}",
            method="DELETE",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list(
        self,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[File]]:
        """
        Read File metadata objects.

        Parameters
        ----------
        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[File]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/files",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[File],
                    construct_type(
                        type_=typing.List[File],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upload(
        self,
        *,
        upload_file: core.File,
        external_file_id: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[File]:
        """
        Upload a file to S3.

        Parameters
        ----------
        upload_file : core.File
            See core.File for more documentation

        external_file_id : typing.Optional[str]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[File]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/files",
            method="POST",
            params={
                "external_file_id": external_file_id,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            data={},
            files={
                "upload_file": upload_file,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    File,
                    construct_type(
                        type_=File,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def generate_presigned_url(
        self,
        *,
        name: str,
        expires_at_seconds: typing.Optional[int] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        external_file_id: typing.Optional[str] = OMIT,
        file_size: typing.Optional[int] = OMIT,
        last_modified_at: typing.Optional[dt.datetime] = OMIT,
        resource_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]]] = OMIT,
        permission_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]]] = OMIT,
        data_source_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[FileIdPresignedUrl]:
        """
        Create a presigned url for uploading a file.

        The presigned url is valid for a limited time period, after which it will expire.
        Be careful on accidental exposure of the presigned url, as it may allow unauthorized access to the file before the expiration.

        Parameters
        ----------
        name : str
            Name that will be used for created file. If possible, always include the file extension in the name.

        expires_at_seconds : typing.Optional[int]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        external_file_id : typing.Optional[str]
            The ID of the file in the external system

        file_size : typing.Optional[int]
            Size of the file in bytes

        last_modified_at : typing.Optional[dt.datetime]
            The last modified time of the file

        resource_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]]]
            Resource information for the file

        permission_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]]]
            Permission information for the file

        data_source_id : typing.Optional[str]
            The ID of the data source that the file belongs to

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FileIdPresignedUrl]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/files",
            method="PUT",
            params={
                "expires_at_seconds": expires_at_seconds,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "name": name,
                "external_file_id": external_file_id,
                "file_size": file_size,
                "last_modified_at": last_modified_at,
                "resource_info": convert_and_respect_annotation_metadata(
                    object_=resource_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]],
                    direction="write",
                ),
                "permission_info": convert_and_respect_annotation_metadata(
                    object_=permission_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]],
                    direction="write",
                ),
                "data_source_id": data_source_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileIdPresignedUrl,
                    construct_type(
                        type_=FileIdPresignedUrl,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def sync(
        self,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[File]]:
        """
        Sync Files API against file contents uploaded via S3 presigned urls.

        Parameters
        ----------
        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[File]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/files/sync",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[File],
                    construct_type(
                        type_=typing.List[File],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upload_from_url(
        self,
        *,
        url: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        name: typing.Optional[str] = OMIT,
        proxy_url: typing.Optional[str] = OMIT,
        request_headers: typing.Optional[typing.Dict[str, typing.Optional[str]]] = OMIT,
        verify_ssl: typing.Optional[bool] = OMIT,
        follow_redirects: typing.Optional[bool] = OMIT,
        resource_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreateFromUrlResourceInfoValue]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[File]:
        """
        Upload a file to the project from a URL.

        If name is ommitted in the request payload, the file name will be
        extracted from the response Content-Disposition header if available
        or otherwise it will be derived from the URL path.

        If providing the name in the request payload, always suffix the
        file extension in the name if available.

        Parameters
        ----------
        url : str
            URL of the file to download

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        name : typing.Optional[str]
            Name that will be used for created file. If possible, always include the file extension in the name.

        proxy_url : typing.Optional[str]
            URL of the proxy server to use for downloading the file

        request_headers : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Headers to include in the request when downloading the file

        verify_ssl : typing.Optional[bool]
            Whether to verify the SSL certificate when downloading the file

        follow_redirects : typing.Optional[bool]
            Whether to follow redirects when downloading the file

        resource_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreateFromUrlResourceInfoValue]]]
            Resource information for the file

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[File]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/files/upload_from_url",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "name": name,
                "url": url,
                "proxy_url": proxy_url,
                "request_headers": request_headers,
                "verify_ssl": verify_ssl,
                "follow_redirects": follow_redirects,
                "resource_info": convert_and_respect_annotation_metadata(
                    object_=resource_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreateFromUrlResourceInfoValue]],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    File,
                    construct_type(
                        type_=File,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_content(
        self,
        id: str,
        *,
        expires_at_seconds: typing.Optional[int] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PresignedUrl]:
        """
        Returns a presigned url to read the file content.

        Parameters
        ----------
        id : str

        expires_at_seconds : typing.Optional[int]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PresignedUrl]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/content",
            method="GET",
            params={
                "expires_at_seconds": expires_at_seconds,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PresignedUrl,
                    construct_type(
                        type_=PresignedUrl,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_page_screenshots(
        self,
        id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[PageScreenshotMetadata]]:
        """
        List metadata for all screenshots of pages from a file.

        Parameters
        ----------
        id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[PageScreenshotMetadata]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page_screenshots",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PageScreenshotMetadata],
                    construct_type(
                        type_=typing.List[PageScreenshotMetadata],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_page_screenshot(
        self,
        id: str,
        page_index: int,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get screenshot of a page from a file.

        Parameters
        ----------
        id : str

        page_index : int

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page_screenshots/{jsonable_encoder(page_index)}",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_pages_figures(
        self,
        id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[PageFigureMetadata]]:
        """
        Parameters
        ----------
        id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[PageFigureMetadata]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page-figures",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PageFigureMetadata],
                    construct_type(
                        type_=typing.List[PageFigureMetadata],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_page_figures(
        self,
        id: str,
        page_index: int,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[PageFigureMetadata]]:
        """
        Parameters
        ----------
        id : str

        page_index : int

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[PageFigureMetadata]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page-figures/{jsonable_encoder(page_index)}",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PageFigureMetadata],
                    construct_type(
                        type_=typing.List[PageFigureMetadata],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_page_figure(
        self,
        id: str,
        page_index: int,
        figure_name: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        id : str

        page_index : int

        figure_name : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page-figures/{jsonable_encoder(page_index)}/{jsonable_encoder(figure_name)}",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def generate_page_screenshot_presigned_url(
        self,
        id: str,
        page_index: int,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PresignedUrl]:
        """
        Returns a presigned url to read a page screenshot.

        The presigned url is valid for a limited time period, after which it will expire.
        Be careful on accidental exposure of the presigned url, as it may allow unauthorized access to the file before the expiration.

        Parameters
        ----------
        id : str

        page_index : int

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PresignedUrl]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page_screenshots/{jsonable_encoder(page_index)}/presigned_url",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PresignedUrl,
                    construct_type(
                        type_=PresignedUrl,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def generate_page_figure_presigned_url(
        self,
        id: str,
        page_index: int,
        figure_name: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PresignedUrl]:
        """
        Returns a presigned url to read a page figure.

        The presigned url is valid for a limited time period, after which it will expire.
        Be careful on accidental exposure of the presigned url, as it may allow unauthorized access to the file before the expiration.

        Parameters
        ----------
        id : str

        page_index : int

        figure_name : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PresignedUrl]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/files/{jsonable_encoder(id)}/page-figures/{jsonable_encoder(page_index)}/{jsonable_encoder(figure_name)}/presigned_url",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PresignedUrl,
                    construct_type(
                        type_=PresignedUrl,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
