# This file was auto-generated by Fern from our API Definition.

import contextlib
import typing
from json.decoder import JSONDecodeError
from logging import error, warning

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.http_sse._api import EventSource
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.chat_data import ChatData
from ..types.chat_message import ChatMessage
from ..types.chat_message_chunk import ChatMessageChunk
from ..types.cloud_document import CloudDocument
from ..types.cloud_document_create import CloudDocumentCreate
from ..types.data_sink_create import DataSinkCreate
from ..types.http_validation_error import HttpValidationError
from ..types.input_message import InputMessage
from ..types.llama_parse_parameters import LlamaParseParameters
from ..types.managed_ingestion_status_response import ManagedIngestionStatusResponse
from ..types.metadata_filters import MetadataFilters
from ..types.paginated_list_cloud_documents_response import PaginatedListCloudDocumentsResponse
from ..types.pipeline import Pipeline
from ..types.pipeline_create_embedding_config import PipelineCreateEmbeddingConfig
from ..types.pipeline_create_transform_config import PipelineCreateTransformConfig
from ..types.pipeline_metadata_config import PipelineMetadataConfig
from ..types.pipeline_type import PipelineType
from ..types.playground_session import PlaygroundSession
from ..types.preset_retrieval_params import PresetRetrievalParams
from ..types.retrieval_mode import RetrievalMode
from ..types.retrieve_results import RetrieveResults
from ..types.sparse_model_config import SparseModelConfig
from ..types.text_node import TextNode
from .types.pipeline_update_embedding_config import PipelineUpdateEmbeddingConfig
from .types.pipeline_update_transform_config import PipelineUpdateTransformConfig
from .types.pipelines_list_documents_paginated_request_status_refresh_policy import (
    PipelinesListDocumentsPaginatedRequestStatusRefreshPolicy,
)
from .types.pipelines_list_documents_request_status_refresh_policy import (
    PipelinesListDocumentsRequestStatusRefreshPolicy,
)
from .types.retrieval_params_search_filters_inference_schema_value import (
    RetrievalParamsSearchFiltersInferenceSchemaValue,
)

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawPipelinesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def search(
        self,
        *,
        project_id: typing.Optional[str] = None,
        project_name: typing.Optional[str] = None,
        pipeline_name: typing.Optional[str] = None,
        pipeline_type: typing.Optional[PipelineType] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Pipeline]]:
        """
        Search for pipelines by various parameters.

        Parameters
        ----------
        project_id : typing.Optional[str]

        project_name : typing.Optional[str]

        pipeline_name : typing.Optional[str]

        pipeline_type : typing.Optional[PipelineType]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Pipeline]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/pipelines",
            method="GET",
            params={
                "project_id": project_id,
                "project_name": project_name,
                "pipeline_name": pipeline_name,
                "pipeline_type": pipeline_type,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Pipeline],
                    construct_type(
                        type_=typing.List[Pipeline],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        *,
        name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        embedding_config: typing.Optional[PipelineCreateEmbeddingConfig] = OMIT,
        transform_config: typing.Optional[PipelineCreateTransformConfig] = OMIT,
        sparse_model_config: typing.Optional[SparseModelConfig] = OMIT,
        data_sink_id: typing.Optional[str] = OMIT,
        embedding_model_config_id: typing.Optional[str] = OMIT,
        data_sink: typing.Optional[DataSinkCreate] = OMIT,
        preset_retrieval_parameters: typing.Optional[PresetRetrievalParams] = OMIT,
        llama_parse_parameters: typing.Optional[LlamaParseParameters] = OMIT,
        status: typing.Optional[str] = OMIT,
        metadata_config: typing.Optional[PipelineMetadataConfig] = OMIT,
        pipeline_type: typing.Optional[PipelineType] = OMIT,
        managed_pipeline_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Pipeline]:
        """
        Create a new pipeline for a project.

        Parameters
        ----------
        name : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        embedding_config : typing.Optional[PipelineCreateEmbeddingConfig]

        transform_config : typing.Optional[PipelineCreateTransformConfig]
            Configuration for the transformation.

        sparse_model_config : typing.Optional[SparseModelConfig]
            Configuration for the sparse model used in hybrid search.

        data_sink_id : typing.Optional[str]
            Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.

        embedding_model_config_id : typing.Optional[str]
            Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.

        data_sink : typing.Optional[DataSinkCreate]
            Data sink. When provided instead of data_sink_id, the data sink will be created.

        preset_retrieval_parameters : typing.Optional[PresetRetrievalParams]
            Preset retrieval parameters for the pipeline.

        llama_parse_parameters : typing.Optional[LlamaParseParameters]

        status : typing.Optional[str]
            Status of the pipeline deployment.

        metadata_config : typing.Optional[PipelineMetadataConfig]
            Metadata configuration for the pipeline.

        pipeline_type : typing.Optional[PipelineType]
            Type of pipeline. Either PLAYGROUND or MANAGED.

        managed_pipeline_id : typing.Optional[str]
            The ID of the ManagedPipeline this playground pipeline is linked to.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Pipeline]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/pipelines",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "embedding_config": convert_and_respect_annotation_metadata(
                    object_=embedding_config, annotation=PipelineCreateEmbeddingConfig, direction="write"
                ),
                "transform_config": convert_and_respect_annotation_metadata(
                    object_=transform_config, annotation=PipelineCreateTransformConfig, direction="write"
                ),
                "sparse_model_config": convert_and_respect_annotation_metadata(
                    object_=sparse_model_config, annotation=SparseModelConfig, direction="write"
                ),
                "data_sink_id": data_sink_id,
                "embedding_model_config_id": embedding_model_config_id,
                "data_sink": convert_and_respect_annotation_metadata(
                    object_=data_sink, annotation=DataSinkCreate, direction="write"
                ),
                "preset_retrieval_parameters": convert_and_respect_annotation_metadata(
                    object_=preset_retrieval_parameters, annotation=PresetRetrievalParams, direction="write"
                ),
                "llama_parse_parameters": convert_and_respect_annotation_metadata(
                    object_=llama_parse_parameters, annotation=LlamaParseParameters, direction="write"
                ),
                "status": status,
                "metadata_config": convert_and_respect_annotation_metadata(
                    object_=metadata_config, annotation=PipelineMetadataConfig, direction="write"
                ),
                "name": name,
                "pipeline_type": pipeline_type,
                "managed_pipeline_id": managed_pipeline_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upsert(
        self,
        *,
        name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        embedding_config: typing.Optional[PipelineCreateEmbeddingConfig] = OMIT,
        transform_config: typing.Optional[PipelineCreateTransformConfig] = OMIT,
        sparse_model_config: typing.Optional[SparseModelConfig] = OMIT,
        data_sink_id: typing.Optional[str] = OMIT,
        embedding_model_config_id: typing.Optional[str] = OMIT,
        data_sink: typing.Optional[DataSinkCreate] = OMIT,
        preset_retrieval_parameters: typing.Optional[PresetRetrievalParams] = OMIT,
        llama_parse_parameters: typing.Optional[LlamaParseParameters] = OMIT,
        status: typing.Optional[str] = OMIT,
        metadata_config: typing.Optional[PipelineMetadataConfig] = OMIT,
        pipeline_type: typing.Optional[PipelineType] = OMIT,
        managed_pipeline_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Pipeline]:
        """
        Upsert a pipeline for a project.
        Updates if a pipeline with the same name and project_id already exists. Otherwise, creates a new pipeline.

        Parameters
        ----------
        name : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        embedding_config : typing.Optional[PipelineCreateEmbeddingConfig]

        transform_config : typing.Optional[PipelineCreateTransformConfig]
            Configuration for the transformation.

        sparse_model_config : typing.Optional[SparseModelConfig]
            Configuration for the sparse model used in hybrid search.

        data_sink_id : typing.Optional[str]
            Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.

        embedding_model_config_id : typing.Optional[str]
            Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.

        data_sink : typing.Optional[DataSinkCreate]
            Data sink. When provided instead of data_sink_id, the data sink will be created.

        preset_retrieval_parameters : typing.Optional[PresetRetrievalParams]
            Preset retrieval parameters for the pipeline.

        llama_parse_parameters : typing.Optional[LlamaParseParameters]

        status : typing.Optional[str]
            Status of the pipeline deployment.

        metadata_config : typing.Optional[PipelineMetadataConfig]
            Metadata configuration for the pipeline.

        pipeline_type : typing.Optional[PipelineType]
            Type of pipeline. Either PLAYGROUND or MANAGED.

        managed_pipeline_id : typing.Optional[str]
            The ID of the ManagedPipeline this playground pipeline is linked to.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Pipeline]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/pipelines",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "embedding_config": convert_and_respect_annotation_metadata(
                    object_=embedding_config, annotation=PipelineCreateEmbeddingConfig, direction="write"
                ),
                "transform_config": convert_and_respect_annotation_metadata(
                    object_=transform_config, annotation=PipelineCreateTransformConfig, direction="write"
                ),
                "sparse_model_config": convert_and_respect_annotation_metadata(
                    object_=sparse_model_config, annotation=SparseModelConfig, direction="write"
                ),
                "data_sink_id": data_sink_id,
                "embedding_model_config_id": embedding_model_config_id,
                "data_sink": convert_and_respect_annotation_metadata(
                    object_=data_sink, annotation=DataSinkCreate, direction="write"
                ),
                "preset_retrieval_parameters": convert_and_respect_annotation_metadata(
                    object_=preset_retrieval_parameters, annotation=PresetRetrievalParams, direction="write"
                ),
                "llama_parse_parameters": convert_and_respect_annotation_metadata(
                    object_=llama_parse_parameters, annotation=LlamaParseParameters, direction="write"
                ),
                "status": status,
                "metadata_config": convert_and_respect_annotation_metadata(
                    object_=metadata_config, annotation=PipelineMetadataConfig, direction="write"
                ),
                "name": name,
                "pipeline_type": pipeline_type,
                "managed_pipeline_id": managed_pipeline_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Pipeline]:
        """
        Get a pipeline by ID for a given project.

        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Pipeline]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update(
        self,
        pipeline_id: str,
        *,
        embedding_config: typing.Optional[PipelineUpdateEmbeddingConfig] = OMIT,
        transform_config: typing.Optional[PipelineUpdateTransformConfig] = OMIT,
        sparse_model_config: typing.Optional[SparseModelConfig] = OMIT,
        data_sink_id: typing.Optional[str] = OMIT,
        embedding_model_config_id: typing.Optional[str] = OMIT,
        data_sink: typing.Optional[DataSinkCreate] = OMIT,
        preset_retrieval_parameters: typing.Optional[PresetRetrievalParams] = OMIT,
        llama_parse_parameters: typing.Optional[LlamaParseParameters] = OMIT,
        status: typing.Optional[str] = OMIT,
        metadata_config: typing.Optional[PipelineMetadataConfig] = OMIT,
        name: typing.Optional[str] = OMIT,
        managed_pipeline_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Pipeline]:
        """
        Update an existing pipeline for a project.

        Parameters
        ----------
        pipeline_id : str

        embedding_config : typing.Optional[PipelineUpdateEmbeddingConfig]

        transform_config : typing.Optional[PipelineUpdateTransformConfig]
            Configuration for the transformation.

        sparse_model_config : typing.Optional[SparseModelConfig]
            Configuration for the sparse model used in hybrid search.

        data_sink_id : typing.Optional[str]
            Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.

        embedding_model_config_id : typing.Optional[str]
            Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.

        data_sink : typing.Optional[DataSinkCreate]
            Data sink. When provided instead of data_sink_id, the data sink will be created.

        preset_retrieval_parameters : typing.Optional[PresetRetrievalParams]
            Preset retrieval parameters for the pipeline.

        llama_parse_parameters : typing.Optional[LlamaParseParameters]
            Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.

        status : typing.Optional[str]
            Status of the pipeline deployment.

        metadata_config : typing.Optional[PipelineMetadataConfig]
            Metadata configuration for the pipeline.

        name : typing.Optional[str]

        managed_pipeline_id : typing.Optional[str]
            The ID of the ManagedPipeline this playground pipeline is linked to.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Pipeline]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}",
            method="PUT",
            json={
                "embedding_config": convert_and_respect_annotation_metadata(
                    object_=embedding_config, annotation=PipelineUpdateEmbeddingConfig, direction="write"
                ),
                "transform_config": convert_and_respect_annotation_metadata(
                    object_=transform_config, annotation=PipelineUpdateTransformConfig, direction="write"
                ),
                "sparse_model_config": convert_and_respect_annotation_metadata(
                    object_=sparse_model_config, annotation=SparseModelConfig, direction="write"
                ),
                "data_sink_id": data_sink_id,
                "embedding_model_config_id": embedding_model_config_id,
                "data_sink": convert_and_respect_annotation_metadata(
                    object_=data_sink, annotation=DataSinkCreate, direction="write"
                ),
                "preset_retrieval_parameters": convert_and_respect_annotation_metadata(
                    object_=preset_retrieval_parameters, annotation=PresetRetrievalParams, direction="write"
                ),
                "llama_parse_parameters": convert_and_respect_annotation_metadata(
                    object_=llama_parse_parameters, annotation=LlamaParseParameters, direction="write"
                ),
                "status": status,
                "metadata_config": convert_and_respect_annotation_metadata(
                    object_=metadata_config, annotation=PipelineMetadataConfig, direction="write"
                ),
                "name": name,
                "managed_pipeline_id": managed_pipeline_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Delete a pipeline by ID.

        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_status(
        self,
        pipeline_id: str,
        *,
        full_details: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ManagedIngestionStatusResponse]:
        """
        Get the status of a pipeline by ID.

        Parameters
        ----------
        pipeline_id : str

        full_details : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ManagedIngestionStatusResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/status",
            method="GET",
            params={
                "full_details": full_details,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ManagedIngestionStatusResponse,
                    construct_type(
                        type_=ManagedIngestionStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def sync(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Pipeline]:
        """
        Run ingestion for the pipeline by incrementally updating the data-sink with upstream changes from data-sources & files.

        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Pipeline]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/sync",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def cancel_sync(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Pipeline]:
        """
        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Pipeline]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/sync/cancel",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def force_delete(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/force-delete",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def copy(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Pipeline]:
        """
        Copy a pipeline by ID.

        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Pipeline]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/copy",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve(
        self,
        pipeline_id: str,
        *,
        query: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        dense_similarity_top_k: typing.Optional[int] = OMIT,
        dense_similarity_cutoff: typing.Optional[float] = OMIT,
        sparse_similarity_top_k: typing.Optional[int] = OMIT,
        enable_reranking: typing.Optional[bool] = OMIT,
        rerank_top_n: typing.Optional[int] = OMIT,
        alpha: typing.Optional[float] = OMIT,
        search_filters: typing.Optional[MetadataFilters] = OMIT,
        search_filters_inference_schema: typing.Optional[
            typing.Dict[str, typing.Optional[RetrievalParamsSearchFiltersInferenceSchemaValue]]
        ] = OMIT,
        files_top_k: typing.Optional[int] = OMIT,
        retrieval_mode: typing.Optional[RetrievalMode] = OMIT,
        retrieve_image_nodes: typing.Optional[bool] = OMIT,
        retrieve_page_screenshot_nodes: typing.Optional[bool] = OMIT,
        retrieve_page_figure_nodes: typing.Optional[bool] = OMIT,
        class_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[RetrieveResults]:
        """
        Get retrieval results for a managed pipeline and a query

        Parameters
        ----------
        pipeline_id : str

        query : str
            The query to retrieve against.

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        dense_similarity_top_k : typing.Optional[int]
            Number of nodes for dense retrieval.

        dense_similarity_cutoff : typing.Optional[float]
            Minimum similarity score wrt query for retrieval

        sparse_similarity_top_k : typing.Optional[int]
            Number of nodes for sparse retrieval.

        enable_reranking : typing.Optional[bool]
            Enable reranking for retrieval

        rerank_top_n : typing.Optional[int]
            Number of reranked nodes for returning.

        alpha : typing.Optional[float]
            Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.

        search_filters : typing.Optional[MetadataFilters]
            Search filters for retrieval.

        search_filters_inference_schema : typing.Optional[typing.Dict[str, typing.Optional[RetrievalParamsSearchFiltersInferenceSchemaValue]]]
            JSON Schema that will be used to infer search_filters. Omit or leave as null to skip inference.

        files_top_k : typing.Optional[int]
            Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).

        retrieval_mode : typing.Optional[RetrievalMode]
            The retrieval mode for the query.

        retrieve_image_nodes : typing.Optional[bool]
            Whether to retrieve image nodes.

        retrieve_page_screenshot_nodes : typing.Optional[bool]
            Whether to retrieve page screenshot nodes.

        retrieve_page_figure_nodes : typing.Optional[bool]
            Whether to retrieve page figure nodes.

        class_name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RetrieveResults]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/retrieve",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "dense_similarity_top_k": dense_similarity_top_k,
                "dense_similarity_cutoff": dense_similarity_cutoff,
                "sparse_similarity_top_k": sparse_similarity_top_k,
                "enable_reranking": enable_reranking,
                "rerank_top_n": rerank_top_n,
                "alpha": alpha,
                "search_filters": convert_and_respect_annotation_metadata(
                    object_=search_filters, annotation=MetadataFilters, direction="write"
                ),
                "search_filters_inference_schema": convert_and_respect_annotation_metadata(
                    object_=search_filters_inference_schema,
                    annotation=typing.Dict[str, typing.Optional[RetrievalParamsSearchFiltersInferenceSchemaValue]],
                    direction="write",
                ),
                "files_top_k": files_top_k,
                "retrieval_mode": retrieval_mode,
                "retrieve_image_nodes": retrieve_image_nodes,
                "retrieve_page_screenshot_nodes": retrieve_page_screenshot_nodes,
                "retrieve_page_figure_nodes": retrieve_page_figure_nodes,
                "query": query,
                "class_name": class_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RetrieveResults,
                    construct_type(
                        type_=RetrieveResults,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_playground_session(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[PlaygroundSession]:
        """
        Get a playground session for a user and pipeline.

        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PlaygroundSession]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/playground-session",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PlaygroundSession,
                    construct_type(
                        type_=PlaygroundSession,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    @contextlib.contextmanager
    def chat_stream(
        self,
        pipeline_id: str,
        *,
        messages: typing.Optional[typing.Sequence[InputMessage]] = OMIT,
        data: typing.Optional[ChatData] = OMIT,
        class_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[HttpResponse[typing.Iterator[ChatMessageChunk]]]:
        """
        Make a retrieval query + chat completion for a managed pipeline.

        Parameters
        ----------
        pipeline_id : str

        messages : typing.Optional[typing.Sequence[InputMessage]]

        data : typing.Optional[ChatData]

        class_name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.Iterator[HttpResponse[typing.Iterator[ChatMessageChunk]]]

        """
        with self._client_wrapper.httpx_client.stream(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/chat",
            method="POST",
            json={
                "messages": convert_and_respect_annotation_metadata(
                    object_=messages, annotation=typing.Sequence[InputMessage], direction="write"
                ),
                "data": convert_and_respect_annotation_metadata(object_=data, annotation=ChatData, direction="write"),
                "class_name": class_name,
                "stream": True,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:

            def _stream() -> HttpResponse[typing.Iterator[ChatMessageChunk]]:
                try:
                    if 200 <= _response.status_code < 300:

                        def _iter():
                            _event_source = EventSource(_response)
                            for _sse in _event_source.iter_sse():
                                if _sse.data == None:
                                    return
                                try:
                                    yield typing.cast(
                                        ChatMessageChunk,
                                        construct_type(
                                            type_=ChatMessageChunk,  # type: ignore
                                            object_=_sse.json(),
                                        ),
                                    )
                                except JSONDecodeError as e:
                                    warning(f"Skipping SSE event with invalid JSON: {e}, sse: {_sse!r}")
                                except (TypeError, ValueError, KeyError, AttributeError) as e:
                                    warning(
                                        f"Skipping SSE event due to model construction error: {type(e).__name__}: {e}, sse: {_sse!r}"
                                    )
                                except Exception as e:
                                    error(
                                        f"Unexpected error processing SSE event: {type(e).__name__}: {e}, sse: {_sse!r}"
                                    )
                            return

                        return HttpResponse(response=_response, data=_iter())
                    _response.read()
                    if _response.status_code == 422:
                        raise UnprocessableEntityError(
                            headers=dict(_response.headers),
                            body=typing.cast(
                                HttpValidationError,
                                construct_type(
                                    type_=HttpValidationError,  # type: ignore
                                    object_=_response.json(),
                                ),
                            ),
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        status_code=_response.status_code, headers=dict(_response.headers), body=_response.text
                    )
                raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

            yield _stream()

    def chat(
        self,
        pipeline_id: str,
        *,
        messages: typing.Optional[typing.Sequence[InputMessage]] = OMIT,
        data: typing.Optional[ChatData] = OMIT,
        class_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ChatMessage]:
        """
        Make a retrieval query + chat completion for a managed pipeline.

        Parameters
        ----------
        pipeline_id : str

        messages : typing.Optional[typing.Sequence[InputMessage]]

        data : typing.Optional[ChatData]

        class_name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ChatMessage]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/chat",
            method="POST",
            json={
                "messages": convert_and_respect_annotation_metadata(
                    object_=messages, annotation=typing.Sequence[InputMessage], direction="write"
                ),
                "data": convert_and_respect_annotation_metadata(object_=data, annotation=ChatData, direction="write"),
                "class_name": class_name,
                "stream": False,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ChatMessage,
                    construct_type(
                        type_=ChatMessage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_documents(
        self,
        pipeline_id: str,
        *,
        skip: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        file_id: typing.Optional[str] = None,
        only_direct_upload: typing.Optional[bool] = None,
        only_api_data_source_documents: typing.Optional[bool] = None,
        status_refresh_policy: typing.Optional[PipelinesListDocumentsRequestStatusRefreshPolicy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[CloudDocument]]:
        """
        Return a list of documents for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        skip : typing.Optional[int]

        limit : typing.Optional[int]

        file_id : typing.Optional[str]

        only_direct_upload : typing.Optional[bool]

        only_api_data_source_documents : typing.Optional[bool]

        status_refresh_policy : typing.Optional[PipelinesListDocumentsRequestStatusRefreshPolicy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[CloudDocument]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents",
            method="GET",
            params={
                "skip": skip,
                "limit": limit,
                "file_id": file_id,
                "only_direct_upload": only_direct_upload,
                "only_api_data_source_documents": only_api_data_source_documents,
                "status_refresh_policy": status_refresh_policy,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[CloudDocument],
                    construct_type(
                        type_=typing.List[CloudDocument],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_batch_documents(
        self,
        pipeline_id: str,
        *,
        request: typing.Sequence[CloudDocumentCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[CloudDocument]]:
        """
        Batch create documents for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        request : typing.Sequence[CloudDocumentCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[CloudDocument]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[CloudDocumentCreate], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[CloudDocument],
                    construct_type(
                        type_=typing.List[CloudDocument],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upsert_batch_documents(
        self,
        pipeline_id: str,
        *,
        request: typing.Sequence[CloudDocumentCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[CloudDocument]]:
        """
        Batch create or update a document for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        request : typing.Sequence[CloudDocumentCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[CloudDocument]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents",
            method="PUT",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[CloudDocumentCreate], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[CloudDocument],
                    construct_type(
                        type_=typing.List[CloudDocument],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_documents_paginated(
        self,
        pipeline_id: str,
        *,
        skip: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        file_id: typing.Optional[str] = None,
        only_direct_upload: typing.Optional[bool] = None,
        only_api_data_source_documents: typing.Optional[bool] = None,
        status_refresh_policy: typing.Optional[PipelinesListDocumentsPaginatedRequestStatusRefreshPolicy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PaginatedListCloudDocumentsResponse]:
        """
        Return a list of documents for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        skip : typing.Optional[int]

        limit : typing.Optional[int]

        file_id : typing.Optional[str]

        only_direct_upload : typing.Optional[bool]

        only_api_data_source_documents : typing.Optional[bool]

        status_refresh_policy : typing.Optional[PipelinesListDocumentsPaginatedRequestStatusRefreshPolicy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PaginatedListCloudDocumentsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/paginated",
            method="GET",
            params={
                "skip": skip,
                "limit": limit,
                "file_id": file_id,
                "only_direct_upload": only_direct_upload,
                "only_api_data_source_documents": only_api_data_source_documents,
                "status_refresh_policy": status_refresh_policy,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedListCloudDocumentsResponse,
                    construct_type(
                        type_=PaginatedListCloudDocumentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_document(
        self, pipeline_id: str, document_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CloudDocument]:
        """
        Return a single document for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        document_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CloudDocument]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/{jsonable_encoder(document_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CloudDocument,
                    construct_type(
                        type_=CloudDocument,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_document(
        self, pipeline_id: str, document_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Delete a document from a pipeline.
        Initiates an async job that will:
        1. Delete vectors from the vector store
        2. Delete the document from MongoDB after vectors are successfully deleted

        Parameters
        ----------
        pipeline_id : str

        document_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/{jsonable_encoder(document_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_document_status(
        self, pipeline_id: str, document_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ManagedIngestionStatusResponse]:
        """
        Return a single document for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        document_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ManagedIngestionStatusResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/{jsonable_encoder(document_id)}/status",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ManagedIngestionStatusResponse,
                    construct_type(
                        type_=ManagedIngestionStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def sync_document(
        self, pipeline_id: str, document_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Sync a specific document for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        document_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/{jsonable_encoder(document_id)}/sync",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_document_chunks(
        self, pipeline_id: str, document_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[TextNode]]:
        """
        Return a list of chunks for a pipeline document.

        Parameters
        ----------
        pipeline_id : str

        document_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[TextNode]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/{jsonable_encoder(document_id)}/chunks",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TextNode],
                    construct_type(
                        type_=typing.List[TextNode],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def force_sync_all_documents(
        self,
        pipeline_id: str,
        *,
        batch_size: typing.Optional[int] = None,
        only_failed: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Force sync all documents in a pipeline by batching document ingestion jobs.

        - Iterates all document refs for the pipeline
        - Enqueues document ingestion jobs in batches of `batch_size`

        Parameters
        ----------
        pipeline_id : str

        batch_size : typing.Optional[int]

        only_failed : typing.Optional[bool]
            Only sync retriable documents (failed/cancelled/not-started/stalled-in-progress)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/force-sync-all",
            method="POST",
            params={
                "batch_size": batch_size,
                "only_failed": only_failed,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawPipelinesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def search(
        self,
        *,
        project_id: typing.Optional[str] = None,
        project_name: typing.Optional[str] = None,
        pipeline_name: typing.Optional[str] = None,
        pipeline_type: typing.Optional[PipelineType] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Pipeline]]:
        """
        Search for pipelines by various parameters.

        Parameters
        ----------
        project_id : typing.Optional[str]

        project_name : typing.Optional[str]

        pipeline_name : typing.Optional[str]

        pipeline_type : typing.Optional[PipelineType]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Pipeline]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/pipelines",
            method="GET",
            params={
                "project_id": project_id,
                "project_name": project_name,
                "pipeline_name": pipeline_name,
                "pipeline_type": pipeline_type,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Pipeline],
                    construct_type(
                        type_=typing.List[Pipeline],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        *,
        name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        embedding_config: typing.Optional[PipelineCreateEmbeddingConfig] = OMIT,
        transform_config: typing.Optional[PipelineCreateTransformConfig] = OMIT,
        sparse_model_config: typing.Optional[SparseModelConfig] = OMIT,
        data_sink_id: typing.Optional[str] = OMIT,
        embedding_model_config_id: typing.Optional[str] = OMIT,
        data_sink: typing.Optional[DataSinkCreate] = OMIT,
        preset_retrieval_parameters: typing.Optional[PresetRetrievalParams] = OMIT,
        llama_parse_parameters: typing.Optional[LlamaParseParameters] = OMIT,
        status: typing.Optional[str] = OMIT,
        metadata_config: typing.Optional[PipelineMetadataConfig] = OMIT,
        pipeline_type: typing.Optional[PipelineType] = OMIT,
        managed_pipeline_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Pipeline]:
        """
        Create a new pipeline for a project.

        Parameters
        ----------
        name : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        embedding_config : typing.Optional[PipelineCreateEmbeddingConfig]

        transform_config : typing.Optional[PipelineCreateTransformConfig]
            Configuration for the transformation.

        sparse_model_config : typing.Optional[SparseModelConfig]
            Configuration for the sparse model used in hybrid search.

        data_sink_id : typing.Optional[str]
            Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.

        embedding_model_config_id : typing.Optional[str]
            Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.

        data_sink : typing.Optional[DataSinkCreate]
            Data sink. When provided instead of data_sink_id, the data sink will be created.

        preset_retrieval_parameters : typing.Optional[PresetRetrievalParams]
            Preset retrieval parameters for the pipeline.

        llama_parse_parameters : typing.Optional[LlamaParseParameters]

        status : typing.Optional[str]
            Status of the pipeline deployment.

        metadata_config : typing.Optional[PipelineMetadataConfig]
            Metadata configuration for the pipeline.

        pipeline_type : typing.Optional[PipelineType]
            Type of pipeline. Either PLAYGROUND or MANAGED.

        managed_pipeline_id : typing.Optional[str]
            The ID of the ManagedPipeline this playground pipeline is linked to.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Pipeline]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/pipelines",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "embedding_config": convert_and_respect_annotation_metadata(
                    object_=embedding_config, annotation=PipelineCreateEmbeddingConfig, direction="write"
                ),
                "transform_config": convert_and_respect_annotation_metadata(
                    object_=transform_config, annotation=PipelineCreateTransformConfig, direction="write"
                ),
                "sparse_model_config": convert_and_respect_annotation_metadata(
                    object_=sparse_model_config, annotation=SparseModelConfig, direction="write"
                ),
                "data_sink_id": data_sink_id,
                "embedding_model_config_id": embedding_model_config_id,
                "data_sink": convert_and_respect_annotation_metadata(
                    object_=data_sink, annotation=DataSinkCreate, direction="write"
                ),
                "preset_retrieval_parameters": convert_and_respect_annotation_metadata(
                    object_=preset_retrieval_parameters, annotation=PresetRetrievalParams, direction="write"
                ),
                "llama_parse_parameters": convert_and_respect_annotation_metadata(
                    object_=llama_parse_parameters, annotation=LlamaParseParameters, direction="write"
                ),
                "status": status,
                "metadata_config": convert_and_respect_annotation_metadata(
                    object_=metadata_config, annotation=PipelineMetadataConfig, direction="write"
                ),
                "name": name,
                "pipeline_type": pipeline_type,
                "managed_pipeline_id": managed_pipeline_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upsert(
        self,
        *,
        name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        embedding_config: typing.Optional[PipelineCreateEmbeddingConfig] = OMIT,
        transform_config: typing.Optional[PipelineCreateTransformConfig] = OMIT,
        sparse_model_config: typing.Optional[SparseModelConfig] = OMIT,
        data_sink_id: typing.Optional[str] = OMIT,
        embedding_model_config_id: typing.Optional[str] = OMIT,
        data_sink: typing.Optional[DataSinkCreate] = OMIT,
        preset_retrieval_parameters: typing.Optional[PresetRetrievalParams] = OMIT,
        llama_parse_parameters: typing.Optional[LlamaParseParameters] = OMIT,
        status: typing.Optional[str] = OMIT,
        metadata_config: typing.Optional[PipelineMetadataConfig] = OMIT,
        pipeline_type: typing.Optional[PipelineType] = OMIT,
        managed_pipeline_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Pipeline]:
        """
        Upsert a pipeline for a project.
        Updates if a pipeline with the same name and project_id already exists. Otherwise, creates a new pipeline.

        Parameters
        ----------
        name : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        embedding_config : typing.Optional[PipelineCreateEmbeddingConfig]

        transform_config : typing.Optional[PipelineCreateTransformConfig]
            Configuration for the transformation.

        sparse_model_config : typing.Optional[SparseModelConfig]
            Configuration for the sparse model used in hybrid search.

        data_sink_id : typing.Optional[str]
            Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.

        embedding_model_config_id : typing.Optional[str]
            Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.

        data_sink : typing.Optional[DataSinkCreate]
            Data sink. When provided instead of data_sink_id, the data sink will be created.

        preset_retrieval_parameters : typing.Optional[PresetRetrievalParams]
            Preset retrieval parameters for the pipeline.

        llama_parse_parameters : typing.Optional[LlamaParseParameters]

        status : typing.Optional[str]
            Status of the pipeline deployment.

        metadata_config : typing.Optional[PipelineMetadataConfig]
            Metadata configuration for the pipeline.

        pipeline_type : typing.Optional[PipelineType]
            Type of pipeline. Either PLAYGROUND or MANAGED.

        managed_pipeline_id : typing.Optional[str]
            The ID of the ManagedPipeline this playground pipeline is linked to.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Pipeline]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/pipelines",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "embedding_config": convert_and_respect_annotation_metadata(
                    object_=embedding_config, annotation=PipelineCreateEmbeddingConfig, direction="write"
                ),
                "transform_config": convert_and_respect_annotation_metadata(
                    object_=transform_config, annotation=PipelineCreateTransformConfig, direction="write"
                ),
                "sparse_model_config": convert_and_respect_annotation_metadata(
                    object_=sparse_model_config, annotation=SparseModelConfig, direction="write"
                ),
                "data_sink_id": data_sink_id,
                "embedding_model_config_id": embedding_model_config_id,
                "data_sink": convert_and_respect_annotation_metadata(
                    object_=data_sink, annotation=DataSinkCreate, direction="write"
                ),
                "preset_retrieval_parameters": convert_and_respect_annotation_metadata(
                    object_=preset_retrieval_parameters, annotation=PresetRetrievalParams, direction="write"
                ),
                "llama_parse_parameters": convert_and_respect_annotation_metadata(
                    object_=llama_parse_parameters, annotation=LlamaParseParameters, direction="write"
                ),
                "status": status,
                "metadata_config": convert_and_respect_annotation_metadata(
                    object_=metadata_config, annotation=PipelineMetadataConfig, direction="write"
                ),
                "name": name,
                "pipeline_type": pipeline_type,
                "managed_pipeline_id": managed_pipeline_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Pipeline]:
        """
        Get a pipeline by ID for a given project.

        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Pipeline]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update(
        self,
        pipeline_id: str,
        *,
        embedding_config: typing.Optional[PipelineUpdateEmbeddingConfig] = OMIT,
        transform_config: typing.Optional[PipelineUpdateTransformConfig] = OMIT,
        sparse_model_config: typing.Optional[SparseModelConfig] = OMIT,
        data_sink_id: typing.Optional[str] = OMIT,
        embedding_model_config_id: typing.Optional[str] = OMIT,
        data_sink: typing.Optional[DataSinkCreate] = OMIT,
        preset_retrieval_parameters: typing.Optional[PresetRetrievalParams] = OMIT,
        llama_parse_parameters: typing.Optional[LlamaParseParameters] = OMIT,
        status: typing.Optional[str] = OMIT,
        metadata_config: typing.Optional[PipelineMetadataConfig] = OMIT,
        name: typing.Optional[str] = OMIT,
        managed_pipeline_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Pipeline]:
        """
        Update an existing pipeline for a project.

        Parameters
        ----------
        pipeline_id : str

        embedding_config : typing.Optional[PipelineUpdateEmbeddingConfig]

        transform_config : typing.Optional[PipelineUpdateTransformConfig]
            Configuration for the transformation.

        sparse_model_config : typing.Optional[SparseModelConfig]
            Configuration for the sparse model used in hybrid search.

        data_sink_id : typing.Optional[str]
            Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.

        embedding_model_config_id : typing.Optional[str]
            Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.

        data_sink : typing.Optional[DataSinkCreate]
            Data sink. When provided instead of data_sink_id, the data sink will be created.

        preset_retrieval_parameters : typing.Optional[PresetRetrievalParams]
            Preset retrieval parameters for the pipeline.

        llama_parse_parameters : typing.Optional[LlamaParseParameters]
            Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.

        status : typing.Optional[str]
            Status of the pipeline deployment.

        metadata_config : typing.Optional[PipelineMetadataConfig]
            Metadata configuration for the pipeline.

        name : typing.Optional[str]

        managed_pipeline_id : typing.Optional[str]
            The ID of the ManagedPipeline this playground pipeline is linked to.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Pipeline]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}",
            method="PUT",
            json={
                "embedding_config": convert_and_respect_annotation_metadata(
                    object_=embedding_config, annotation=PipelineUpdateEmbeddingConfig, direction="write"
                ),
                "transform_config": convert_and_respect_annotation_metadata(
                    object_=transform_config, annotation=PipelineUpdateTransformConfig, direction="write"
                ),
                "sparse_model_config": convert_and_respect_annotation_metadata(
                    object_=sparse_model_config, annotation=SparseModelConfig, direction="write"
                ),
                "data_sink_id": data_sink_id,
                "embedding_model_config_id": embedding_model_config_id,
                "data_sink": convert_and_respect_annotation_metadata(
                    object_=data_sink, annotation=DataSinkCreate, direction="write"
                ),
                "preset_retrieval_parameters": convert_and_respect_annotation_metadata(
                    object_=preset_retrieval_parameters, annotation=PresetRetrievalParams, direction="write"
                ),
                "llama_parse_parameters": convert_and_respect_annotation_metadata(
                    object_=llama_parse_parameters, annotation=LlamaParseParameters, direction="write"
                ),
                "status": status,
                "metadata_config": convert_and_respect_annotation_metadata(
                    object_=metadata_config, annotation=PipelineMetadataConfig, direction="write"
                ),
                "name": name,
                "managed_pipeline_id": managed_pipeline_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete a pipeline by ID.

        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_status(
        self,
        pipeline_id: str,
        *,
        full_details: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ManagedIngestionStatusResponse]:
        """
        Get the status of a pipeline by ID.

        Parameters
        ----------
        pipeline_id : str

        full_details : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ManagedIngestionStatusResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/status",
            method="GET",
            params={
                "full_details": full_details,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ManagedIngestionStatusResponse,
                    construct_type(
                        type_=ManagedIngestionStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def sync(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Pipeline]:
        """
        Run ingestion for the pipeline by incrementally updating the data-sink with upstream changes from data-sources & files.

        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Pipeline]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/sync",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def cancel_sync(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Pipeline]:
        """
        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Pipeline]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/sync/cancel",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def force_delete(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/force-delete",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def copy(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Pipeline]:
        """
        Copy a pipeline by ID.

        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Pipeline]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/copy",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Pipeline,
                    construct_type(
                        type_=Pipeline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve(
        self,
        pipeline_id: str,
        *,
        query: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        dense_similarity_top_k: typing.Optional[int] = OMIT,
        dense_similarity_cutoff: typing.Optional[float] = OMIT,
        sparse_similarity_top_k: typing.Optional[int] = OMIT,
        enable_reranking: typing.Optional[bool] = OMIT,
        rerank_top_n: typing.Optional[int] = OMIT,
        alpha: typing.Optional[float] = OMIT,
        search_filters: typing.Optional[MetadataFilters] = OMIT,
        search_filters_inference_schema: typing.Optional[
            typing.Dict[str, typing.Optional[RetrievalParamsSearchFiltersInferenceSchemaValue]]
        ] = OMIT,
        files_top_k: typing.Optional[int] = OMIT,
        retrieval_mode: typing.Optional[RetrievalMode] = OMIT,
        retrieve_image_nodes: typing.Optional[bool] = OMIT,
        retrieve_page_screenshot_nodes: typing.Optional[bool] = OMIT,
        retrieve_page_figure_nodes: typing.Optional[bool] = OMIT,
        class_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[RetrieveResults]:
        """
        Get retrieval results for a managed pipeline and a query

        Parameters
        ----------
        pipeline_id : str

        query : str
            The query to retrieve against.

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        dense_similarity_top_k : typing.Optional[int]
            Number of nodes for dense retrieval.

        dense_similarity_cutoff : typing.Optional[float]
            Minimum similarity score wrt query for retrieval

        sparse_similarity_top_k : typing.Optional[int]
            Number of nodes for sparse retrieval.

        enable_reranking : typing.Optional[bool]
            Enable reranking for retrieval

        rerank_top_n : typing.Optional[int]
            Number of reranked nodes for returning.

        alpha : typing.Optional[float]
            Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.

        search_filters : typing.Optional[MetadataFilters]
            Search filters for retrieval.

        search_filters_inference_schema : typing.Optional[typing.Dict[str, typing.Optional[RetrievalParamsSearchFiltersInferenceSchemaValue]]]
            JSON Schema that will be used to infer search_filters. Omit or leave as null to skip inference.

        files_top_k : typing.Optional[int]
            Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).

        retrieval_mode : typing.Optional[RetrievalMode]
            The retrieval mode for the query.

        retrieve_image_nodes : typing.Optional[bool]
            Whether to retrieve image nodes.

        retrieve_page_screenshot_nodes : typing.Optional[bool]
            Whether to retrieve page screenshot nodes.

        retrieve_page_figure_nodes : typing.Optional[bool]
            Whether to retrieve page figure nodes.

        class_name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RetrieveResults]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/retrieve",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "dense_similarity_top_k": dense_similarity_top_k,
                "dense_similarity_cutoff": dense_similarity_cutoff,
                "sparse_similarity_top_k": sparse_similarity_top_k,
                "enable_reranking": enable_reranking,
                "rerank_top_n": rerank_top_n,
                "alpha": alpha,
                "search_filters": convert_and_respect_annotation_metadata(
                    object_=search_filters, annotation=MetadataFilters, direction="write"
                ),
                "search_filters_inference_schema": convert_and_respect_annotation_metadata(
                    object_=search_filters_inference_schema,
                    annotation=typing.Dict[str, typing.Optional[RetrievalParamsSearchFiltersInferenceSchemaValue]],
                    direction="write",
                ),
                "files_top_k": files_top_k,
                "retrieval_mode": retrieval_mode,
                "retrieve_image_nodes": retrieve_image_nodes,
                "retrieve_page_screenshot_nodes": retrieve_page_screenshot_nodes,
                "retrieve_page_figure_nodes": retrieve_page_figure_nodes,
                "query": query,
                "class_name": class_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RetrieveResults,
                    construct_type(
                        type_=RetrieveResults,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_playground_session(
        self, pipeline_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[PlaygroundSession]:
        """
        Get a playground session for a user and pipeline.

        Parameters
        ----------
        pipeline_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PlaygroundSession]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/playground-session",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PlaygroundSession,
                    construct_type(
                        type_=PlaygroundSession,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    @contextlib.asynccontextmanager
    async def chat_stream(
        self,
        pipeline_id: str,
        *,
        messages: typing.Optional[typing.Sequence[InputMessage]] = OMIT,
        data: typing.Optional[ChatData] = OMIT,
        class_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[ChatMessageChunk]]]:
        """
        Make a retrieval query + chat completion for a managed pipeline.

        Parameters
        ----------
        pipeline_id : str

        messages : typing.Optional[typing.Sequence[InputMessage]]

        data : typing.Optional[ChatData]

        class_name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[ChatMessageChunk]]]

        """
        async with self._client_wrapper.httpx_client.stream(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/chat",
            method="POST",
            json={
                "messages": convert_and_respect_annotation_metadata(
                    object_=messages, annotation=typing.Sequence[InputMessage], direction="write"
                ),
                "data": convert_and_respect_annotation_metadata(object_=data, annotation=ChatData, direction="write"),
                "class_name": class_name,
                "stream": True,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:

            async def _stream() -> AsyncHttpResponse[typing.AsyncIterator[ChatMessageChunk]]:
                try:
                    if 200 <= _response.status_code < 300:

                        async def _iter():
                            _event_source = EventSource(_response)
                            async for _sse in _event_source.aiter_sse():
                                if _sse.data == None:
                                    return
                                try:
                                    yield typing.cast(
                                        ChatMessageChunk,
                                        construct_type(
                                            type_=ChatMessageChunk,  # type: ignore
                                            object_=_sse.json(),
                                        ),
                                    )
                                except JSONDecodeError as e:
                                    warning(f"Skipping SSE event with invalid JSON: {e}, sse: {_sse!r}")
                                except (TypeError, ValueError, KeyError, AttributeError) as e:
                                    warning(
                                        f"Skipping SSE event due to model construction error: {type(e).__name__}: {e}, sse: {_sse!r}"
                                    )
                                except Exception as e:
                                    error(
                                        f"Unexpected error processing SSE event: {type(e).__name__}: {e}, sse: {_sse!r}"
                                    )
                            return

                        return AsyncHttpResponse(response=_response, data=_iter())
                    await _response.aread()
                    if _response.status_code == 422:
                        raise UnprocessableEntityError(
                            headers=dict(_response.headers),
                            body=typing.cast(
                                HttpValidationError,
                                construct_type(
                                    type_=HttpValidationError,  # type: ignore
                                    object_=_response.json(),
                                ),
                            ),
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        status_code=_response.status_code, headers=dict(_response.headers), body=_response.text
                    )
                raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

            yield await _stream()

    async def chat(
        self,
        pipeline_id: str,
        *,
        messages: typing.Optional[typing.Sequence[InputMessage]] = OMIT,
        data: typing.Optional[ChatData] = OMIT,
        class_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ChatMessage]:
        """
        Make a retrieval query + chat completion for a managed pipeline.

        Parameters
        ----------
        pipeline_id : str

        messages : typing.Optional[typing.Sequence[InputMessage]]

        data : typing.Optional[ChatData]

        class_name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ChatMessage]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/chat",
            method="POST",
            json={
                "messages": convert_and_respect_annotation_metadata(
                    object_=messages, annotation=typing.Sequence[InputMessage], direction="write"
                ),
                "data": convert_and_respect_annotation_metadata(object_=data, annotation=ChatData, direction="write"),
                "class_name": class_name,
                "stream": False,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ChatMessage,
                    construct_type(
                        type_=ChatMessage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_documents(
        self,
        pipeline_id: str,
        *,
        skip: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        file_id: typing.Optional[str] = None,
        only_direct_upload: typing.Optional[bool] = None,
        only_api_data_source_documents: typing.Optional[bool] = None,
        status_refresh_policy: typing.Optional[PipelinesListDocumentsRequestStatusRefreshPolicy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[CloudDocument]]:
        """
        Return a list of documents for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        skip : typing.Optional[int]

        limit : typing.Optional[int]

        file_id : typing.Optional[str]

        only_direct_upload : typing.Optional[bool]

        only_api_data_source_documents : typing.Optional[bool]

        status_refresh_policy : typing.Optional[PipelinesListDocumentsRequestStatusRefreshPolicy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[CloudDocument]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents",
            method="GET",
            params={
                "skip": skip,
                "limit": limit,
                "file_id": file_id,
                "only_direct_upload": only_direct_upload,
                "only_api_data_source_documents": only_api_data_source_documents,
                "status_refresh_policy": status_refresh_policy,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[CloudDocument],
                    construct_type(
                        type_=typing.List[CloudDocument],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_batch_documents(
        self,
        pipeline_id: str,
        *,
        request: typing.Sequence[CloudDocumentCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[CloudDocument]]:
        """
        Batch create documents for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        request : typing.Sequence[CloudDocumentCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[CloudDocument]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[CloudDocumentCreate], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[CloudDocument],
                    construct_type(
                        type_=typing.List[CloudDocument],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upsert_batch_documents(
        self,
        pipeline_id: str,
        *,
        request: typing.Sequence[CloudDocumentCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[CloudDocument]]:
        """
        Batch create or update a document for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        request : typing.Sequence[CloudDocumentCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[CloudDocument]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents",
            method="PUT",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[CloudDocumentCreate], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[CloudDocument],
                    construct_type(
                        type_=typing.List[CloudDocument],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_documents_paginated(
        self,
        pipeline_id: str,
        *,
        skip: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        file_id: typing.Optional[str] = None,
        only_direct_upload: typing.Optional[bool] = None,
        only_api_data_source_documents: typing.Optional[bool] = None,
        status_refresh_policy: typing.Optional[PipelinesListDocumentsPaginatedRequestStatusRefreshPolicy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PaginatedListCloudDocumentsResponse]:
        """
        Return a list of documents for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        skip : typing.Optional[int]

        limit : typing.Optional[int]

        file_id : typing.Optional[str]

        only_direct_upload : typing.Optional[bool]

        only_api_data_source_documents : typing.Optional[bool]

        status_refresh_policy : typing.Optional[PipelinesListDocumentsPaginatedRequestStatusRefreshPolicy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PaginatedListCloudDocumentsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/paginated",
            method="GET",
            params={
                "skip": skip,
                "limit": limit,
                "file_id": file_id,
                "only_direct_upload": only_direct_upload,
                "only_api_data_source_documents": only_api_data_source_documents,
                "status_refresh_policy": status_refresh_policy,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedListCloudDocumentsResponse,
                    construct_type(
                        type_=PaginatedListCloudDocumentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_document(
        self, pipeline_id: str, document_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CloudDocument]:
        """
        Return a single document for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        document_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CloudDocument]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/{jsonable_encoder(document_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CloudDocument,
                    construct_type(
                        type_=CloudDocument,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_document(
        self, pipeline_id: str, document_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete a document from a pipeline.
        Initiates an async job that will:
        1. Delete vectors from the vector store
        2. Delete the document from MongoDB after vectors are successfully deleted

        Parameters
        ----------
        pipeline_id : str

        document_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/{jsonable_encoder(document_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_document_status(
        self, pipeline_id: str, document_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ManagedIngestionStatusResponse]:
        """
        Return a single document for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        document_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ManagedIngestionStatusResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/{jsonable_encoder(document_id)}/status",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ManagedIngestionStatusResponse,
                    construct_type(
                        type_=ManagedIngestionStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def sync_document(
        self, pipeline_id: str, document_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Sync a specific document for a pipeline.

        Parameters
        ----------
        pipeline_id : str

        document_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/{jsonable_encoder(document_id)}/sync",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_document_chunks(
        self, pipeline_id: str, document_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[TextNode]]:
        """
        Return a list of chunks for a pipeline document.

        Parameters
        ----------
        pipeline_id : str

        document_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[TextNode]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/{jsonable_encoder(document_id)}/chunks",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TextNode],
                    construct_type(
                        type_=typing.List[TextNode],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def force_sync_all_documents(
        self,
        pipeline_id: str,
        *,
        batch_size: typing.Optional[int] = None,
        only_failed: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Force sync all documents in a pipeline by batching document ingestion jobs.

        - Iterates all document refs for the pipeline
        - Enqueues document ingestion jobs in batches of `batch_size`

        Parameters
        ----------
        pipeline_id : str

        batch_size : typing.Optional[int]

        only_failed : typing.Optional[bool]
            Only sync retriable documents (failed/cancelled/not-started/stalled-in-progress)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/pipelines/{jsonable_encoder(pipeline_id)}/documents/force-sync-all",
            method="POST",
            params={
                "batch_size": batch_size,
                "only_failed": only_failed,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
