# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.agent_data import AgentData
from ..types.api_key import ApiKey
from ..types.api_key_query_response import ApiKeyQueryResponse
from ..types.api_key_type import ApiKeyType
from ..types.batch import Batch
from ..types.batch_paginated_list import BatchPaginatedList
from ..types.batch_public_output import BatchPublicOutput
from ..types.delete_response import DeleteResponse
from ..types.file import File
from ..types.file_create_permission_info_value import FileCreatePermissionInfoValue
from ..types.file_create_resource_info_value import FileCreateResourceInfoValue
from ..types.file_filter import FileFilter
from ..types.file_query_response import FileQueryResponse
from ..types.filter_operation import FilterOperation
from ..types.http_validation_error import HttpValidationError
from ..types.llama_parse_parameters import LlamaParseParameters
from ..types.paginated_response_agent_data import PaginatedResponseAgentData
from ..types.paginated_response_aggregate_group import PaginatedResponseAggregateGroup
from ..types.paginated_response_quota_configuration import PaginatedResponseQuotaConfiguration
from ..types.paginated_response_spreadsheet_job import PaginatedResponseSpreadsheetJob
from ..types.parse_configuration import ParseConfiguration
from ..types.parse_configuration_filter import ParseConfigurationFilter
from ..types.parse_configuration_query_response import ParseConfigurationQueryResponse
from ..types.presigned_url import PresignedUrl
from ..types.spreadsheet_job import SpreadsheetJob
from ..types.spreadsheet_parsing_config import SpreadsheetParsingConfig
from ..types.spreadsheet_result_type import SpreadsheetResultType

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawBetaClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_api_keys(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_token: typing.Optional[str] = None,
        name: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        key_type: typing.Optional[ApiKeyType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ApiKeyQueryResponse]:
        """
        List API keys.

        If project_id is provided, validates user has access to that project.
        If project_id is not provided, scopes results to the current user.

        Args:
            user: Current user
            db: Database session
            page_size: Number of items per page
            page_token: Token for pagination
            name: Filter by API key name
            project_id: Filter by project ID
            key_type: Filter by key type

        Returns:
            Paginated response with API keys

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_token : typing.Optional[str]

        name : typing.Optional[str]

        project_id : typing.Optional[str]

        key_type : typing.Optional[ApiKeyType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ApiKeyQueryResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/api-keys",
            method="GET",
            params={
                "page_size": page_size,
                "page_token": page_token,
                "name": name,
                "project_id": project_id,
                "key_type": key_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ApiKeyQueryResponse,
                    construct_type(
                        type_=ApiKeyQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_api_key(
        self,
        *,
        name: typing.Optional[str] = OMIT,
        project_id: typing.Optional[str] = OMIT,
        key_type: typing.Optional[ApiKeyType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ApiKey]:
        """
        Create a new API key.

        If project_id is specified, validates user has admin permissions for that project.

        Args:
            api_key_create: API key creation data
            user: Current user
            db: Database session

        Returns:
            The created API key with the secret key visible in redacted_api_key field

        Parameters
        ----------
        name : typing.Optional[str]

        project_id : typing.Optional[str]
            The project ID to associate with the API key.

        key_type : typing.Optional[ApiKeyType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ApiKey]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/api-keys",
            method="POST",
            json={
                "name": name,
                "project_id": project_id,
                "key_type": key_type,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ApiKey,
                    construct_type(
                        type_=ApiKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_api_key(
        self, api_key_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ApiKey]:
        """
        Get an API key by ID.

        Args:
            api_key_id: The ID of the API key
            user: Current user
            db: Database session

        Returns:
            The API key

        Parameters
        ----------
        api_key_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ApiKey]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/beta/api-keys/{jsonable_encoder(api_key_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ApiKey,
                    construct_type(
                        type_=ApiKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_api_key(
        self, api_key_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Delete an API key.

        If the API key belongs to a project, validates user has admin permissions for that project.
        If the API key has no project, validates it belongs to the current user.

        Args:
            api_key_id: The ID of the API key to delete
            user: Current user
            db: Database session

        Parameters
        ----------
        api_key_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/beta/api-keys/{jsonable_encoder(api_key_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_batches(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BatchPaginatedList]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]

        offset : typing.Optional[int]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BatchPaginatedList]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/batches",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchPaginatedList,
                    construct_type(
                        type_=BatchPaginatedList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_batch(
        self,
        *,
        tool: str,
        input_type: str,
        input_id: str,
        external_id: str,
        organization_id: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        tool_data: typing.Optional[LlamaParseParameters] = OMIT,
        output_type: typing.Optional[str] = OMIT,
        output_id: typing.Optional[str] = OMIT,
        completion_window: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Batch]:
        """
        Parameters
        ----------
        tool : str
            The tool to be used for all requests in the batch.

        input_type : str
            The type of input file. Currently only 'datasource' is supported.

        input_id : str
            The ID of the input file for the batch.

        external_id : str
            A developer-provided ID for the batch. This ID will be returned in the response.

        organization_id : typing.Optional[str]

        project_id : typing.Optional[str]

        tool_data : typing.Optional[LlamaParseParameters]
            The data to be used for the tool.

        output_type : typing.Optional[str]
            The type of output file. Currently only 'datasource' is supported.

        output_id : typing.Optional[str]
            The ID of the output file for the batch.

        completion_window : typing.Optional[int]
            The time frame within which the batch should be processed. Currently only 24h is supported.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Batch]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/batches",
            method="POST",
            params={
                "organization_id": organization_id,
                "project_id": project_id,
            },
            json={
                "tool": tool,
                "tool_data": convert_and_respect_annotation_metadata(
                    object_=tool_data, annotation=LlamaParseParameters, direction="write"
                ),
                "input_type": input_type,
                "input_id": input_id,
                "output_type": output_type,
                "output_id": output_id,
                "external_id": external_id,
                "completion_window": completion_window,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Batch,
                    construct_type(
                        type_=Batch,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_batch(
        self,
        batch_id: str,
        *,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BatchPublicOutput]:
        """
        Parameters
        ----------
        batch_id : str

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BatchPublicOutput]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/beta/batches/{jsonable_encoder(batch_id)}",
            method="GET",
            params={
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchPublicOutput,
                    construct_type(
                        type_=BatchPublicOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_agent_data(
        self,
        item_id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AgentData]:
        """
        Get agent data by ID.

        Parameters
        ----------
        item_id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AgentData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/beta/agent-data/{jsonable_encoder(item_id)}",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AgentData,
                    construct_type(
                        type_=AgentData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_agent_data(
        self,
        item_id: str,
        *,
        data: typing.Dict[str, typing.Optional[typing.Any]],
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AgentData]:
        """
        Update agent data by ID (overwrites).

        Parameters
        ----------
        item_id : str

        data : typing.Dict[str, typing.Optional[typing.Any]]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AgentData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/beta/agent-data/{jsonable_encoder(item_id)}",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "data": data,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AgentData,
                    construct_type(
                        type_=AgentData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_agent_data(
        self,
        item_id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Dict[str, str]]:
        """
        Delete agent data by ID.

        Parameters
        ----------
        item_id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Dict[str, str]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/beta/agent-data/{jsonable_encoder(item_id)}",
            method="DELETE",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, str],
                    construct_type(
                        type_=typing.Dict[str, str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_agent_data(
        self,
        *,
        deployment_name: str,
        data: typing.Dict[str, typing.Optional[typing.Any]],
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        collection: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AgentData]:
        """
        Create new agent data.

        Parameters
        ----------
        deployment_name : str

        data : typing.Dict[str, typing.Optional[typing.Any]]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        collection : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AgentData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/agent-data",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "deployment_name": deployment_name,
                "collection": collection,
                "data": data,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AgentData,
                    construct_type(
                        type_=AgentData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def search_agent_data_api_v_1_beta_agent_data_search_post(
        self,
        *,
        deployment_name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        page_size: typing.Optional[int] = OMIT,
        page_token: typing.Optional[str] = OMIT,
        filter: typing.Optional[typing.Dict[str, typing.Optional[FilterOperation]]] = OMIT,
        order_by: typing.Optional[str] = OMIT,
        collection: typing.Optional[str] = OMIT,
        include_total: typing.Optional[bool] = OMIT,
        offset: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PaginatedResponseAgentData]:
        """
        Search agent data with filtering, sorting, and pagination.

        Parameters
        ----------
        deployment_name : str
            The agent deployment's name to search within

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        page_size : typing.Optional[int]
            The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.

        page_token : typing.Optional[str]
            A page token, received from a previous list call. Provide this to retrieve the subsequent page.

        filter : typing.Optional[typing.Dict[str, typing.Optional[FilterOperation]]]
            A filter object or expression that filters resources listed in the response.

        order_by : typing.Optional[str]
            A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.

        collection : typing.Optional[str]
            The logical agent data collection to search within

        include_total : typing.Optional[bool]
            Whether to include the total number of items in the response

        offset : typing.Optional[int]
            The offset to start from. If not provided, the first page is returned

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PaginatedResponseAgentData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/agent-data/:search",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "page_size": page_size,
                "page_token": page_token,
                "filter": convert_and_respect_annotation_metadata(
                    object_=filter, annotation=typing.Dict[str, typing.Optional[FilterOperation]], direction="write"
                ),
                "order_by": order_by,
                "deployment_name": deployment_name,
                "collection": collection,
                "include_total": include_total,
                "offset": offset,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedResponseAgentData,
                    construct_type(
                        type_=PaginatedResponseAgentData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def aggregate_agent_data_api_v_1_beta_agent_data_aggregate_post(
        self,
        *,
        deployment_name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        page_size: typing.Optional[int] = OMIT,
        page_token: typing.Optional[str] = OMIT,
        filter: typing.Optional[typing.Dict[str, typing.Optional[FilterOperation]]] = OMIT,
        order_by: typing.Optional[str] = OMIT,
        collection: typing.Optional[str] = OMIT,
        group_by: typing.Optional[typing.Sequence[str]] = OMIT,
        count: typing.Optional[bool] = OMIT,
        first: typing.Optional[bool] = OMIT,
        offset: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PaginatedResponseAggregateGroup]:
        """
        Aggregate agent data with grouping and optional counting/first item retrieval.

        Parameters
        ----------
        deployment_name : str
            The agent deployment's name to aggregate data for

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        page_size : typing.Optional[int]
            The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.

        page_token : typing.Optional[str]
            A page token, received from a previous list call. Provide this to retrieve the subsequent page.

        filter : typing.Optional[typing.Dict[str, typing.Optional[FilterOperation]]]
            A filter object or expression that filters resources listed in the response.

        order_by : typing.Optional[str]
            A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.

        collection : typing.Optional[str]
            The logical agent data collection to aggregate data for

        group_by : typing.Optional[typing.Sequence[str]]
            The fields to group by. If empty, the entire dataset is grouped on. e.g. if left out, can be used for simple count operations

        count : typing.Optional[bool]
            Whether to count the number of items in each group

        first : typing.Optional[bool]
            Whether to return the first item in each group (Sorted by created_at)

        offset : typing.Optional[int]
            The offset to start from. If not provided, the first page is returned

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PaginatedResponseAggregateGroup]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/agent-data/:aggregate",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "page_size": page_size,
                "page_token": page_token,
                "filter": convert_and_respect_annotation_metadata(
                    object_=filter, annotation=typing.Dict[str, typing.Optional[FilterOperation]], direction="write"
                ),
                "order_by": order_by,
                "deployment_name": deployment_name,
                "collection": collection,
                "group_by": group_by,
                "count": count,
                "first": first,
                "offset": offset,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedResponseAggregateGroup,
                    construct_type(
                        type_=PaginatedResponseAggregateGroup,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_agent_data_by_query_api_v_1_beta_agent_data_delete_post(
        self,
        *,
        deployment_name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        collection: typing.Optional[str] = OMIT,
        filter: typing.Optional[typing.Dict[str, typing.Optional[FilterOperation]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeleteResponse]:
        """
        Bulk delete agent data by query (deployment_name, collection, optional filters).

        Parameters
        ----------
        deployment_name : str
            The agent deployment's name to delete data for

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        collection : typing.Optional[str]
            The logical agent data collection to delete from

        filter : typing.Optional[typing.Dict[str, typing.Optional[FilterOperation]]]
            Optional filters to select which items to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/agent-data/:delete",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "deployment_name": deployment_name,
                "collection": collection,
                "filter": convert_and_respect_annotation_metadata(
                    object_=filter, annotation=typing.Dict[str, typing.Optional[FilterOperation]], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteResponse,
                    construct_type(
                        type_=DeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_quota_configurations(
        self,
        *,
        source_id: str,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PaginatedResponseQuotaConfiguration]:
        """
        Retrieve a paginated list of quota configurations with optional filtering.

        Parameters
        ----------
        source_id : str

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PaginatedResponseQuotaConfiguration]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/quota-management",
            method="GET",
            params={
                "source_type": "organization",
                "source_id": source_id,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedResponseQuotaConfiguration,
                    construct_type(
                        type_=PaginatedResponseQuotaConfiguration,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_file(
        self,
        *,
        name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        external_file_id: typing.Optional[str] = OMIT,
        file_size: typing.Optional[int] = OMIT,
        last_modified_at: typing.Optional[dt.datetime] = OMIT,
        resource_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]]] = OMIT,
        permission_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]]] = OMIT,
        data_source_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[File]:
        """
        Create a new file in the project.

        Args:
            file_create: File creation data
            project: Validated project from dependency
            db: Database session

        Returns:
            The created file

        Parameters
        ----------
        name : str
            Name that will be used for created file. If possible, always include the file extension in the name.

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        external_file_id : typing.Optional[str]
            The ID of the file in the external system

        file_size : typing.Optional[int]
            Size of the file in bytes

        last_modified_at : typing.Optional[dt.datetime]
            The last modified time of the file

        resource_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]]]
            Resource information for the file

        permission_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]]]
            Permission information for the file

        data_source_id : typing.Optional[str]
            The ID of the data source that the file belongs to

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[File]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/files",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "name": name,
                "external_file_id": external_file_id,
                "file_size": file_size,
                "last_modified_at": last_modified_at,
                "resource_info": convert_and_respect_annotation_metadata(
                    object_=resource_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]],
                    direction="write",
                ),
                "permission_info": convert_and_respect_annotation_metadata(
                    object_=permission_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]],
                    direction="write",
                ),
                "data_source_id": data_source_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    File,
                    construct_type(
                        type_=File,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upsert_file(
        self,
        *,
        name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        external_file_id: typing.Optional[str] = OMIT,
        file_size: typing.Optional[int] = OMIT,
        last_modified_at: typing.Optional[dt.datetime] = OMIT,
        resource_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]]] = OMIT,
        permission_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]]] = OMIT,
        data_source_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[File]:
        """
        Upsert a file (create or update if exists) in the project.

        Args:
            file_create: File creation/update data
            project: Validated project from dependency
            db: Database session

        Returns:
            The upserted file

        Parameters
        ----------
        name : str
            Name that will be used for created file. If possible, always include the file extension in the name.

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        external_file_id : typing.Optional[str]
            The ID of the file in the external system

        file_size : typing.Optional[int]
            Size of the file in bytes

        last_modified_at : typing.Optional[dt.datetime]
            The last modified time of the file

        resource_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]]]
            Resource information for the file

        permission_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]]]
            Permission information for the file

        data_source_id : typing.Optional[str]
            The ID of the data source that the file belongs to

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[File]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/files",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "name": name,
                "external_file_id": external_file_id,
                "file_size": file_size,
                "last_modified_at": last_modified_at,
                "resource_info": convert_and_respect_annotation_metadata(
                    object_=resource_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]],
                    direction="write",
                ),
                "permission_info": convert_and_respect_annotation_metadata(
                    object_=permission_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]],
                    direction="write",
                ),
                "data_source_id": data_source_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    File,
                    construct_type(
                        type_=File,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def query_files(
        self,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        page_size: typing.Optional[int] = OMIT,
        page_token: typing.Optional[str] = OMIT,
        filter: typing.Optional[FileFilter] = OMIT,
        order_by: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[FileQueryResponse]:
        """
        Query files with flexible filtering and pagination.

        Args:
            request: The query request with filters and pagination
            project: Validated project from dependency
            db: Database session

        Returns:
            Paginated response with files

        Parameters
        ----------
        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        page_size : typing.Optional[int]
            The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.

        page_token : typing.Optional[str]
            A page token, received from a previous list call. Provide this to retrieve the subsequent page.

        filter : typing.Optional[FileFilter]
            A filter object or expression that filters resources listed in the response.

        order_by : typing.Optional[str]
            A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FileQueryResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/files/query",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "page_size": page_size,
                "page_token": page_token,
                "filter": convert_and_respect_annotation_metadata(
                    object_=filter, annotation=FileFilter, direction="write"
                ),
                "order_by": order_by,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileQueryResponse,
                    construct_type(
                        type_=FileQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_file(
        self,
        file_id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Delete a single file from the project.

        Args:
            file_id: The ID of the file to delete
            project: Validated project from dependency
            db: Database session

        Returns:
            None (204 No Content on success)

        Parameters
        ----------
        file_id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/beta/files/{jsonable_encoder(file_id)}",
            method="DELETE",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_parse_configurations(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_token: typing.Optional[str] = None,
        name: typing.Optional[str] = None,
        creator: typing.Optional[str] = None,
        version: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ParseConfigurationQueryResponse]:
        """
        List parse configurations for the current project.

        Args:
            project: Validated project from dependency
            user: Current user
            db: Database session
            page_size: Number of items per page
            page_token: Token for pagination
            name: Filter by configuration name
            creator: Filter by creator
            version: Filter by version

        Returns:
            Paginated response with parse configurations

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_token : typing.Optional[str]

        name : typing.Optional[str]

        creator : typing.Optional[str]

        version : typing.Optional[str]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ParseConfigurationQueryResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/parse-configurations",
            method="GET",
            params={
                "page_size": page_size,
                "page_token": page_token,
                "name": name,
                "creator": creator,
                "version": version,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParseConfigurationQueryResponse,
                    construct_type(
                        type_=ParseConfigurationQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_parse_configuration(
        self,
        *,
        name: str,
        version: str,
        parameters: LlamaParseParameters,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        source_type: typing.Optional[str] = OMIT,
        source_id: typing.Optional[str] = OMIT,
        creator: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ParseConfiguration]:
        """
        Create a new parse configuration.

        Args:
            config_create: Parse configuration creation data
            project: Validated project from dependency
            user: Current user
            db: Database session

        Returns:
            The created parse configuration

        Parameters
        ----------
        name : str
            Name of the parse configuration

        version : str
            Version of the configuration

        parameters : LlamaParseParameters
            LlamaParseParameters configuration

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        source_type : typing.Optional[str]
            Type of the source (e.g., 'project')

        source_id : typing.Optional[str]
            ID of the source

        creator : typing.Optional[str]
            Creator of the configuration

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ParseConfiguration]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/parse-configurations",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "name": name,
                "source_type": source_type,
                "source_id": source_id,
                "creator": creator,
                "version": version,
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=LlamaParseParameters, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParseConfiguration,
                    construct_type(
                        type_=ParseConfiguration,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upsert_parse_configuration(
        self,
        *,
        name: str,
        version: str,
        parameters: LlamaParseParameters,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        source_type: typing.Optional[str] = OMIT,
        source_id: typing.Optional[str] = OMIT,
        creator: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ParseConfiguration]:
        """
        Create or update a parse configuration by name.

        Args:
            config_create: Parse configuration creation data
            project: Validated project from dependency
            user: Current user
            db: Database session

        Returns:
            The created or updated parse configuration

        Parameters
        ----------
        name : str
            Name of the parse configuration

        version : str
            Version of the configuration

        parameters : LlamaParseParameters
            LlamaParseParameters configuration

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        source_type : typing.Optional[str]
            Type of the source (e.g., 'project')

        source_id : typing.Optional[str]
            ID of the source

        creator : typing.Optional[str]
            Creator of the configuration

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ParseConfiguration]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/parse-configurations",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "name": name,
                "source_type": source_type,
                "source_id": source_id,
                "creator": creator,
                "version": version,
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=LlamaParseParameters, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParseConfiguration,
                    construct_type(
                        type_=ParseConfiguration,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_parse_configuration(
        self,
        config_id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ParseConfiguration]:
        """
        Get a parse configuration by ID.

        Args:
            config_id: The ID of the parse configuration
            project: Validated project from dependency
            user: Current user
            db: Database session

        Returns:
            The parse configuration

        Parameters
        ----------
        config_id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ParseConfiguration]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/beta/parse-configurations/{jsonable_encoder(config_id)}",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParseConfiguration,
                    construct_type(
                        type_=ParseConfiguration,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_parse_configuration(
        self,
        config_id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        parameters: typing.Optional[LlamaParseParameters] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ParseConfiguration]:
        """
        Update a parse configuration.

        Args:
            config_id: The ID of the parse configuration to update
            config_update: Update data
            project: Validated project from dependency
            user: Current user
            db: Database session

        Returns:
            The updated parse configuration

        Parameters
        ----------
        config_id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        parameters : typing.Optional[LlamaParseParameters]
            Updated LlamaParseParameters configuration

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ParseConfiguration]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/beta/parse-configurations/{jsonable_encoder(config_id)}",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=LlamaParseParameters, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParseConfiguration,
                    construct_type(
                        type_=ParseConfiguration,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_parse_configuration(
        self,
        config_id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Delete a parse configuration.

        Args:
            config_id: The ID of the parse configuration to delete
            project: Validated project from dependency
            user: Current user
            db: Database session

        Parameters
        ----------
        config_id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/beta/parse-configurations/{jsonable_encoder(config_id)}",
            method="DELETE",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def query_parse_configurations(
        self,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        page_size: typing.Optional[int] = OMIT,
        page_token: typing.Optional[str] = OMIT,
        filter: typing.Optional[ParseConfigurationFilter] = OMIT,
        order_by: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ParseConfigurationQueryResponse]:
        """
        Query parse configurations with filtering and pagination.

        Args:
            query_request: Query request with filters and pagination
            project: Validated project from dependency
            user: Current user
            db: Database session

        Returns:
            Paginated response with parse configurations

        Parameters
        ----------
        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        page_size : typing.Optional[int]
            The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.

        page_token : typing.Optional[str]
            A page token, received from a previous list call. Provide this to retrieve the subsequent page.

        filter : typing.Optional[ParseConfigurationFilter]
            A filter object or expression that filters resources listed in the response.

        order_by : typing.Optional[str]
            A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ParseConfigurationQueryResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/parse-configurations/query",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "page_size": page_size,
                "page_token": page_token,
                "filter": convert_and_respect_annotation_metadata(
                    object_=filter, annotation=ParseConfigurationFilter, direction="write"
                ),
                "order_by": order_by,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParseConfigurationQueryResponse,
                    construct_type(
                        type_=ParseConfigurationQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_latest_parse_configuration(
        self,
        *,
        creator: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[ParseConfiguration]]:
        """
        Get the latest parse configuration for the current project.

        Args:
            project: Validated project from dependency
            user: Current user
            db: Database session
            creator: Optional creator filter

        Returns:
            The latest parse configuration or None if not found

        Parameters
        ----------
        creator : typing.Optional[str]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[ParseConfiguration]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/parse-configurations/latest",
            method="GET",
            params={
                "creator": creator,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[ParseConfiguration],
                    construct_type(
                        type_=typing.Optional[ParseConfiguration],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_spreadsheet_jobs(
        self,
        *,
        include_results: typing.Optional[bool] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        page_size: typing.Optional[int] = None,
        page_token: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PaginatedResponseSpreadsheetJob]:
        """
        List spreadsheet parsing jobs.
        Experimental: This endpoint is not yet ready for production use and is subject to change at any time.

        Parameters
        ----------
        include_results : typing.Optional[bool]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        page_size : typing.Optional[int]

        page_token : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PaginatedResponseSpreadsheetJob]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/spreadsheet/jobs",
            method="GET",
            params={
                "include_results": include_results,
                "project_id": project_id,
                "organization_id": organization_id,
                "page_size": page_size,
                "page_token": page_token,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedResponseSpreadsheetJob,
                    construct_type(
                        type_=PaginatedResponseSpreadsheetJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_spreadsheet_job(
        self,
        *,
        file_id: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        config: typing.Optional[SpreadsheetParsingConfig] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SpreadsheetJob]:
        """
        Create a spreadsheet parsing job.
        Experimental: This endpoint is not yet ready for production use and is subject to change at any time.

        Parameters
        ----------
        file_id : str
            The ID of the file to parse

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        config : typing.Optional[SpreadsheetParsingConfig]
            Configuration for the parsing job

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SpreadsheetJob]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/beta/spreadsheet/jobs",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "file_id": file_id,
                "config": convert_and_respect_annotation_metadata(
                    object_=config, annotation=SpreadsheetParsingConfig, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SpreadsheetJob,
                    construct_type(
                        type_=SpreadsheetJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_spreadsheet_job(
        self,
        spreadsheet_job_id: str,
        *,
        include_results: typing.Optional[bool] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SpreadsheetJob]:
        """
        Get a spreadsheet parsing job.

        When include_results=True (default), the response will include extracted tables and results
        if the job is complete, eliminating the need for a separate /results call.

        Experimental: This endpoint is not yet ready for production use and is subject to change at any time.

        Parameters
        ----------
        spreadsheet_job_id : str

        include_results : typing.Optional[bool]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SpreadsheetJob]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/beta/spreadsheet/jobs/{jsonable_encoder(spreadsheet_job_id)}",
            method="GET",
            params={
                "include_results": include_results,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SpreadsheetJob,
                    construct_type(
                        type_=SpreadsheetJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_result_table(
        self,
        spreadsheet_job_id: str,
        table_id: str,
        table_type: SpreadsheetResultType,
        *,
        expires_at_seconds: typing.Optional[int] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PresignedUrl]:
        """
        Generate a presigned URL to download a specific extracted table.
        Experimental: This endpoint is not yet ready for production use and is subject to change at any time.

        Parameters
        ----------
        spreadsheet_job_id : str

        table_id : str

        table_type : SpreadsheetResultType

        expires_at_seconds : typing.Optional[int]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PresignedUrl]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/beta/spreadsheet/jobs/{jsonable_encoder(spreadsheet_job_id)}/tables/{jsonable_encoder(table_id)}/result/{jsonable_encoder(table_type)}",
            method="GET",
            params={
                "expires_at_seconds": expires_at_seconds,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PresignedUrl,
                    construct_type(
                        type_=PresignedUrl,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawBetaClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_api_keys(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_token: typing.Optional[str] = None,
        name: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        key_type: typing.Optional[ApiKeyType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ApiKeyQueryResponse]:
        """
        List API keys.

        If project_id is provided, validates user has access to that project.
        If project_id is not provided, scopes results to the current user.

        Args:
            user: Current user
            db: Database session
            page_size: Number of items per page
            page_token: Token for pagination
            name: Filter by API key name
            project_id: Filter by project ID
            key_type: Filter by key type

        Returns:
            Paginated response with API keys

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_token : typing.Optional[str]

        name : typing.Optional[str]

        project_id : typing.Optional[str]

        key_type : typing.Optional[ApiKeyType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ApiKeyQueryResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/api-keys",
            method="GET",
            params={
                "page_size": page_size,
                "page_token": page_token,
                "name": name,
                "project_id": project_id,
                "key_type": key_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ApiKeyQueryResponse,
                    construct_type(
                        type_=ApiKeyQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_api_key(
        self,
        *,
        name: typing.Optional[str] = OMIT,
        project_id: typing.Optional[str] = OMIT,
        key_type: typing.Optional[ApiKeyType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ApiKey]:
        """
        Create a new API key.

        If project_id is specified, validates user has admin permissions for that project.

        Args:
            api_key_create: API key creation data
            user: Current user
            db: Database session

        Returns:
            The created API key with the secret key visible in redacted_api_key field

        Parameters
        ----------
        name : typing.Optional[str]

        project_id : typing.Optional[str]
            The project ID to associate with the API key.

        key_type : typing.Optional[ApiKeyType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ApiKey]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/api-keys",
            method="POST",
            json={
                "name": name,
                "project_id": project_id,
                "key_type": key_type,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ApiKey,
                    construct_type(
                        type_=ApiKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_api_key(
        self, api_key_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ApiKey]:
        """
        Get an API key by ID.

        Args:
            api_key_id: The ID of the API key
            user: Current user
            db: Database session

        Returns:
            The API key

        Parameters
        ----------
        api_key_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ApiKey]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/beta/api-keys/{jsonable_encoder(api_key_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ApiKey,
                    construct_type(
                        type_=ApiKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_api_key(
        self, api_key_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete an API key.

        If the API key belongs to a project, validates user has admin permissions for that project.
        If the API key has no project, validates it belongs to the current user.

        Args:
            api_key_id: The ID of the API key to delete
            user: Current user
            db: Database session

        Parameters
        ----------
        api_key_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/beta/api-keys/{jsonable_encoder(api_key_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_batches(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BatchPaginatedList]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]

        offset : typing.Optional[int]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BatchPaginatedList]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/batches",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchPaginatedList,
                    construct_type(
                        type_=BatchPaginatedList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_batch(
        self,
        *,
        tool: str,
        input_type: str,
        input_id: str,
        external_id: str,
        organization_id: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        tool_data: typing.Optional[LlamaParseParameters] = OMIT,
        output_type: typing.Optional[str] = OMIT,
        output_id: typing.Optional[str] = OMIT,
        completion_window: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Batch]:
        """
        Parameters
        ----------
        tool : str
            The tool to be used for all requests in the batch.

        input_type : str
            The type of input file. Currently only 'datasource' is supported.

        input_id : str
            The ID of the input file for the batch.

        external_id : str
            A developer-provided ID for the batch. This ID will be returned in the response.

        organization_id : typing.Optional[str]

        project_id : typing.Optional[str]

        tool_data : typing.Optional[LlamaParseParameters]
            The data to be used for the tool.

        output_type : typing.Optional[str]
            The type of output file. Currently only 'datasource' is supported.

        output_id : typing.Optional[str]
            The ID of the output file for the batch.

        completion_window : typing.Optional[int]
            The time frame within which the batch should be processed. Currently only 24h is supported.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Batch]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/batches",
            method="POST",
            params={
                "organization_id": organization_id,
                "project_id": project_id,
            },
            json={
                "tool": tool,
                "tool_data": convert_and_respect_annotation_metadata(
                    object_=tool_data, annotation=LlamaParseParameters, direction="write"
                ),
                "input_type": input_type,
                "input_id": input_id,
                "output_type": output_type,
                "output_id": output_id,
                "external_id": external_id,
                "completion_window": completion_window,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Batch,
                    construct_type(
                        type_=Batch,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_batch(
        self,
        batch_id: str,
        *,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BatchPublicOutput]:
        """
        Parameters
        ----------
        batch_id : str

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BatchPublicOutput]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/beta/batches/{jsonable_encoder(batch_id)}",
            method="GET",
            params={
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchPublicOutput,
                    construct_type(
                        type_=BatchPublicOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_agent_data(
        self,
        item_id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AgentData]:
        """
        Get agent data by ID.

        Parameters
        ----------
        item_id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AgentData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/beta/agent-data/{jsonable_encoder(item_id)}",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AgentData,
                    construct_type(
                        type_=AgentData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_agent_data(
        self,
        item_id: str,
        *,
        data: typing.Dict[str, typing.Optional[typing.Any]],
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AgentData]:
        """
        Update agent data by ID (overwrites).

        Parameters
        ----------
        item_id : str

        data : typing.Dict[str, typing.Optional[typing.Any]]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AgentData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/beta/agent-data/{jsonable_encoder(item_id)}",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "data": data,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AgentData,
                    construct_type(
                        type_=AgentData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_agent_data(
        self,
        item_id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Dict[str, str]]:
        """
        Delete agent data by ID.

        Parameters
        ----------
        item_id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Dict[str, str]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/beta/agent-data/{jsonable_encoder(item_id)}",
            method="DELETE",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, str],
                    construct_type(
                        type_=typing.Dict[str, str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_agent_data(
        self,
        *,
        deployment_name: str,
        data: typing.Dict[str, typing.Optional[typing.Any]],
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        collection: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AgentData]:
        """
        Create new agent data.

        Parameters
        ----------
        deployment_name : str

        data : typing.Dict[str, typing.Optional[typing.Any]]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        collection : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AgentData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/agent-data",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "deployment_name": deployment_name,
                "collection": collection,
                "data": data,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AgentData,
                    construct_type(
                        type_=AgentData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def search_agent_data_api_v_1_beta_agent_data_search_post(
        self,
        *,
        deployment_name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        page_size: typing.Optional[int] = OMIT,
        page_token: typing.Optional[str] = OMIT,
        filter: typing.Optional[typing.Dict[str, typing.Optional[FilterOperation]]] = OMIT,
        order_by: typing.Optional[str] = OMIT,
        collection: typing.Optional[str] = OMIT,
        include_total: typing.Optional[bool] = OMIT,
        offset: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PaginatedResponseAgentData]:
        """
        Search agent data with filtering, sorting, and pagination.

        Parameters
        ----------
        deployment_name : str
            The agent deployment's name to search within

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        page_size : typing.Optional[int]
            The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.

        page_token : typing.Optional[str]
            A page token, received from a previous list call. Provide this to retrieve the subsequent page.

        filter : typing.Optional[typing.Dict[str, typing.Optional[FilterOperation]]]
            A filter object or expression that filters resources listed in the response.

        order_by : typing.Optional[str]
            A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.

        collection : typing.Optional[str]
            The logical agent data collection to search within

        include_total : typing.Optional[bool]
            Whether to include the total number of items in the response

        offset : typing.Optional[int]
            The offset to start from. If not provided, the first page is returned

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PaginatedResponseAgentData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/agent-data/:search",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "page_size": page_size,
                "page_token": page_token,
                "filter": convert_and_respect_annotation_metadata(
                    object_=filter, annotation=typing.Dict[str, typing.Optional[FilterOperation]], direction="write"
                ),
                "order_by": order_by,
                "deployment_name": deployment_name,
                "collection": collection,
                "include_total": include_total,
                "offset": offset,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedResponseAgentData,
                    construct_type(
                        type_=PaginatedResponseAgentData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def aggregate_agent_data_api_v_1_beta_agent_data_aggregate_post(
        self,
        *,
        deployment_name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        page_size: typing.Optional[int] = OMIT,
        page_token: typing.Optional[str] = OMIT,
        filter: typing.Optional[typing.Dict[str, typing.Optional[FilterOperation]]] = OMIT,
        order_by: typing.Optional[str] = OMIT,
        collection: typing.Optional[str] = OMIT,
        group_by: typing.Optional[typing.Sequence[str]] = OMIT,
        count: typing.Optional[bool] = OMIT,
        first: typing.Optional[bool] = OMIT,
        offset: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PaginatedResponseAggregateGroup]:
        """
        Aggregate agent data with grouping and optional counting/first item retrieval.

        Parameters
        ----------
        deployment_name : str
            The agent deployment's name to aggregate data for

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        page_size : typing.Optional[int]
            The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.

        page_token : typing.Optional[str]
            A page token, received from a previous list call. Provide this to retrieve the subsequent page.

        filter : typing.Optional[typing.Dict[str, typing.Optional[FilterOperation]]]
            A filter object or expression that filters resources listed in the response.

        order_by : typing.Optional[str]
            A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.

        collection : typing.Optional[str]
            The logical agent data collection to aggregate data for

        group_by : typing.Optional[typing.Sequence[str]]
            The fields to group by. If empty, the entire dataset is grouped on. e.g. if left out, can be used for simple count operations

        count : typing.Optional[bool]
            Whether to count the number of items in each group

        first : typing.Optional[bool]
            Whether to return the first item in each group (Sorted by created_at)

        offset : typing.Optional[int]
            The offset to start from. If not provided, the first page is returned

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PaginatedResponseAggregateGroup]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/agent-data/:aggregate",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "page_size": page_size,
                "page_token": page_token,
                "filter": convert_and_respect_annotation_metadata(
                    object_=filter, annotation=typing.Dict[str, typing.Optional[FilterOperation]], direction="write"
                ),
                "order_by": order_by,
                "deployment_name": deployment_name,
                "collection": collection,
                "group_by": group_by,
                "count": count,
                "first": first,
                "offset": offset,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedResponseAggregateGroup,
                    construct_type(
                        type_=PaginatedResponseAggregateGroup,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_agent_data_by_query_api_v_1_beta_agent_data_delete_post(
        self,
        *,
        deployment_name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        collection: typing.Optional[str] = OMIT,
        filter: typing.Optional[typing.Dict[str, typing.Optional[FilterOperation]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeleteResponse]:
        """
        Bulk delete agent data by query (deployment_name, collection, optional filters).

        Parameters
        ----------
        deployment_name : str
            The agent deployment's name to delete data for

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        collection : typing.Optional[str]
            The logical agent data collection to delete from

        filter : typing.Optional[typing.Dict[str, typing.Optional[FilterOperation]]]
            Optional filters to select which items to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/agent-data/:delete",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "deployment_name": deployment_name,
                "collection": collection,
                "filter": convert_and_respect_annotation_metadata(
                    object_=filter, annotation=typing.Dict[str, typing.Optional[FilterOperation]], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteResponse,
                    construct_type(
                        type_=DeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_quota_configurations(
        self,
        *,
        source_id: str,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PaginatedResponseQuotaConfiguration]:
        """
        Retrieve a paginated list of quota configurations with optional filtering.

        Parameters
        ----------
        source_id : str

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PaginatedResponseQuotaConfiguration]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/quota-management",
            method="GET",
            params={
                "source_type": "organization",
                "source_id": source_id,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedResponseQuotaConfiguration,
                    construct_type(
                        type_=PaginatedResponseQuotaConfiguration,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_file(
        self,
        *,
        name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        external_file_id: typing.Optional[str] = OMIT,
        file_size: typing.Optional[int] = OMIT,
        last_modified_at: typing.Optional[dt.datetime] = OMIT,
        resource_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]]] = OMIT,
        permission_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]]] = OMIT,
        data_source_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[File]:
        """
        Create a new file in the project.

        Args:
            file_create: File creation data
            project: Validated project from dependency
            db: Database session

        Returns:
            The created file

        Parameters
        ----------
        name : str
            Name that will be used for created file. If possible, always include the file extension in the name.

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        external_file_id : typing.Optional[str]
            The ID of the file in the external system

        file_size : typing.Optional[int]
            Size of the file in bytes

        last_modified_at : typing.Optional[dt.datetime]
            The last modified time of the file

        resource_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]]]
            Resource information for the file

        permission_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]]]
            Permission information for the file

        data_source_id : typing.Optional[str]
            The ID of the data source that the file belongs to

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[File]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/files",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "name": name,
                "external_file_id": external_file_id,
                "file_size": file_size,
                "last_modified_at": last_modified_at,
                "resource_info": convert_and_respect_annotation_metadata(
                    object_=resource_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]],
                    direction="write",
                ),
                "permission_info": convert_and_respect_annotation_metadata(
                    object_=permission_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]],
                    direction="write",
                ),
                "data_source_id": data_source_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    File,
                    construct_type(
                        type_=File,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upsert_file(
        self,
        *,
        name: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        external_file_id: typing.Optional[str] = OMIT,
        file_size: typing.Optional[int] = OMIT,
        last_modified_at: typing.Optional[dt.datetime] = OMIT,
        resource_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]]] = OMIT,
        permission_info: typing.Optional[typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]]] = OMIT,
        data_source_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[File]:
        """
        Upsert a file (create or update if exists) in the project.

        Args:
            file_create: File creation/update data
            project: Validated project from dependency
            db: Database session

        Returns:
            The upserted file

        Parameters
        ----------
        name : str
            Name that will be used for created file. If possible, always include the file extension in the name.

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        external_file_id : typing.Optional[str]
            The ID of the file in the external system

        file_size : typing.Optional[int]
            Size of the file in bytes

        last_modified_at : typing.Optional[dt.datetime]
            The last modified time of the file

        resource_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]]]
            Resource information for the file

        permission_info : typing.Optional[typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]]]
            Permission information for the file

        data_source_id : typing.Optional[str]
            The ID of the data source that the file belongs to

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[File]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/files",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "name": name,
                "external_file_id": external_file_id,
                "file_size": file_size,
                "last_modified_at": last_modified_at,
                "resource_info": convert_and_respect_annotation_metadata(
                    object_=resource_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreateResourceInfoValue]],
                    direction="write",
                ),
                "permission_info": convert_and_respect_annotation_metadata(
                    object_=permission_info,
                    annotation=typing.Dict[str, typing.Optional[FileCreatePermissionInfoValue]],
                    direction="write",
                ),
                "data_source_id": data_source_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    File,
                    construct_type(
                        type_=File,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def query_files(
        self,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        page_size: typing.Optional[int] = OMIT,
        page_token: typing.Optional[str] = OMIT,
        filter: typing.Optional[FileFilter] = OMIT,
        order_by: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[FileQueryResponse]:
        """
        Query files with flexible filtering and pagination.

        Args:
            request: The query request with filters and pagination
            project: Validated project from dependency
            db: Database session

        Returns:
            Paginated response with files

        Parameters
        ----------
        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        page_size : typing.Optional[int]
            The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.

        page_token : typing.Optional[str]
            A page token, received from a previous list call. Provide this to retrieve the subsequent page.

        filter : typing.Optional[FileFilter]
            A filter object or expression that filters resources listed in the response.

        order_by : typing.Optional[str]
            A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FileQueryResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/files/query",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "page_size": page_size,
                "page_token": page_token,
                "filter": convert_and_respect_annotation_metadata(
                    object_=filter, annotation=FileFilter, direction="write"
                ),
                "order_by": order_by,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileQueryResponse,
                    construct_type(
                        type_=FileQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_file(
        self,
        file_id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Delete a single file from the project.

        Args:
            file_id: The ID of the file to delete
            project: Validated project from dependency
            db: Database session

        Returns:
            None (204 No Content on success)

        Parameters
        ----------
        file_id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/beta/files/{jsonable_encoder(file_id)}",
            method="DELETE",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_parse_configurations(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_token: typing.Optional[str] = None,
        name: typing.Optional[str] = None,
        creator: typing.Optional[str] = None,
        version: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ParseConfigurationQueryResponse]:
        """
        List parse configurations for the current project.

        Args:
            project: Validated project from dependency
            user: Current user
            db: Database session
            page_size: Number of items per page
            page_token: Token for pagination
            name: Filter by configuration name
            creator: Filter by creator
            version: Filter by version

        Returns:
            Paginated response with parse configurations

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_token : typing.Optional[str]

        name : typing.Optional[str]

        creator : typing.Optional[str]

        version : typing.Optional[str]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ParseConfigurationQueryResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/parse-configurations",
            method="GET",
            params={
                "page_size": page_size,
                "page_token": page_token,
                "name": name,
                "creator": creator,
                "version": version,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParseConfigurationQueryResponse,
                    construct_type(
                        type_=ParseConfigurationQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_parse_configuration(
        self,
        *,
        name: str,
        version: str,
        parameters: LlamaParseParameters,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        source_type: typing.Optional[str] = OMIT,
        source_id: typing.Optional[str] = OMIT,
        creator: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ParseConfiguration]:
        """
        Create a new parse configuration.

        Args:
            config_create: Parse configuration creation data
            project: Validated project from dependency
            user: Current user
            db: Database session

        Returns:
            The created parse configuration

        Parameters
        ----------
        name : str
            Name of the parse configuration

        version : str
            Version of the configuration

        parameters : LlamaParseParameters
            LlamaParseParameters configuration

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        source_type : typing.Optional[str]
            Type of the source (e.g., 'project')

        source_id : typing.Optional[str]
            ID of the source

        creator : typing.Optional[str]
            Creator of the configuration

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ParseConfiguration]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/parse-configurations",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "name": name,
                "source_type": source_type,
                "source_id": source_id,
                "creator": creator,
                "version": version,
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=LlamaParseParameters, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParseConfiguration,
                    construct_type(
                        type_=ParseConfiguration,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upsert_parse_configuration(
        self,
        *,
        name: str,
        version: str,
        parameters: LlamaParseParameters,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        source_type: typing.Optional[str] = OMIT,
        source_id: typing.Optional[str] = OMIT,
        creator: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ParseConfiguration]:
        """
        Create or update a parse configuration by name.

        Args:
            config_create: Parse configuration creation data
            project: Validated project from dependency
            user: Current user
            db: Database session

        Returns:
            The created or updated parse configuration

        Parameters
        ----------
        name : str
            Name of the parse configuration

        version : str
            Version of the configuration

        parameters : LlamaParseParameters
            LlamaParseParameters configuration

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        source_type : typing.Optional[str]
            Type of the source (e.g., 'project')

        source_id : typing.Optional[str]
            ID of the source

        creator : typing.Optional[str]
            Creator of the configuration

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ParseConfiguration]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/parse-configurations",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "name": name,
                "source_type": source_type,
                "source_id": source_id,
                "creator": creator,
                "version": version,
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=LlamaParseParameters, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParseConfiguration,
                    construct_type(
                        type_=ParseConfiguration,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_parse_configuration(
        self,
        config_id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ParseConfiguration]:
        """
        Get a parse configuration by ID.

        Args:
            config_id: The ID of the parse configuration
            project: Validated project from dependency
            user: Current user
            db: Database session

        Returns:
            The parse configuration

        Parameters
        ----------
        config_id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ParseConfiguration]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/beta/parse-configurations/{jsonable_encoder(config_id)}",
            method="GET",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParseConfiguration,
                    construct_type(
                        type_=ParseConfiguration,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_parse_configuration(
        self,
        config_id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        parameters: typing.Optional[LlamaParseParameters] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ParseConfiguration]:
        """
        Update a parse configuration.

        Args:
            config_id: The ID of the parse configuration to update
            config_update: Update data
            project: Validated project from dependency
            user: Current user
            db: Database session

        Returns:
            The updated parse configuration

        Parameters
        ----------
        config_id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        parameters : typing.Optional[LlamaParseParameters]
            Updated LlamaParseParameters configuration

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ParseConfiguration]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/beta/parse-configurations/{jsonable_encoder(config_id)}",
            method="PUT",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=LlamaParseParameters, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParseConfiguration,
                    construct_type(
                        type_=ParseConfiguration,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_parse_configuration(
        self,
        config_id: str,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Delete a parse configuration.

        Args:
            config_id: The ID of the parse configuration to delete
            project: Validated project from dependency
            user: Current user
            db: Database session

        Parameters
        ----------
        config_id : str

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/beta/parse-configurations/{jsonable_encoder(config_id)}",
            method="DELETE",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def query_parse_configurations(
        self,
        *,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        page_size: typing.Optional[int] = OMIT,
        page_token: typing.Optional[str] = OMIT,
        filter: typing.Optional[ParseConfigurationFilter] = OMIT,
        order_by: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ParseConfigurationQueryResponse]:
        """
        Query parse configurations with filtering and pagination.

        Args:
            query_request: Query request with filters and pagination
            project: Validated project from dependency
            user: Current user
            db: Database session

        Returns:
            Paginated response with parse configurations

        Parameters
        ----------
        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        page_size : typing.Optional[int]
            The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.

        page_token : typing.Optional[str]
            A page token, received from a previous list call. Provide this to retrieve the subsequent page.

        filter : typing.Optional[ParseConfigurationFilter]
            A filter object or expression that filters resources listed in the response.

        order_by : typing.Optional[str]
            A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ParseConfigurationQueryResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/parse-configurations/query",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "page_size": page_size,
                "page_token": page_token,
                "filter": convert_and_respect_annotation_metadata(
                    object_=filter, annotation=ParseConfigurationFilter, direction="write"
                ),
                "order_by": order_by,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParseConfigurationQueryResponse,
                    construct_type(
                        type_=ParseConfigurationQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_latest_parse_configuration(
        self,
        *,
        creator: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[ParseConfiguration]]:
        """
        Get the latest parse configuration for the current project.

        Args:
            project: Validated project from dependency
            user: Current user
            db: Database session
            creator: Optional creator filter

        Returns:
            The latest parse configuration or None if not found

        Parameters
        ----------
        creator : typing.Optional[str]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[ParseConfiguration]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/parse-configurations/latest",
            method="GET",
            params={
                "creator": creator,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[ParseConfiguration],
                    construct_type(
                        type_=typing.Optional[ParseConfiguration],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_spreadsheet_jobs(
        self,
        *,
        include_results: typing.Optional[bool] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        page_size: typing.Optional[int] = None,
        page_token: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PaginatedResponseSpreadsheetJob]:
        """
        List spreadsheet parsing jobs.
        Experimental: This endpoint is not yet ready for production use and is subject to change at any time.

        Parameters
        ----------
        include_results : typing.Optional[bool]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        page_size : typing.Optional[int]

        page_token : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PaginatedResponseSpreadsheetJob]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/spreadsheet/jobs",
            method="GET",
            params={
                "include_results": include_results,
                "project_id": project_id,
                "organization_id": organization_id,
                "page_size": page_size,
                "page_token": page_token,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedResponseSpreadsheetJob,
                    construct_type(
                        type_=PaginatedResponseSpreadsheetJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_spreadsheet_job(
        self,
        *,
        file_id: str,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        config: typing.Optional[SpreadsheetParsingConfig] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SpreadsheetJob]:
        """
        Create a spreadsheet parsing job.
        Experimental: This endpoint is not yet ready for production use and is subject to change at any time.

        Parameters
        ----------
        file_id : str
            The ID of the file to parse

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        config : typing.Optional[SpreadsheetParsingConfig]
            Configuration for the parsing job

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SpreadsheetJob]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/beta/spreadsheet/jobs",
            method="POST",
            params={
                "project_id": project_id,
                "organization_id": organization_id,
            },
            json={
                "file_id": file_id,
                "config": convert_and_respect_annotation_metadata(
                    object_=config, annotation=SpreadsheetParsingConfig, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SpreadsheetJob,
                    construct_type(
                        type_=SpreadsheetJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_spreadsheet_job(
        self,
        spreadsheet_job_id: str,
        *,
        include_results: typing.Optional[bool] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SpreadsheetJob]:
        """
        Get a spreadsheet parsing job.

        When include_results=True (default), the response will include extracted tables and results
        if the job is complete, eliminating the need for a separate /results call.

        Experimental: This endpoint is not yet ready for production use and is subject to change at any time.

        Parameters
        ----------
        spreadsheet_job_id : str

        include_results : typing.Optional[bool]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SpreadsheetJob]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/beta/spreadsheet/jobs/{jsonable_encoder(spreadsheet_job_id)}",
            method="GET",
            params={
                "include_results": include_results,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SpreadsheetJob,
                    construct_type(
                        type_=SpreadsheetJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_result_table(
        self,
        spreadsheet_job_id: str,
        table_id: str,
        table_type: SpreadsheetResultType,
        *,
        expires_at_seconds: typing.Optional[int] = None,
        project_id: typing.Optional[str] = None,
        organization_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PresignedUrl]:
        """
        Generate a presigned URL to download a specific extracted table.
        Experimental: This endpoint is not yet ready for production use and is subject to change at any time.

        Parameters
        ----------
        spreadsheet_job_id : str

        table_id : str

        table_type : SpreadsheetResultType

        expires_at_seconds : typing.Optional[int]

        project_id : typing.Optional[str]

        organization_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PresignedUrl]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/beta/spreadsheet/jobs/{jsonable_encoder(spreadsheet_job_id)}/tables/{jsonable_encoder(table_id)}/result/{jsonable_encoder(table_type)}",
            method="GET",
            params={
                "expires_at_seconds": expires_at_seconds,
                "project_id": project_id,
                "organization_id": organization_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PresignedUrl,
                    construct_type(
                        type_=PresignedUrl,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
