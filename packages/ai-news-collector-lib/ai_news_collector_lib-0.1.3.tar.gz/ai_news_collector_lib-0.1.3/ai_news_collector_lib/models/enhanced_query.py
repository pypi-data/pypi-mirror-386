"""
Enhanced Query Model for LLM-based Query Optimization

This module provides the EnhancedQuery dataclass that stores optimized query variants
for all supported search engines. It's generated by the QueryEnhancer class which uses
Google Gemini LLM to enhance user queries for better search results across different
search engine types.

Supported Engines:
- Free Engines (4): hackernews, arxiv, duckduckgo, rss_feeds
- API-based Engines (7): newsapi, tavily, google_search, bing_search, serper,
  brave_search, metasota_search
"""

from dataclasses import dataclass, asdict, field
from typing import Dict, Optional, List
import json


@dataclass
class EnhancedQuery:
    """
    Stores the original query and optimized variants for each supported search engine.

    The LLM (Google Gemini 2.5 Pro) generates optimized query variants for each enabled
    search engine. This class provides convenient access and serialization methods.

    Attributes:
        original (str): The original, unmodified user query

        # Free Search Engines (4)
        hackernews (Optional[str]): Optimized query for HackerNews search
        arxiv (Optional[str]): Optimized query for ArXiv (academic papers)
        duckduckgo (Optional[str]): Optimized query for DuckDuckGo
        rss_feeds (Optional[str]): Optimized query for RSS feeds

        # API-based Search Engines (7)
        newsapi (Optional[str]): Optimized query for NewsAPI
        tavily (Optional[str]): Optimized query for Tavily search
        google_search (Optional[str]): Optimized query for Google Custom Search
        bing_search (Optional[str]): Optimized query for Bing Search
        serper (Optional[str]): Optimized query for Serper
        brave_search (Optional[str]): Optimized query for Brave Search
        metasota_search (Optional[str]): Optimized query for MetaSota Search
    """

    original: str

    # Free Search Engines
    hackernews: Optional[str] = None
    arxiv: Optional[str] = None
    duckduckgo: Optional[str] = None
    rss_feeds: Optional[str] = None

    # API-based Search Engines
    newsapi: Optional[str] = None
    tavily: Optional[str] = None
    google_search: Optional[str] = None
    bing_search: Optional[str] = None
    serper: Optional[str] = None
    brave_search: Optional[str] = None
    metasota_search: Optional[str] = None

    # Metadata
    _timestamp: Optional[float] = field(default=None, repr=False, compare=False)

    # All supported search engines
    SUPPORTED_ENGINES = [
        # Free engines
        "hackernews",
        "arxiv",
        "duckduckgo",
        "rss_feeds",
        # API-based engines
        "newsapi",
        "tavily",
        "google_search",
        "bing_search",
        "serper",
        "brave_search",
        "metasota_search",
    ]

    CACHE_TTL = 24 * 60 * 60  # 24 hours in seconds

    def get_for_engine(self, engine_name: str) -> Optional[str]:
        """
        Get the optimized query for a specific search engine.

        Args:
            engine_name (str): The name of the search engine (e.g., 'arxiv', 'google_search')

        Returns:
            Optional[str]: The optimized query for the engine, or None if not set

        Raises:
            ValueError: If the engine is not supported

        Example:
            >>> eq = EnhancedQuery(
            ...     original="machine learning",
            ...     arxiv="deep learning neural networks",
            ...     google_search="machine learning tutorial"
            ... )
            >>> eq.get_for_engine('arxiv')
            'deep learning neural networks'
        """
        if engine_name not in self.SUPPORTED_ENGINES:
            raise ValueError(
                f"Unsupported engine: {engine_name}. "
                f"Supported engines: {', '.join(self.SUPPORTED_ENGINES)}"
            )
        return getattr(self, engine_name, None)

    def set_for_engine(self, engine_name: str, query: str) -> None:
        """
        Set the optimized query for a specific search engine.

        Args:
            engine_name (str): The name of the search engine
            query (str): The optimized query for this engine

        Raises:
            ValueError: If the engine is not supported
        """
        if engine_name not in self.SUPPORTED_ENGINES:
            raise ValueError(
                f"Unsupported engine: {engine_name}. "
                f"Supported engines: {', '.join(self.SUPPORTED_ENGINES)}"
            )
        setattr(self, engine_name, query)

    def to_dict(self, include_null: bool = False) -> Dict[str, Optional[str]]:
        """
        Convert the EnhancedQuery to a dictionary.

        Args:
            include_null (bool): If False (default), exclude None values.
                                If True, include all fields.

        Returns:
            Dict[str, Optional[str]]: Dictionary representation of the query

        Example:
            >>> eq = EnhancedQuery(original="test", arxiv="optimized")
            >>> eq.to_dict()
            {'original': 'test', 'arxiv': 'optimized'}

            >>> eq.to_dict(include_null=True)
            {'original': 'test', 'arxiv': 'optimized', 'hackernews': None, ...}
        """
        result = asdict(self)
        # Remove internal fields
        result.pop("_timestamp", None)

        if not include_null:
            result = {k: v for k, v in result.items() if v is not None}

        return result

    def to_json(self, include_null: bool = False) -> str:
        """
        Convert the EnhancedQuery to a JSON string.

        Args:
            include_null (bool): If False (default), exclude None values.

        Returns:
            str: JSON representation of the query
        """
        return json.dumps(self.to_dict(include_null=include_null), ensure_ascii=False, indent=2)

    @classmethod
    def from_dict(cls, data: Dict[str, Optional[str]]) -> "EnhancedQuery":
        """
        Create an EnhancedQuery from a dictionary.

        Args:
            data (Dict[str, Optional[str]]): Dictionary with query data.
                                            Must contain 'original' key.

        Returns:
            EnhancedQuery: New instance created from the dictionary

        Raises:
            ValueError: If 'original' key is missing

        Example:
            >>> data = {
            ...     'original': 'AI safety',
            ...     'arxiv': 'AI safety alignment',
            ...     'google_search': 'artificial intelligence safety'
            ... }
            >>> eq = EnhancedQuery.from_dict(data)
            >>> eq.original
            'AI safety'
        """
        if "original" not in data:
            raise ValueError("Dictionary must contain 'original' key")

        # Filter to only supported fields
        filtered_data = {}
        for key, value in data.items():
            if key in cls.SUPPORTED_ENGINES or key == "original":
                filtered_data[key] = value

        return cls(**filtered_data)

    @classmethod
    def from_json(cls, json_str: str) -> "EnhancedQuery":
        """
        Create an EnhancedQuery from a JSON string.

        Args:
            json_str (str): JSON string representation

        Returns:
            EnhancedQuery: New instance created from JSON

        Raises:
            json.JSONDecodeError: If JSON is invalid
            ValueError: If 'original' key is missing
        """
        data = json.loads(json_str)
        return cls.from_dict(data)

    def get_enabled_engines(self) -> List[str]:
        """
        Get list of engines that have optimized queries (non-None values).

        Returns:
            List[str]: List of engine names with non-None queries

        Example:
            >>> eq = EnhancedQuery(
            ...     original="test",
            ...     arxiv="optimized arxiv",
            ...     google_search="optimized google"
            ... )
            >>> eq.get_enabled_engines()
            ['arxiv', 'google_search']
        """
        return [
            engine for engine in self.SUPPORTED_ENGINES if self.get_for_engine(engine) is not None
        ]

    def get_engine_count(self) -> int:
        """
        Get the number of engines with optimized queries.

        Returns:
            int: Count of engines with non-None queries
        """
        return len(self.get_enabled_engines())

    def validate(self) -> bool:
        """
        Validate that the EnhancedQuery has at least one optimized query.

        Returns:
            bool: True if at least one optimized query exists, False otherwise
        """
        return self.get_engine_count() > 0

    def __repr__(self) -> str:
        """Return a detailed string representation."""
        enabled = self.get_enabled_engines()
        return (
            f"EnhancedQuery(original='{self.original}', "
            f"engines={enabled}, count={self.get_engine_count()})"
        )
