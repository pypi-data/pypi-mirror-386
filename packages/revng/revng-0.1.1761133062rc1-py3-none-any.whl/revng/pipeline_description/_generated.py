# This file is distributed under the MIT License. See LICENSE.md for details.
# This file is autogenerated! Do not edit it directly
import random
import sys
from dataclasses import dataclass, field
from io import TextIOBase
from typing import ClassVar, Optional

import yaml

from revng.tupletree import (
    EnumBase,
    Reference,
    StructBase,
    AbstractStructBase,
    dataclass_kwargs,
    no_default,
    TypedList,
    TypedListDescriptor,
    force_constructor_kwarg,
    force_kw_only,
    TypesMetadata,
    DiffSet,
)
from revng.tupletree import YamlLoader as _ExternalYamlLoader
from revng.tupletree import (
    YamlDumper as _ExternalYamlDumper,
)  # Every subclass of YamlLoader can register its own independent loaders


class YamlLoader(_ExternalYamlLoader):
    pass


# Every subclass of YamlDumper can register its own independent dumpers
class YamlDumper(_ExternalYamlDumper):
    pass


class DiffYamlLoader(YamlLoader):
    pass


class DiffYamlDumper(YamlDumper):
    pass


def random_id():
    return random.randint(2**10 + 1, 2**64 - 1)


@dataclass(**dataclass_kwargs)
class AnalysisReference(
    StructBase,
):
    """A reference to an analysis"""

    """The step where the analysis belongs to"""
    Step: "str"
    """The name of the analysis"""
    Name: "str"

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Step": parts[0], "Name": parts[1]}

    keyed = True

    def key(self):
        return f"{self.Step}-{self.Name}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class AnalysisContainerInput(
    StructBase,
):
    """Data structure representing an analysis' container input"""

    """AnalysisContainerInput' name"""
    Name: "str"
    """Kinds accepted by the analysis"""
    AcceptableKinds: "TypedList[str]" = field(
        metadata={"optional": True, "default_value": lambda: []}, default=TypedListDescriptor(str)
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Name": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Name}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class AnalysisOption(
    StructBase,
):
    """Data structure representing an analysis' container input"""

    """AnalysisOption' name"""
    Name: "str"
    """Type of the option"""
    Type: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Name": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Name}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class Artifacts(
    StructBase,
):
    """Data structure representing a Artifacts"""

    """Artifacts's kind"""
    Kind: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """Artifacts's container"""
    Container: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The Artifacts's filename to use for a single element"""
    SingleTargetFilename: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )

    def __hash__(self):
        return id(self)

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class Container(
    StructBase,
):
    """Data structure representing a Container"""

    """Container's name"""
    Name: "str"
    """Container's mime type"""
    MIMEType: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Name": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Name}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class Kind(
    StructBase,
):
    """Data structure representing a Kind"""

    """Kind's name"""
    Name: "str"
    """Kind's rank"""
    Rank: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The Kind's parent (if present)"""
    Parent: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """List of locations that the Kind provides"""
    DefinedLocations: "TypedList[str]" = field(
        metadata={"optional": True, "default_value": lambda: []}, default=TypedListDescriptor(str)
    )
    """These are the kinds that should be looked into in order to find definitions to locations that are not present in the current document"""
    PreferredKinds: "TypedList[str]" = field(
        metadata={"optional": True, "default_value": lambda: []}, default=TypedListDescriptor(str)
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Name": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Name}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class Rank(
    StructBase,
):
    """Data structure representing a Rank"""

    """Rank's name"""
    Name: "str"
    """Rank's depth"""
    Depth: "int" = field(
        metadata={"optional": True, "default_value": lambda: 0}, default_factory=lambda: 0
    )
    """The Rank's parent (if present)"""
    Parent: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The model path corresponding to this rank."""
    TupleTreePath: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Name": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Name}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class AnalysesList(
    StructBase,
):
    """Data structure representing a list of analyses"""

    """AnalysesList's name"""
    Name: "str"
    """AnalysesList's list of analyses"""
    Analyses: "TypedList[AnalysisReference]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(AnalysisReference),
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Name": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Name}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class Analysis(
    StructBase,
):
    """Data structure representing an analysis"""

    """Analysis' name"""
    Name: "str"
    """Analysis' container inputs"""
    ContainerInputs: "TypedList[AnalysisContainerInput]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(AnalysisContainerInput),
    )
    """Analysis' options"""
    Options: "TypedList[AnalysisOption]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(AnalysisOption),
    )
    """If the analysis is available for execution"""
    Available: "bool" = field(
        metadata={"optional": True, "default_value": lambda: False}, default_factory=lambda: False
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Name": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Name}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class Step(
    StructBase,
):
    """Data structure representing a Step"""

    """Step's name"""
    Name: "str"
    """Step's component"""
    Component: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The Step's parent (if present)"""
    Parent: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """List of Analyses that the Step provides"""
    Analyses: "TypedList[Analysis]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(Analysis),
    )
    """The artifacts that this step provides"""
    Artifacts: "Artifacts" = field(
        metadata={"optional": True, "default_value": lambda: Artifacts()},
        default_factory=lambda: Artifacts(),
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Name": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Name}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class PipelineDescription(
    StructBase,
):
    """Data structure representing the structure of the pipeline"""

    SchemaVersion: ClassVar[int] = 1

    """The input's version, must match revng's schema version"""
    Version: "int" = field(
        metadata={"optional": True, "default_value": lambda: 0}, default_factory=lambda: 1
    )
    """AnalysesLists available in the pipeline"""
    AnalysesLists: "TypedList[AnalysesList]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(AnalysesList),
    )
    """List of Globals"""
    Globals: "TypedList[str]" = field(
        metadata={"optional": True, "default_value": lambda: []}, default=TypedListDescriptor(str)
    )
    """Kinds"""
    Kinds: "TypedList[Kind]" = field(
        metadata={"optional": True, "default_value": lambda: []}, default=TypedListDescriptor(Kind)
    )
    """Ranks"""
    Ranks: "TypedList[Rank]" = field(
        metadata={"optional": True, "default_value": lambda: []}, default=TypedListDescriptor(Rank)
    )
    """Containers"""
    Containers: "TypedList[Container]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(Container),
    )
    """Steps"""
    Steps: "TypedList[Step]" = field(
        metadata={"optional": True, "default_value": lambda: []}, default=TypedListDescriptor(Step)
    )

    def __post_init__(self):
        if self.Version != PipelineDescription.SchemaVersion:
            raise ValueError(
                f"Schema version is not supported, version = {self.Version}, supported version = {PipelineDescription.SchemaVersion}"
            )

    def __hash__(self):
        return id(self)

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


if sys.version_info < (3, 10, 0):
    force_kw_only(AnalysisReference)
    force_kw_only(AnalysisContainerInput)
    force_kw_only(AnalysisOption)
    force_kw_only(Artifacts)
    force_kw_only(Container)
    force_kw_only(Kind)
    force_kw_only(Rank)
    force_kw_only(AnalysesList)
    force_kw_only(Analysis)
    force_kw_only(Step)
    force_kw_only(PipelineDescription)

types_metadata: TypesMetadata = {}
types_metadata[AnalysisReference] = {
    "Step": {
        "type": str,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[AnalysisContainerInput] = {
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "AcceptableKinds": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[AnalysisOption] = {
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Type": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[Artifacts] = {
    "Kind": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Container": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "SingleTargetFilename": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[Container] = {
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "MIMEType": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[Kind] = {
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Rank": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Parent": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "DefinedLocations": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "PreferredKinds": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[Rank] = {
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Depth": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Parent": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "TupleTreePath": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[AnalysesList] = {
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Analyses": {
        "type": AnalysisReference,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[Analysis] = {
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "ContainerInputs": {
        "type": AnalysisContainerInput,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Options": {
        "type": AnalysisOption,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Available": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[Step] = {
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Component": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Parent": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Analyses": {
        "type": Analysis,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Artifacts": {
        "type": Artifacts,
        "ctor": "class",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[PipelineDescription] = {
    "Version": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "AnalysesLists": {
        "type": AnalysesList,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Globals": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Kinds": {
        "type": Kind,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Ranks": {
        "type": Rank,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Containers": {
        "type": Container,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Steps": {
        "type": Step,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
}


YamlDumper.add_representer(AnalysisReference, AnalysisReference.yaml_representer)
YamlDumper.add_representer(AnalysisContainerInput, AnalysisContainerInput.yaml_representer)
YamlDumper.add_representer(AnalysisOption, AnalysisOption.yaml_representer)
YamlDumper.add_representer(Artifacts, Artifacts.yaml_representer)
YamlDumper.add_representer(Container, Container.yaml_representer)
YamlDumper.add_representer(Kind, Kind.yaml_representer)
YamlDumper.add_representer(Rank, Rank.yaml_representer)
YamlDumper.add_representer(AnalysesList, AnalysesList.yaml_representer)
YamlDumper.add_representer(Analysis, Analysis.yaml_representer)
YamlDumper.add_representer(Step, Step.yaml_representer)
YamlDumper.add_representer(PipelineDescription, PipelineDescription.yaml_representer)

# Allows to deserialize YAML as a 'generator.root_type' even if the root of the YAML document is
# not tagged
YamlLoader.add_constructor("!PipelineDescription", PipelineDescription.yaml_constructor)
YamlLoader.add_path_resolver("!PipelineDescription", [])

DiffYamlLoader.add_constructor("!DiffSet", DiffSet.yaml_constructor)
DiffYamlLoader.add_path_resolver("!DiffSet", [])
