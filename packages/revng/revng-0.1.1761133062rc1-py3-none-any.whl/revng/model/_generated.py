# This file is distributed under the MIT License. See LICENSE.md for details.
# This file is autogenerated! Do not edit it directly
import random
import sys
from dataclasses import dataclass, field
from io import TextIOBase
from typing import ClassVar, Optional

import yaml

from revng.tupletree import (
    EnumBase,
    Reference,
    StructBase,
    AbstractStructBase,
    dataclass_kwargs,
    no_default,
    TypedList,
    TypedListDescriptor,
    force_constructor_kwarg,
    force_kw_only,
    TypesMetadata,
    DiffSet,
)
from revng.tupletree import YamlLoader as _ExternalYamlLoader
from revng.tupletree import YamlDumper as _ExternalYamlDumper
from .external import MetaAddress

from .mixins import (
    AllMixin,
    _ArtifactMixin,
    BinaryMixin,
    FunctionMixin,
    TypeDefinitionMixin,
)  # Every subclass of YamlLoader can register its own independent loaders


class YamlLoader(_ExternalYamlLoader):
    pass


# Every subclass of YamlDumper can register its own independent dumpers
class YamlDumper(_ExternalYamlDumper):
    pass


class DiffYamlLoader(YamlLoader):
    pass


class DiffYamlDumper(YamlDumper):
    pass


def random_id():
    return random.randint(2**10 + 1, 2**64 - 1)


class PrimitiveKind(EnumBase):
    Invalid = "Invalid"
    """The `void` type."""
    Void = "Void"
    """The most generic primitive kind: it can be any of the other primitive
    kinds, except for `Void`.
    """
    Generic = "Generic"
    """A kind representing either a `Number` kind or a pointer.
    This can also be seen as not-a-`Float`.
    """
    PointerOrNumber = "PointerOrNumber"
    """A two's complement integer number, either `Signed` or `Unsigned`."""
    Number = "Number"
    """An `unsigned` two's complement integer number."""
    Unsigned = "Unsigned"
    """An `signed` two's complement integer number."""
    Signed = "Signed"
    """A IEEE 754 floating point number."""
    Float = "Float"


class RelocationType(EnumBase):
    Invalid = "Invalid"
    """Write the absolute address of the object as a 32-bit integer."""
    WriteAbsoluteAddress32 = "WriteAbsoluteAddress32"
    """Write the absolute address of the object as a 64-bit integer."""
    WriteAbsoluteAddress64 = "WriteAbsoluteAddress64"
    """Add to the 32-bit integer present at the target location the absolute
    address of the object.
    """
    AddAbsoluteAddress32 = "AddAbsoluteAddress32"
    """Add to the 64-bit integer present at the target location the absolute
    address of the object.
    """
    AddAbsoluteAddress64 = "AddAbsoluteAddress64"
    """Write the address of the object as a 32-bit integer, expressed as a
    relative from the target of the relocation.
    """
    WriteRelativeAddress32 = "WriteRelativeAddress32"
    """Write the address of the object as a 64-bit integer, expressed as a
    relative from the target of the relocation.
    """
    WriteRelativeAddress64 = "WriteRelativeAddress64"
    """Add to the 32-bit integer present at the target location the address of
    the object, expressed as a relative from the target of the relocation.
    """
    AddRelativeAddress32 = "AddRelativeAddress32"
    """Add to the 32-bit integer present at the target location the address of
    the object, expressed as a relative from the target of the relocation.
    """
    AddRelativeAddress64 = "AddRelativeAddress64"


class FunctionAttribute(EnumBase):
    Invalid = "Invalid"
    """The function call does not return."""
    NoReturn = "NoReturn"
    """The function call must be inlined in the caller."""
    Inline = "Inline"


class Architecture(EnumBase):
    Invalid = "Invalid"
    x86 = "x86"
    x86_64 = "x86_64"
    arm = "arm"
    aarch64 = "aarch64"
    mips = "mips"
    mipsel = "mipsel"
    systemz = "systemz"


class ABI(EnumBase):
    Invalid = "Invalid"
    """64-bit SystemV ABI for x86 processor architecture
    ([reference](https://gitlab.com/x86-psABIs/x86-64-ABI)).
    """
    SystemV_x86_64 = "SystemV_x86_64"
    """32-bit SystemV ABI for x86 processor architecture ([reference][abi1]).
    
    [abi1]: https://gitlab.com/x86-psABIs/i386-ABI/-/tree/hjl/x86/master
    """
    SystemV_x86 = "SystemV_x86"
    """A GCC specific modification of the 32-bit SystemV ABI for x86 processor
    architecture. It allows three first GPR-sized arguments to be passed
    using the EAX, EDX, and ECX registers.
    See the reference for `regparm` x86 function attribute.
    """
    SystemV_x86_regparm_3 = "SystemV_x86_regparm_3"
    """A GCC specific modification of the 32-bit SystemV ABI for x86 processor
    architecture. It allows two first GPR-sized arguments to be passed
    using the EAX, and ECX registers.
    See the GCC documentation for `regparm` x86 function attribute.
    """
    SystemV_x86_regparm_2 = "SystemV_x86_regparm_2"
    """A GCC specific modification of the 32-bit SystemV ABI for x86 processor
    architecture. It allows the first GPR-sized argument to be passed
    using the EAX register.
    See the GCC documentation for `regparm` x86 function attribute.
    """
    SystemV_x86_regparm_1 = "SystemV_x86_regparm_1"
    """64-bit Microsoft ABI for x86 processor architecture
    ([reference][abi2]).
    
    [abi2]: https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention
    """
    Microsoft_x86_64 = "Microsoft_x86_64"
    """A modification of 64-bit Microsoft ABI for x86 processor architecture
    ([reference](https://docs.microsoft.com/en-us/cpp/cpp/vectorcall)).
    It allows using extra vector registers for passing function arguments.
    """
    Microsoft_x86_64_vectorcall = "Microsoft_x86_64_vectorcall"
    """The default 32-bit Microsoft ABI for x86 processor architecture
    ([reference](https://docs.microsoft.com/en-us/cpp/cpp/cdecl)).
    It was indented to be compatible with `SystemV_x86` but there are slight
    differences.
    """
    Microsoft_x86_cdecl = "Microsoft_x86_cdecl"
    """32-bit Microsoft x86 `cdecl` abi as implemented in GCC (subtly different
    from the original).
    """
    Microsoft_x86_cdecl_gcc = "Microsoft_x86_cdecl_gcc"
    """A modification of the 32-bit `__cdecl` Microsoft ABI for x86 processor
    architecture
    ([reference](https://docs.microsoft.com/en-us/cpp/cpp/stdcall)).
    The main difference is the fact that the callee is responsible for stack
    cleanup instead of the caller.
    """
    Microsoft_x86_stdcall = "Microsoft_x86_stdcall"
    """32-bit Microsoft x86 `stdcall` abi as implemented in GCC (subtly different
    from the original).
    """
    Microsoft_x86_stdcall_gcc = "Microsoft_x86_stdcall_gcc"
    """A modification of the 32-bit `__stdcall` Microsoft ABI for x86 processor
    architecture
    ([reference](https://docs.microsoft.com/en-us/cpp/cpp/thiscall)).
    The main difference is the fact that it allows to pass a
    single (the first) function argument using a register. This ABI is only
    used for member function call where the first argument is always a `this`
    pointer.
    """
    Microsoft_x86_thiscall = "Microsoft_x86_thiscall"
    """A modification of the 32-bit `__stdcall` Microsoft ABI for x86 processor
    architecture
    ([reference](https://docs.microsoft.com/en-us/cpp/cpp/fastcall)).
    The main difference is the fact that it allows to pass two
    first GPR-sized non-aggregate function arguments in registers.
    """
    Microsoft_x86_fastcall = "Microsoft_x86_fastcall"
    """32-bit Microsoft x86 `fastcall` abi as implemented in GCC (subtly
    different from the original).
    """
    Microsoft_x86_fastcall_gcc = "Microsoft_x86_fastcall_gcc"
    """A modification of the 32-bit `__fastcall` Microsoft ABI for x86 processor
    architecture
    ([reference](https://docs.microsoft.com/en-us/cpp/cpp/vectorcall)).
    It allows using extra vector registers for passing function arguments.
    """
    Microsoft_x86_vectorcall = "Microsoft_x86_vectorcall"
    """Stands for `Arm Architecture Procedure Call Standard (64-bit)`
    ([reference](https://github.com/ARM-software/abi-aa/releases)).
    The official ABI for AArch64 (ARM64) processor architecture.
    """
    AAPCS64 = "AAPCS64"
    """Stands for "Arm Architecture Procedure Call Standard (64-bit)".
    This represents the version of the ABI used by windows-on-arm.
    For differences from the original ABI see the [reference][ab3].
    
    [ab3]: https://learn.microsoft.com/cpp/build/arm64-windows-abi-conventions
    """
    Microsoft_AAPCS64 = "Microsoft_AAPCS64"
    """Stands for "Arm Architecture Procedure Call Standard (64-bit)".
     This represents the version of the ABI used by the apple products.
     For differences from the original ABI see the [reference](https://developer.apple.com/documentation/xcode/writing-arm64- code-for-apple-platforms).
    """
    Apple_AAPCS64 = "Apple_AAPCS64"
    """Stands for "Arm Architecture Procedure Call Standard"
    ([reference](https://github.com/ARM-software/abi-aa/releases)).
    The official ABI for ARM processor architecture.
    """
    AAPCS = "AAPCS"
    """The ABI for MIPS RISC processor architecture
    ([reference][abi4]).
    
    [abi4]: http://math-atlas.sourceforge.net/devel/assembly/mipsabi32.pdf
    """
    SystemV_MIPS_o32 = "SystemV_MIPS_o32"
    """The ABI for little-endian edition of the MIPS RISC processor architecture
    ([reference][abi5]).
    
    [abi5]: http://math-atlas.sourceforge.net/devel/assembly/mipsabi32.pdf
    """
    SystemV_MIPSEL_o32 = "SystemV_MIPSEL_o32"
    """The s390x ABI for SystemZ processor architecture
    ([reference](https://github.com/IBM/s390x-abi)).
    """
    SystemZ_s390x = "SystemZ_s390x"


class Register(EnumBase):
    Invalid = "Invalid"
    eax_x86 = "eax_x86"
    ebx_x86 = "ebx_x86"
    ecx_x86 = "ecx_x86"
    edx_x86 = "edx_x86"
    esi_x86 = "esi_x86"
    edi_x86 = "edi_x86"
    ebp_x86 = "ebp_x86"
    esp_x86 = "esp_x86"
    st0_x86 = "st0_x86"
    xmm0_x86 = "xmm0_x86"
    xmm1_x86 = "xmm1_x86"
    xmm2_x86 = "xmm2_x86"
    xmm3_x86 = "xmm3_x86"
    xmm4_x86 = "xmm4_x86"
    xmm5_x86 = "xmm5_x86"
    xmm6_x86 = "xmm6_x86"
    xmm7_x86 = "xmm7_x86"
    rax_x86_64 = "rax_x86_64"
    rbx_x86_64 = "rbx_x86_64"
    rcx_x86_64 = "rcx_x86_64"
    rdx_x86_64 = "rdx_x86_64"
    rbp_x86_64 = "rbp_x86_64"
    rsp_x86_64 = "rsp_x86_64"
    rsi_x86_64 = "rsi_x86_64"
    rdi_x86_64 = "rdi_x86_64"
    r8_x86_64 = "r8_x86_64"
    r9_x86_64 = "r9_x86_64"
    r10_x86_64 = "r10_x86_64"
    r11_x86_64 = "r11_x86_64"
    r12_x86_64 = "r12_x86_64"
    r13_x86_64 = "r13_x86_64"
    r14_x86_64 = "r14_x86_64"
    r15_x86_64 = "r15_x86_64"
    xmm0_x86_64 = "xmm0_x86_64"
    xmm1_x86_64 = "xmm1_x86_64"
    xmm2_x86_64 = "xmm2_x86_64"
    xmm3_x86_64 = "xmm3_x86_64"
    xmm4_x86_64 = "xmm4_x86_64"
    xmm5_x86_64 = "xmm5_x86_64"
    xmm6_x86_64 = "xmm6_x86_64"
    xmm7_x86_64 = "xmm7_x86_64"
    fs_x86_64 = "fs_x86_64"
    r0_arm = "r0_arm"
    r1_arm = "r1_arm"
    r2_arm = "r2_arm"
    r3_arm = "r3_arm"
    r4_arm = "r4_arm"
    r5_arm = "r5_arm"
    r6_arm = "r6_arm"
    r7_arm = "r7_arm"
    r8_arm = "r8_arm"
    r9_arm = "r9_arm"
    r10_arm = "r10_arm"
    r11_arm = "r11_arm"
    r12_arm = "r12_arm"
    r13_arm = "r13_arm"
    r14_arm = "r14_arm"
    r15_arm = "r15_arm"
    q0_arm = "q0_arm"
    q1_arm = "q1_arm"
    q2_arm = "q2_arm"
    q3_arm = "q3_arm"
    q4_arm = "q4_arm"
    q5_arm = "q5_arm"
    q6_arm = "q6_arm"
    q7_arm = "q7_arm"
    x0_aarch64 = "x0_aarch64"
    x1_aarch64 = "x1_aarch64"
    x2_aarch64 = "x2_aarch64"
    x3_aarch64 = "x3_aarch64"
    x4_aarch64 = "x4_aarch64"
    x5_aarch64 = "x5_aarch64"
    x6_aarch64 = "x6_aarch64"
    x7_aarch64 = "x7_aarch64"
    x8_aarch64 = "x8_aarch64"
    x9_aarch64 = "x9_aarch64"
    x10_aarch64 = "x10_aarch64"
    x11_aarch64 = "x11_aarch64"
    x12_aarch64 = "x12_aarch64"
    x13_aarch64 = "x13_aarch64"
    x14_aarch64 = "x14_aarch64"
    x15_aarch64 = "x15_aarch64"
    x16_aarch64 = "x16_aarch64"
    x17_aarch64 = "x17_aarch64"
    x18_aarch64 = "x18_aarch64"
    x19_aarch64 = "x19_aarch64"
    x20_aarch64 = "x20_aarch64"
    x21_aarch64 = "x21_aarch64"
    x22_aarch64 = "x22_aarch64"
    x23_aarch64 = "x23_aarch64"
    x24_aarch64 = "x24_aarch64"
    x25_aarch64 = "x25_aarch64"
    x26_aarch64 = "x26_aarch64"
    x27_aarch64 = "x27_aarch64"
    x28_aarch64 = "x28_aarch64"
    x29_aarch64 = "x29_aarch64"
    lr_aarch64 = "lr_aarch64"
    sp_aarch64 = "sp_aarch64"
    v0_aarch64 = "v0_aarch64"
    v1_aarch64 = "v1_aarch64"
    v2_aarch64 = "v2_aarch64"
    v3_aarch64 = "v3_aarch64"
    v4_aarch64 = "v4_aarch64"
    v5_aarch64 = "v5_aarch64"
    v6_aarch64 = "v6_aarch64"
    v7_aarch64 = "v7_aarch64"
    v8_aarch64 = "v8_aarch64"
    v9_aarch64 = "v9_aarch64"
    v10_aarch64 = "v10_aarch64"
    v11_aarch64 = "v11_aarch64"
    v12_aarch64 = "v12_aarch64"
    v13_aarch64 = "v13_aarch64"
    v14_aarch64 = "v14_aarch64"
    v15_aarch64 = "v15_aarch64"
    v16_aarch64 = "v16_aarch64"
    v17_aarch64 = "v17_aarch64"
    v18_aarch64 = "v18_aarch64"
    v19_aarch64 = "v19_aarch64"
    v20_aarch64 = "v20_aarch64"
    v21_aarch64 = "v21_aarch64"
    v22_aarch64 = "v22_aarch64"
    v23_aarch64 = "v23_aarch64"
    v24_aarch64 = "v24_aarch64"
    v25_aarch64 = "v25_aarch64"
    v26_aarch64 = "v26_aarch64"
    v27_aarch64 = "v27_aarch64"
    v28_aarch64 = "v28_aarch64"
    v29_aarch64 = "v29_aarch64"
    v30_aarch64 = "v30_aarch64"
    v31_aarch64 = "v31_aarch64"
    v0_mips = "v0_mips"
    v1_mips = "v1_mips"
    a0_mips = "a0_mips"
    a1_mips = "a1_mips"
    a2_mips = "a2_mips"
    a3_mips = "a3_mips"
    s0_mips = "s0_mips"
    s1_mips = "s1_mips"
    s2_mips = "s2_mips"
    s3_mips = "s3_mips"
    s4_mips = "s4_mips"
    s5_mips = "s5_mips"
    s6_mips = "s6_mips"
    s7_mips = "s7_mips"
    t0_mips = "t0_mips"
    t1_mips = "t1_mips"
    t2_mips = "t2_mips"
    t3_mips = "t3_mips"
    t4_mips = "t4_mips"
    t5_mips = "t5_mips"
    t6_mips = "t6_mips"
    t7_mips = "t7_mips"
    t8_mips = "t8_mips"
    t9_mips = "t9_mips"
    gp_mips = "gp_mips"
    sp_mips = "sp_mips"
    fp_mips = "fp_mips"
    ra_mips = "ra_mips"
    f0_mips = "f0_mips"
    f1_mips = "f1_mips"
    f2_mips = "f2_mips"
    f3_mips = "f3_mips"
    f4_mips = "f4_mips"
    f5_mips = "f5_mips"
    f6_mips = "f6_mips"
    f7_mips = "f7_mips"
    f8_mips = "f8_mips"
    f9_mips = "f9_mips"
    f10_mips = "f10_mips"
    f11_mips = "f11_mips"
    f12_mips = "f12_mips"
    f13_mips = "f13_mips"
    f14_mips = "f14_mips"
    f15_mips = "f15_mips"
    f16_mips = "f16_mips"
    f17_mips = "f17_mips"
    f18_mips = "f18_mips"
    f19_mips = "f19_mips"
    f20_mips = "f20_mips"
    f21_mips = "f21_mips"
    f22_mips = "f22_mips"
    f23_mips = "f23_mips"
    f24_mips = "f24_mips"
    f25_mips = "f25_mips"
    f26_mips = "f26_mips"
    f27_mips = "f27_mips"
    f28_mips = "f28_mips"
    f29_mips = "f29_mips"
    f30_mips = "f30_mips"
    f31_mips = "f31_mips"
    r0_systemz = "r0_systemz"
    r1_systemz = "r1_systemz"
    r2_systemz = "r2_systemz"
    r3_systemz = "r3_systemz"
    r4_systemz = "r4_systemz"
    r5_systemz = "r5_systemz"
    r6_systemz = "r6_systemz"
    r7_systemz = "r7_systemz"
    r8_systemz = "r8_systemz"
    r9_systemz = "r9_systemz"
    r10_systemz = "r10_systemz"
    r11_systemz = "r11_systemz"
    r12_systemz = "r12_systemz"
    r13_systemz = "r13_systemz"
    r14_systemz = "r14_systemz"
    r15_systemz = "r15_systemz"
    f0_systemz = "f0_systemz"
    f1_systemz = "f1_systemz"
    f2_systemz = "f2_systemz"
    f3_systemz = "f3_systemz"
    f4_systemz = "f4_systemz"
    f5_systemz = "f5_systemz"
    f6_systemz = "f6_systemz"
    f7_systemz = "f7_systemz"
    f8_systemz = "f8_systemz"
    f9_systemz = "f9_systemz"
    f10_systemz = "f10_systemz"
    f11_systemz = "f11_systemz"
    f12_systemz = "f12_systemz"
    f13_systemz = "f13_systemz"
    f14_systemz = "f14_systemz"
    f15_systemz = "f15_systemz"


class DisassemblyConfigurationImmediateStyle(EnumBase):
    Invalid = "Invalid"
    """Print immediate values as decimal, for example `42`."""
    Decimal = "Decimal"
    """Print immediate values as c-style hexadecimal, for example `0x2a`."""
    CHexadecimal = "CHexadecimal"
    """Print immediate values as asm-style hexadecimal, for example `02ah`."""
    AsmHexadecimal = "AsmHexadecimal"


class DisassemblyConfigurationAddressStyle(EnumBase):
    Invalid = "Invalid"
    """Look for the addresses among basic blocks and functions.
    When a match is found, replace the addresses with relevant labels.
    Otherwise, prints an absolute address instead.
    """
    Smart = "Smart"
    """Same as `Smart`, except when unable to single out the target,
    print a PC-relative address instead.
    """
    SmartWithPCRelativeFallback = "SmartWithPCRelativeFallback"
    """Same as `Smart`, except when unable to single out the target,
    print an error token.
    """
    Strict = "Strict"
    """Convert PC relative addresses into global representation."""
    Global = "Global"
    """Print all the addresses exactly how disassembler emitted them
    in PC-relative mode.
    """
    PCRelative = "PCRelative"


class TypeDefinitionKind(EnumBase):
    Invalid = "Invalid"
    CABIFunctionDefinition = "CABIFunctionDefinition"
    EnumDefinition = "EnumDefinition"
    RawFunctionDefinition = "RawFunctionDefinition"
    TypedefDefinition = "TypedefDefinition"
    StructDefinition = "StructDefinition"
    UnionDefinition = "UnionDefinition"


class TypeKind(EnumBase):
    Invalid = "Invalid"
    PrimitiveType = "PrimitiveType"
    PointerType = "PointerType"
    DefinedType = "DefinedType"
    ArrayType = "ArrayType"


@dataclass(**dataclass_kwargs)
class Type(AbstractStructBase, AllMixin):
    """A type such as an array, a pointer, a primitive or a defined type."""

    """Specifies which of the children classes this object is upcastable to."""
    Kind: "TypeKind"
    """Specifies whether the type this object denotes is `const` or not."""
    IsConst: "bool" = field(
        metadata={"optional": True, "default_value": lambda: False}, default_factory=lambda: False
    )

    def __hash__(self):
        return id(self)

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class BinaryIdentifier(StructBase, AllMixin):
    """Information needed to identify a single binary in the project"""

    """The identifier index"""
    Index: "int"
    """The sha256 hash of the binary (in hexadecimal)"""
    Hash: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The size of the binary (in bytes)"""
    Size: "int" = field(
        metadata={"optional": True, "default_value": lambda: 0}, default_factory=lambda: 0
    )
    """The binary's filename at the time when it was imported. This is kept
    as an heuristic to re-search the file if it is missing.
    """
    Name: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Index": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Index}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class TypeDefinition(AbstractStructBase, TypeDefinitionMixin):
    """Base data structure for all the type definitions.

    A type definition differs from a `Type` in the fact that it has an identity.
    In fact, while two identical instances of `Type` can be considered to be the
    same `Type`, two instances of a `TypeDefinition` that only differ from their
    `ID` are two distinct types.

    A type definition can be a `struct`, a `union`, a `typedef`, an `enum` or a
    function prototype.
    """

    """A unique numeric identifier for this type."""
    ID: "int" = field(default_factory=random_id)
    """Specifies which of the children classes this object is upcastable to."""
    Kind: "TypeDefinitionKind"
    """A user-chosen identifier for this type."""
    Name: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """A comment attached to the *definition* of this type."""
    Comment: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"ID": parts[0], "Kind": parts[1]}

    keyed = True

    def key(self):
        return f"{self.ID}-{self.Kind}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class CanonicalRegisterValue(StructBase, AllMixin):
    """A [`Segment`](#Segment) can specify a set of *canonical values* for certain
    registers.
    This can be used to represent concepts such as the global pointer, which in
    certain ABIs, is not set by each function, but it's possible to assume it has
    a certain value at the entry of the function.
    """

    """The register for which to specify the canonical value."""
    Register: "Register"
    """The canonical value that `Register` can be assumed to hold upon
    function entry.
    """
    Value: "int" = field(
        metadata={"optional": True, "default_value": lambda: 0}, default_factory=lambda: 0
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Register": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Register}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class DisassemblyConfiguration(StructBase, AllMixin):
    """The subset of configuration options dedicated to the disassembly view."""

    """When set to `true`, the addresses of the instructions are not present
    in the disassembly view.
    
    ```
    400df8:    fd 7b bd a9    stp x29, x30, [sp, #-0x30]!
    400dfc:    fd 03 00 91    mov x29, sp
    -----------
    ^
    This part
    ```
    """
    DisableEmissionOfInstructionAddress: "bool" = field(
        metadata={"optional": True, "default_value": lambda: False}, default_factory=lambda: False
    )
    """When set to `true`, the raw bytes of the instructions are not present
    in the disassembly view.
    
    ```
    400df8:    fd 7b bd a9    stp x29, x30, [sp, #-0x30]!
    400dfc:    fd 03 00 91    mov x29, sp
               ---------------
               ^
               This part
    ```
    """
    DisableEmissionOfRawBytes: "bool" = field(
        metadata={"optional": True, "default_value": lambda: False}, default_factory=lambda: False
    )
    """When set to `true`, ATT syntax is used.
    
    `true`:
    ```
    80491a0:    83 c4 10             addl $0x10, %esp
    80491a3:    8b 5d fc             movl -0x4(%ebp), %ebx
    80491a6:    c9                   leave
    80491a7:    e9 ec fe ff ff       jmp bb_0x8049098
    ```
    
    `false` (default):
    ```
    80491a0:    83 c4 10             add esp, 0x10
    80491a3:    8b 5d fc             mov ebx, dword ptr [ebp - 0x4]
    80491a6:    c9                   leave
    80491a7:    e9 ec fe ff ff       jmp bb_0x8049098
    ```
    
    Note that this option has no effect on non-x86 binaries.
    """
    UseX86ATTSyntax: "bool" = field(
        metadata={"optional": True, "default_value": lambda: False}, default_factory=lambda: False
    )
    """This describes the way labels / addresses should be printed in
    the disassembly view.
    See the related enum for further explanation and examples.
    """
    AddressStyle: "DisassemblyConfigurationAddressStyle" = field(
        metadata={"optional": True, "default_value": lambda: "Smart"},
        default_factory=lambda: "Smart",
    )
    """This describes the way immediate values are printed in
    the disassembly view.
    See the related enum for further explanation and examples.
    
    The default value is `CHexadecimal`.
    """
    ImmediateStyle: "DisassemblyConfigurationImmediateStyle" = field(
        metadata={"optional": True, "default_value": lambda: "CHexadecimal"},
        default_factory=lambda: "CHexadecimal",
    )
    """Set this to true to include the full meta-address whenever one is printed.
    The default value of `false` omits the address type as long as it matches
    that of the binary.
    
    `true`:
    ```
    80491a7_Code_x86:    e9 ec fe ff ff       jmp bb_0x8049098_Code_x86
    ```
    `false` (default):
    ```
    80491a7:    e9 ec fe ff ff       jmp bb_0x8049098
    ```
    """
    PrintFullMetaAddress: "bool" = field(
        metadata={"optional": True, "default_value": lambda: False}, default_factory=lambda: False
    )
    """The prefix attached to the basic block address in the disassembly views.
    
    `my_value_`:
    ```
    80491a7:    e9 ec fe ff ff       jmp my_value_0x8049098
    ```
    default:
    ```
    80491a7:    e9 ec fe ff ff       jmp bb_0x8049098
    ```
    """
    BasicBlockPrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "bb_"}, default_factory=lambda: "bb_"
    )

    def __hash__(self):
        return id(self)

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class NamingConfiguration(StructBase, AllMixin):
    """Subset of configuration options dedicated to naming rules, mostly (but not
    exclusively) centered around reserved name prefixes.
    """

    """The prefix for a segment without a name."""
    UnnamedSegmentPrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "segment_"},
        default_factory=lambda: "segment_",
    )
    """The prefix for a dynamic function with an invalid name."""
    UnnamedDynamicFunctionPrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "dynamic_function_"},
        default_factory=lambda: "dynamic_function_",
    )
    """The prefix for a local function without a name."""
    UnnamedFunctionPrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "function_"},
        default_factory=lambda: "function_",
    )
    """The prefix for a type definition without a name.
    
    Note that the type kind (like `struct`, or `typedef`) is going to be
    inserted automatically after this prefix.
    """
    UnnamedTypeDefinitionPrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The prefix for an enum entry without a name."""
    UnnamedEnumEntryPrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "enum_entry_"},
        default_factory=lambda: "enum_entry_",
    )
    """The prefix for a struct field without a name."""
    UnnamedStructFieldPrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "offset_"},
        default_factory=lambda: "offset_",
    )
    """The prefix for a union member without a name."""
    UnnamedUnionFieldPrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "member_"},
        default_factory=lambda: "member_",
    )
    """The prefix for a cabi function argument without a name."""
    UnnamedFunctionArgumentPrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "argument_"},
        default_factory=lambda: "argument_",
    )
    """The prefix for a raw function register without a name."""
    UnnamedFunctionRegisterPrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "register_"},
        default_factory=lambda: "register_",
    )
    """The prefix for a local variable without a name."""
    UnnamedLocalVariablePrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "var_"}, default_factory=lambda: "var_"
    )
    """The prefix for a local variable without a name."""
    UnnamedBreakFromLoopVariablePrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "break_from_loop_"},
        default_factory=lambda: "break_from_loop_",
    )
    """The prefix for a goto label without a name."""
    UnnamedGotoLabelPrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "label_"},
        default_factory=lambda: "label_",
    )
    """The prefix for accessing an opaque CSV Value."""
    OpaqueCSVValuePrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "revng_undefined_"},
        default_factory=lambda: "revng_undefined_",
    )
    """The prefix for the maximum enum value."""
    MaximumEnumValuePrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "enum_max_value_"},
        default_factory=lambda: "enum_max_value_",
    )
    """The name of the variable representing stack."""
    StackFrameVariableName: "str" = field(
        metadata={"optional": True, "default_value": lambda: "stack"},
        default_factory=lambda: "stack",
    )
    """The name of the variable representing stack."""
    RawStackArgumentName: "str" = field(
        metadata={"optional": True, "default_value": lambda: "stack_arguments"},
        default_factory=lambda: "stack_arguments",
    )
    """The name of the variable representing stack."""
    LoopStateVariableName: "str" = field(
        metadata={"optional": True, "default_value": lambda: "loop_state_var"},
        default_factory=lambda: "loop_state_var",
    )
    """The prefix for a padding struct field."""
    StructPaddingPrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "padding_at_"},
        default_factory=lambda: "padding_at_",
    )
    """The prefix for an artificial raw function return value."""
    ArtificialReturnValuePrefix: "str" = field(
        metadata={"optional": True, "default_value": lambda: "artificial_struct_returned_by_"},
        default_factory=lambda: "artificial_struct_returned_by_",
    )
    """When this is set to `true`, all the names starting with underscores will
    be replaced by an automatic name.
    """
    ReserveNamesStartingWithUnderscore: "bool" = field(
        metadata={"optional": True, "default_value": lambda: False}, default_factory=lambda: False
    )

    def __hash__(self):
        return id(self)

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class Relocation(StructBase, AllMixin):
    """A relocation, i.e., a directive to write the address of an object (a
    `DynamicFunction` or a `Segment`) at a specific address.
    Optionally, the address of the object can be modified with a constant offset.
    """

    """Where to write the address of the object."""
    Address: "MetaAddress"
    """How to write the address of the object (e.g., 32-bit vs 64-bit
    integer).
    """
    Type: "RelocationType"
    """Fixed offset to add when writing the address of the object."""
    Addend: "int" = field(
        metadata={"optional": True, "default_value": lambda: 0}, default_factory=lambda: 0
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Address": parts[0], "Type": parts[1]}

    keyed = True

    def key(self):
        return f"{self.Address}-{self.Type}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class EnumEntry(StructBase, AllMixin):
    """An entry in an `enum`."""

    """The value associated to this `enum` entry.
    
    Has to be unique within the `enum`.
    """
    Value: "int"
    """A user-chosen identifier for this `enum` entry."""
    Name: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """A comment that will be emitted right before the *definition* of this
    `enum` entry.
    """
    Comment: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Value": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Value}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class LocalIdentifier(StructBase, AllMixin):
    """The common type for attaching metadata (like names) to function-local
    identifiers (like variables and labels).
    """

    """The user-provided name for this variable or label."""
    Name: "str"
    """The set of `MetaAddress`es of the instructions using this variable (or label)."""
    Location: "TypedList[MetaAddress]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(MetaAddress),
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Name": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Name}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class StatementComment(StructBase, AllMixin):
    """A comment that can be attached to a statement in the decompiled code
    *if* we have a way to uniquely identify said statement.
    """

    """The index of the comment."""
    Index: "int"
    """The point this comment is attached to, encoded as a set of addresses.
    
    When emitted artifact contains a statement with a set of addresses exactly
    matching the set provided here, the comment is emitted before that
    statement.
    
    If there's no such statement, one is chosen based on how similar its
    address set is to the address set of the comment.
    
    Note that the same comment can be emitted multiple times if there are
    multiple statements (that do *not* dominate each other) with the same
    address set.
    """
    Location: "TypedList[MetaAddress]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(MetaAddress),
    )
    """The text of the comment."""
    Body: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Index": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Index}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class Argument(StructBase, AllMixin):
    """The argument of a `CABIFunctionType`."""

    """The argument index."""
    Index: "int"
    """The type of the argument."""
    Type: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )
    """The name of the argument."""
    Name: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """A comment that will be emitted as part of this function's definition
    in the `\\param ${NAME} ${COMMENT}` shape.
    """
    Comment: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Index": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Index}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class ArrayType(Type, StructBase, AllMixin):
    """An array of `Type`s."""

    """The number of elements in this array."""
    ElementCount: "int" = field(
        metadata={"optional": True, "default_value": lambda: -1}, default_factory=lambda: -1
    )
    """The type of the elements in this array."""
    ElementType: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )

    def __hash__(self):
        return id(self)

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class CallSitePrototype(StructBase, AllMixin):
    """Information about the prototype of a specific callsite within a `Function`."""

    """Address of the basic block of the call."""
    CallerBlockAddress: "MetaAddress"
    """The prototype specific to *this* call site."""
    Prototype: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )
    """Whether this call site is a tail call or not."""
    IsTailCall: "bool" = field(
        metadata={"optional": True, "default_value": lambda: False}, default_factory=lambda: False
    )
    """Attributes for this call site."""
    Attributes: "TypedList[FunctionAttribute]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(FunctionAttribute),
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"CallerBlockAddress": parts[0]}

    keyed = True

    def key(self):
        return f"{self.CallerBlockAddress}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class NamedTypedRegister(StructBase, AllMixin):
    """An argument or a return value in a `RawFunctionDefinition`.

    It is basically a pair of a register and a `Type`.
    """

    """The register this argument or return value is created for."""
    Location: "Register"
    """The type of this argument or return value."""
    Type: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )
    """The name for this argument or return value."""
    Name: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The comment for this argument or return value."""
    Comment: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Location": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Location}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class PointerType(Type, StructBase, AllMixin):
    """A pointer type."""

    """The size of the pointer.
    
    As of now, only 4 and 8 byte pointers are supported.
    """
    PointerSize: "int" = field(
        metadata={"optional": True, "default_value": lambda: -1}, default_factory=lambda: -1
    )
    """The pointee type."""
    PointeeType: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )

    def __hash__(self):
        return id(self)

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class PrimitiveType(Type, StructBase, AllMixin):
    """A Primitive type defined by its kind (signed, float, etc) and size."""

    """Specifies whether this primitive type is `Signed`, `Float`,
    `PointerOrNumber`, and so on.
    """
    PrimitiveKind: "PrimitiveKind" = field(
        metadata={"optional": True, "default_value": lambda: "Invalid"},
        default_factory=lambda: "Invalid",
    )
    """Specifies the size of this primitive type.
    
    As of now, supported sizes include
    ```
    { 1, 2, 4, 8, 16 }
    ```
    
    Note that *only* floating point primitives (and `Generic` primitives,
    whose kind is not known, so they are assumed to be floating point
    compatible) can also have additional sizes:
    ```
    { 10, 12 }
    ```
    
    Note that 1-byte floating point primitives are not allowed.
    
    Note that `Void` *must* have size of 0.
    """
    Size: "int" = field(
        metadata={"optional": True, "default_value": lambda: -1}, default_factory=lambda: -1
    )

    def __hash__(self):
        return id(self)

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class StructField(StructBase, AllMixin):
    """A field of a `StructDefinition`.

    It is composed by the offset of the field and its type.
    """

    """The number of bytes in the given struct before this field."""
    Offset: "int"
    """The name of this field."""
    Name: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The comment that will be emitted before this field's *definition*."""
    Comment: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The type of the field."""
    Type: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Offset": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Offset}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class UnionField(StructBase, AllMixin):
    """Specifies one of the possible types a given `UnionDefinition` can assume.

    It is composed by a index and the `Type`.
    """

    """A numeric index unique within a given `UnionDefinition`.
    
    Note that indexing is dense, so if a given union has a type with
    index 4, it must also have types indexed 0-3.
    """
    Index: "int"
    """The name of this "field" (union alternative)."""
    Name: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The comment that will be emitted right before the *definition*
    of the given "field" (union alternative).
    """
    Comment: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The name of this "field" (union alternative)."""
    Type: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Index": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Index}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class DefinedType(Type, StructBase, AllMixin):
    """A reference to a `TypeDefinition`."""

    """The definition of the type this object represents."""
    Definition: "Reference[TypeDefinition, Binary]" = field(
        metadata={"optional": True, "default_value": lambda: ""},
        default_factory=lambda: Reference(""),
    )

    def __hash__(self):
        return id(self)

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class TypedefDefinition(TypeDefinition, StructBase, AllMixin):
    """A `typedef` type.

    Note, that unlike in C, in our type system two `typedef`s aliasing
    the same type are actually distinct types.
    """

    """The type this `typedef` is aliasing."""
    UnderlyingType: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"ID": parts[0], "Kind": parts[1]}

    keyed = True

    def key(self):
        return f"{self.ID}-{self.Kind}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class Configuration(StructBase, AllMixin):
    """A list of configuration options"""

    """The options specific to the disassembly artifact."""
    Disassembly: "DisassemblyConfiguration" = field(
        metadata={"optional": True, "default_value": lambda: DisassemblyConfiguration()},
        default_factory=lambda: DisassemblyConfiguration(),
    )
    """The options specific to the naming conventions"""
    Naming: "NamingConfiguration" = field(
        metadata={"optional": True, "default_value": lambda: NamingConfiguration()},
        default_factory=lambda: NamingConfiguration(),
    )
    """Sets a recommended comment line width to improve their readability.
    
    Set to `-1` for unlimited line size.
    """
    CommentLineWidth: "int" = field(
        metadata={"optional": True, "default_value": lambda: 80}, default_factory=lambda: 80
    )

    def __hash__(self):
        return id(self)

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class DynamicFunction(StructBase, AllMixin):
    """A function defined in a dynamic library."""

    """The name of the symbol for this dynamic function.
    
    Currently, this must not contain `/`s and `\\n`s. This restriction will
    eventually be lifted, when proper escaping is in place.
    """
    Name: "str"
    """The user-provided comment for this dynamic function."""
    Comment: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The prototype of this dynamic function."""
    Prototype: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )
    """The attributes of this dynamic function."""
    Attributes: "TypedList[FunctionAttribute]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(FunctionAttribute),
    )
    """A list of locations where the address of this dynamic function should
    be placed.
    """
    Relocations: "TypedList[Relocation]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(Relocation),
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Name": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Name}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class Segment(StructBase, AllMixin):
    """A segment contains the information necessary for rev.ng to load the executable
    in memory.
    """

    """The address at which this segment should be loaded."""
    StartAddress: "MetaAddress"
    """The size of this segment in memory.
    
    If this value is greater than `FileSize`, the discrepancy is considered to
    full of `0`s.
    """
    VirtualSize: "int"
    """The binary from where the segment is loaded from."""
    Binary: "Reference[BinaryIdentifier, Binary]" = field(
        metadata={"optional": True, "default_value": lambda: ""},
        default_factory=lambda: Reference(""),
    )
    """Start file offset from which the segment will be loaded."""
    StartOffset: "int" = field(
        metadata={"optional": True, "default_value": lambda: 0}, default_factory=lambda: 0
    )
    """Number of bytes that will be loaded in memory from the file."""
    FileSize: "int" = field(
        metadata={"optional": True, "default_value": lambda: 0}, default_factory=lambda: 0
    )
    """Is this segment readable?"""
    IsReadable: "bool" = field(
        metadata={"optional": True, "default_value": lambda: False}, default_factory=lambda: False
    )
    """Is this segment writable?"""
    IsWriteable: "bool" = field(
        metadata={"optional": True, "default_value": lambda: False}, default_factory=lambda: False
    )
    """Is this segment executable?"""
    IsExecutable: "bool" = field(
        metadata={"optional": True, "default_value": lambda: False}, default_factory=lambda: False
    )
    """The name of the segment."""
    Name: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The comment to emit right before the global variable that will be
    created for this segment.
    """
    Comment: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The list of registers that are assumed to have a canonical value set
    upon an entry into a function contained within this segment.
    """
    CanonicalRegisterValues: "TypedList[CanonicalRegisterValue]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(CanonicalRegisterValue),
    )
    """A list of locations where the address of this segment should be
    placed.
    """
    Relocations: "TypedList[Relocation]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(Relocation),
    )
    """The struct type associated to this segment.
    Informally, each field of such a `struct` is a global variable.
    """
    Type: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"StartAddress": parts[0], "VirtualSize": parts[1]}

    keyed = True

    def key(self):
        return f"{self.StartAddress}-{self.VirtualSize}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class EnumDefinition(TypeDefinition, StructBase, AllMixin):
    """An `enum` type definition."""

    """The underlying type of the `enum`.
    
    This must only ever be set to a `PrimitiveType` with either
    an `Unsigned` or a `Signed` kind.
    """
    UnderlyingType: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )
    """The entries of the `enum`.
    
    There can be no two entries associated to the same value.
    """
    Entries: "TypedList[EnumEntry]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(EnumEntry),
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"ID": parts[0], "Kind": parts[1]}

    keyed = True

    def key(self):
        return f"{self.ID}-{self.Kind}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class CABIFunctionDefinition(TypeDefinition, StructBase, AllMixin):
    """The function type described through a C-like prototype plus an ABI.

    This is an "high level" representation of the prototype of a function. It is
    expressed as list of arguments composed by an index and a type. No
    information about the register is embedded. That information is implicit in
    the ABI this type is associated to.

    In contrast, a `RawFunctionType` is not associated to any ABI and explicitly
    describes, among other things, what registers are used to pass arguments and
    return values.
    """

    """The C ABI associated to this function type."""
    ABI: "ABI" = field(
        metadata={"optional": True, "default_value": lambda: "Invalid"},
        default_factory=lambda: "Invalid",
    )
    """The function return type."""
    ReturnType: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )
    """A comment that will be emitted as part of this function's definiktion
    in the `\\returns ${COMMENT_TEXT}` shape.
    """
    ReturnValueComment: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The list of formal arguments of the function type."""
    Arguments: "TypedList[Argument]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(Argument),
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"ID": parts[0], "Kind": parts[1]}

    keyed = True

    def key(self):
        return f"{self.ID}-{self.Kind}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class Function(StructBase, FunctionMixin):
    """A function defined within this binary."""

    """The address of the entry point.
    
    Note: this does not necessarily correspond to the address of the basic
    block with the lowest address.
    """
    Entry: "MetaAddress"
    """The user-provided name for this function."""
    Name: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The user-provided comment for this function."""
    Comment: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The type of the stack frame."""
    StackFrameType: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )
    """The prototype of the function."""
    Prototype: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )
    """Attributes for *every* call site."""
    Attributes: "TypedList[FunctionAttribute]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(FunctionAttribute),
    )
    """Information about specific call sites within this function."""
    CallSitePrototypes: "TypedList[CallSitePrototype]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(CallSitePrototype),
    )
    """The list of names used to make this function available as a dynamic
    symbol.
    """
    ExportedNames: "TypedList[str]" = field(
        metadata={"optional": True, "default_value": lambda: []}, default=TypedListDescriptor(str)
    )
    """The list of comments attached to statements (e.g., disassembled
    instructions or C statements) within the body of this function.
    """
    Comments: "TypedList[StatementComment]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(StatementComment),
    )
    """The list of *named* local variables within this function's body."""
    LocalVariables: "TypedList[LocalIdentifier]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(LocalIdentifier),
    )
    """The list of *named* goto labels within this function's body."""
    GotoLabels: "TypedList[LocalIdentifier]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(LocalIdentifier),
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"Entry": parts[0]}

    keyed = True

    def key(self):
        return f"{self.Entry}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class RawFunctionDefinition(TypeDefinition, StructBase, AllMixin):
    """The function type described by explicitly listing how arguments and return
    values are passed.

    This is a "low level" representation of the prototype of a function. Where
    the list of registers used to pass arguments and return values is explicitl.
    For stack arguments, they are collected in a single `struct`
    (`StackArgumentsType`).

    In contrast, a `CABIFunctionDefinition` expresses the function type from a
    high-level perspective (e.g., a single argument might span multiple registers)
    and his associated to a well-known ABI. Given an ABI, it is always possible
    to convert a `CABIFunctionDefinition` into a `RawFunctionDefinition`.
    """

    """The processor architecture of this function type."""
    Architecture: "Architecture" = field(
        metadata={"optional": True, "default_value": lambda: "Invalid"},
        default_factory=lambda: "Invalid",
    )
    """The list of registers used to pass arguments.
    
    The registers must belong to the `Architecture`.
    """
    Arguments: "TypedList[NamedTypedRegister]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(NamedTypedRegister),
    )
    """The list of registers used to return values.
    
    The registers must belong to the `Architecture`.
    """
    ReturnValues: "TypedList[NamedTypedRegister]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(NamedTypedRegister),
    )
    """A comment that will be emitted as part of this function's definition
    in the `\\returns ${COMMENT}` shape.
    """
    ReturnValueComment: "str" = field(
        metadata={"optional": True, "default_value": lambda: ""}, default_factory=lambda: ""
    )
    """The list of registers preserved by functions using this function type.
    
    The registers must belong to `Architecture`.
    """
    PreservedRegisters: "TypedList[Register]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(Register),
    )
    """The expected difference between the initial and final value of the stack
    pointer.
    
    For instance, in the x86-64 SystemV ABI, the difference between the
    initial and final value of the stack pointer is 8.
    This is due to the fact that `ret` instruction increase the stack pointer
    by 8.
    """
    FinalStackOffset: "int" = field(
        metadata={"optional": True, "default_value": lambda: 0}, default_factory=lambda: 0
    )
    """The type of the `struct` representing all of the stack arguments."""
    StackArgumentsType: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"ID": parts[0], "Kind": parts[1]}

    keyed = True

    def key(self):
        return f"{self.ID}-{self.Kind}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class StructDefinition(TypeDefinition, StructBase, AllMixin):
    """A `struct` type."""

    """The size, in bytes, of the `struct`."""
    Size: "int" = field(
        metadata={"optional": True, "default_value": lambda: 0}, default_factory=lambda: 0
    )
    """When this field is set to `true` *and* this `struct` is reachable for
    a segment's root type without traversing pointer, arrays or other
    qualifiers, the padding of the struct is treated at if it contains code.
    """
    CanContainCode: "bool" = field(
        metadata={"optional": True, "default_value": lambda: False}, default_factory=lambda: False
    )
    """The list of fields of this `struct`."""
    Fields: "TypedList[StructField]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(StructField),
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"ID": parts[0], "Kind": parts[1]}

    keyed = True

    def key(self):
        return f"{self.ID}-{self.Kind}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class UnionDefinition(TypeDefinition, StructBase, AllMixin):
    """A `union` type."""

    """The list of alternative types in this `union`."""
    Fields: "TypedList[UnionField]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(UnionField),
    )

    def __hash__(self):
        return id(self)

    @staticmethod
    def parse_key(key):
        parts = key.split("-")
        return {"ID": parts[0], "Kind": parts[1]}

    keyed = True

    def key(self):
        return f"{self.ID}-{self.Kind}"

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


@dataclass(**dataclass_kwargs)
class Binary(StructBase, BinaryMixin):
    """Data structure representing the whole binary.
    This is the entry point of the model.
    It contains the type system (`TypeDefinitions`),
    the list of functions (`Functions`), loading information (`Segments`),
    and more.
    """

    SchemaVersion: ClassVar[int] = 7

    """The input's version, must match revng's schema version"""
    Version: "int" = field(
        metadata={"optional": True, "default_value": lambda: 0}, default_factory=lambda: 7
    )
    """The architecture for this binary."""
    Architecture: "Architecture" = field(
        metadata={"optional": True, "default_value": lambda: "Invalid"},
        default_factory=lambda: "Invalid",
    )
    """The program entry point, if any."""
    EntryPoint: "MetaAddress" = field(
        metadata={"optional": True, "default_value": lambda: MetaAddress()},
        default_factory=lambda: MetaAddress(),
    )
    """The default ABI to adopt for analysis purposes."""
    DefaultABI: "ABI" = field(
        metadata={"optional": True, "default_value": lambda: "Invalid"},
        default_factory=lambda: "Invalid",
    )
    """The default function prototype to adopt for functions that do not provide
    it explicitly.
    """
    DefaultPrototype: "Type" = field(
        metadata={"optional": True, "default_value": lambda: None}, default_factory=lambda: None
    )
    """Project-level artifact configuration options"""
    Configuration: "Configuration" = field(
        metadata={"optional": True, "default_value": lambda: Configuration()},
        default_factory=lambda: Configuration(),
    )
    """A list of binaries used in this project. Currently only limited to 0
    or 1 elements.
    This is currently optional and a Model is valid without any Binaries
    specified. This is done as a transitional measure as the new
    experimental pipeline is implemented. Eventually this limitation will
    be lifted and each element of `Segments` will need to reference a
    binary present in `Binaries`.
    Do note that, even in this transitional phase, running some pipes in
    the new experimental pipeline will lead to an error being thrown if
    `Binaries` is empty.
    """
    Binaries: "TypedList[BinaryIdentifier]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(BinaryIdentifier),
    )
    """`Segment`s represent instructions on what part of the raw binary needs to
    be loaded at which address.
    """
    Segments: "TypedList[Segment]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(Segment),
    )
    """A list of addresses known to contain code.
    rev.ng is usually able to discover all the code by itself by recursively
    visiting the control-flow graph of functions and the call graph.
    However, certain pieces of code cannot be identified through these
    techniques.
    A prime example are the addresses of `catch` blocks of C++ exception
    handlers: no code ever directly jumps there and their address is not
    stored in jump tables. Their address can only be obtained by interpreting
    metadata in the ELF.
    """
    ExtraCodeAddresses: "TypedList[MetaAddress]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(MetaAddress),
    )
    """The list of imported libraries identified by their file name.
    For instance, if the input binary is linked to OpenSSL, this list would
    should `libcrypto.so.1.1`.
    """
    ImportedLibraries: "TypedList[str]" = field(
        metadata={"optional": True, "default_value": lambda: []}, default=TypedListDescriptor(str)
    )
    """List of functions imported from dynamic libraries (`.so`, `.dll`)."""
    ImportedDynamicFunctions: "TypedList[DynamicFunction]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(DynamicFunction),
    )
    """List of the functions present in the binary."""
    Functions: "TypedList[Function]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(Function),
    )
    """The set of types used in this binary.
    It contains `struct`, `union`, `typedef`, `enum` and function prototypes.
    """
    TypeDefinitions: "TypedList[TypeDefinition]" = field(
        metadata={"optional": True, "default_value": lambda: []},
        default=TypedListDescriptor(TypeDefinition),
    )

    def __post_init__(self):
        if self.Version != Binary.SchemaVersion:
            raise ValueError(
                f"Schema version is not supported, version = {self.Version}, supported version = {Binary.SchemaVersion}"
            )

    def __hash__(self):
        return id(self)

    def serialize(self, output: Optional[TextIOBase] = None):
        if output is None:
            return yaml.dump(self, Dumper=YamlDumper)
        else:
            return yaml.dump(self, output, Dumper=YamlDumper)


Type._children = {
    "PrimitiveType": PrimitiveType,
    "PointerType": PointerType,
    "DefinedType": DefinedType,
    "ArrayType": ArrayType,
}

force_constructor_kwarg(PrimitiveType, "Kind", TypeKind.PrimitiveType)
force_constructor_kwarg(PointerType, "Kind", TypeKind.PointerType)
force_constructor_kwarg(DefinedType, "Kind", TypeKind.DefinedType)
force_constructor_kwarg(ArrayType, "Kind", TypeKind.ArrayType)


TypeDefinition._children = {
    "CABIFunctionDefinition": CABIFunctionDefinition,
    "EnumDefinition": EnumDefinition,
    "RawFunctionDefinition": RawFunctionDefinition,
    "TypedefDefinition": TypedefDefinition,
    "StructDefinition": StructDefinition,
    "UnionDefinition": UnionDefinition,
}

force_constructor_kwarg(CABIFunctionDefinition, "Kind", TypeDefinitionKind.CABIFunctionDefinition)
force_constructor_kwarg(EnumDefinition, "Kind", TypeDefinitionKind.EnumDefinition)
force_constructor_kwarg(RawFunctionDefinition, "Kind", TypeDefinitionKind.RawFunctionDefinition)
force_constructor_kwarg(TypedefDefinition, "Kind", TypeDefinitionKind.TypedefDefinition)
force_constructor_kwarg(StructDefinition, "Kind", TypeDefinitionKind.StructDefinition)
force_constructor_kwarg(UnionDefinition, "Kind", TypeDefinitionKind.UnionDefinition)


if sys.version_info < (3, 10, 0):
    force_kw_only(Type)
    force_kw_only(BinaryIdentifier)
    force_kw_only(TypeDefinition)
    force_kw_only(CanonicalRegisterValue)
    force_kw_only(DisassemblyConfiguration)
    force_kw_only(NamingConfiguration)
    force_kw_only(Relocation)
    force_kw_only(EnumEntry)
    force_kw_only(LocalIdentifier)
    force_kw_only(StatementComment)
    force_kw_only(Argument)
    force_kw_only(ArrayType)
    force_kw_only(CallSitePrototype)
    force_kw_only(NamedTypedRegister)
    force_kw_only(PointerType)
    force_kw_only(PrimitiveType)
    force_kw_only(StructField)
    force_kw_only(UnionField)
    force_kw_only(DefinedType)
    force_kw_only(TypedefDefinition)
    force_kw_only(Configuration)
    force_kw_only(DynamicFunction)
    force_kw_only(Segment)
    force_kw_only(EnumDefinition)
    force_kw_only(CABIFunctionDefinition)
    force_kw_only(Function)
    force_kw_only(RawFunctionDefinition)
    force_kw_only(StructDefinition)
    force_kw_only(UnionDefinition)
    force_kw_only(Binary)

types_metadata: TypesMetadata = {}
types_metadata[Type] = {
    "Kind": {
        "type": str,
        "possible_values": TypeKind,
        "ctor": "enum",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "IsConst": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[BinaryIdentifier] = {
    "Index": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Hash": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Size": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[TypeDefinition] = {
    "ID": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Kind": {
        "type": str,
        "possible_values": TypeDefinitionKind,
        "ctor": "enum",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[CanonicalRegisterValue] = {
    "Register": {
        "type": str,
        "possible_values": Register,
        "ctor": "enum",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Value": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[DisassemblyConfiguration] = {
    "DisableEmissionOfInstructionAddress": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "DisableEmissionOfRawBytes": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "UseX86ATTSyntax": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "AddressStyle": {
        "type": str,
        "possible_values": DisassemblyConfigurationAddressStyle,
        "ctor": "enum",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "ImmediateStyle": {
        "type": str,
        "possible_values": DisassemblyConfigurationImmediateStyle,
        "ctor": "enum",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "PrintFullMetaAddress": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "BasicBlockPrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[NamingConfiguration] = {
    "UnnamedSegmentPrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "UnnamedDynamicFunctionPrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "UnnamedFunctionPrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "UnnamedTypeDefinitionPrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "UnnamedEnumEntryPrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "UnnamedStructFieldPrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "UnnamedUnionFieldPrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "UnnamedFunctionArgumentPrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "UnnamedFunctionRegisterPrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "UnnamedLocalVariablePrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "UnnamedBreakFromLoopVariablePrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "UnnamedGotoLabelPrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "OpaqueCSVValuePrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "MaximumEnumValuePrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "StackFrameVariableName": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "RawStackArgumentName": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "LoopStateVariableName": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "StructPaddingPrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "ArtificialReturnValuePrefix": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "ReserveNamesStartingWithUnderscore": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[Relocation] = {
    "Address": {
        "type": MetaAddress,
        "ctor": "class",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": True,
    },
    "Type": {
        "type": str,
        "possible_values": RelocationType,
        "ctor": "enum",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Addend": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[EnumEntry] = {
    "Value": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[LocalIdentifier] = {
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Location": {
        "type": MetaAddress,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": True,
    },
}
types_metadata[StatementComment] = {
    "Index": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Location": {
        "type": MetaAddress,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": True,
    },
    "Body": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[Argument] = {
    "Index": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Type": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[ArrayType] = {
    "ElementCount": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "ElementType": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
    "Kind": {
        "type": str,
        "possible_values": TypeKind,
        "ctor": "enum",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "IsConst": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[CallSitePrototype] = {
    "CallerBlockAddress": {
        "type": MetaAddress,
        "ctor": "class",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": True,
    },
    "Prototype": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
    "IsTailCall": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Attributes": {
        "type": str,
        "possible_values": FunctionAttribute,
        "ctor": "enum",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[NamedTypedRegister] = {
    "Location": {
        "type": str,
        "possible_values": Register,
        "ctor": "enum",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Type": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[PointerType] = {
    "PointerSize": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "PointeeType": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
    "Kind": {
        "type": str,
        "possible_values": TypeKind,
        "ctor": "enum",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "IsConst": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[PrimitiveType] = {
    "PrimitiveKind": {
        "type": str,
        "possible_values": PrimitiveKind,
        "ctor": "enum",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Size": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Kind": {
        "type": str,
        "possible_values": TypeKind,
        "ctor": "enum",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "IsConst": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[StructField] = {
    "Offset": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Type": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
}
types_metadata[UnionField] = {
    "Index": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Type": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
}
types_metadata[DefinedType] = {
    "Definition": {
        "type": Reference,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Kind": {
        "type": str,
        "possible_values": TypeKind,
        "ctor": "enum",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "IsConst": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[TypedefDefinition] = {
    "UnderlyingType": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
    "ID": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Kind": {
        "type": str,
        "possible_values": TypeDefinitionKind,
        "ctor": "enum",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[Configuration] = {
    "Disassembly": {
        "type": DisassemblyConfiguration,
        "ctor": "class",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Naming": {
        "type": NamingConfiguration,
        "ctor": "class",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "CommentLineWidth": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[DynamicFunction] = {
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Prototype": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
    "Attributes": {
        "type": str,
        "possible_values": FunctionAttribute,
        "ctor": "enum",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Relocations": {
        "type": Relocation,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[Segment] = {
    "Binary": {
        "type": Reference,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "StartAddress": {
        "type": MetaAddress,
        "ctor": "class",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": True,
    },
    "VirtualSize": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "StartOffset": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "FileSize": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "IsReadable": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "IsWriteable": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "IsExecutable": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "CanonicalRegisterValues": {
        "type": CanonicalRegisterValue,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Relocations": {
        "type": Relocation,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Type": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
}
types_metadata[EnumDefinition] = {
    "UnderlyingType": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
    "Entries": {
        "type": EnumEntry,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "ID": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Kind": {
        "type": str,
        "possible_values": TypeDefinitionKind,
        "ctor": "enum",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[CABIFunctionDefinition] = {
    "ABI": {
        "type": str,
        "possible_values": ABI,
        "ctor": "enum",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "ReturnType": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
    "ReturnValueComment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Arguments": {
        "type": Argument,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "ID": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Kind": {
        "type": str,
        "possible_values": TypeDefinitionKind,
        "ctor": "enum",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[Function] = {
    "Entry": {
        "type": MetaAddress,
        "ctor": "class",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": True,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "StackFrameType": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
    "Prototype": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
    "Attributes": {
        "type": str,
        "possible_values": FunctionAttribute,
        "ctor": "enum",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "CallSitePrototypes": {
        "type": CallSitePrototype,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "ExportedNames": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Comments": {
        "type": StatementComment,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "LocalVariables": {
        "type": LocalIdentifier,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "GotoLabels": {
        "type": LocalIdentifier,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[RawFunctionDefinition] = {
    "Architecture": {
        "type": str,
        "possible_values": Architecture,
        "ctor": "enum",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Arguments": {
        "type": NamedTypedRegister,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "ReturnValues": {
        "type": NamedTypedRegister,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "ReturnValueComment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "PreservedRegisters": {
        "type": str,
        "possible_values": Register,
        "ctor": "enum",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "FinalStackOffset": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "StackArgumentsType": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
    "ID": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Kind": {
        "type": str,
        "possible_values": TypeDefinitionKind,
        "ctor": "enum",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[StructDefinition] = {
    "Size": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "CanContainCode": {
        "type": bool,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Fields": {
        "type": StructField,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "ID": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Kind": {
        "type": str,
        "possible_values": TypeDefinitionKind,
        "ctor": "enum",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[UnionDefinition] = {
    "Fields": {
        "type": UnionField,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "ID": {
        "type": int,
        "ctor": "native",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Kind": {
        "type": str,
        "possible_values": TypeDefinitionKind,
        "ctor": "enum",
        "is_key": True,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Name": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Comment": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
}
types_metadata[Binary] = {
    "Version": {
        "type": int,
        "ctor": "native",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Architecture": {
        "type": str,
        "possible_values": Architecture,
        "ctor": "enum",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "EntryPoint": {
        "type": MetaAddress,
        "ctor": "class",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": True,
    },
    "DefaultABI": {
        "type": str,
        "possible_values": ABI,
        "ctor": "enum",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "DefaultPrototype": {
        "type": Type,
        "ctor": "parse",
        "is_key": False,
        "is_array": False,
        "is_abstract": True,
        "external": False,
    },
    "Configuration": {
        "type": Configuration,
        "ctor": "class",
        "is_key": False,
        "is_array": False,
        "is_abstract": False,
        "external": False,
    },
    "Binaries": {
        "type": BinaryIdentifier,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Segments": {
        "type": Segment,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "ExtraCodeAddresses": {
        "type": MetaAddress,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": True,
    },
    "ImportedLibraries": {
        "type": str,
        "ctor": "native",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "ImportedDynamicFunctions": {
        "type": DynamicFunction,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "Functions": {
        "type": Function,
        "ctor": "class",
        "is_key": False,
        "is_array": True,
        "is_abstract": False,
        "external": False,
    },
    "TypeDefinitions": {
        "type": TypeDefinition,
        "ctor": "parse",
        "is_key": False,
        "is_array": True,
        "is_abstract": True,
        "external": False,
    },
}


YamlDumper.add_representer(PrimitiveKind, PrimitiveKind.yaml_representer)
YamlDumper.add_representer(RelocationType, RelocationType.yaml_representer)
YamlDumper.add_representer(FunctionAttribute, FunctionAttribute.yaml_representer)
YamlDumper.add_representer(Architecture, Architecture.yaml_representer)
YamlDumper.add_representer(ABI, ABI.yaml_representer)
YamlDumper.add_representer(Register, Register.yaml_representer)
YamlDumper.add_representer(
    DisassemblyConfigurationImmediateStyle, DisassemblyConfigurationImmediateStyle.yaml_representer
)
YamlDumper.add_representer(
    DisassemblyConfigurationAddressStyle, DisassemblyConfigurationAddressStyle.yaml_representer
)
YamlDumper.add_representer(TypeDefinitionKind, TypeDefinitionKind.yaml_representer)
YamlDumper.add_representer(TypeKind, TypeKind.yaml_representer)

YamlDumper.add_representer(Type, Type.yaml_representer)
YamlDumper.add_representer(BinaryIdentifier, BinaryIdentifier.yaml_representer)
YamlDumper.add_representer(TypeDefinition, TypeDefinition.yaml_representer)
YamlDumper.add_representer(CanonicalRegisterValue, CanonicalRegisterValue.yaml_representer)
YamlDumper.add_representer(DisassemblyConfiguration, DisassemblyConfiguration.yaml_representer)
YamlDumper.add_representer(NamingConfiguration, NamingConfiguration.yaml_representer)
YamlDumper.add_representer(Relocation, Relocation.yaml_representer)
YamlDumper.add_representer(EnumEntry, EnumEntry.yaml_representer)
YamlDumper.add_representer(LocalIdentifier, LocalIdentifier.yaml_representer)
YamlDumper.add_representer(StatementComment, StatementComment.yaml_representer)
YamlDumper.add_representer(Argument, Argument.yaml_representer)
YamlDumper.add_representer(ArrayType, ArrayType.yaml_representer)
YamlDumper.add_representer(CallSitePrototype, CallSitePrototype.yaml_representer)
YamlDumper.add_representer(NamedTypedRegister, NamedTypedRegister.yaml_representer)
YamlDumper.add_representer(PointerType, PointerType.yaml_representer)
YamlDumper.add_representer(PrimitiveType, PrimitiveType.yaml_representer)
YamlDumper.add_representer(StructField, StructField.yaml_representer)
YamlDumper.add_representer(UnionField, UnionField.yaml_representer)
YamlDumper.add_representer(DefinedType, DefinedType.yaml_representer)
YamlDumper.add_representer(TypedefDefinition, TypedefDefinition.yaml_representer)
YamlDumper.add_representer(Configuration, Configuration.yaml_representer)
YamlDumper.add_representer(DynamicFunction, DynamicFunction.yaml_representer)
YamlDumper.add_representer(Segment, Segment.yaml_representer)
YamlDumper.add_representer(EnumDefinition, EnumDefinition.yaml_representer)
YamlDumper.add_representer(CABIFunctionDefinition, CABIFunctionDefinition.yaml_representer)
YamlDumper.add_representer(Function, Function.yaml_representer)
YamlDumper.add_representer(RawFunctionDefinition, RawFunctionDefinition.yaml_representer)
YamlDumper.add_representer(StructDefinition, StructDefinition.yaml_representer)
YamlDumper.add_representer(UnionDefinition, UnionDefinition.yaml_representer)
YamlDumper.add_representer(Binary, Binary.yaml_representer)

# Allows to deserialize YAML as a 'generator.root_type' even if the root of the YAML document is
# not tagged
YamlLoader.add_constructor("!Binary", Binary.yaml_constructor)
YamlLoader.add_path_resolver("!Binary", [])

DiffYamlLoader.add_constructor("!DiffSet", DiffSet.yaml_constructor)
DiffYamlLoader.add_path_resolver("!DiffSet", [])
