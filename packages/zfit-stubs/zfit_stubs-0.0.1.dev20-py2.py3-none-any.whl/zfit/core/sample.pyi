import tensorflow as tf
from .. import settings as settings, z as z
from ..settings import run as run, ztypes as ztypes
from ..util import ztyping as ztyping
from ..util.container import convert_to_container as convert_to_container
from ..util.exception import WorkInProgressError as WorkInProgressError
from .data import Data as Data
from .space import Space as Space
from _typeshed import Incomplete
from collections.abc import Callable as Callable, Iterable
from zfit._interfaces import ZfitPDF as ZfitPDF, ZfitSpace as ZfitSpace

class UniformSampleAndWeights:
    def __call__(self, n_to_produce: int | tf.Tensor, limits: Space, dtype, prng=None): ...

class EventSpace(Space):
    dtype: Incomplete
    def __init__(self, obs: ztyping.ObsTypeInput, limits: ztyping.LimitsTypeInput, factory=None, dtype=..., name: str | None = 'Space') -> None: ...
    @property
    def factory(self): ...
    @property
    def is_generator(self): ...
    @property
    def limits(self) -> ztyping.LimitsTypeReturn: ...
    def create_limits(self, n) -> None: ...
    def iter_areas(self, rel: bool = False) -> tuple[float, ...]: ...
    def add(self, other: ztyping.SpaceOrSpacesTypeInput): ...
    def combine(self, other: ztyping.SpaceOrSpacesTypeInput): ...
    def __hash__(self): ...

def accept_reject_sample(prob: Callable, n: int, limits: ZfitSpace, sample_and_weights_factory: Callable = ..., dtype=..., prob_max: None | int = None, efficiency_estimation: float = 0.5) -> tf.Tensor: ...
def extract_extended_pdfs(pdfs: Iterable[ZfitPDF] | ZfitPDF) -> list[ZfitPDF]: ...
def extended_sampling(pdfs: Iterable[ZfitPDF] | ZfitPDF, limits: Space) -> tf.Tensor: ...
