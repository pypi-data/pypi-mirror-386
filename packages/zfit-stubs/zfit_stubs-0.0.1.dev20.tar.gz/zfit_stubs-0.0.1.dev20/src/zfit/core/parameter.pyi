import abc
import tensorflow as tf
from .. import z as z
from .._interfaces import ZfitIndependentParameter as ZfitIndependentParameter, ZfitModel as ZfitModel, ZfitParameter as ZfitParameter
from ..core.baseobject import BaseNumeric as BaseNumeric, extract_filter_params as extract_filter_params, validate_preprocess_name as validate_preprocess_name
from ..minimizers.interface import ZfitResult as ZfitResult
from ..serialization.paramrepr import make_param_constructor as make_param_constructor
from ..serialization.serializer import BaseRepr as BaseRepr, Serializer as Serializer
from ..settings import run as run, ztypes as ztypes
from ..util import ztyping as ztyping
from ..util.checks import NotSpecified as NotSpecified
from ..util.container import convert_to_container as convert_to_container
from ..util.deprecation import deprecated as deprecated, deprecated_args as deprecated_args
from ..util.exception import BreakingAPIChangeError as BreakingAPIChangeError, FunctionNotImplemented as FunctionNotImplemented, IllegalInGraphModeError as IllegalInGraphModeError, LogicalUndefinedOperationError as LogicalUndefinedOperationError, ParameterNotIndependentError as ParameterNotIndependentError
from ..util.temporary import TemporarilySet as TemporarilySet
from .serialmixin import SerializableMixin as SerializableMixin
from _typeshed import Incomplete
from collections.abc import Callable as Callable, Iterable, Mapping
from ordered_set import OrderedSet
from tensorflow.python.ops.resource_variable_ops import ResourceVariable as TFVariable, VariableSpec
from tensorflow.python.ops.variables import Variable
from tensorflow.python.types.core import Tensor as TensorType
from typing import Literal

class MetaBaseParameter(Incomplete, Incomplete): ...

def register_tensor_conversion(convertable, name=None, overload_operators: bool = True, priority: int = 10): ...

class OverloadableMixin(ZfitParameter, metaclass=abc.ABCMeta): ...

class WrappedVariable(metaclass=MetaBaseParameter):
    variable: Incomplete
    def __init__(self, initial_value, *args, **kwargs) -> None: ...
    @property
    @abc.abstractmethod
    def name(self): ...
    @property
    def constraint(self): ...
    @property
    def dtype(self): ...
    def value(self): ...
    @property
    def shape(self): ...
    def numpy(self): ...
    def assign(self, value, use_locking: bool = False, name=None, read_value: bool = True): ...

class BaseParameter(Variable, ZfitParameter, TensorType, metaclass=MetaBaseParameter):
    def __init__(self, *args, **kwargs) -> None: ...
    def __len__(self) -> int: ...

class ZfitParameterMixin(BaseNumeric):
    def __init__(self, name, label=None, **kwargs) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def label(self) -> str: ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class TFBaseVariable(TFVariable, metaclass=MetaBaseParameter): ...

class Parameter(ZfitParameterMixin, TFBaseVariable, BaseParameter, SerializableMixin, ZfitIndependentParameter, metaclass=abc.ABCMeta):
    DEFAULT_stepsize: float
    def __init__(self, name: str, value: ztyping.NumericalScalarType, lower: ztyping.NumericalScalarType | None = None, upper: ztyping.NumericalScalarType | None = None, stepsize: ztyping.NumericalScalarType | None = None, floating: bool = True, *, label: str | None = None, dtype: tf.DType = None, step_size: ztyping.NumericalScalarType | None = None) -> None: ...
    def __init_subclass__(cls, **kwargs) -> None: ...
    @property
    def lower(self) -> tf.Tensor | None: ...
    @lower.setter
    def lower(self, value) -> None: ...
    @property
    def upper(self) -> tf.Tensor | None: ...
    @upper.setter
    def upper(self, value) -> None: ...
    @property
    def has_limits(self) -> bool: ...
    @property
    def at_limit(self) -> tf.Tensor: ...
    def value(self) -> tf.Tensor: ...
    @property
    def floating(self) -> bool: ...
    @floating.setter
    def floating(self, value) -> None: ...
    @property
    def independent(self) -> bool: ...
    @property
    def has_stepsize(self) -> bool: ...
    @property
    def has_step_size(self): ...
    @property
    def stepsize(self) -> tf.Tensor: ...
    @stepsize.setter
    def stepsize(self, value) -> None: ...
    @property
    def step_size(self) -> tf.Tensor: ...
    @step_size.setter
    def step_size(self, value) -> None: ...
    def set_value(self, value: ztyping.NumericalScalarType, *, clip: bool | None = None): ...
    def assign(self, value, use_locking: bool | None = None, read_value: bool = False): ...
    def randomize(self, minval: ztyping.NumericalScalarType | None = None, maxval: ztyping.NumericalScalarType | None = None, sampler: Callable = ...) -> tf.Tensor: ...
    def get_params(self, floating: bool | None = True, is_yield: bool | None = None, extract_independent: bool | None = True, *, autograd: bool | None = None) -> OrderedSet[ZfitParameter]: ...
    @property
    def lower_limit(self) -> None: ...
    @lower_limit.setter
    def lower_limit(self, value) -> None: ...
    @property
    def upper_limit(self) -> None: ...
    @upper_limit.setter
    def upper_limit(self, value) -> None: ...
    def __tf_tracing_type__(self, signature_context): ...
    def __reduce__(self): ...

class ParameterSpec(VariableSpec):
    value_type: Incomplete
    parameter_value: Incomplete
    parameter_type: Incomplete
    hash: Incomplete
    def __init__(self, shape=None, dtype=None, trainable: bool = True, alias_id=None, *, parameter=None) -> None: ...
    @classmethod
    def from_value(cls, value): ...
    def is_subtype_of(self, other): ...
    def most_specific_common_supertype(self, others): ...
    def placeholder_value(self, placeholder_context=None): ...
    def is_compatible_with(self, spec_or_value): ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self): ...

class ParameterRepr(BaseRepr):
    hs3_type: Literal['Parameter']
    name: str
    value: float
    lower: float | None
    upper: float | None
    stepsize: float | None
    floating: bool | None
    label: str | None
    def __hash__(self): ...

class BaseComposedParameter(ZfitParameterMixin, OverloadableMixin, BaseParameter):
    def __init__(self, params, func, dtype=None, name: str = 'BaseComposedParameter', **kwargs) -> None: ...
    @property
    def floating(self) -> None: ...
    @floating.setter
    def floating(self, value) -> None: ...
    @property
    def params(self): ...
    def value(self): ...
    @property
    def shape(self): ...
    def numpy(self): ...
    @property
    def independent(self): ...
    def set_value(self, value) -> None: ...
    def randomize(self, minval=None, maxval=None, sampler=...) -> None: ...
    def assign(self, value, use_locking: bool = False, name=None, read_value: bool = True) -> None: ...

class ConstantParameter(OverloadableMixin, ZfitParameterMixin, BaseParameter, SerializableMixin):
    def __init__(self, name, value, *, label: str | None = None) -> None: ...
    @property
    def shape(self): ...
    def value(self) -> tf.Tensor: ...
    @property
    def floating(self): ...
    @floating.setter
    def floating(self, value) -> None: ...
    @property
    def independent(self) -> bool: ...
    @property
    def static_value(self): ...
    def numpy(self): ...

class ConstantParamRepr(BaseRepr):
    hs3_type: Literal['ConstantParameter']
    name: str
    value: float
    floating: bool
    label: str | None

class ComposedParameter(SerializableMixin, BaseComposedParameter):
    def __init__(self, name: str, func: Callable | None = None, *, value_fn: Callable | None = None, params: dict[str, ZfitParameter] | Iterable[ZfitParameter] | ZfitParameter = ..., label: str | None = None, unpack_params: bool | None = None, dependents: dict[str, ZfitParameter] | Iterable[ZfitParameter] | ZfitParameter = ..., dtype: tf.dtypes.DType = ...) -> None: ...

class ComposedParameterRepr(BaseRepr):
    hs3_type: Literal['ComposedParameter']
    name: str
    func: str
    params: dict[str, Serializer.types.ParamTypeDiscriminated]
    unpack_params: bool | None
    label: str | None
    internal_params: Serializer.types.ParamTypeDiscriminated | list[Serializer.types.ParamTypeDiscriminated] | dict[str, Serializer.types.ParamTypeDiscriminated] | None
    def validate_all_functor(cls, values): ...

class ComplexParameter(ComposedParameter):
    def __init__(self, name: str, func: Callable | None = None, *, value_fn: Callable | None = None, params, dtype=None, label: str | None = None) -> None: ...
    @classmethod
    def from_cartesian(cls, name: str, real: ztyping.NumericalScalarType, imag: ztyping.NumericalScalarType, floating: bool = True, *, dtype=..., label: str | None = None) -> ComplexParameter: ...
    @classmethod
    def from_polar(cls, name: str, mod: ztyping.NumericalScalarType, arg: ztyping.NumericalScalarType, floating: bool = True, *, label: str | None = None, **__) -> ComplexParameter: ...
    @property
    def conj(self): ...
    @property
    def real(self) -> tf.Tensor: ...
    @property
    def imag(self) -> tf.Tensor: ...
    @property
    def mod(self) -> tf.Tensor: ...
    @property
    def arg(self) -> tf.Tensor: ...

def get_auto_number(): ...

ALLOWED_KEYS: Incomplete

def convert_to_parameters(value, name: str | list[str] | None = None, prefer_constant: bool | None = None, lower=None, upper=None, stepsize=None): ...
def convert_to_parameter(value: ztyping.NumericalScalarType | ZfitParameter | Callable, name: str | None = None, prefer_constant: bool = True, params: ZfitParameter | Iterable[ZfitParameter] | None = None, lower: ztyping.NumericalScalarType | None = None, upper: ztyping.NumericalScalarType | None = None, stepsize: ztyping.NumericalScalarType | None = None, *, label: str | None = None, dependents=None) -> ZfitParameter: ...
def assign_values_jit(params: Parameter | Iterable[Parameter], values: ztyping.NumericalScalarType | Iterable[ztyping.NumericalScalarType], use_locking: bool = False): ...
def assign_values(params: Parameter | Iterable[Parameter], values: ztyping.NumericalScalarType | Iterable[ztyping.NumericalScalarType], use_locking: bool = False, allow_partial: bool | None = None): ...
def set_values(params: Parameter | Iterable[Parameter], values: tuple[ztyping.NumericalScalarType | Iterable[ztyping.NumericalScalarType] | ZfitResult | Mapping[str | ZfitParameter, ztyping.NumericalScalarType] | None] = None, allow_partial: bool | None = None, *, clip: bool | None = None): ...
def check_convert_param_values_assign(params, values, allow_partial: bool = False): ...
