import contextlib
import pydantic.v1 as pydantic
from _typeshed import Incomplete
from collections.abc import Generator, Iterable, Mapping
from dataclasses import dataclass
from enum import Enum
from typing import Any, ClassVar
from zfit._interfaces import ZfitBinnedData as ZfitBinnedData, ZfitConstraint as ZfitConstraint, ZfitData as ZfitData, ZfitLoss as ZfitLoss, ZfitPDF as ZfitPDF, ZfitParameter as ZfitParameter
from zfit.core.serialmixin import ZfitSerializable as ZfitSerializable
from zfit.util.container import convert_to_container as convert_to_container
from zfit.util.warnings import warn_experimental_feature as warn_experimental_feature

@dataclass
class Aliases:
    hs3_type: str = ...

alias1: Incomplete

class Types:
    block_forward_refs: bool
    alias: Incomplete
    DUMMYTYPE: Incomplete
    def __init__(self) -> None: ...
    def one_or_many(self, repr): ...
    @property
    def PDFTypeDiscriminated(self): ...
    @property
    def DataTypeDiscriminated(self): ...
    @property
    def ConstraintTypeDiscriminated(self): ...
    @property
    def ParamTypeDiscriminated(self): ...
    @property
    def ListParamTypeDiscriminated(self): ...
    @property
    def ParamInputTypeDiscriminated(self): ...
    @property
    def ListParamInputTypeDiscriminated(self): ...
    def register_repr(self, repr: ZfitPDF | ZfitParameter) -> None: ...

class SerializationTypeError(TypeError): ...

class Serializer:
    def __new__(cls, *_, **__) -> None: ...
    types: Incomplete
    is_initialized: bool
    constructor_repr: ClassVar
    type_repr: ClassVar
    @classmethod
    def register(own_cls, repr: ZfitSerializable) -> None: ...
    @classmethod
    @contextlib.contextmanager
    def initialize(cls, *, reuse_params=None) -> None: ...
    @classmethod
    @warn_experimental_feature
    def to_hs3(cls, obj: list[ZfitPDF] | tuple[ZfitPDF] | ZfitPDF | list[ZfitLoss] | tuple[ZfitLoss] | ZfitLoss) -> Mapping[str, Any]: ...
    @classmethod
    @warn_experimental_feature
    def from_hs3(cls, load: Mapping[str, Mapping], *, reuse_params: ZfitParameter | Iterable[ZfitParameter] | None = None) -> Mapping[str, ZfitPDF | ZfitParameter]: ...
    @classmethod
    @contextlib.contextmanager
    def deserializing(cls) -> Generator[None]: ...
    @classmethod
    def post_serialize(cls, out): ...
    @classmethod
    def pre_deserialize(cls, out): ...
    @classmethod
    def post_deserialize(cls, out): ...

TYPENAME: str

def elements_match(mapping, replace): ...
def replace_matching(mapping, replace): ...
def convert_to_orm(init): ...
def to_orm_init(func): ...

class MODES(Enum):
    orm = 'orm'
    repr = 'repr'

class BaseRepr(pydantic.BaseModel):
    dictionary: dict | None
    tags: list[str] | None
    def __init_subclass__(cls, **kwargs) -> None: ...
    class Config:
        orm_mode: bool
        arbitrary_types_allowed: bool
        allow_population_by_field_name: bool
        smart_union: bool
    @classmethod
    def orm_mode(cls, v): ...
    @classmethod
    def from_orm(cls, obj: Any) -> BaseRepr: ...
    def to_orm(self, *, reuse_params=None): ...
