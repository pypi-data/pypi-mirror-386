# This file is a list of parameters needed by the NEEMUDS MCMC program.
# This line is a comment, like every bit of text following a hash symbol.
#
##########################
# D1 -- A short description to keep in mind about what is a parameter model
##########################
# A parameter model is a composite Bezier curve. This is a serie of N=(n-1) joint cubic Bezier curves.
# Note that a cubic curve is defined by four points called the control points.
# What is called a parameter is: RHO, VP, VS or depending on your MCMC configuration ETA or XI.
# A model is totally defined by its n anchor points and gradients.
# If i is in {1, ..., n}, then the i-th anchor point is the first control point of the i-th bezier curve.
# If i>1 then the i-th anchor point is also the last control point of the (i-1)-th bezier curve of the model.
# 3 anchor points in the model are special in the sense that their depths never change during the MCMC (in depth ascending order):
# - The shallowest, typically at zero depth.
# - The deepest point of the MCMC working zone, at this point starts the last curve of the model leading to the PREM point.
# - The overall deepest point which is called the PREM point, because at global scale (Earth or Mars)
#	 this is where the model joins the reference model (aka PREM for Earth).
#	 At local scale too this point is fixed, there is not joint ref. model though.
# So each curve of the model is a cubic symmetric Bezier curve. What it precisely means by symmetric is that each curve is symmetric
# with respect to its middle point. That's why in fact only one gradient defines the curve, it gives the second control point of the curve
# starting from its first one. This gradient intervenes also to give the third control point of the curve starting from the fourth
# (applying the opposite translation of the gradient).
# That's how is defined the whole model, because the same gradient is used identically for each component curve definition.

#-------------------------------------------------
# #1 MCMC Profile Name
#-------------------------------------------------
# This name will be the result folder's prefix name.
# The computation result files will be put out into it.
# It will be created if doesn't exist (in the current working directory).
# A suffix R will be added to the folder name if you do a MCMC only on Rayleigh waves.
# A suffix RL will be added if you do a MCMC on Rayleigh and Love waves.
mcmc_mars_global

#-------------------------------------------------
# #2 Scale Type
#-------------------------------------------------
# Set it to 0 for local scale/DispHerrmann or 1 for global scale/Mineos.
# 2 for local scale/DispHerrman but using K and MU parameters instead of VP and VS
# 3 for global scale/Mineos but using K and MU parameters instead of VP and VS.
# If the config. is 2 or 3, many options are reinterpreted to replace VP by K and VS by MU.
3

#-------------------------------------------------
# #3 Herrmann/Mineos Configuration File
#-------------------------------------------------
# Not used yet for Herrmann (let the value 'none')
# For Mineos this is a file containing variable-value pairs like this:
# rhobar = 5515.0
# lmin = 5
# lmax = 8000
# nmin = 0
# nmax = 0
~/.ndata/conf/neemuds_mars.conf

#-------------------------------------------------
# #4 PREM File
#-------------------------------------------------
# File of the prem to connect to at maximal depth, set it to 'none' for rather using join values (see below, sections #19 to #22).
# N.B.: if scale type in section #2 is set to 0 (local/DispHerrmann), you must set this value to 'none' because we don't use a prem in this mode.
# N.B.: on the contrary, if scale type is global (value 1 in section #2), you must set a valid prem file.
# N.B.: file format is imposed by Mineos (for global scale).
~/.ndata/prior/mars/DWThot.tvel

#-------------------------------------------------
# #5 Prior Files : the first line for lower bound, the second for upper bound
#-------------------------------------------------
# Two files: the first for the minimal values, the second for the maximal values.
# N.B.: file format is specific to each scale type (section #2), that is, Mineos or Herrmann.
~/.ndata/prior/mod_mars_rayl_lo
~/.ndata/prior/mod_mars_rayl_hi

#-------------------------------------------------
# #6 Reserved section for future use
#-------------------------------------------------
# RESERVED

#-------------------------------------------------
# #7 Number Of Markov Chains
#-------------------------------------------------
# -1 for auto-adjusting to the number of CPU cores MPI will find.
10

#-------------------------------------------------
# #8 Markov Chain Seeds
#-------------------------------------------------
# Initial seeds to use for MT-PRNG.
# Set them to -1 to use a "random" seed auto-generated with system time clock.
# One seed per chain (see section #7).
# N.B.: If you have more chains than seeds, the additional chains will have random seeds (-1 value equivalent).
#855 435 678 835 845 935 673 95
-1

#-------------------------------------------------
# #9 Numbers of Iterations for Cold and Hot Runs
#-------------------------------------------------
# MCMC works in two stages for models exploration.
# Firstly with cold runs, secondly with hot runs.
# Numbers of iterations, respectively for the cold and hot runs:
#300 600
1500 10000

#-------------------------------------------------
# #10 Minimal and Maximal Depths for Models Exploration
#-------------------------------------------------
# Minimal and maximal model depths (in km).
# N.B.: non-zero minimal depth isn't yet implemented.
0 500

#-------------------------------------------------
# #11 The Max Depth of the MCMC Working Zone
#-------------------------------------------------
# This is the (n-1)-th anchor point's depth of the models.
# Important consideration about this choice when the models are defined by only 2 component bezier curves (see section #12):
#    Recall that each curve is symmetric wrt to its middle point so
#    the structure of the model (its oscillations) are constrained.
#    The first curve inflection point will be at Z/2 depth (if you chose to set this section depth at the value Z).
#    It implies that models whose the first inflection point is located at another depth than Z/2 won't be explored!
####
# Set it to a valid depth between min and max values defined in section #10 (in km).
#
300

#-------------------------------------------------
# #12 Number of Bezier Blocks/Curves per Parameter
#-------------------------------------------------
# It's the number of Bezier curves along the depth for one parameter (vs, vp,...).
# Notice that curves are joined together to form one composite curve for the whole parameter profile.
# So one curve's first point is also the last point of the previous curve (curve for lower depths).
4 5 6 7 4 5 6 7 5 6
# If you want a different number of points for each Markov chain,
# precise it on the same line (as replacement of the line above), like this:
# 5 7 9 10
# here it's for 4 Markov chains, each one generating the number of blocks specified.
# If you have less numbers on the line than the number of chains defined in section #7,
# the remaining chains will all have a number of curves equal to the last number found on the line.
# For example, if you have 4 chains and set the line to:
# 5 7
# the third and fourth chains will have 7 points like the second one.


#-------------------------------------------------
# #13 Minimal distance between two anchor points
#-------------------------------------------------
# An anchor point is a start and/or an end of a Bezier curve (in km).
20

#-------------------------------------------------
# #14 Layer Thickness of the Depth Models
#-------------------------------------------------
# That is, the depth distance between two samples of a Bezier curve.
# Must be less than the minimal distance above (section #13). (in km)
4

#-------------------------------------------------
# #15 Radius/Modulus/Norm for the gradient/tangent of each Bezier curve
#-------------------------------------------------
# That is, the norm of vec(P0,P1) and vec(P2,P3).
# Should be less or equal to minimal_distance/2 (section #13) to surely avoid two intermediary control points inversion.
# Even though the two points are reverted you'll can sample the Bezier curve from the first to the last points.
# but you'll have a degenerated curve as result because the sampling will reduce the whole curve (multiple points for a single depth)
# to a simple non-parametric curve (only one point per depth -- the first one found, starting from t=0).
# The value entered will be clamped into prior defined in next section.
# Notice that the radius will be changed during model exploration, here it's just an initial value.
# (in km)
3

#-------------------------------------------------
# #16 Radius Prior Domain
#-------------------------------------------------
# Absolute values in km.
### Min and max bounds (in km)
7.5 20

#------------------------------------------------
# #17 PHI Reference Angle
#------------------------------------------------
# Used for calculation of the angle prior for the tangent above (section #15),
# The prior's computation is based on the radius (sections #15 #16) and
# the reference angle for the global trend.
### in degrees
15

#------------------------------------------------
# #18 PHI Prior Min Max Bounds
#------------------------------------------------
# The PHI angle prior is computed dynamically as explained in section #17.
# However this prior can't go outside two angles defined interval.
# Overflowing prior is clamped into these bounds.
### min and max bounds in degrees (must contain reference angle -- section #17)
# NOTE: NEEMUDS will anyway limit min value to 2° and max value to 45°.
2.5 25

#------------------------------------------------
# #19 VS Prem Join Value (at max depth or just after)
#------------------------------------------------
# Only for local scale/Herrmann case. Ignored for global scale/Mineos case but don't delete the line.
# In m.s^-1.
-1

#------------------------------------------------
# #20 VP Prem Join Value (at max depth or just after)
#------------------------------------------------
# Only for local scale/Herrmann case. Ignored for global scale/Mineos case but don't delete the line.
# In m.s^-1.
-1

#------------------------------------------------
# #21 RHO Prem Join Value (at max depth or just after)
#------------------------------------------------
# Only for local scale/Herrmann case. Ignored for global scale/Mineos case but don't delete the line.
# In km.m^-3.
-1

#------------------------------------------------
# #22 Anisotropy XI Prem Join Value (at max depth or just after)
#------------------------------------------------
# Used only if you pass Rayleigh + Love U PDFs to the program.
# Take care that this value cannot be retrieved from prem file.
# So it's mandatory if you do a MCMC on Rayleigh + Love either in global scale or local scale.
1

#-------------------------------------------------
# #23 Prior ETA Bounds (min and max)
#-------------------------------------------------
# Only for global scale/Mineos.
# Set it to -1 -1, for ignoring in local/Herrmann case (but don't delete the line).
.95 1.05

#-------------------------------------------------
# #24 Prior XI bounds (min and max)
#-------------------------------------------------
# Straight prior XI min and max limits.
.9 1.1

#------------------------------------------------
# #25 Prior Construction Method (for VS, VP and RHO parameters only)
#------------------------------------------------
# #1st method: the prior for a parameter is defined by the min and max ref. models given in sections above (sections #5 and #6).
# 	      If we are in the Rayleigh+Love case, then the program creates one prior
# 	      for each wave type and keep the union prior of them (set operation) as the parameter prior.
# #2nd method: (Available only for global scale/Mineos case)
#	      Priors are defined using the prem model section #4 (and not min and max prems of sections #5 and #6).
# 	      VS prior bounds are calculated respecting the following rule:
# 		     prior_min=vsv-percentage*vsv # vsv is the third column in a Mineos prem file.
# 	      	 prior_max=vsv+percentage*vsv (see the custom percent value below in this file, section #26).
# 	      VP prior is inferred from VS prior, multiplying the lower bounds by a coeff. and upper bounds by another one (see section #25 for the coeffs).
# 	      Likewise RHO prior is inferred from VP prior but besides there are offsets values in addition to coeff. multipliers (see section #26 for the coeffs).
# #3rd method: (Available only for global scale/Mineos case)
#			Identical to the 2nd method except that here we take the prem only first depth and last depth vsv values
#			(corresponding to the min and max depths of the explored models, see section #10).
#			Those two values describe a segment which is the central values set of the prior for VS
#			(each prior bound is computed by shifting of a percent coefficient like in 2nd method).
#			
# N.B.: 2nd and 3rd methods aren't available for local scale/DispHerrmann (set in section #2).
### method choice: 1, 2, or 3
1

#------------------------------------------------
# #26 Coefficients for 2nd Method Prior Construction and 3rd Method Effective Prior Construction
#------------------------------------------------
# See section #25 for method choice description for basis prior construction.
# See also section #27 for 3rd method of effective prior construction.
# Spacing percentage for VS prior, relatively to prem values (vsv).
# Floating point normalized value between 0 and 1 (1 for 100%).
.20
# Coeffs to define VP prior from VS prior by mul. (1st coeff. for lower bounds, 2nd for higher bounds)
# Floating point normalized values between 0 and 1 (coeffs called C1 and C2 elsewhere in conf. file).
1.6733200530 1.816590212 # sqrt(2.8), sqrt(3.3)
# Coeffs to define RHO prior from VP prior by mul. (1st coeff. for lower bounds, 2nd for highers)
# Floating point values between 0 and 1 (coeffs called C3 and C4 elsewhere in conf. file).
.328 .3788
# Offsets to define RHO prior (kg/m³)
# (coeffs called O5 and 06 elsewhere in conf. file).
# N.B.: O5 correponds to C4 and O6 to C3.
252 768

#------------------------------------------------
# #27 Effective Prior Construction Method
#------------------------------------------------
# The effective prior is the real domain used to explore parameters.
# #1st method: the program just copies the basis priors built before (see sections above).
# #2nd method: for each parameter (VS, VP,...) the program works with a triangle prior,
# 	      intersecting it with the basis prior to obtain the effective prior
# 	      (see the next section for details about this method).
# #3rd method:	just after generating a model for VS in its prior the program deduces the prior limits for VP and RHO.
# 		The effective prior limits of VP are clamped to respect the relations with VS.
# 		Calling C1 and C2 the two coeffs (section #26) used for VP and i the depth index
# 		the VP prior limits will be clamped into [VS(i)*C1,VS(i)*C2].
# 		Likewise,  if C3, C4, O5 and O6 are the four coeffs set in section #26 for RHO and
# 		VP(i) the current model points for VP (with i the depth index),
# 		the RHO prior limits will be clamped into [VP(i)*C3+O5,VP(i)*C4+O6]
# 		(reversing the limits of the interval if necessary to get an ascendant order).
# 		Be aware that this method can put your effective prior out of the basis prior for VP and likewise for RHO's prior.
# #4th method: apply 2nd method for VS effective prior construction and 3rd method for VP and RHO effective priors.
#
# #5th method: Identical to 4th method for VP and RHO effective priors and a method similar to 2nd method for VS with the difference that the triangle is defined with two gradients (the triangle edges are directly inferred from them). Set the gradients section #29. Note that with this method you can go completely outside the basis prior for VS because in case of void intersection at some depth, the triangle eprior is kept alone in place of its intersection with basis prior (as opposite to 4th and 2nd methods which always take the intersection-prior because they avoid totally to get empty intersection at every depth).
### Choose the method to apply the line below (1, 2, 3, 4 or 5).
1

# --------------------------------------------------
# #28 Dynamic Triangle for Effective Prior Construction
# -------------------------------------------------
# This option applies only if you chose method 2 in section #27.
# Intersection between the parameter's triangle and prior gives the effective prior used for the corresponding parameter (VP, VS...).
# * Explanations for the triangle's 1st and 2nd points:
# * The triangle 1st point P1 is auto-calculated (at min depth on X -- section #10, and random into the parameter's prior for Y).
# * The 2nd point P2 will be at max depth or a little bit bottom -- section #10, and will have the parameter value determined by an angle.
# * This angle is the one defining the slope for segment P1P2 relatively to the vertical axis (x-axis/depth axis).
# * The angle is defined in the right handed basis (x-axis,y-axis) vectors taken in this order.
# * Note that the x-axis is the depth axis.
# * Restriction for P2: it can't be less than the minimal value of the prior and it's brought back to this value if this is not the case.
### Angle for 2nd point in degrees:
-0.1
# * Explanations for the 3rd point P3: it's auto-calculated to avoid empty intersection with the parameter reference prior.
# * The depth (x coord) of this point is the same than P2. And its parameter value is at least prior's max bound value for this depth.

#---------------------------------------------------
# #29 Gradients for VS effective prior method 5 (see section #27)
#---------------------------------------------------
# Two gradients to define the triangle effective prior for VS (in [m][s^-1][m^-1] = [s^-1]).
5 20

#---------------------------------------------------
# #30 Clamping VS, VP, RHO etc. sample-points into priors
#---------------------------------------------------
# Anyway the Bezier control points are picked into the effective prior, but depending on tangents, the samples of the curve can go outside the priors.
# This option serves as toggle to enable/disable the clamping of these samples into their effective prior. Note that for a matter of consistency if samples are clamped, model anchor points are clamped too.
# For some configurations (e.g. method 3 of section #27) it's possible for one parameter effective prior to not be totally included into its start prior (as defined in section #5). If you want to avoid that situation, use option value 2 to apply a second pass clamping into the parameter basis/start prior after the first pass clamping into effective prior (as for the value 1).
# ######
# Choose 1 to enable eprior-clamping, 2 for eprior-clamping and prior-clamping afterward, 0 for no clamping at all.
0

#---------------------------------------------------
# #31 Constraining VP and RHO samples from VS
#---------------------------------------------------
# The VS values can be used to constrain VP and RHO. There are several modes for constraining.
# Mode 0: No constraints at all.
# Mode 1: after VS, VP and RHO have been sampled from Bezier curves,
#       you can furthermore constrain VP depending on VS values and next RHO with new VP values.
#       The constraints are applied by clamping in the valid domain defined relatively to the coeffs you'll find above (section #26).
#       Calling C1 and C2 the two coeffs (section #26) used for VP and i the depth index of the sample/point: VP(i) will be clamped into [VS(i)*C1,VS(i)*C2].
#       Likewise, if C3, C4, O5 and O6 are the four coeffs set in section #26 for RHO (two per lines):
#               RHO(i) will be clamped into [VP(i)*C3+O6,VP(i)*C4+O5] (reversing the limits if necessary to get an ascendant order).
# N.B.: it's not necessarily wise to use the mode 1 and meanwhile the effective prior construction method 3 in section #27 but it could be complementary.
# ########
# Choose a constraining mode among 0 and 1.
0

#---------------------------------------------------
# #32 Gaussian width parameters for VP, VS, RHO, XI, ETA, depth, radius and PHI
#---------------------------------------------------
# A model update consists to move randomly one point in at least one dimension
# according to a gaussian law of probability.
# The center of normal law is the point's current set of coordinates.
# There are two ways to set the gaussian width (sigma):
# 1) Set it as a constant.
# 2) Use a width divider (wdiv) in order to define sigma dynamically as follows:
# 	sigma_p = prior_width(p, z) / wdiv_p for any point to move in the parameter p dimension, given its depth z and
# 	sigma_z = (max_depth-min_depth) / wdiv_z for any parameter point to move in the depth dimension
# 	(this is the same idea to update the radius and phi for an anchor point)
#-----------------------
# 32.0 Method used to compute sigma (1 for constant value, 2 for using wdiv)
#----------------------
# ** For VP, VS, RHO, XI, ETA:
# (N.B.: if you set less than 5 values, the last will be used to set all the missing ones.)
# on cold runs:
2 2 2 2 2
# on hot runs:
2 2 2 2 2
# ** For the depth
# on cold runs:
2
# on hot runs:
2
# ** For radius and phi:
# on cold runs:
2 2
# on hot runs:
2 2
# ----------------------
# 32.1 The sigma constant values (these values apply only if you chose the method 1 in the corresponding previous option of 32.0)
# ----------------------
# Pass them in this order VP, VS (m.s^-1), RHO (in kg/m³), XI, ETA for the cold runs:
# (N.B.: if you set less than 5 values, the last will be used to set all the missing ones.)
10000 10000 300 .5 .5
# and for the hot runs:
.5 .5 300 .5 .5
# Likewise for the depth (in km)
# for cold runs:
750
# for hot runs
375
# And it's again the same for radius (in km) and angle phi (in degrees)
# for cold runs:
300 20
# for hot runs:
150 10
# ----------------------
# 32.2 The wdiv values (these values apply only if you chose the method 2 in the corresponding previous option of 32.0)
# ----------------------
# You might want to set a different wdiv value for each parameter
# Pass them in this order VP, VS, RHO, XI, ETA for the cold runs:
# (N.B.: if you set less than 5 values, the last will be used to set all the missing ones.)
4 4 4 4 4
# and for the hot runs:
10 10 10 10 10
# Likewise for the depth's wdiv defining sigma = (max_depth-min_depth)/wdiv
# for cold runs:
1
# for hot runs
2
# And it's again the same for radius and angle phi
# for cold runs:
4 1.4
# for hot runs:
10 2.4

#---------------------------------------------------
# #33 Flushing period for result output in files
#---------------------------------------------------
# The files are in the folder name given in section #1.
# The flushing period counts in number of iterations.
# For examples, set 0 for immediate data writing in files,
# and 100 to flush the files every 100 iterations (for cold or hot runs).
10

#---------------------------------------------------
# #34 Sampled Models Output Option
#---------------------------------------------------
# Outputting Mineos/Herrmann models generated and accepted (all samples)
# Files are prefixed with "mineos" or "herrmann", and put into your mcmc profile folder (section #1).
# 1 for enabling, 0 for disabling.
1

#---------------------------------------------------
# #35 Accepting All Models in Metropolis Hastings Algo.
#---------------------------------------------------
# 1 to enable (accept all models, whatever the goodness of fit).
# 0 to disable (normal behavior).
# 2 the same as 1 but shunting group velocities and Goodness of Fit computation (a quicker version of 1).
0

#---------------------------------------------------
# #36 Weight coefficients for hot run model change's probability law
#---------------------------------------------------
# see mcmc_generic.f90 for precision about the law.
# alpha gives weight to point parameter change (VP, VS, RHO, ETA, XI) at a specific depth.
# Note that by default each anchor point (pair composed of a parameter and a depth) has the same probability to change its value (uniform distrib.).
# If you want to set a different probability law you can do it in the next section (#36).
# The last depth model point (prem join) can't have its value changed.
# beta is the weight given for a random depth's anchor points to move at another depth (parameter values are clamped into their prior).
# The first, last and before the last points for a parameter can't change of position. The movable depth is chosen according a uniform distribution.
# gamma is the weight given to change the radius or equiprobably the angle phi, both defining the Bezier control points of the model.
# The three coefficients are defined relatively to each other (they are not absolute).
# Sole limitation: the coefficients must be positive.
# Specify them in this order: alpha, beta, gamma
20 15 5

#------------------------------------------------------------------
# #37 Hot run probabilities of picking one parameter rather another
#------------------------------------------------------------------
# This section allows to set arbitrary probabilities to pick parameter VP, VS, RHO and ETA or XI if used.
# It intervenes when generating a new model in hot run and choosing randomly to change a point
# parameter value at a certain random depth instead of changing a depth, radius or phi (like commented in section #35).
#
# If you set the next value to 0, the probability distribution will be uniform (same proba. to pick any parameter).
# Otherwise (if you set the value to 1) you'll enable the custom probabilities set in the next lines.
1
# The sum of values set below must be equal 1.
# There should be up to five probability real values taken in this order: VP, VS, RHO, XI, ETA
# If there are less than five values, the missing ones will be set to 0 by default
0.1 0.85 0.05 0 0

#-----------------------------------------------------------------
# #38 Goodness of Fit Computation Method
#-----------------------------------------------------------------
# 0 discrete method
# 1 continuous method (linear interpolation)
# TODO: define options in further details
0

#-----------------------------------------------------------------
# #39 Radius-phi Priors Relationship
#-----------------------------------------------------------------
# Several values/methods are available:
# 0 No relation at all between phi and radius priors, they are defined respectively in sections #18 and #16
# 1 This method sets a group of 4 linear relations.
# 	Two linear phi-radius prior relations for low radii : one linear relation defining the inf prior limit, the other the sup prior limit.
# 	Likewise, two linear relations (inf and sup) are defined for the high radii but with different slopes than for low radii.
# 2 Linear relation set in order to limit phi values when radii are large (upward triangle)
# 3 Quad/Parabolic relation set in order to limit phi values when radii are large
1

#-----------------------------------------------------------------
# #40 Computing (VP/VS) Bézier model
#-----------------------------------------------------------------
# This option is for computing a Bezier model of VP/VS starting from
# the anchor points of VP and VS (picked as defined by any other options).
# The VP/VS curve is sampled as respect to the layer thickness and clamped into its prior defined by C1 and C2 (see #26).
# Then the VP curve is constructed based on the VS and VP/VS sampled curves.
# Likewise RHO is deduced from VP, VS curves and an affine relationship defined by C3, C4 and O5, O6 (see #26).
# NOTE: this method comes in the last time of model exploration and can override other previous methods applied, the clamping set in #30 comes after though.
# Set 1 to enable this method, 0 otherwise.
0
