# This file is a list of parameters needed by the NEEMUDS MCMC program.
# This line is a comment, like every bit of text following a hash symbol in
# this file.
#
##########################
# What is a parameter model?
##########################
#
# What is called a parameter is mainly: RHO, VP or VS.
#
# Other parameters are possible:
# - K and MU (if enabled in section #1).
# - ETA and XI if anisotropy is enabled for the MCMC (see neemuds_mcmc.py help).
#
# A parameter model is a composite Bézier curve.
# This is a series of N=(n-1) joint cubic Bézier curves.
# Note that a cubic curve is defined by four points called the control points.
# The first and last points of each Bézier curves are named anchor points. They
# are the points drawn during the MCMC to anchor the model.
# Indeed, a model is totally defined by its n anchor points and associated
# gradients.
# If i is in {1, ..., n}, then the i-th anchor point is the first control point of
# the i-th Bézier curve.
# If i>1 then the i-th anchor point is also the last control point of the (i-1)-th
# Bézier curve of the model.
# 3 anchor points in the model are particular. Their depths never change during the
# MCMC (in depth ascending order):
# - The shallowest, typically at zero depth.
# - The deepest point of the MCMC working zone. At this depth starts the last curve
# of the model leading to the reference model (e.g. PREM) point.
# - The overall deepest point which is called the reference model point, because for
# global scale MCMC (Earth, Mars, etc.) this is where the model joins the reference
# model. For a local scale MCMC too this point is fixed, although there is no
# reference model joint.
# Each curve of the model is a cubic symmetric Bézier curve. More precisely, each
# curve is symmetric with respect to its middle point. That's why in fact only one
# gradient defines the curve, it gives the second control point of the curve starting
# from the first one. This gradient is also used to give the third control point of
# the curve starting from the fourth (applying the opposite translation defined by
# the gradient). That's how is defined the whole model, because the same gradient
# is used identically to define each component curve.

[#1  MCMC Profile Name]
# `profile_name' defines the MCMC output directory.
# The folder is created if doesn't already exist (in the current working directory).
# The folder name format is `<profile_name>-<R|RL>' (e.g. `mcmc_example-R', or
# `mcmc_example-RL').
# A suffix R is appended if the MCMC prior PDF is only for Rayleigh waves.
# A suffix RL is appended if there are two prior PDFs, one for Rayleigh waves
# the other for Love waves.
# See neemuds_mcmc.py help for more details about R and RL commands.
profile_name = mcmc_example

[#2  Scale Type]
# The MCMC scale type.
# `scale_type = 0' for local scale,
# `scale_type = 1' for global scale.
# `scale_type = 2' for local scale but using K and MU parameters instead of VP and VS.
# `scale_type = 3' for global scale but using K and MU parameters instead of VP and VS.
# For `2' and `3', many configuration options in this file are reinterpreted replacing
# VP by K and VS by MU.
# In particular, the values for VP and VS used in sections #32, #36 and #37 are used
# respectively for K and MU.
#scale_type = 0
scale_type = 1

[#3  Disper96/Mineos Configuration File]
# Configuration files for computing the group velocities.
# Please refer to examples neemuds_earth.ini for Mineos and neemuds_local.ini for
# Disper96.
#grv_conf_file = ~/.ndata/conf/neemuds_local.ini
grv_conf_file = ~/.ndata/conf/neemuds_earth.ini

[#4  Reference Model]
# The filepath of the reference model to join to drawn models at z = `max_depth'
# (see section #10).
#
# Local scale:
# If `scale_type' is 0 or 2 in #2 (local scale), this value must be `None'
# because no reference model is used for local scale MCMC. The joint point
# values are used instead (see sections #19 to #22).
#
# Global scale:
# If `scale_type' is 1 or 3 in #2 (global scale), a valid reference model
# file is mandatory.
# The file format is imposed by Mineos.
#
#ref_mod_file = None
ref_mod_file = ~/.ndata/prior/prem_noocean.txt

[#5  Prior Files]
# Two files:
# - the first for the prior minimal values,
# - the second for the maximal values.
# Note: file format is specific to each scale type (see section #2).
# Note: the NEEMUDS script neem_prior_builder.py is a good way to generate
# priors easily.
#prior_lo_file = ~/.ndata/prior/mod_loc_lo
#prior_hi_file = ~/.ndata/prior/mod_loc_hi
prior_lo_file = ~/.ndata/prior/mod_earth_rayl_lo
prior_hi_file = ~/.ndata/prior/mod_earth_rayl_hi

[#6  K and MU Prior Files]
# This section is only useful if #2 scale_type > 1.
# If K_prior_file (resp. MU_prior_file) is None then
# the prior is computed according to #5 (wrt to VP, VS, RHO, K and MU relationships).
# Otherwise the K and MU priors are directly defined by these files.
# The line format of the prior must be: z min max,
# (one line per triplet of (z, min, max) points of the prior)
# Note: the two priors must be defined or none of them.
K_prior_file = None
MU_prior_file = None

[#7  Number Of Markov Chains]
# The number of Markov Chains to generate during the MCMC.
# -1 for auto-adjusting to the number of CPU cores MPI will find.
chain_number = 4

[#8  Markov Chain Seeds]
# Initial seeds to use for the MT-PRNG (Mersenne Twister).
# Set them to -1 to use a "random" seed auto-generated using system time clock.
# One seed per chain (see section #7).
# Note: If there are more chains than seeds, the additional chains will have
# random seeds (same effect as a -1).
chain_seeds = 855 435 678 835

[#9  Numbers of Iterations for Cold and Hot Runs ]
# MCMC works in two stages for models exploration.
# Firstly with cold runs, secondly with hot runs.
# Numbers of iterations, respectively for the cold and hot runs:
cold_n_iters = 10
hot_n_iters = 30

[#10  Minimal and Maximal Depths for Models Exploration]
# Minimal and maximal model depths (in km).
# Note: nonzero minimal depth isn't yet implemented.
min_depth = 0
max_depth = 192

[#11  The Max Depth of the MCMC Working Zone]
# This is the (n-1)-th anchor point depth of the models
# The n-th point being the joint point to the reference model.
# (see `What is a parameter model?' in head of file).
#
# Set it to a valid depth between min and max values defined in section #10 (in km).
last_bz3_min_depth = 100

[#12  Number of Bézier Blocks/Curves per Parameter]
# Number of Bézier curves along the depth for one parameter (VS, VP,...).
#
# Notice that the curves are joined together to form one composite curve for
# the whole parameter profile (see `What is a parameter model?' in head of file).
# So one curve's first point is also the last point of the previous curve (for
# lower depths).
#
# Note that the number of Bézier curves directly determines the number of inflection
# points/oscillations of the whole model (recall that each curve is symmetric to its
# middle point).
#
# The number of curves can be different from one Markov chain to another.
#
# Example:
# chain_bz3_numbers = 5 7 9 10
# That is, 4 Markov chains, each one generating the number of blocks specified
# (the first Markov Chain generates models of 5 curves, the 2nd Markov chain
# models of 7 curves, etc.).
#
# If the length of `chain_bz3_numbers' list is shorter than the number of chains
# defined in #7 the remaining chains will all have a number of curves equal to the
# last number of `chain_bz3_numbers'.
# For example, if you have 4 chains and set the line to:
# chain_bz3_numbers = 5 7
# the third and fourth chains will have 7 points as the second one.
#
# Other authorized forms, in Python style with str mul operator:
# chain_bz3_numbers = "4 5 6" * 10
# or
# chain_bz3_numbers = 10 * "4 5 6"
# with are both equivalent to "4 5 6 ... [ten times]" in case you set thirty
# Markov chains.
#
# If you exceed the number of Markov chains set in #7, the extra numbers are
# just ignored.
chain_bz3_numbers = 4

[#13  Minimal distance between two anchor points]
# An anchor point is a start and/or an end of a Bézier curve
# (respectively the first and the last control points of a Bézier curve).
# Set in min_dist the minimal distance (in km) between two anchor points
# (their exact positions along the depth will be generated randomly according
# to this minimal value).
min_dist = 10

[#14  Layer Thickness of the Depth Models]
# That is, the depth distance between two samples of a Bézier curve.
# Must be less than the minimal distance above (section #13). (in km)
layer_thickness = 2

[#15  Radius/Modulus/Norm for the gradient/tangent of each Bézier curve]
# Let P0, P1, P2 and P3 the four control points to define a cubic Bézier curve.
# `bz3_starting_radius' is the euclidean norm of vec(P0,P1) and vec(P2,P3).
#
# Note about possible control points inversion:
# It should be less or equal to `min_dist / 2' (section #13) to surely avoid
# two intermediary control points inversion.
# Even though the two points are swapped the Bézier curve is sampled from
# the first to the last points. However it gives a degenerated curve because the
# sampling will reduce the whole curve (with multiple points for certains depths)
# to a simple non-parametric curve (only one point per depth -- the first one found).
#
# The `bz3_starting_radius' value is clamped into prior defined in section #16.
# Notice that the radius value is only the initial value. It will be randomly
# changed during model exploration.
#
# (in km)
bz3_starting_radius = 5

[#16  Radius Prior Domain ]
# Absolute values in km.
# It defines the domain in which the radius defined in #15 will vary during the model
# exploration.
#
# See also section #39.
# Min and max bounds (in km)
bz3_radius_min = 9.6
bz3_radius_max = 67.2

[#17  PHI Reference Angle]
# Additionally to the radius (see #15), an angle comes to define precisely the gradient
# of anchor points.
# `bz3_starting_angle' is used for the calculation of the angle prior for this tangent.
# The reference angle for the global trend is initalized to `bz3_starting_angle' value
# and then varies randomly during the MCMC.
#
# (degrees)
bz3_starting_angle = 22

[#18  PHI Prior Min Max Bounds]
# The PHI angle prior is computed dynamically according to the radius defined in #15
# and #16.
# However this prior can't go outside two angles defined in this section.
#
# Thie min and max bounds in degrees (must contain reference angle -- section #17)
#
# Note: NEEMUDS will anyway limit min value to 2° and max value to 45°.
# See also section #39.
bz3_angle_min = 2
bz3_angle_max = 45

[#19  VS Prem Join Value (at max depth or just after) ]
# Only for local scale/Disper96 case. Ignored for global scale/Mineos case.
# In m.s^-1.
prem_join_vs = 4400

[#20  VP Prem Join Value (at max depth or just after)]
# Only for local scale/Disper96 case.
# Ignored for global scale/Mineos case (set it to -1).
# In m.s^-1.
prem_join_vp = 7621

[#21  RHO Prem Join Value (at max depth or just after)]
# Only for local scale/Disper96 case.
# Ignored for global scale/Mineos case (set it to -1).
# In kg.m^-3.
prem_join_rho = 4500

[#22  Anisotropy XI Prem Join Value (at max depth or just after)]
# Used only in Rayleigh + Love PDFs case.
# Take care that this value cannot be retrieved directly from the reference model
# (as it doesn't contain this variable). So it is mandatory if you do a MCMC on
# Rayleigh + Love waves either in global or local scale.
prem_join_xi = 1

[#23  Prior ETA Bounds (min and max)]
# Only for global scale/Mineos.
# Set these values to -1, for ignoring in local/Disper96 case.
#eta_prior_min = -1
#eta_prior_max = -1
eta_prior_min = 0.95
eta_prior_max = 1.05

[#24  Prior XI bounds (min and max)]
# Straight prior XI min and max limits.
xi_prior_min = 0.9
xi_prior_max = 1.1

[#25  Slope Regularization of Sampled-models]
# TODO: doc for general explanation
# Note: the slope regularization takes place after clamping (see #30).
# defaultly disabled:
slope_reg = None
# General Format:
# slope_reg = <glob_min_slope> <z1>:<z2>:<min_slope1> ... <zNx2-1>:<zNx2>:<min_slopeN>
# Examples:
# 1. never authorize a decreasing parameter at any depth:
# slope_reg = 0
# 2. make an exception for Earth mantle layers between 136 and 220 km where the
#  model is permitted to decrease with a slope of -1.3%
# all sampled-models are increasing
# slope_reg = 0 136:192:-0.013


[#26  Coefficients for Effective Prior Building 3rd Method]
# The coefficients below are used in section #27 methods for effective
# prior building.
# See also section #27 for 3rd method of effective prior building.
# Spacing percentage for VS prior, relatively to prem values (vsv).
# Floating point normalized value between 0 and 1 (1 for 100%).
prem_vsv2prior_vs_percent = 0.15
# Coeffs to define VP prior from VS prior by mul. (1st coeff. for lower bounds, 2nd
# for higher bounds)
# Floating point normalized values between 0 and 1 (coeffs called C1 and C2 elsewhere
# in conf. file).
prior_vs2vp_coeffs = 1.6733200530 1.9235384061
# Coeffs to define RHO prior from VP prior by mul. (1st coeff. for lower bounds, 2nd
# for highers)
# Floating point values between 0 and 1 (coeffs called C3 and C4 elsewhere in conf.
# file).
prior_vp2rho_coeffs = .328 .3788
# Offsets to define RHO prior (kg/m³)
# (coeffs called O5 and 06 elsewhere in conf. file).
# Note: O5 correponds to C4 and O6 to C3.
prior_rho_offsets = 252 768

[#27  Effective Prior Construction Method]
# The effective prior is the real domain used to explore parameters.
# Different methods are available for building the effective priors.
#
# Method 1: the effective priors are exactly the basis priors set/built
#           according to section #5/#6.
#
# Method 2: for each parameter (VS, VP,...) a triangle prior is built.
#           The effective prior is then the intersection between this triangle prior
#           and the basis prior. (See section #28 for more details about this method).
#
# Method 3: the method used for the VS effective prior is one of the two above.
#           The VP and RHO effective priors are dynamically inferred at each VS
#           model generation.
# 		    Let C1 and C2 the two coefficients (in `prior_vs2vp_coeffs',
#           section #26) used for VP and any depth index i. The VP effective prior
#           is formed the interval [VS(i)*C1,VS(i)*C2].
# 		    Likewise, Let C3, C4, O5 and O6 the four values set for RHO in
#           section #26 (prior_vp2rho_coeffs and prior_rho_offsets) and VP(i) a
#           model point at depth i, the RHO effective prior is formed by the
#           interval [VP(i)*C3+O5,VP(i)*C4+O6].
#           (the limits of the interval are swapped if necessary to get an ascending
#            order).
#
#           Note: this method can put the VP effective prior out of the basis prior.
#           The same holds for RHO.
#
# Method 4: apply method 2 for VS effective prior and method 3 for VP and RHO
#           effective priors.
#
# Method 5: apply method 3 for VP and RHO effective priors and a method similar
#           to 2nd method for VS but the triangle is defined with two gradients:
#           (See the gradients in section #29).
#           Note that this method can bring models completely outside the basis
#           prior for VS because in case of an empty intersection at some depth,
#           the triangle is kept alone in place of its intersection with basis
#           prior (as opposite to 4th and 2nd methods which always take the
#           intersection-prior because they avoid totally to get empty intersection
#           at every depth).
#
# Choose the method to apply (1, 2, 3, 4 or 5).
eprior_construct_method = 1

[#28  Dynamic Triangle for Effective Prior Construction  ]
# This option applies only if method 2 is used in section #27.
#
# The intersection between the parameter triangle and basis prior gives the effective
# prior used for the corresponding parameter (VP, VS, etc).
#
#
# Definition of the triangle 1st point P1 (minimal depth point):
#      z(P1) = `min_depth' -- section #10,
#      y(P1) = random value (picked into the parameter prior).
#
# Definition of the triangle 2nd point P2 (maximal depth left point):
#      z(P2) = `max_depth' (section #10) or a little bit bottom.
#      y(P2) is determined by an angle.
#      This angle defines the slope for segment P1P2 relatively to the vertical axis
#      (z-axis/depth axis).
#      The angle is defined in the right-handed basis (z-axis, y-axis).
#    * Restriction for y(P2): it can't be smaller than the minimal value of the prior
#      and is clamped if necessary.
#
# Definition of the triangle 3rd point P3 (maximal depth right point):
#    It is calculated to avoid an empty intersection with the parameter
#    basis prior at any depth.
#    z(P3) = z(P2) = `max_depth' and y(P3) is at least prior max value
#    for this depth.
#
# (degrees)
prior_triangle_angle = -10

[#29  Gradients for VS effective prior method 5 (see section #27)]
# Two gradients to define the triangle effective prior for VS
# (in [m][s^-1][m^-1] = [s^-1]).
eprior_triangle_gradients = -0.0055555 0.1

[#30  Clamping VS, VP, RHO etc. sample-points into priors]
# The Bézier control points are always picked into the effective prior, but
# depending on tangents, the samples of the curve can go outside the priors.
# This option serves to enable/disable the clamping of these samples into their
# effective prior. For some configurations (e.g. method 3 of section #27) it is
# possible for one parameter effective prior to not be totally included into
# its basis prior (defined in section #5). In order to avoid that situation,
# use option value 2 to apply a second pass of clamping into the parameter
# basis prior after the first pass of clamping into effective prior
# (as for the value 1).
#
# Choose:
# - 0 for no clamping at all,
# - 1 to enable effective prior-clamping,
# - 2 for effective prior-clamping and prior-clamping afterward.
#
# If the value is an integer then the configuration is applied to all explored
# parameters.
# Otherwise, if the value is a (space-separated) list of integers as for example:
# clamping_samples = 0 1 2
# then the first value is applied to the first parameter (VP), the second value
# to the second parameter (VS) and so on for the next parameters (RHO, XI, ETA).
# Non-specified parameters are not clamped, the example below is hence equivalent
# to:
# clamping_samples = 0 1 2 0 0
# But note that a single integer case as this example:
# clamping_samples = 1
# is not considered as a list then it is equivalent to:
# clamping_samples = 1 1 1 1 1
# (clamping enabled on all parameters)
#
# Note: the joint point shared with the reference model (section #4) might also be
# clamped if it is outside the (effective) prior.
#
clamping_samples = 0

[#31  Constraining VP and RHO samples from VS]
# The VS values can be used to constrain VP and RHO. There are several constraint modes.
#
# Mode 0: No constraints at all.
# Mode 1: after VS, VP and RHO have been sampled from Bézier curves,
#       VP can be furthermore constrained depending on VS values and next RHO with
#       new VP values. The constraints are applied by clamping in the valid domain
#       defined relatively to the coefficients set in section #26.
#       Let C1 and C2 the two coefficients (in `prior_vs2vp_coeffs', section #26)
#       used for VP and i the depth index of the sample/point: VP(i) is clamped into
#       [VS(i)*C1,VS(i)*C2].
#       Likewise, let C3, C4, O5 and O6 the four values set for RHO in section #26
#       (`prior_vp2rho_coeffs' and `prior_rho_offsets'), RHO(i) is clamped into
#       [VP(i)*C3+O6,VP(i)*C4+O5].
#       (the limits of the interval are swapped if necessary to get an ascending
#        order).
#
# Note: it is not necessarily wise to combine the mode 1 and the effective prior
# construction method 3 in section #27 but it could be complementary.
#
# ########
# Choose a constraining mode among 0 and 1.
constraining_vp_rho_from_vs = 0

[#32  Gaussian width parameters for VP, VS, RHO, XI, ETA, depth, radius and PHI]
# A model update consists to move randomly one point in at least one dimension
# according to a gaussian law of probability.
# The mean of the normal law is located at the current point.
# There are two ways to set the gaussian width/std deviation (sigma):
# 1) Set it as a constant.
# 2) Use a width divider (wdiv) in order to define sigma dynamically as follows:
# 	sigma_p = prior_width(p, z) / wdiv_p for any point to move in the parameter p
#   dimension, for any depth z.
# 	sigma_z = (max_depth - min_depth) / wdiv_z for any parameter point to move
#   in the z dimension
#   (this is the same principle to update the radius and phi for an anchor point)
#-----------------------
# 32.0 Method used to compute sigma (1 for constant value, 2 to use wdiv)
#----------------------
# ** For VP, VS, RHO, XI, ETA:
# on cold runs:
coldrun_vp_meth = 2
coldrun_vs_meth = 2
coldrun_rho_meth = 2
coldrun_xi_meth = 2
coldrun_eta_meth = 2
# on hot runs:
hotrun_vp_meth = 2
hotrun_vs_meth = 2
hotrun_rho_meth = 2
hotrun_xi_meth = 2
hotrun_eta_meth = 2
# ** For the depth
# on cold runs:
coldrun_depth_meth = 2
# on hot runs:
hotrun_depth_meth = 2
# ** For radius and phi:
# on cold runs:
coldrun_radius_meth = 2
coldrun_phi_meth = 2
# on hot runs:
hotrun_radius_meth = 2
hotrun_phi_meth = 2
# ----------------------
# 32.1 The sigma constant values (these values apply only if method 1 is used
# in the corresponding previous option of 32.0)
# ----------------------
# VP, VS are in m.s^-1, RHO in kg/m³, XI, ETA without units:
# for the cold runs:
coldrun_vp_const_sigma = 10000
coldrun_vs_const_sigma = 10000
coldrun_rho_const_sigma = 300
coldrun_xi_const_sigma = 0.5
coldrun_eta_const_sigma = 0.5
# for the hot runs:
hotrun_vp_const_sigma = 500
hotrun_vs_const_sigma = 500
hotrun_rho_const_sigma = 300
hotrun_xi_const_sigma = 0.5
hotrun_eta_const_sigma = 0.5
# Likewise for the depth (in km)
# for the cold and hot runs:
coldrun_depth_const_sigma = 750
hotrun_depth_const_sigma = 375
# And it's again the same for radius (in km) and angle phi (in degrees)
# for cold and hot runs:
coldrun_radius_const_sigma = 300
coldrun_phi_const_sigma = 20
hotrun_radius_const_sigma = 150
hotrun_phi_const_sigma = 10
# ----------------------
# 32.2 The wdiv values (these values apply only if method 2 is used in the
# corresponding previous option of 32.0)
# ----------------------
# It is possible to set a different wdiv value for each parameter.
# For the cold runs:
coldrun_vp_wdiv = 4
coldrun_vs_wdiv = 4
coldrun_rho_wdiv = 4
coldrun_xi_wdiv = 4
coldrun_eta_wdiv = 4
# and for the hot runs:
hotrun_vp_wdiv = 10
hotrun_vs_wdiv = 10
hotrun_rho_wdiv = 10
hotrun_xi_wdiv = 10
hotrun_eta_wdiv = 10
# the same for the depth's wdiv to define sigma = (max_depth - min_depth) / wdiv
# for cold and hot runs:
coldrun_depth_wdiv = 1
hotrun_depth_wdiv = 2
# And it's again the same for radius and angle phi
# for cold and hot runs:
coldrun_radius_wdiv = 4
coldrun_phi_wdiv = 1.4
hotrun_radius_wdiv = 10
hotrun_phi_wdiv = 2.4

[#33  Flushing period for result output in files]
# The output files flushing period (into folder defined in section #1).
# The flushing period is set in number of MCMC iterations.
# For example, set 0 for immediate data writing in files,
# and 100 to flush the files every 100 iterations (for cold or hot runs).
output_flush_iter_period = 10

[#34  Sampled Models Output Option]
# Outputting Mineos/Disper96 models generated and accepted (all samples).
# Files are prefixed with "mineos" or "herrmann" (for Disper96), and output in the
# mcmc profile folder (see section #1).
# 1 for enabling, 0 for disabling.
outputting_sampled_models = 1

[#35  Accepting All Models in Metropolis Hastings Algo.]
# 0 to disable (normal behavior of Metropolis Hastings).
# 1 to enable (accept all models, whatever is the goodness of fit).
# 2 the same as 1 but skipping group velocities and Goodness of Fit computation
# (a quicker version of 1).
accepting_all_models = 0

[#36  Weight coefficients for hot run model change probability law]
# Coefficients to define the probability law to change one point on one dimension
# or another.
#
# - alpha is the weight for changing the anchor point in parameter dimension
#   (VP, VS, RHO, ETA, XI).
#   Note that by default each anchor point (pair composed of a parameter value and
#   a depth) has the same probability to be changed (uniform distribution).
#   To set a different probability law see the next section (#37).
#   The last depth model point (reference model join) can't have its value changed.
#
# - beta is the weight given to the probability to move an anchor point at another
#   depth (parameter values are then clamped into their prior at this depth).
#   The first, the last and before the last points for a parameter cannot change
#   of depth. The movable depth is chosen according to a uniform distribution.
#
# - gamma is the weight given to change the radius or the angle phi (they define
#   all the Bézier control points of the model). Then there is half a chance to
#   change the radius or the angle.
#
# The three coefficients are defined relatively to each other (they are not absolute).
# The coefficients must be positive.
hotrun_alpha = 10
hotrun_beta = 15
hotrun_gamma = 5

[#37  Hot run probabilities of picking one parameter instead of another]
# This section allows to set arbitrary probabilities to pick parameter VP, VS, RHO
# and ETA or XI if used.
# Those probabilities are used when generating a new model in hot run and choosing
# randomly to change a point parameter value at a certain random depth instead of
# changing a depth, radius or phi (as explained in section #36).
#
# If `using_hotrun_param_custom_probas' is set to 0, the probability distribution is
# uniform (same probability to pick any parameter).
# Otherwise (`using_hotrun_param_custom_probas = 1') custom probabilities set in
# `hotrun_param_choice_custom_prob_law' apply.
using_hotrun_param_custom_probas = 1
# The sum of values set below must be equal 1.
# There should be up to five probability real values taken in this order: VP, VS,
# RHO, XI, ETA.
# If there are less than five values, the missing ones will be set to 0 by default
hotrun_param_choice_custom_prob_law = .3 .6 .1 0 0
# Note that if scale_type > 1 in #2, then first and second values apply to K and MU
# instead of VP and VS.

[#38  Goodness of Fit Computation Method]
# We denote (f, v) a pair of random variables with:
# - f a frequency,
# - v a velocity.
# The goodness of fit for a model is the logarithm (base 10) of the product of the
# probabilities P(f_i, v_i):
# - The f_i are all the frequencies defined in the McMC prior PDF.
# - The v_i are the group/phase velocities computed by inversion of a subsurface
#   model (generated during the McMC).
# There are two possible methods to compute one probability P(f_i, v_i):
# - 0 (discrete method): the probability is directly obtained from the matching bin
#   of the prior PDF (the bin (f_i, v_i) belongs to).
# - 1 (continuous method): the probability is computed by linear interpolation of
#   the probabilities given by two bins in the prior PDF: the one v_i belongs to
#   and the closest neighbor bin in velocity dimension. The closest v_i is from
#   one bin velocity, the higher the weight is for that bin probability in the
#   linear interpolation.
gof_calc_method = 0

[#39  Radius-phi Priors Relationship]
# Several values/methods are available:
# - `phi_radius_prior_relation = 0': no relation at all between phi and radius
#    priors. They are defined respectively in sections #18 and #16.
# - `phi_radius_prior_relation = 1': a group of 4 linear relations is used.
# 	Two linear phi-radius prior relations for low radii:
#    *  one linear relation defining the inf prior limit,
#    *  the other the sup prior limit.
# 	Likewise, two linear relations (inf and sup) are defined for the high radii
#   but with different slopes than for low radii.
# - `phi_radius_prior_relation = 2': linear relation set in order to limit phi
#    values when radii are too large.
# - `phi_radius_prior_relation = 3': Quad/Parabolic relation set in order to limit
#    phi values when radii are large.
phi_radius_prior_relation = 1

[#40  Computing (VP/VS) Bézier model]
# This option is for computing a Bézier model of VP/VS starting from
# the anchor points of VP and VS (picked as defined by other options).
# The VP/VS curve is sampled with respect to the layer thickness and clamped into
# its prior defined by C1 and C2 (see #26).
# Then the VP curve is built based on the VS and VP/VS sampled curves.
# Likewise RHO is deduced from VP, VS curves through an affine relationship defined
# by C3, C4 and O5, O6 (see #26).
# Note: this method comes in the last time of model exploration and can override
# other previous methods applied, the clamping set in #30 comes after though.
# Set 1 to enable this method, 0 otherwise.
enabling_vp_over_vs_model = 0
