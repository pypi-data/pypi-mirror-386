#!/usr/bin/env python3
"""
Dependency Management Automation for JMo Security

This script ensures safe, forward-only dependency updates with Python version validation.

Usage:
    # Recompile with version validation (safe default)
    python3 scripts/dev/update_dependencies.py --compile

    # Upgrade all dependencies to latest versions
    python3 scripts/dev/update_dependencies.py --upgrade

    # Check for outdated dependencies
    python3 scripts/dev/update_dependencies.py --check-outdated

    # Validate current requirements-dev.txt
    python3 scripts/dev/update_dependencies.py --validate

Features:
    - Python version validation (enforces 3.10+)
    - Prevents accidental downgrades
    - Detects dependency conflicts
    - Provides upgrade preview before applying
    - CI-compatible (exit codes for automation)
"""
import argparse
import json
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Tuple

# ANSI colors for output
GREEN = "\033[92m"
YELLOW = "\033[93m"
RED = "\033[91m"
BLUE = "\033[94m"
RESET = "\033[0m"


def get_python_version() -> Tuple[int, int]:
    """Get current Python version as (major, minor)."""
    return (sys.version_info.major, sys.version_info.minor)


def validate_python_version(min_major: int = 3, min_minor: int = 10) -> bool:
    """Validate Python version meets minimum requirements."""
    major, minor = get_python_version()
    if major < min_major or (major == min_major and minor < min_minor):
        print(f"{RED}[error]{RESET} Python {min_major}.{min_minor}+ required (detected {major}.{minor})")
        print(f"{YELLOW}[hint]{RESET} Use: python3.10 -m pip install pip-tools")
        print(f"{YELLOW}[hint]{RESET} Then: python3.10 scripts/dev/update_dependencies.py --compile")
        return False
    print(f"{GREEN}[ok]{RESET} Python {major}.{minor} (meets requirement ≥{min_major}.{min_minor})")
    return True


def check_requirements_txt_python_version(req_file: Path) -> Tuple[bool, str]:
    """Check Python version used to compile requirements-dev.txt."""
    if not req_file.exists():
        return False, "File not found"

    with open(req_file) as f:
        for line in f:
            if line.startswith("# This file is autogenerated by pip-compile with Python"):
                # Extract version from line like "# This file is autogenerated by pip-compile with Python 3.8"
                parts = line.split("Python")
                if len(parts) > 1:
                    version_str = parts[1].strip()
                    return True, version_str

    return False, "Python version header not found"


def run_pip_compile(upgrade: bool = False, repo_root: Path = None) -> int:
    """Run pip-compile to regenerate requirements-dev.txt."""
    if repo_root is None:
        repo_root = Path(__file__).parent.parent.parent

    req_in = repo_root / "requirements-dev.in"
    req_out = repo_root / "requirements-dev.txt"

    if not req_in.exists():
        print(f"{RED}[error]{RESET} {req_in} not found")
        return 1

    cmd = [
        sys.executable, "-m", "piptools", "compile",
        "--output-file", str(req_out),
        str(req_in)
    ]

    if upgrade:
        cmd.append("--upgrade")
        print(f"{BLUE}[info]{RESET} Running pip-compile with --upgrade (will update all dependencies)")
    else:
        print(f"{BLUE}[info]{RESET} Running pip-compile (will preserve existing versions if compatible)")

    print(f"{BLUE}[cmd]{RESET} {' '.join(cmd)}")

    try:
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            print(f"{GREEN}[ok]{RESET} requirements-dev.txt compiled successfully")
            print(result.stdout)
            return 0
        else:
            print(f"{RED}[error]{RESET} pip-compile failed")
            print(result.stderr)
            return result.returncode
    except FileNotFoundError:
        print(f"{RED}[error]{RESET} pip-tools not installed")
        print(f"{YELLOW}[hint]{RESET} Install with: {sys.executable} -m pip install pip-tools")
        return 1


def check_pip_conflicts() -> Tuple[bool, List[str]]:
    """Check for dependency conflicts using pip check."""
    try:
        result = subprocess.run(
            [sys.executable, "-m", "pip", "check"],
            capture_output=True,
            text=True
        )

        if result.returncode == 0:
            print(f"{GREEN}[ok]{RESET} No dependency conflicts detected")
            return True, []
        else:
            conflicts = result.stdout.strip().split("\n")
            print(f"{RED}[error]{RESET} {len(conflicts)} dependency conflict(s) detected:")
            for conflict in conflicts:
                print(f"  {RED}•{RESET} {conflict}")
            return False, conflicts
    except Exception as e:
        print(f"{RED}[error]{RESET} Failed to run pip check: {e}")
        return False, [str(e)]


def check_outdated_packages() -> List[Dict[str, str]]:
    """Check for outdated packages using pip list --outdated."""
    try:
        result = subprocess.run(
            [sys.executable, "-m", "pip", "list", "--outdated", "--format=json"],
            capture_output=True,
            text=True
        )

        if result.returncode == 0:
            outdated = json.loads(result.stdout)
            if outdated:
                print(f"{YELLOW}[warn]{RESET} {len(outdated)} outdated package(s) detected:")
                for pkg in outdated:
                    print(f"  {YELLOW}•{RESET} {pkg['name']}: {pkg['version']} → {pkg['latest_version']}")
            else:
                print(f"{GREEN}[ok]{RESET} All packages up-to-date")
            return outdated
        else:
            print(f"{RED}[error]{RESET} Failed to check outdated packages")
            print(result.stderr)
            return []
    except Exception as e:
        print(f"{RED}[error]{RESET} Failed to check outdated packages: {e}")
        return []


def compare_requirements(old_file: Path, new_file: Path) -> Tuple[List[str], List[str], List[str]]:
    """Compare old and new requirements files to detect changes."""
    def parse_requirements(file_path: Path) -> Dict[str, str]:
        """Parse requirements file into dict of package: version."""
        packages = {}
        if not file_path.exists():
            return packages

        with open(file_path) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#") and "==" in line:
                    pkg, version = line.split("==", 1)
                    packages[pkg.strip()] = version.strip()
        return packages

    old_packages = parse_requirements(old_file)
    new_packages = parse_requirements(new_file)

    upgrades = []
    downgrades = []
    new_pkgs = []

    for pkg, new_ver in new_packages.items():
        if pkg in old_packages:
            old_ver = old_packages[pkg]
            if new_ver > old_ver:
                upgrades.append(f"{pkg}: {old_ver} → {new_ver}")
            elif new_ver < old_ver:
                downgrades.append(f"{pkg}: {old_ver} → {new_ver}")
        else:
            new_pkgs.append(f"{pkg}: {new_ver}")

    return upgrades, downgrades, new_pkgs


def main():
    parser = argparse.ArgumentParser(
        description="Dependency management automation for JMo Security",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Validate current requirements-dev.txt
  %(prog)s --validate

  # Recompile with current dependencies (safe)
  %(prog)s --compile

  # Upgrade all dependencies to latest
  %(prog)s --upgrade

  # Check for outdated packages
  %(prog)s --check-outdated

CI Usage:
  # Pre-release validation
  %(prog)s --validate && %(prog)s --check-conflicts

  # Dependency update workflow
  %(prog)s --check-outdated
  %(prog)s --compile  # Review changes
  git diff requirements-dev.txt
  %(prog)s --validate && %(prog)s --check-conflicts
        """
    )

    parser.add_argument(
        "--compile",
        action="store_true",
        help="Recompile requirements-dev.txt (preserves existing versions)"
    )
    parser.add_argument(
        "--upgrade",
        action="store_true",
        help="Upgrade all dependencies to latest versions (use with caution)"
    )
    parser.add_argument(
        "--check-outdated",
        action="store_true",
        help="Check for outdated packages"
    )
    parser.add_argument(
        "--validate",
        action="store_true",
        help="Validate requirements-dev.txt Python version and conflicts"
    )
    parser.add_argument(
        "--check-conflicts",
        action="store_true",
        help="Check for dependency conflicts (pip check)"
    )

    args = parser.parse_args()

    # Default to validation if no action specified
    if not any([args.compile, args.upgrade, args.check_outdated, args.validate, args.check_conflicts]):
        args.validate = True

    repo_root = Path(__file__).parent.parent.parent
    req_file = repo_root / "requirements-dev.txt"

    exit_code = 0

    # Validate Python version for compilation
    if args.compile or args.upgrade:
        if not validate_python_version(min_major=3, min_minor=10):
            return 1

    # Validation
    if args.validate:
        print(f"\n{BLUE}=== Validating requirements-dev.txt ==={RESET}\n")

        # Check Python version in requirements-dev.txt
        found, version_str = check_requirements_txt_python_version(req_file)
        if found:
            if "3.8" in version_str or "3.9" in version_str:
                print(f"{RED}[error]{RESET} requirements-dev.txt compiled with {version_str}")
                print(f"{YELLOW}[hint]{RESET} Must be Python 3.10+")
                print(f"{YELLOW}[fix]{RESET} Run: python3.10 scripts/dev/update_dependencies.py --compile")
                exit_code = 1
            else:
                print(f"{GREEN}[ok]{RESET} requirements-dev.txt compiled with {version_str}")
        else:
            print(f"{YELLOW}[warn]{RESET} Could not detect Python version in requirements-dev.txt")

        # Check for conflicts
        conflicts_ok, _ = check_pip_conflicts()
        if not conflicts_ok:
            exit_code = 1

    # Check outdated packages
    if args.check_outdated:
        print(f"\n{BLUE}=== Checking for outdated packages ==={RESET}\n")
        outdated = check_outdated_packages()
        if outdated and not args.upgrade:
            print(f"\n{YELLOW}[hint]{RESET} Run with --upgrade to update all packages")

    # Check conflicts only
    if args.check_conflicts and not args.validate:
        print(f"\n{BLUE}=== Checking dependency conflicts ==={RESET}\n")
        conflicts_ok, _ = check_pip_conflicts()
        if not conflicts_ok:
            exit_code = 1

    # Compile or upgrade
    if args.compile or args.upgrade:
        print(f"\n{BLUE}=== Compiling requirements-dev.txt ==={RESET}\n")

        # Backup old file for comparison
        req_backup = repo_root / "requirements-dev.txt.bak"
        if req_file.exists():
            import shutil
            shutil.copy(req_file, req_backup)

        # Run pip-compile
        compile_result = run_pip_compile(upgrade=args.upgrade, repo_root=repo_root)
        if compile_result != 0:
            return compile_result

        # Compare changes
        if req_backup.exists():
            print(f"\n{BLUE}=== Dependency Changes ==={RESET}\n")
            upgrades, downgrades, new_pkgs = compare_requirements(req_backup, req_file)

            if upgrades:
                print(f"{GREEN}Upgrades ({len(upgrades)}):{RESET}")
                for upgrade in upgrades:
                    print(f"  {GREEN}↑{RESET} {upgrade}")

            if downgrades:
                print(f"{RED}Downgrades ({len(downgrades)}):{RESET}")
                for downgrade in downgrades:
                    print(f"  {RED}↓{RESET} {downgrade}")
                print(f"\n{RED}[error]{RESET} Downgrades detected! This should not happen.")
                print(f"{YELLOW}[hint]{RESET} Check if requirements-dev.in has version constraints causing downgrades")
                exit_code = 1

            if new_pkgs:
                print(f"{BLUE}New packages ({len(new_pkgs)}):{RESET}")
                for new_pkg in new_pkgs:
                    print(f"  {BLUE}+{RESET} {new_pkg}")

            if not upgrades and not downgrades and not new_pkgs:
                print(f"{GREEN}[ok]{RESET} No changes detected")

            # Cleanup backup
            req_backup.unlink()

        # Post-compile validation
        print(f"\n{BLUE}=== Post-Compile Validation ==={RESET}\n")

        # Verify Python version
        found, version_str = check_requirements_txt_python_version(req_file)
        if found:
            print(f"{GREEN}[ok]{RESET} Compiled with {version_str}")

        # Check for conflicts
        conflicts_ok, _ = check_pip_conflicts()
        if not conflicts_ok:
            print(f"\n{RED}[error]{RESET} Dependency conflicts detected after compilation")
            print(f"{YELLOW}[hint]{RESET} Review requirements-dev.in for conflicting version constraints")
            exit_code = 1

    return exit_code


if __name__ == "__main__":
    sys.exit(main())
