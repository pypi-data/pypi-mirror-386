"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .url import URL, URLTypedDict
from enum import Enum
from mollie.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from mollie.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class GetPartnerStatusRequestTypedDict(TypedDict):
    idempotency_key: NotRequired[str]
    r"""A unique key to ensure idempotent requests. This key should be a UUID v4 string."""


class GetPartnerStatusRequest(BaseModel):
    idempotency_key: Annotated[
        Optional[str],
        pydantic.Field(alias="idempotency-key"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A unique key to ensure idempotent requests. This key should be a UUID v4 string."""


class PartnerType(str, Enum):
    r"""Indicates the type of partner. Will be `null` if the currently authenticated organization is not
    enrolled as a partner.
    """

    OAUTH = "oauth"
    SIGNUPLINK = "signuplink"
    USERAGENT = "useragent"


class UserAgentTokenTypedDict(TypedDict):
    token: NotRequired[str]
    r"""The unique User-Agent token."""
    starts_at: NotRequired[str]
    r"""The date from which the token is active, in ISO 8601 format."""
    ends_at: NotRequired[Nullable[str]]
    r"""The date until when the token will be active, in ISO 8601 format. Will be `null` if the token
    does not have an end date (yet).
    """


class UserAgentToken(BaseModel):
    token: Optional[str] = None
    r"""The unique User-Agent token."""

    starts_at: Annotated[Optional[str], pydantic.Field(alias="startsAt")] = None
    r"""The date from which the token is active, in ISO 8601 format."""

    ends_at: Annotated[OptionalNullable[str], pydantic.Field(alias="endsAt")] = UNSET
    r"""The date until when the token will be active, in ISO 8601 format. Will be `null` if the token
    does not have an end date (yet).
    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["token", "startsAt", "endsAt"]
        nullable_fields = ["endsAt"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetPartnerStatusLinksTypedDict(TypedDict):
    r"""An object with several relevant URLs. Every URL object will contain an `href` and a `type` field."""

    self_: NotRequired[URLTypedDict]
    r"""In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field."""
    signuplink: NotRequired[URLTypedDict]
    r"""In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field."""
    documentation: NotRequired[URLTypedDict]
    r"""In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field."""


class GetPartnerStatusLinks(BaseModel):
    r"""An object with several relevant URLs. Every URL object will contain an `href` and a `type` field."""

    self_: Annotated[Optional[URL], pydantic.Field(alias="self")] = None
    r"""In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field."""

    signuplink: Optional[URL] = None
    r"""In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field."""

    documentation: Optional[URL] = None
    r"""In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field."""


class GetPartnerStatusResponseTypedDict(TypedDict):
    r"""The partner status object."""

    resource: str
    r"""Indicates the response contains a partner status object. Will always contain the string `partner` for
    this endpoint.
    """
    partner_type: Nullable[PartnerType]
    r"""Indicates the type of partner. Will be `null` if the currently authenticated organization is not
    enrolled as a partner.
    """
    is_commission_partner: NotRequired[bool]
    r"""Whether the current organization is receiving commissions."""
    user_agent_tokens: NotRequired[List[UserAgentTokenTypedDict]]
    r"""Array of User-Agent token objects. Present if the organization is a partner of type `useragent`, or if
    they were in the past.
    """
    partner_contract_signed_at: NotRequired[Nullable[str]]
    r"""The date the partner contract was signed, in ISO 8601 format. Omitted if no contract has been signed
    (yet).
    """
    partner_contract_update_available: NotRequired[bool]
    r"""Whether an update to the partner contract is available and requiring the organization's agreement."""
    partner_contract_expires_at: NotRequired[str]
    r"""The expiration date of the signed partner contract, in ISO 8601 format. Omitted if contract has no
    expiration date (yet).
    """
    links: NotRequired[GetPartnerStatusLinksTypedDict]
    r"""An object with several relevant URLs. Every URL object will contain an `href` and a `type` field."""


class GetPartnerStatusResponse(BaseModel):
    r"""The partner status object."""

    resource: str
    r"""Indicates the response contains a partner status object. Will always contain the string `partner` for
    this endpoint.
    """

    partner_type: Annotated[Nullable[PartnerType], pydantic.Field(alias="partnerType")]
    r"""Indicates the type of partner. Will be `null` if the currently authenticated organization is not
    enrolled as a partner.
    """

    is_commission_partner: Annotated[
        Optional[bool], pydantic.Field(alias="isCommissionPartner")
    ] = None
    r"""Whether the current organization is receiving commissions."""

    user_agent_tokens: Annotated[
        Optional[List[UserAgentToken]], pydantic.Field(alias="userAgentTokens")
    ] = None
    r"""Array of User-Agent token objects. Present if the organization is a partner of type `useragent`, or if
    they were in the past.
    """

    partner_contract_signed_at: Annotated[
        OptionalNullable[str], pydantic.Field(alias="partnerContractSignedAt")
    ] = UNSET
    r"""The date the partner contract was signed, in ISO 8601 format. Omitted if no contract has been signed
    (yet).
    """

    partner_contract_update_available: Annotated[
        Optional[bool], pydantic.Field(alias="partnerContractUpdateAvailable")
    ] = None
    r"""Whether an update to the partner contract is available and requiring the organization's agreement."""

    partner_contract_expires_at: Annotated[
        Optional[str], pydantic.Field(alias="partnerContractExpiresAt")
    ] = None
    r"""The expiration date of the signed partner contract, in ISO 8601 format. Omitted if contract has no
    expiration date (yet).
    """

    links: Annotated[
        Optional[GetPartnerStatusLinks], pydantic.Field(alias="_links")
    ] = None
    r"""An object with several relevant URLs. Every URL object will contain an `href` and a `type` field."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "isCommissionPartner",
            "userAgentTokens",
            "partnerContractSignedAt",
            "partnerContractUpdateAvailable",
            "partnerContractExpiresAt",
            "_links",
        ]
        nullable_fields = ["partnerType", "partnerContractSignedAt"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
