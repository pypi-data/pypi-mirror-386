#!/usr/bin/env python
# -*- coding: utf-8 -*-

import click
from ase.io import read
from ase import Atoms
import numpy as np
import copy
from itertools import groupby


from . import Fourthorder_core  # type: ignore
from .Fourthorder_common import (
    H,
    SYMPREC,
    gen_SPOSCAR,
    calc_dists,
    calc_frange,
    write_ifcs,
    move_three_atoms,
)


@click.group()
def fourthorder():
    """Fourth-order force-constants for VASP."""
    pass


def read_POSCAR():
    """
    Return all the relevant information contained in a POSCAR file.
    """

    atoms = read("POSCAR", format="vasp")

    nruter = dict()
    nruter["lattvec"] = 0.1 * atoms.get_cell().T

    chemical_symbols = atoms.get_chemical_symbols()
    unique_symbols = []
    numbers = []

    for symbol, group in groupby(chemical_symbols):
        unique_symbols.append(symbol)
        numbers.append(len(list(group)))

    nruter["elements"] = unique_symbols
    nruter["numbers"] = np.array(numbers, dtype=np.intc)

    positions = atoms.get_scaled_positions()
    nruter["positions"] = positions.T
    nruter["types"] = []
    nruter["types"] = np.repeat(
        range(len(nruter["numbers"])), nruter["numbers"]
    ).tolist()

    return nruter


def write_POSCAR(poscar, filename):
    symbols = np.repeat(poscar["elements"], poscar["numbers"]).tolist()

    atoms = Atoms(
        symbols=symbols,
        scaled_positions=poscar["positions"].T,
        cell=poscar["lattvec"].T,
    )

    atoms.write(filename, format="vasp", direct=True)


def normalize_SPOSCAR(sposcar):
    """
    Rearrange sposcar, as generated by gen_SPOSCAR, so that it is in
    valid VASP order, and return the result.
    """
    nruter = copy.deepcopy(sposcar)
    indices = np.array(range(nruter["positions"].shape[1])).reshape(
        (sposcar["nc"], sposcar["nb"], sposcar["na"], -1)
    )
    indices = np.rollaxis(indices, 3, 0).flatten().tolist()
    nruter["positions"] = nruter["positions"][:, indices]
    nruter["types"].sort()
    return nruter


def read_forces(filename):
    atoms = read(filename)
    nruter = atoms.get_forces()
    return nruter


def build_unpermutation(sposcar):
    """
    Return a list of integers mapping the atoms in the normalized
    version of sposcar to their original indices.
    """
    indices = np.array(range(sposcar["positions"].shape[1])).reshape(
        (sposcar["nc"], sposcar["nb"], sposcar["na"], -1)
    )
    indices = np.rollaxis(indices, 3, 0).flatten()
    return indices.argsort().tolist()


def _validate_cutoff(na, nb, nc):
    if min(na, nb, nc) < 1:
        raise click.BadParameter("na, nb and nc must be positive integers")


def _parse_cutoff(cutoff):
    if cutoff.startswith("-"):
        try:
            nneigh = -int(cutoff)
        except ValueError:
            raise click.BadParameter("invalid cutoff")
        if nneigh == 0:
            raise click.BadParameter("invalid cutoff")
        return nneigh, None
    else:
        try:
            frange = float(cutoff)
        except ValueError:
            raise click.BadParameter("invalid cutoff")
        if frange == 0.0:
            raise click.BadParameter("invalid cutoff")
        return None, frange


def _prepare_calculation(na, nb, nc, cutoff):
    """
    Validate the input parameters and prepare the calculation.
    """
    _validate_cutoff(na, nb, nc)
    nneigh, frange = _parse_cutoff(cutoff)
    print("Reading POSCAR")
    poscar = read_POSCAR()
    print("Analyzing the symmetries")
    symops = Fourthorder_core.SymmetryOperations(
        poscar["lattvec"], poscar["types"], poscar["positions"].T, SYMPREC
    )
    print(f"- Symmetry group {symops.symbol} detected")
    print(f"- {symops.translations.shape[0]} symmetry operations")
    print("Creating the supercell")
    sposcar = gen_SPOSCAR(poscar, na, nb, nc)
    print("Computing all distances in the supercell")
    dmin, nequi, shifts = calc_dists(sposcar)
    if nneigh is not None:
        frange = calc_frange(poscar, sposcar, nneigh, dmin)
        print(f"- Automatic cutoff: {frange} nm")
    else:
        print(f"- User-defined cutoff: {frange} nm")
    print("Looking for an irreducible set of fourth-order IFCs")

    return poscar, sposcar, symops, dmin, nequi, shifts, frange, nneigh


@fourthorder.command()
@click.argument("na", type=int)
@click.argument("nb", type=int)
@click.argument("nc", type=int)
@click.option(
    "--cutoff",
    "-c",
    type=str,
    required=True,
    help="Cutoff value (negative for nearest neighbors, positive for distance in nm)",
)
def sow(na, nb, nc, cutoff):
    poscar, sposcar, symops, dmin, nequi, shifts, frange, nneigh = _prepare_calculation(
        na, nb, nc, cutoff
    )
    wedge = Fourthorder_core.Wedge(poscar, sposcar, symops, dmin, nequi, shifts, frange)
    print(f"- {wedge.nlist} quartet equivalence classes found")
    list6 = wedge.build_list4()
    nirred = len(list6)
    nruns = 8 * nirred
    print(f"- {nruns} DFT runs are needed")
    print("Writing undisplaced coordinates to 4TH.SPOSCAR")
    write_POSCAR(normalize_SPOSCAR(sposcar), "4TH.SPOSCAR")
    width = len(str(8 * (len(list6) + 1)))
    namepattern = "4TH.POSCAR.{{0:0{0}d}}".format(width)
    print("Writing displaced coordinates to 4TH.POSCAR.*")
    for i, e in enumerate(list6):
        for n in range(8):
            isign = (-1) ** (n // 4)
            jsign = (-1) ** (n % 4 // 2)
            ksign = (-1) ** (n % 2)
            number = nirred * n + i + 1
            dsposcar = normalize_SPOSCAR(
                move_three_atoms(
                    sposcar,
                    e[2],
                    e[5],
                    isign * H,
                    e[1],
                    e[4],
                    jsign * H,
                    e[0],
                    e[3],
                    ksign * H,
                )
            )
            filename = namepattern.format(number)
            write_POSCAR(dsposcar, filename)


@fourthorder.command()
@click.argument("na", type=int)
@click.argument("nb", type=int)
@click.argument("nc", type=int)
@click.option(
    "--cutoff",
    "-c",
    type=str,
    required=True,
    help="Cutoff value (negative for nearest neighbors, positive for distance in nm)",
)
@click.argument("vaspruns", type=click.Path(exists=True), nargs=-1, required=True)
def reap(na, nb, nc, cutoff, vaspruns):
    """收集力并写出 4TH 力常数（reap 阶段）."""
    poscar, sposcar, symops, dmin, nequi, shifts, frange, nneigh = _prepare_calculation(
        na, nb, nc, cutoff
    )
    wedge = Fourthorder_core.Wedge(poscar, sposcar, symops, dmin, nequi, shifts, frange)
    print(f"- {wedge.nlist} quartet equivalence classes found")
    list6 = wedge.build_list4()
    natoms = len(poscar["types"])
    ntot = natoms * na * nb * nc
    nirred = len(list6)
    nruns = 8 * nirred
    if len(vaspruns) != nruns:
        raise click.ClickException(
            f"Error: {nruns} vasprun.xml files were expected, got {len(vaspruns)}"
        )
    print("Reading the forces")
    p = build_unpermutation(sposcar)
    forces = []
    for f in vaspruns:
        forces.append(read_forces(f)[p, :])
        print(f"- {f} read successfully")
        res = forces[-1].mean(axis=0)
        print("- \t Average force:")
        print(f"- \t {res} eV/(A * atom)")
    print("Computing an irreducible set of anharmonic force constants")
    phipart = np.zeros((3, nirred, ntot))
    for i, e in enumerate(list6):
        for n in range(8):
            isign = (-1) ** (n // 4)
            jsign = (-1) ** (n % 4 // 2)
            ksign = (-1) ** (n % 2)
            number = nirred * n + i
            phipart[:, i, :] -= isign * jsign * ksign * forces[number].T
    phipart /= 8000.0 * H * H * H
    print("Reconstructing the full array")
    phifull = Fourthorder_core.reconstruct_ifcs(phipart, wedge, list6, poscar, sposcar)
    print("Writing the constants to FORCE_CONSTANTS_4TH")
    write_ifcs(
        phifull, poscar, sposcar, dmin, nequi, shifts, frange, "FORCE_CONSTANTS_4TH"
    )
