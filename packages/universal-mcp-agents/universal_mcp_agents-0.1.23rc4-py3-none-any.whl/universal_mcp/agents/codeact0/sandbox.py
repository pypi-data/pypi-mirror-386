import contextlib
import inspect
import io
import queue
import re
import socket
import threading
import types
from typing import Any

from langchain_core.tools import tool

from universal_mcp.agents.codeact0.utils import derive_context, inject_context, smart_truncate


def eval_unsafe(
    code: str, _locals: dict[str, Any], add_context: dict[str, Any], timeout: int = 180
) -> tuple[str, dict[str, Any], dict[str, Any]]:
    """
    Execute code safely with a timeout.
    - Returns (output_str, filtered_locals_dict, new_add_context)
    - Errors or timeout are returned as output_str.
    - Previous variables in _locals persist across calls.
    """

    EXCLUDE_TYPES = (
        types.ModuleType,
        type(re.match("", "")),
        type(re.compile("")),
        type(threading.Lock()),
        type(threading.RLock()),
        threading.Event,
        threading.Condition,
        threading.Semaphore,
        queue.Queue,
        socket.socket,
        io.IOBase,
    )

    result_container = {"output": "<no output>"}

    def target():
        try:
            with contextlib.redirect_stdout(io.StringIO()) as f:
                exec(code, _locals, _locals)
            result_container["output"] = f.getvalue() or "<code ran, no output printed to stdout>"
        except Exception as e:
            result_container["output"] = f"Error during execution: {type(e).__name__}: {e}"

    thread = threading.Thread(target=target)
    thread.start()
    thread.join(timeout)

    if thread.is_alive():
        result_container["output"] = f"Code timeout: code execution exceeded {timeout} seconds."

    # If NameError for provider__tool occurred, append guidance (no retry)
    try:
        m = re.search(r"NameError:\s*name\s*'([^']+)'\s*is\s*not\s*defined", result_container["output"])
        if m and "__" in m.group(1):
            result_container["output"] += "\nHint: If it is a valid tool, load it before running this snippet."
    except Exception:
        pass

    # Filter locals for picklable/storable variables
    all_vars = {}
    for key, value in _locals.items():
        if key == "__builtins__":
            continue
        if inspect.iscoroutine(value) or inspect.iscoroutinefunction(value):
            continue
        if inspect.isasyncgen(value) or inspect.isasyncgenfunction(value):
            continue
        if isinstance(value, EXCLUDE_TYPES):
            continue
        if not callable(value) or not hasattr(value, "__name__"):
            all_vars[key] = value

    # Safely derive context
    try:
        new_add_context = derive_context(code, add_context)
    except Exception:
        new_add_context = add_context

    return result_container["output"], all_vars, new_add_context


@tool(parse_docstring=True)
def execute_ipython_cell(snippet: str) -> str:
    """
    Executes Python code in an IPython notebook cell:
    * The output generated by the notebook cell is returned by this tool
    * State is persistent across executions and discussions with the user
    * The input code may reference variables created in previous executions

    Args:
        snippet: The Python code to execute.

    Returns:
        String containing the execution output or error message.

    Raises:
        ValueError: If snippet is empty.
    """
    # Validate required parameters
    if not snippet or not snippet.strip():
        raise ValueError("Parameter 'snippet' is required and cannot be empty or whitespace")

    # Your actual execution logic would go here
    return f"Successfully executed {len(snippet)} characters of Python code"


async def handle_execute_ipython_cell(
    code: str,
    tools_context: dict[str, Any],
    eval_fn,
    effective_previous_add_context: dict[str, Any],
    effective_existing_context: dict[str, Any],
) -> tuple[str, dict[str, Any], dict[str, Any]]:
    """
    Execute a code cell with shared state, supporting both sync and async eval functions.

    Returns (output, new_context, new_add_context).
    """
    add_context = inject_context(effective_previous_add_context, tools_context)
    context = {**effective_existing_context, **add_context}
    if inspect.iscoroutinefunction(eval_fn):
        output, new_context, new_add_context = await eval_fn(code, context, effective_previous_add_context, 180)
    else:
        output, new_context, new_add_context = eval_fn(code, context, effective_previous_add_context, 180)
    output = smart_truncate(output)
    return output, new_context, new_add_context
